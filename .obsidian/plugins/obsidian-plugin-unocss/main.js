'use strict';

const require$$0$a = require('obsidian');
const require$$1$4 = require('@codemirror/view');
const require$$0$2 = require('node:http');
const require$$1 = require('node:https');
const require$$1$1 = require('tty');
const require$$1$2 = require('util');
const require$$0$3 = require('os');
const require$$0$5 = require('fs');
const require$$9 = require('node:path');
const require$$2$1 = require('node:fs');
const require$$2$2 = require('node:fs/promises');
const require$$8 = require('node:process');
const require$$1$3 = require('node:module');
const require$$3$1 = require('node:url');
const require$$7 = require('node:assert');
const require$$10 = require('node:v8');
const require$$11 = require('node:util');
const require$$0$4 = require('path');
const require$$0$6 = require('child_process');
const require$$0$7 = require('assert');
const require$$2$3 = require('events');
const require$$0$9 = require('buffer');
const require$$0$8 = require('stream');

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs$1 (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var dist$q = {};

var dist$p = {};

function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function escapeSelector(str) {
  const length = str.length;
  let index = -1;
  let codeUnit;
  let result = "";
  const firstCodeUnit = str.charCodeAt(0);
  while (++index < length) {
    codeUnit = str.charCodeAt(index);
    if (codeUnit === 0) {
      result += "\uFFFD";
      continue;
    }
    if (codeUnit === 37) {
      result += "\\%";
      continue;
    }
    if (codeUnit === 44) {
      result += "\\,";
      continue;
    }
    if (
      // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
      // U+007F, […]
      codeUnit >= 1 && codeUnit <= 31 || codeUnit === 127 || index === 0 && codeUnit >= 48 && codeUnit <= 57 || index === 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit === 45
    ) {
      result += `\\${codeUnit.toString(16)} `;
      continue;
    }
    if (
      // If the character is the first character and is a `-` (U+002D), and
      // there is no second character, […]
      index === 0 && length === 1 && codeUnit === 45
    ) {
      result += `\\${str.charAt(index)}`;
      continue;
    }
    if (codeUnit >= 128 || codeUnit === 45 || codeUnit === 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
      result += str.charAt(index);
      continue;
    }
    result += `\\${str.charAt(index)}`;
  }
  return result;
}
const e$1 = escapeSelector;

function toArray(value = []) {
  return Array.isArray(value) ? value : [value];
}
function uniq(value) {
  return Array.from(new Set(value));
}
function uniqueBy(array, equalFn) {
  return array.reduce((acc, cur) => {
    const index = acc.findIndex((item) => equalFn(cur, item));
    if (index === -1)
      acc.push(cur);
    return acc;
  }, []);
}
function isString(s) {
  return typeof s === "string";
}

function normalizeCSSEntries(obj) {
  if (isString(obj))
    return obj;
  return (!Array.isArray(obj) ? Object.entries(obj) : obj).filter((i) => i[1] != null);
}
function normalizeCSSValues(obj) {
  if (Array.isArray(obj)) {
    if (obj.find((i) => !Array.isArray(i) || Array.isArray(i[0])))
      return obj.map((i) => normalizeCSSEntries(i));
    else
      return [obj];
  } else {
    return [normalizeCSSEntries(obj)];
  }
}
function clearIdenticalEntries(entry) {
  return entry.filter(([k, v], idx) => {
    if (k.startsWith("$$"))
      return false;
    for (let i = idx - 1; i >= 0; i--) {
      if (entry[i][0] === k && entry[i][1] === v)
        return false;
    }
    return true;
  });
}
function entriesToCss(arr) {
  if (arr == null)
    return "";
  return clearIdenticalEntries(arr).map(([key, value]) => value != null ? `${key}:${value};` : void 0).filter(Boolean).join("");
}
function isObject$1(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
function mergeDeep(original, patch, mergeArray = false) {
  const o = original;
  const p = patch;
  if (Array.isArray(p)) {
    if (mergeArray && Array.isArray(p))
      return [...o, ...p];
    else
      return [...p];
  }
  const output = { ...o };
  if (isObject$1(o) && isObject$1(p)) {
    Object.keys(p).forEach((key) => {
      if (isObject$1(o[key]) && isObject$1(p[key]) || Array.isArray(o[key]) && Array.isArray(p[key]))
        output[key] = mergeDeep(o[key], p[key], mergeArray);
      else
        Object.assign(output, { [key]: p[key] });
    });
  }
  return output;
}
function clone$3(val) {
  let k, out, tmp;
  if (Array.isArray(val)) {
    out = Array(k = val.length);
    while (k--)
      out[k] = (tmp = val[k]) && typeof tmp === "object" ? clone$3(tmp) : tmp;
    return out;
  }
  if (Object.prototype.toString.call(val) === "[object Object]") {
    out = {};
    for (k in val) {
      if (k === "__proto__") {
        Object.defineProperty(out, k, {
          value: clone$3(val[k]),
          configurable: true,
          enumerable: true,
          writable: true
        });
      } else {
        out[k] = (tmp = val[k]) && typeof tmp === "object" ? clone$3(tmp) : tmp;
      }
    }
    return out;
  }
  return val;
}
function isStaticRule(rule) {
  return isString(rule[0]);
}
function isStaticShortcut(sc) {
  return isString(sc[0]);
}

const attributifyRE = /^\[(.+?)~?="(.*)"\]$/;
const cssIdRE = /\.(css|postcss|sass|scss|less|stylus|styl)($|\?)/;
const validateFilterRE = /[\w\u00A0-\uFFFF-_:%-?]/;
const CONTROL_SHORTCUT_NO_MERGE = "$$shortcut-no-merge";
function isAttributifySelector(selector) {
  return selector.match(attributifyRE);
}
function isValidSelector(selector = "") {
  return validateFilterRE.test(selector);
}
function normalizeVariant(variant) {
  return typeof variant === "function" ? { match: variant } : variant;
}
function isRawUtil(util) {
  return util.length === 3;
}
function notNull(value) {
  return value != null;
}
function noop$3() {
}

var __defProp$2$1 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$2 = (obj, key, value) => {
  __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class TwoKeyMap {
  constructor() {
    __publicField$2(this, "_map", /* @__PURE__ */ new Map());
  }
  get(key1, key2) {
    const m2 = this._map.get(key1);
    if (m2)
      return m2.get(key2);
  }
  getFallback(key1, key2, fallback) {
    let m2 = this._map.get(key1);
    if (!m2) {
      m2 = /* @__PURE__ */ new Map();
      this._map.set(key1, m2);
    }
    if (!m2.has(key2))
      m2.set(key2, fallback);
    return m2.get(key2);
  }
  set(key1, key2, value) {
    let m2 = this._map.get(key1);
    if (!m2) {
      m2 = /* @__PURE__ */ new Map();
      this._map.set(key1, m2);
    }
    m2.set(key2, value);
    return this;
  }
  has(key1, key2) {
    return this._map.get(key1)?.has(key2);
  }
  delete(key1, key2) {
    return this._map.get(key1)?.delete(key2) || false;
  }
  deleteTop(key1) {
    return this._map.delete(key1);
  }
  map(fn) {
    return Array.from(this._map.entries()).flatMap(([k1, m2]) => Array.from(m2.entries()).map(([k2, v]) => {
      return fn(v, k1, k2);
    }));
  }
}
class BetterMap extends Map {
  getFallback(key, fallback) {
    const v = this.get(key);
    if (v === void 0) {
      this.set(key, fallback);
      return fallback;
    }
    return v;
  }
  map(mapFn) {
    const result = [];
    this.forEach((v, k) => {
      result.push(mapFn(v, k));
    });
    return result;
  }
  flatMap(mapFn) {
    const result = [];
    this.forEach((v, k) => {
      result.push(...mapFn(v, k));
    });
    return result;
  }
}

var __defProp$1$1 = Object.defineProperty;
var __defNormalProp$1$1 = (obj, key, value) => key in obj ? __defProp$1$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1$1 = (obj, key, value) => {
  __defNormalProp$1$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class CountableSet extends Set {
  constructor(values) {
    super(values);
    __publicField$1$1(this, "_map");
    this._map ?? (this._map = /* @__PURE__ */ new Map());
  }
  add(key) {
    this._map ?? (this._map = /* @__PURE__ */ new Map());
    this._map.set(key, (this._map.get(key) ?? 0) + 1);
    return super.add(key);
  }
  delete(key) {
    this._map.delete(key);
    return super.delete(key);
  }
  clear() {
    this._map.clear();
    super.clear();
  }
  getCount(key) {
    return this._map.get(key) ?? 0;
  }
  setCount(key, count) {
    this._map.set(key, count);
    return super.add(key);
  }
}
function isCountableSet(value) {
  return value instanceof CountableSet;
}

function withLayer(layer, rules) {
  rules.forEach((r) => {
    if (!r[2])
      r[2] = { layer };
    else
      r[2].layer = layer;
  });
  return rules;
}

const regexCache = {};
function makeRegexClassGroup(separators = ["-", ":"]) {
  const key = separators.join("|");
  if (!regexCache[key])
    regexCache[key] = new RegExp(`((?:[!@<~\\w+:_/-]|\\[&?>?:?\\S*\\])+?)(${key})\\(((?:[~!<>\\w\\s:/\\\\,%#.$?-]|\\[.*?\\])+?)\\)(?!\\s*?=>)`, "gm");
  regexCache[key].lastIndex = 0;
  return regexCache[key];
}
function parseVariantGroup(str, separators = ["-", ":"], depth = 5) {
  const regexClassGroup = makeRegexClassGroup(separators);
  let hasChanged;
  let content = str.toString();
  const prefixes = /* @__PURE__ */ new Set();
  const groupsByOffset = /* @__PURE__ */ new Map();
  do {
    hasChanged = false;
    content = content.replace(
      regexClassGroup,
      (from, pre, sep, body, groupOffset) => {
        if (!separators.includes(sep))
          return from;
        hasChanged = true;
        prefixes.add(pre + sep);
        const bodyOffset = groupOffset + pre.length + sep.length + 1;
        const group = { length: from.length, items: [] };
        groupsByOffset.set(groupOffset, group);
        for (const itemMatch of [...body.matchAll(/\S+/g)]) {
          const itemOffset = bodyOffset + itemMatch.index;
          let innerItems = groupsByOffset.get(itemOffset)?.items;
          if (innerItems) {
            groupsByOffset.delete(itemOffset);
          } else {
            innerItems = [{
              offset: itemOffset,
              length: itemMatch[0].length,
              className: itemMatch[0]
            }];
          }
          for (const item of innerItems) {
            item.className = item.className === "~" ? pre : item.className.replace(/^(!?)(.*)/, `$1${pre}${sep}$2`);
            group.items.push(item);
          }
        }
        return "$".repeat(from.length);
      }
    );
    depth -= 1;
  } while (hasChanged && depth);
  let expanded;
  if (typeof str === "string") {
    expanded = "";
    let prevOffset = 0;
    for (const [offset, group] of groupsByOffset) {
      expanded += str.slice(prevOffset, offset);
      expanded += group.items.map((item) => item.className).join(" ");
      prevOffset = offset + group.length;
    }
    expanded += str.slice(prevOffset);
  } else {
    expanded = str;
    for (const [offset, group] of groupsByOffset) {
      expanded.overwrite(
        offset,
        offset + group.length,
        group.items.map((item) => item.className).join(" ")
      );
    }
  }
  return {
    prefixes: Array.from(prefixes),
    hasChanged,
    groupsByOffset,
    // Computed lazily because MagicString's toString does a lot of work
    get expanded() {
      return expanded.toString();
    }
  };
}
function collapseVariantGroup(str, prefixes) {
  const collection = /* @__PURE__ */ new Map();
  const sortedPrefix = prefixes.sort((a, b) => b.length - a.length);
  return str.split(/\s+/g).map((part) => {
    const prefix = sortedPrefix.find((prefix2) => part.startsWith(prefix2));
    if (!prefix)
      return part;
    const body = part.slice(prefix.length);
    if (collection.has(prefix)) {
      collection.get(prefix).push(body);
      return null;
    } else {
      const items = [body];
      collection.set(prefix, items);
      return {
        prefix,
        items
      };
    }
  }).filter(notNull).map((i) => {
    if (typeof i === "string")
      return i;
    return `${i.prefix}(${i.items.join(" ")})`;
  }).join(" ");
}
function expandVariantGroup(str, separators = ["-", ":"], depth = 5) {
  const res = parseVariantGroup(str, separators, depth);
  return typeof str === "string" ? res.expanded : str;
}

const warned$1 = /* @__PURE__ */ new Set();
function warnOnce(msg) {
  if (warned$1.has(msg))
    return;
  console.warn("[unocss]", msg);
  warned$1.add(msg);
}

const defaultSplitRE = /[\\:]?[\s'"`;{}]+/g;
const splitWithVariantGroupRE = /([\\:]?[\s"'`;<>]|:\(|\)"|\)\s)/g;
function splitCode(code) {
  return code.split(defaultSplitRE);
}
const extractorSplit = {
  name: "@unocss/core/extractor-split",
  order: 0,
  extract({ code }) {
    return splitCode(code);
  }
};

function createNanoEvents() {
  return {
    events: {},
    emit(event, ...args) {
      (this.events[event] || []).forEach((i) => i(...args));
    },
    on(event, cb) {
      (this.events[event] = this.events[event] || []).push(cb);
      return () => this.events[event] = (this.events[event] || []).filter((i) => i !== cb);
    }
  };
}

const LAYER_DEFAULT = "default";
const LAYER_PREFLIGHTS = "preflights";
const LAYER_SHORTCUTS = "shortcuts";
const LAYER_IMPORTS$1 = "imports";
const DEFAULT_LAYERS = {
  [LAYER_IMPORTS$1]: -200,
  [LAYER_PREFLIGHTS]: -100,
  [LAYER_SHORTCUTS]: -10,
  [LAYER_DEFAULT]: 0
};

function resolveShortcuts(shortcuts) {
  return toArray(shortcuts).flatMap((s) => {
    if (Array.isArray(s))
      return [s];
    return Object.entries(s);
  });
}
const __RESOLVED = "_uno_resolved";
function resolvePreset(presetInput) {
  let preset = typeof presetInput === "function" ? presetInput() : presetInput;
  if (__RESOLVED in preset)
    return preset;
  preset = { ...preset };
  Object.defineProperty(preset, __RESOLVED, {
    value: true,
    enumerable: false
  });
  const shortcuts = preset.shortcuts ? resolveShortcuts(preset.shortcuts) : void 0;
  preset.shortcuts = shortcuts;
  if (preset.prefix || preset.layer) {
    const apply = (i) => {
      if (!i[2])
        i[2] = {};
      const meta = i[2];
      if (meta.prefix == null && preset.prefix)
        meta.prefix = toArray(preset.prefix);
      if (meta.layer == null && preset.layer)
        meta.layer = preset.layer;
    };
    shortcuts?.forEach(apply);
    preset.rules?.forEach(apply);
  }
  return preset;
}
function resolvePresets(preset) {
  const root = resolvePreset(preset);
  if (!root.presets)
    return [root];
  const nested = (root.presets || []).flatMap(toArray).flatMap(resolvePresets);
  return [root, ...nested];
}
function resolveConfig(userConfig = {}, defaults = {}) {
  const config = Object.assign({}, defaults, userConfig);
  const rawPresets = uniqueBy((config.presets || []).flatMap(toArray).flatMap(resolvePresets), (a, b) => a.name === b.name);
  const sortedPresets = [
    ...rawPresets.filter((p) => p.enforce === "pre"),
    ...rawPresets.filter((p) => !p.enforce),
    ...rawPresets.filter((p) => p.enforce === "post")
  ];
  const sources = [
    ...sortedPresets,
    config
  ];
  const sourcesReversed = [...sources].reverse();
  const layers = Object.assign({}, DEFAULT_LAYERS, ...sources.map((i) => i.layers));
  function getMerged(key) {
    return uniq(sources.flatMap((p) => toArray(p[key] || [])));
  }
  const extractors = getMerged("extractors");
  let extractorDefault = sourcesReversed.find((i) => i.extractorDefault !== void 0)?.extractorDefault;
  if (extractorDefault === void 0)
    extractorDefault = extractorSplit;
  if (extractorDefault && !extractors.includes(extractorDefault))
    extractors.unshift(extractorDefault);
  extractors.sort((a, b) => (a.order || 0) - (b.order || 0));
  const rules = getMerged("rules");
  const rulesStaticMap = {};
  const rulesSize = rules.length;
  const rulesDynamic = rules.map((rule, i) => {
    if (isStaticRule(rule)) {
      const prefixes = toArray(rule[2]?.prefix || "");
      prefixes.forEach((prefix) => {
        rulesStaticMap[prefix + rule[0]] = [i, rule[1], rule[2], rule];
      });
      return void 0;
    }
    return [i, ...rule];
  }).filter(Boolean).reverse();
  let theme = mergeThemes(sources.map((p) => p.theme));
  const extendThemes = getMerged("extendTheme");
  for (const extendTheme of extendThemes)
    theme = extendTheme(theme) || theme;
  const autocomplete = {
    templates: uniq(sources.flatMap((p) => toArray(p.autocomplete?.templates))),
    extractors: sources.flatMap((p) => toArray(p.autocomplete?.extractors)).sort((a, b) => (a.order || 0) - (b.order || 0)),
    shorthands: mergeAutocompleteShorthands(sources.map((p) => p.autocomplete?.shorthands || {}))
  };
  let separators = getMerged("separators");
  if (!separators.length)
    separators = [":", "-"];
  const resolved = {
    mergeSelectors: true,
    warn: true,
    sortLayers: (layers2) => layers2,
    ...config,
    blocklist: getMerged("blocklist"),
    presets: sortedPresets,
    envMode: config.envMode || "build",
    shortcutsLayer: config.shortcutsLayer || "shortcuts",
    layers,
    theme,
    rulesSize,
    rulesDynamic,
    rulesStaticMap,
    preprocess: getMerged("preprocess"),
    postprocess: getMerged("postprocess"),
    preflights: getMerged("preflights"),
    autocomplete,
    variants: getMerged("variants").map(normalizeVariant).sort((a, b) => (a.order || 0) - (b.order || 0)),
    shortcuts: resolveShortcuts(getMerged("shortcuts")).reverse(),
    extractors,
    safelist: getMerged("safelist"),
    separators,
    details: config.details ?? config.envMode === "dev"
  };
  for (const p of sources)
    p?.configResolved?.(resolved);
  return resolved;
}
function mergeConfigs(configs) {
  const maybeArrays = ["shortcuts", "preprocess", "postprocess"];
  const config = configs.map((config2) => Object.entries(config2).reduce((acc, [key, value]) => ({
    ...acc,
    [key]: maybeArrays.includes(key) ? toArray(value) : value
  }), {})).reduce(({ theme: themeA, ...a }, { theme: themeB, ...b }) => {
    const c = mergeDeep(a, b, true);
    if (themeA || themeB)
      c.theme = mergeThemes([themeA, themeB]);
    return c;
  }, {});
  return config;
}
function mergeThemes(themes) {
  return themes.map((theme) => theme ? clone$3(theme) : {}).reduce((a, b) => mergeDeep(a, b), {});
}
function mergeAutocompleteShorthands(shorthands) {
  return shorthands.reduce((a, b) => {
    const rs = {};
    for (const key in b) {
      const value = b[key];
      if (Array.isArray(value))
        rs[key] = `(${value.join("|")})`;
      else
        rs[key] = value;
    }
    return {
      ...a,
      ...rs
    };
  }, {});
}
function definePreset(preset) {
  return preset;
}

const version$4 = "0.58.9";

var __defProp$4 = Object.defineProperty;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$3 = (obj, key, value) => {
  __defNormalProp$3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class UnoGenerator {
  constructor(userConfig = {}, defaults = {}) {
    this.userConfig = userConfig;
    this.defaults = defaults;
    __publicField$3(this, "version", version$4);
    __publicField$3(this, "_cache", /* @__PURE__ */ new Map());
    __publicField$3(this, "config");
    __publicField$3(this, "blocked", /* @__PURE__ */ new Set());
    __publicField$3(this, "parentOrders", /* @__PURE__ */ new Map());
    __publicField$3(this, "events", createNanoEvents());
    this.config = resolveConfig(userConfig, defaults);
    this.events.emit("config", this.config);
  }
  setConfig(userConfig, defaults) {
    if (!userConfig)
      return;
    if (defaults)
      this.defaults = defaults;
    this.userConfig = userConfig;
    this.blocked.clear();
    this.parentOrders.clear();
    this._cache.clear();
    this.config = resolveConfig(userConfig, this.defaults);
    this.events.emit("config", this.config);
  }
  async applyExtractors(code, id, extracted = /* @__PURE__ */ new Set()) {
    const context = {
      original: code,
      code,
      id,
      extracted,
      envMode: this.config.envMode
    };
    for (const extractor of this.config.extractors) {
      const result = await extractor.extract?.(context);
      if (!result)
        continue;
      if (isCountableSet(result) && isCountableSet(extracted)) {
        for (const token of result)
          extracted.setCount(token, extracted.getCount(token) + result.getCount(token));
      } else {
        for (const token of result)
          extracted.add(token);
      }
    }
    return extracted;
  }
  makeContext(raw, applied) {
    const context = {
      rawSelector: raw,
      currentSelector: applied[1],
      theme: this.config.theme,
      generator: this,
      variantHandlers: applied[2],
      constructCSS: (...args) => this.constructCustomCSS(context, ...args),
      variantMatch: applied
    };
    return context;
  }
  async parseToken(raw, alias) {
    if (this.blocked.has(raw))
      return;
    const cacheKey = `${raw}${alias ? ` ${alias}` : ""}`;
    if (this._cache.has(cacheKey))
      return this._cache.get(cacheKey);
    let current = raw;
    for (const p of this.config.preprocess)
      current = p(raw);
    if (this.isBlocked(current)) {
      this.blocked.add(raw);
      this._cache.set(cacheKey, null);
      return;
    }
    const applied = await this.matchVariants(raw, current);
    if (!applied || this.isBlocked(applied[1])) {
      this.blocked.add(raw);
      this._cache.set(cacheKey, null);
      return;
    }
    const context = this.makeContext(raw, [alias || applied[0], applied[1], applied[2], applied[3]]);
    if (this.config.details)
      context.variants = [...applied[3]];
    const expanded = await this.expandShortcut(context.currentSelector, context);
    const utils = expanded ? await this.stringifyShortcuts(context.variantMatch, context, expanded[0], expanded[1]) : (await this.parseUtil(context.variantMatch, context))?.map((i) => this.stringifyUtil(i, context)).filter(notNull);
    if (utils?.length) {
      this._cache.set(cacheKey, utils);
      return utils;
    }
    this._cache.set(cacheKey, null);
  }
  async generate(input, options = {}) {
    const {
      id,
      scope,
      preflights = true,
      safelist = true,
      minify = false,
      extendedInfo = false
    } = options;
    const outputCssLayers = this.config.outputToCssLayers;
    const tokens = isString(input) ? await this.applyExtractors(
      input,
      id,
      extendedInfo ? new CountableSet() : /* @__PURE__ */ new Set()
    ) : Array.isArray(input) ? new Set(input) : input;
    if (safelist) {
      this.config.safelist.forEach((s) => {
        if (!tokens.has(s))
          tokens.add(s);
      });
    }
    const nl = minify ? "" : "\n";
    const layerSet = /* @__PURE__ */ new Set([LAYER_DEFAULT]);
    const matched = extendedInfo ? /* @__PURE__ */ new Map() : /* @__PURE__ */ new Set();
    const sheet = /* @__PURE__ */ new Map();
    let preflightsMap = {};
    const tokenPromises = Array.from(tokens).map(async (raw) => {
      if (matched.has(raw))
        return;
      const payload = await this.parseToken(raw);
      if (payload == null)
        return;
      if (matched instanceof Map) {
        matched.set(raw, {
          data: payload,
          count: isCountableSet(tokens) ? tokens.getCount(raw) : -1
        });
      } else {
        matched.add(raw);
      }
      for (const item of payload) {
        const parent = item[3] || "";
        const layer = item[4]?.layer;
        if (!sheet.has(parent))
          sheet.set(parent, []);
        sheet.get(parent).push(item);
        if (layer)
          layerSet.add(layer);
      }
    });
    await Promise.all(tokenPromises);
    await (async () => {
      if (!preflights)
        return;
      const preflightContext = {
        generator: this,
        theme: this.config.theme
      };
      const preflightLayerSet = /* @__PURE__ */ new Set([]);
      this.config.preflights.forEach(({ layer = LAYER_PREFLIGHTS }) => {
        layerSet.add(layer);
        preflightLayerSet.add(layer);
      });
      preflightsMap = Object.fromEntries(
        await Promise.all(Array.from(preflightLayerSet).map(
          async (layer) => {
            const preflights2 = await Promise.all(
              this.config.preflights.filter((i) => (i.layer || LAYER_PREFLIGHTS) === layer).map(async (i) => await i.getCSS(preflightContext))
            );
            const css = preflights2.filter(Boolean).join(nl);
            return [layer, css];
          }
        ))
      );
    })();
    const layers = this.config.sortLayers(Array.from(layerSet).sort((a, b) => (this.config.layers[a] ?? 0) - (this.config.layers[b] ?? 0) || a.localeCompare(b)));
    const layerCache = {};
    const getLayer = (layer = LAYER_DEFAULT) => {
      if (layerCache[layer])
        return layerCache[layer];
      let css = Array.from(sheet).sort((a, b) => (this.parentOrders.get(a[0]) ?? 0) - (this.parentOrders.get(b[0]) ?? 0) || a[0]?.localeCompare(b[0] || "") || 0).map(([parent, items]) => {
        const size = items.length;
        const sorted = items.filter((i) => (i[4]?.layer || LAYER_DEFAULT) === layer).sort((a, b) => {
          return a[0] - b[0] || (a[4]?.sort || 0) - (b[4]?.sort || 0) || a[5]?.currentSelector?.localeCompare(b[5]?.currentSelector ?? "") || a[1]?.localeCompare(b[1] || "") || a[2]?.localeCompare(b[2] || "") || 0;
        }).map(([, selector, body, , meta, , variantNoMerge]) => {
          const scopedSelector = selector ? applyScope(selector, scope) : selector;
          return [
            [[scopedSelector ?? "", meta?.sort ?? 0]],
            body,
            !!(variantNoMerge ?? meta?.noMerge)
          ];
        });
        if (!sorted.length)
          return void 0;
        const rules = sorted.reverse().map(([selectorSortPair, body, noMerge], idx) => {
          if (!noMerge && this.config.mergeSelectors) {
            for (let i = idx + 1; i < size; i++) {
              const current = sorted[i];
              if (current && !current[2] && (selectorSortPair && current[0] || selectorSortPair == null && current[0] == null) && current[1] === body) {
                if (selectorSortPair && current[0])
                  current[0].push(...selectorSortPair);
                return null;
              }
            }
          }
          const selectors = selectorSortPair ? uniq(selectorSortPair.sort((a, b) => a[1] - b[1] || a[0]?.localeCompare(b[0] || "") || 0).map((pair) => pair[0]).filter(Boolean)) : [];
          return selectors.length ? `${selectors.join(`,${nl}`)}{${body}}` : body;
        }).filter(Boolean).reverse().join(nl);
        if (!parent)
          return rules;
        const parents = parent.split(" $$ ");
        return `${parents.join("{")}{${nl}${rules}${nl}${"}".repeat(parents.length)}`;
      }).filter(Boolean).join(nl);
      if (preflights) {
        css = [preflightsMap[layer], css].filter(Boolean).join(nl);
      }
      if (outputCssLayers && css) {
        let cssLayer = typeof outputCssLayers === "object" ? outputCssLayers.cssLayerName?.(layer) : void 0;
        if (cssLayer !== null) {
          if (!cssLayer)
            cssLayer = layer;
          css = `@layer ${cssLayer}{${nl}${css}${nl}}`;
        }
      }
      const layerMark = minify ? "" : `/* layer: ${layer} */${nl}`;
      return layerCache[layer] = css ? layerMark + css : "";
    };
    const getLayers = (includes = layers, excludes) => {
      return includes.filter((i) => !excludes?.includes(i)).map((i) => getLayer(i) || "").filter(Boolean).join(nl);
    };
    return {
      get css() {
        return getLayers();
      },
      layers,
      matched,
      getLayers,
      getLayer
    };
  }
  async matchVariants(raw, current) {
    const variants = /* @__PURE__ */ new Set();
    const handlers = [];
    let processed = current || raw;
    let applied = true;
    const context = {
      rawSelector: raw,
      theme: this.config.theme,
      generator: this
    };
    while (applied) {
      applied = false;
      for (const v of this.config.variants) {
        if (!v.multiPass && variants.has(v))
          continue;
        let handler = await v.match(processed, context);
        if (!handler)
          continue;
        if (isString(handler)) {
          if (handler === processed)
            continue;
          handler = { matcher: handler };
        }
        processed = handler.matcher;
        handlers.unshift(handler);
        variants.add(v);
        applied = true;
        break;
      }
      if (!applied)
        break;
      if (handlers.length > 500)
        throw new Error(`Too many variants applied to "${raw}"`);
    }
    return [raw, processed, handlers, variants];
  }
  applyVariants(parsed, variantHandlers = parsed[4], raw = parsed[1]) {
    const handler = variantHandlers.slice().sort((a, b) => (a.order || 0) - (b.order || 0)).reduceRight(
      (previous, v) => (input) => {
        const entries = v.body?.(input.entries) || input.entries;
        const parents = Array.isArray(v.parent) ? v.parent : [v.parent, void 0];
        return (v.handle ?? defaultVariantHandler)({
          ...input,
          entries,
          selector: v.selector?.(input.selector, entries) || input.selector,
          parent: parents[0] || input.parent,
          parentOrder: parents[1] || input.parentOrder,
          layer: v.layer || input.layer,
          sort: v.sort || input.sort
        }, previous);
      },
      (input) => input
    );
    const variantContextResult = handler({
      prefix: "",
      selector: toEscapedSelector(raw),
      pseudo: "",
      entries: parsed[2]
    });
    const { parent, parentOrder } = variantContextResult;
    if (parent != null && parentOrder != null)
      this.parentOrders.set(parent, parentOrder);
    const obj = {
      selector: [
        variantContextResult.prefix,
        variantContextResult.selector,
        variantContextResult.pseudo
      ].join(""),
      entries: variantContextResult.entries,
      parent,
      layer: variantContextResult.layer,
      sort: variantContextResult.sort,
      noMerge: variantContextResult.noMerge
    };
    for (const p of this.config.postprocess)
      p(obj);
    return obj;
  }
  constructCustomCSS(context, body, overrideSelector) {
    const normalizedBody = normalizeCSSEntries(body);
    if (isString(normalizedBody))
      return normalizedBody;
    const { selector, entries, parent } = this.applyVariants([0, overrideSelector || context.rawSelector, normalizedBody, void 0, context.variantHandlers]);
    const cssBody = `${selector}{${entriesToCss(entries)}}`;
    if (parent)
      return `${parent}{${cssBody}}`;
    return cssBody;
  }
  async parseUtil(input, context, internal = false, shortcutPrefix) {
    const [raw, processed, variantHandlers] = isString(input) ? await this.matchVariants(input) : input;
    if (this.config.details)
      context.rules = context.rules ?? [];
    const staticMatch = this.config.rulesStaticMap[processed];
    if (staticMatch) {
      if (staticMatch[1] && (internal || !staticMatch[2]?.internal)) {
        if (this.config.details)
          context.rules.push(staticMatch[3]);
        const index = staticMatch[0];
        const entry = normalizeCSSEntries(staticMatch[1]);
        const meta = staticMatch[2];
        if (isString(entry))
          return [[index, entry, meta]];
        else
          return [[index, raw, entry, meta, variantHandlers]];
      }
    }
    context.variantHandlers = variantHandlers;
    const { rulesDynamic } = this.config;
    for (const [i, matcher, handler, meta] of rulesDynamic) {
      if (meta?.internal && !internal)
        continue;
      let unprefixed = processed;
      if (meta?.prefix) {
        const prefixes = toArray(meta.prefix);
        if (shortcutPrefix) {
          const shortcutPrefixes = toArray(shortcutPrefix);
          if (!prefixes.some((i2) => shortcutPrefixes.includes(i2)))
            continue;
        } else {
          const prefix = prefixes.find((i2) => processed.startsWith(i2));
          if (prefix == null)
            continue;
          unprefixed = processed.slice(prefix.length);
        }
      }
      const match = unprefixed.match(matcher);
      if (!match)
        continue;
      const result = await handler(match, context);
      if (!result)
        continue;
      if (this.config.details)
        context.rules.push([matcher, handler, meta]);
      const entries = normalizeCSSValues(result).filter((i2) => i2.length);
      if (entries.length) {
        return entries.map((e2) => {
          if (isString(e2))
            return [i, e2, meta];
          else
            return [i, raw, e2, meta, variantHandlers];
        });
      }
    }
  }
  stringifyUtil(parsed, context) {
    if (!parsed)
      return;
    if (isRawUtil(parsed))
      return [parsed[0], void 0, parsed[1], void 0, parsed[2], this.config.details ? context : void 0, void 0];
    const { selector, entries, parent, layer: variantLayer, sort: variantSort, noMerge } = this.applyVariants(parsed);
    const body = entriesToCss(entries);
    if (!body)
      return;
    const { layer: metaLayer, sort: metaSort, ...meta } = parsed[3] ?? {};
    const ruleMeta = {
      ...meta,
      layer: variantLayer ?? metaLayer,
      sort: variantSort ?? metaSort
    };
    return [parsed[0], selector, body, parent, ruleMeta, this.config.details ? context : void 0, noMerge];
  }
  async expandShortcut(input, context, depth = 5) {
    if (depth === 0)
      return;
    const recordShortcut = this.config.details ? (s) => {
      context.shortcuts = context.shortcuts ?? [];
      context.shortcuts.push(s);
    } : noop$3;
    let meta;
    let result;
    for (const s of this.config.shortcuts) {
      let unprefixed = input;
      if (s[2]?.prefix) {
        const prefixes = toArray(s[2].prefix);
        const prefix = prefixes.find((i) => input.startsWith(i));
        if (prefix == null)
          continue;
        unprefixed = input.slice(prefix.length);
      }
      if (isStaticShortcut(s)) {
        if (s[0] === unprefixed) {
          meta = meta || s[2];
          result = s[1];
          recordShortcut(s);
          break;
        }
      } else {
        const match = unprefixed.match(s[0]);
        if (match)
          result = s[1](match, context);
        if (result) {
          meta = meta || s[2];
          recordShortcut(s);
          break;
        }
      }
    }
    if (isString(result))
      result = expandVariantGroup(result.trim()).split(/\s+/g);
    if (!result) {
      const [raw, inputWithoutVariant] = isString(input) ? await this.matchVariants(input) : input;
      if (raw !== inputWithoutVariant) {
        const expanded = await this.expandShortcut(inputWithoutVariant, context, depth - 1);
        if (expanded)
          result = expanded[0].map((item) => isString(item) ? raw.replace(inputWithoutVariant, item) : item);
      }
    }
    if (!result)
      return;
    return [
      (await Promise.all(result.map(async (r) => (isString(r) ? (await this.expandShortcut(r, context, depth - 1))?.[0] : void 0) || [r]))).flat(1).filter(Boolean),
      meta
    ];
  }
  async stringifyShortcuts(parent, context, expanded, meta = { layer: this.config.shortcutsLayer }) {
    const layerMap = new BetterMap();
    const parsed = (await Promise.all(uniq(expanded).map(async (i) => {
      const result = isString(i) ? await this.parseUtil(i, context, true, meta.prefix) : [[Number.POSITIVE_INFINITY, "{inline}", normalizeCSSEntries(i), void 0, []]];
      if (!result && this.config.warn)
        warnOnce(`unmatched utility "${i}" in shortcut "${parent[1]}"`);
      return result || [];
    }))).flat(1).filter(Boolean).sort((a, b) => a[0] - b[0]);
    const [raw, , parentVariants] = parent;
    const rawStringifiedUtil = [];
    for (const item of parsed) {
      if (isRawUtil(item)) {
        rawStringifiedUtil.push([item[0], void 0, item[1], void 0, item[2], context, void 0]);
        continue;
      }
      const { selector, entries, parent: parent2, sort, noMerge, layer } = this.applyVariants(item, [...item[4], ...parentVariants], raw);
      const selectorMap = layerMap.getFallback(layer ?? meta.layer, new TwoKeyMap());
      const mapItem = selectorMap.getFallback(selector, parent2, [[], item[0]]);
      mapItem[0].push([entries, !!(noMerge ?? item[3]?.noMerge), sort ?? 0]);
    }
    return rawStringifiedUtil.concat(layerMap.flatMap(
      (selectorMap, layer) => selectorMap.map(([e2, index], selector, joinedParents) => {
        const stringify = (flatten, noMerge, entrySortPair) => {
          const maxSort = Math.max(...entrySortPair.map((e3) => e3[1]));
          const entriesList = entrySortPair.map((e3) => e3[0]);
          return (flatten ? [entriesList.flat(1)] : entriesList).map((entries) => {
            const body = entriesToCss(entries);
            if (body)
              return [index, selector, body, joinedParents, { ...meta, noMerge, sort: maxSort, layer }, context, void 0];
            return void 0;
          });
        };
        const merges = [
          [e2.filter(([, noMerge]) => noMerge).map(([entries, , sort]) => [entries, sort]), true],
          [e2.filter(([, noMerge]) => !noMerge).map(([entries, , sort]) => [entries, sort]), false]
        ];
        return merges.map(([e3, noMerge]) => [
          ...stringify(false, noMerge, e3.filter(([entries]) => entries.some((entry) => entry[0] === CONTROL_SHORTCUT_NO_MERGE))),
          ...stringify(true, noMerge, e3.filter(([entries]) => entries.every((entry) => entry[0] !== CONTROL_SHORTCUT_NO_MERGE)))
        ]);
      }).flat(2).filter(Boolean)
    ));
  }
  isBlocked(raw) {
    return !raw || this.config.blocklist.some((e2) => typeof e2 === "function" ? e2(raw) : isString(e2) ? e2 === raw : e2.test(raw));
  }
}
function createGenerator$1(config, defaults) {
  return new UnoGenerator(config, defaults);
}
const regexScopePlaceholder = /\s\$\$\s+/g;
function hasScopePlaceholder(css) {
  return regexScopePlaceholder.test(css);
}
function applyScope(css, scope) {
  if (hasScopePlaceholder(css))
    return css.replace(regexScopePlaceholder, scope ? ` ${scope} ` : " ");
  else
    return scope ? `${scope} ${css}` : css;
}
const attributifyRe = /^\[(.+?)(~?=)"(.*)"\]$/;
function toEscapedSelector(raw) {
  if (attributifyRe.test(raw))
    return raw.replace(attributifyRe, (_, n, s, i) => `[${e$1(n)}${s}"${e$1(i)}"]`);
  return `.${e$1(raw)}`;
}
function defaultVariantHandler(input, next) {
  return next(input);
}

dist$p.BetterMap = BetterMap;
dist$p.CONTROL_SHORTCUT_NO_MERGE = CONTROL_SHORTCUT_NO_MERGE;
dist$p.CountableSet = CountableSet;
dist$p.TwoKeyMap = TwoKeyMap;
dist$p.UnoGenerator = UnoGenerator;
dist$p.attributifyRE = attributifyRE;
dist$p.clearIdenticalEntries = clearIdenticalEntries;
dist$p.clone = clone$3;
dist$p.collapseVariantGroup = collapseVariantGroup;
dist$p.createGenerator = createGenerator$1;
dist$p.cssIdRE = cssIdRE;
dist$p.defaultSplitRE = defaultSplitRE;
dist$p.definePreset = definePreset;
dist$p.e = e$1;
dist$p.entriesToCss = entriesToCss;
dist$p.escapeRegExp = escapeRegExp;
dist$p.escapeSelector = escapeSelector;
dist$p.expandVariantGroup = expandVariantGroup;
dist$p.extractorDefault = extractorSplit;
dist$p.extractorSplit = extractorSplit;
dist$p.hasScopePlaceholder = hasScopePlaceholder;
dist$p.isAttributifySelector = isAttributifySelector;
dist$p.isCountableSet = isCountableSet;
dist$p.isObject = isObject$1;
dist$p.isRawUtil = isRawUtil;
dist$p.isStaticRule = isStaticRule;
dist$p.isStaticShortcut = isStaticShortcut;
dist$p.isString = isString;
dist$p.isValidSelector = isValidSelector;
dist$p.makeRegexClassGroup = makeRegexClassGroup;
dist$p.mergeConfigs = mergeConfigs;
dist$p.mergeDeep = mergeDeep;
dist$p.noop = noop$3;
dist$p.normalizeCSSEntries = normalizeCSSEntries;
dist$p.normalizeCSSValues = normalizeCSSValues;
dist$p.normalizeVariant = normalizeVariant;
dist$p.notNull = notNull;
dist$p.parseVariantGroup = parseVariantGroup;
dist$p.regexScopePlaceholder = regexScopePlaceholder;
dist$p.resolveConfig = resolveConfig;
dist$p.resolvePreset = resolvePreset;
dist$p.resolvePresets = resolvePresets;
dist$p.resolveShortcuts = resolveShortcuts;
dist$p.splitWithVariantGroupRE = splitWithVariantGroupRE;
dist$p.toArray = toArray;
dist$p.toEscapedSelector = toEscapedSelector;
dist$p.uniq = uniq;
dist$p.uniqueBy = uniqueBy;
dist$p.validateFilterRE = validateFilterRE;
dist$p.warnOnce = warnOnce;
dist$p.withLayer = withLayer;

var dist$o = {};

var dist$n = {};

var dist$m = {};

var dist$l = {};

Object.defineProperty(dist$l, '__esModule', { value: true });

const core$j = dist$p;

const sourceMapRE = /\/\/#\s*sourceMappingURL=.*\n?/g;
function removeSourceMap(code) {
  if (code.includes("sourceMappingURL="))
    return code.replace(sourceMapRE, "");
  return code;
}

const quotedArbitraryValuesRE = /(?:[\w&:[\]-]|\[\S{1,64}=\S{1,64}\]){1,64}\[\\?['"]?\S{1,64}?['"]\]\]?[\w:-]{0,64}/g;
const arbitraryPropertyRE = /\[(\\\W|[\w-]){1,64}:[^\s:]{0,64}?("\S{1,64}?"|'\S{1,64}?'|`\S{1,64}?`|[^\s:]{1,64}?)[^\s:]{0,64}?\)?\]/g;
const arbitraryPropertyCandidateRE = /^\[(\\\W|[\w-]){1,64}:['"]?\S{1,64}?['"]?\]$/;
function splitCodeWithArbitraryVariants(code) {
  const result = [];
  for (const match of code.matchAll(arbitraryPropertyRE)) {
    if (match.index !== 0 && !/^[\s'"`]/.test(code[match.index - 1] ?? ""))
      continue;
    result.push(match[0]);
  }
  for (const match of code.matchAll(quotedArbitraryValuesRE))
    result.push(match[0]);
  code.split(core$j.defaultSplitRE).forEach((match) => {
    if (core$j.isValidSelector(match) && !arbitraryPropertyCandidateRE.test(match))
      result.push(match);
  });
  return result;
}
const extractorArbitraryVariants$1 = {
  name: "@unocss/extractor-arbitrary-variants",
  order: 0,
  extract({ code }) {
    return splitCodeWithArbitraryVariants(removeSourceMap(code));
  }
};

dist$l.arbitraryPropertyRE = arbitraryPropertyRE;
dist$l.default = extractorArbitraryVariants$1;
dist$l.extractorArbitraryVariants = extractorArbitraryVariants$1;
dist$l.quotedArbitraryValuesRE = quotedArbitraryValuesRE;
dist$l.splitCodeWithArbitraryVariants = splitCodeWithArbitraryVariants;

var presetMini_DahJgnb1 = {};

var dist$k = {};

var sourcemapCodec_umd = {exports: {}};

(function (module, exports) {
	(function (global, factory) {
	    factory(exports) ;
	})(commonjsGlobal, (function (exports) {
	    const comma = ','.charCodeAt(0);
	    const semicolon = ';'.charCodeAt(0);
	    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	    const intToChar = new Uint8Array(64); // 64 possible chars.
	    const charToInt = new Uint8Array(128); // z is 122 in ASCII
	    for (let i = 0; i < chars.length; i++) {
	        const c = chars.charCodeAt(i);
	        intToChar[i] = c;
	        charToInt[c] = i;
	    }
	    // Provide a fallback for older environments.
	    const td = typeof TextDecoder !== 'undefined'
	        ? /* #__PURE__ */ new TextDecoder()
	        : typeof Buffer !== 'undefined'
	            ? {
	                decode(buf) {
	                    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
	                    return out.toString();
	                },
	            }
	            : {
	                decode(buf) {
	                    let out = '';
	                    for (let i = 0; i < buf.length; i++) {
	                        out += String.fromCharCode(buf[i]);
	                    }
	                    return out;
	                },
	            };
	    function decode(mappings) {
	        const state = new Int32Array(5);
	        const decoded = [];
	        let index = 0;
	        do {
	            const semi = indexOf(mappings, index);
	            const line = [];
	            let sorted = true;
	            let lastCol = 0;
	            state[0] = 0;
	            for (let i = index; i < semi; i++) {
	                let seg;
	                i = decodeInteger(mappings, i, state, 0); // genColumn
	                const col = state[0];
	                if (col < lastCol)
	                    sorted = false;
	                lastCol = col;
	                if (hasMoreVlq(mappings, i, semi)) {
	                    i = decodeInteger(mappings, i, state, 1); // sourcesIndex
	                    i = decodeInteger(mappings, i, state, 2); // sourceLine
	                    i = decodeInteger(mappings, i, state, 3); // sourceColumn
	                    if (hasMoreVlq(mappings, i, semi)) {
	                        i = decodeInteger(mappings, i, state, 4); // namesIndex
	                        seg = [col, state[1], state[2], state[3], state[4]];
	                    }
	                    else {
	                        seg = [col, state[1], state[2], state[3]];
	                    }
	                }
	                else {
	                    seg = [col];
	                }
	                line.push(seg);
	            }
	            if (!sorted)
	                sort(line);
	            decoded.push(line);
	            index = semi + 1;
	        } while (index <= mappings.length);
	        return decoded;
	    }
	    function indexOf(mappings, index) {
	        const idx = mappings.indexOf(';', index);
	        return idx === -1 ? mappings.length : idx;
	    }
	    function decodeInteger(mappings, pos, state, j) {
	        let value = 0;
	        let shift = 0;
	        let integer = 0;
	        do {
	            const c = mappings.charCodeAt(pos++);
	            integer = charToInt[c];
	            value |= (integer & 31) << shift;
	            shift += 5;
	        } while (integer & 32);
	        const shouldNegate = value & 1;
	        value >>>= 1;
	        if (shouldNegate) {
	            value = -0x80000000 | -value;
	        }
	        state[j] += value;
	        return pos;
	    }
	    function hasMoreVlq(mappings, i, length) {
	        if (i >= length)
	            return false;
	        return mappings.charCodeAt(i) !== comma;
	    }
	    function sort(line) {
	        line.sort(sortComparator);
	    }
	    function sortComparator(a, b) {
	        return a[0] - b[0];
	    }
	    function encode(decoded) {
	        const state = new Int32Array(5);
	        const bufLength = 1024 * 16;
	        const subLength = bufLength - 36;
	        const buf = new Uint8Array(bufLength);
	        const sub = buf.subarray(0, subLength);
	        let pos = 0;
	        let out = '';
	        for (let i = 0; i < decoded.length; i++) {
	            const line = decoded[i];
	            if (i > 0) {
	                if (pos === bufLength) {
	                    out += td.decode(buf);
	                    pos = 0;
	                }
	                buf[pos++] = semicolon;
	            }
	            if (line.length === 0)
	                continue;
	            state[0] = 0;
	            for (let j = 0; j < line.length; j++) {
	                const segment = line[j];
	                // We can push up to 5 ints, each int can take at most 7 chars, and we
	                // may push a comma.
	                if (pos > subLength) {
	                    out += td.decode(sub);
	                    buf.copyWithin(0, subLength, pos);
	                    pos -= subLength;
	                }
	                if (j > 0)
	                    buf[pos++] = comma;
	                pos = encodeInteger(buf, pos, state, segment, 0); // genColumn
	                if (segment.length === 1)
	                    continue;
	                pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex
	                pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine
	                pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn
	                if (segment.length === 4)
	                    continue;
	                pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex
	            }
	        }
	        return out + td.decode(buf.subarray(0, pos));
	    }
	    function encodeInteger(buf, pos, state, segment, j) {
	        const next = segment[j];
	        let num = next - state[j];
	        state[j] = next;
	        num = num < 0 ? (-num << 1) | 1 : num << 1;
	        do {
	            let clamped = num & 0b011111;
	            num >>>= 5;
	            if (num > 0)
	                clamped |= 0b100000;
	            buf[pos++] = intToChar[clamped];
	        } while (num > 0);
	        return pos;
	    }

	    exports.decode = decode;
	    exports.encode = encode;

	    Object.defineProperty(exports, '__esModule', { value: true });

	}));
	
} (sourcemapCodec_umd, sourcemapCodec_umd.exports));

var sourcemapCodec_umdExports = sourcemapCodec_umd.exports;

var sourcemapCodec = sourcemapCodec_umdExports;

class BitSet {
	constructor(arg) {
		this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
	}

	add(n) {
		this.bits[n >> 5] |= 1 << (n & 31);
	}

	has(n) {
		return !!(this.bits[n >> 5] & (1 << (n & 31)));
	}
}

class Chunk {
	constructor(start, end, content) {
		this.start = start;
		this.end = end;
		this.original = content;

		this.intro = '';
		this.outro = '';

		this.content = content;
		this.storeName = false;
		this.edited = false;

		{
			this.previous = null;
			this.next = null;
		}
	}

	appendLeft(content) {
		this.outro += content;
	}

	appendRight(content) {
		this.intro = this.intro + content;
	}

	clone() {
		const chunk = new Chunk(this.start, this.end, this.original);

		chunk.intro = this.intro;
		chunk.outro = this.outro;
		chunk.content = this.content;
		chunk.storeName = this.storeName;
		chunk.edited = this.edited;

		return chunk;
	}

	contains(index) {
		return this.start < index && index < this.end;
	}

	eachNext(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.next;
		}
	}

	eachPrevious(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.previous;
		}
	}

	edit(content, storeName, contentOnly) {
		this.content = content;
		if (!contentOnly) {
			this.intro = '';
			this.outro = '';
		}
		this.storeName = storeName;

		this.edited = true;

		return this;
	}

	prependLeft(content) {
		this.outro = content + this.outro;
	}

	prependRight(content) {
		this.intro = content + this.intro;
	}

	reset() {
		this.intro = '';
		this.outro = '';
		if (this.edited) {
			this.content = this.original;
			this.storeName = false;
			this.edited = false;
		}
	}

	split(index) {
		const sliceIndex = index - this.start;

		const originalBefore = this.original.slice(0, sliceIndex);
		const originalAfter = this.original.slice(sliceIndex);

		this.original = originalBefore;

		const newChunk = new Chunk(index, this.end, originalAfter);
		newChunk.outro = this.outro;
		this.outro = '';

		this.end = index;

		if (this.edited) {
			// after split we should save the edit content record into the correct chunk
			// to make sure sourcemap correct
			// For example:
			// '  test'.trim()
			//     split   -> '  ' + 'test'
			//   ✔️ edit    -> '' + 'test'
			//   ✖️ edit    -> 'test' + '' 
			// TODO is this block necessary?...
			newChunk.edit('', false);
			this.content = '';
		} else {
			this.content = originalBefore;
		}

		newChunk.next = this.next;
		if (newChunk.next) newChunk.next.previous = newChunk;
		newChunk.previous = this;
		this.next = newChunk;

		return newChunk;
	}

	toString() {
		return this.intro + this.content + this.outro;
	}

	trimEnd(rx) {
		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) return true;

		const trimmed = this.content.replace(rx, '');

		if (trimmed.length) {
			if (trimmed !== this.content) {
				this.split(this.start + trimmed.length).edit('', undefined, true);
				if (this.edited) {
					// save the change, if it has been edited
					this.edit(trimmed, this.storeName, true);
				}
			}
			return true;
		} else {
			this.edit('', undefined, true);

			this.intro = this.intro.replace(rx, '');
			if (this.intro.length) return true;
		}
	}

	trimStart(rx) {
		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) return true;

		const trimmed = this.content.replace(rx, '');

		if (trimmed.length) {
			if (trimmed !== this.content) {
				const newChunk = this.split(this.end - trimmed.length);
				if (this.edited) {
					// save the change, if it has been edited
					newChunk.edit(trimmed, this.storeName, true);
				}
				this.edit('', undefined, true);
			}
			return true;
		} else {
			this.edit('', undefined, true);

			this.outro = this.outro.replace(rx, '');
			if (this.outro.length) return true;
		}
	}
}

function getBtoa() {
	if (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {
		return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));
	} else if (typeof Buffer === 'function') {
		return (str) => Buffer.from(str, 'utf-8').toString('base64');
	} else {
		return () => {
			throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
		};
	}
}

const btoa = /*#__PURE__*/ getBtoa();

class SourceMap {
	constructor(properties) {
		this.version = 3;
		this.file = properties.file;
		this.sources = properties.sources;
		this.sourcesContent = properties.sourcesContent;
		this.names = properties.names;
		this.mappings = sourcemapCodec.encode(properties.mappings);
		if (typeof properties.x_google_ignoreList !== 'undefined') {
			this.x_google_ignoreList = properties.x_google_ignoreList;
		}
	}

	toString() {
		return JSON.stringify(this);
	}

	toUrl() {
		return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
	}
}

function guessIndent(code) {
	const lines = code.split('\n');

	const tabbed = lines.filter((line) => /^\t+/.test(line));
	const spaced = lines.filter((line) => /^ {2,}/.test(line));

	if (tabbed.length === 0 && spaced.length === 0) {
		return null;
	}

	// More lines tabbed than spaced? Assume tabs, and
	// default to tabs in the case of a tie (or nothing
	// to go on)
	if (tabbed.length >= spaced.length) {
		return '\t';
	}

	// Otherwise, we need to guess the multiple
	const min = spaced.reduce((previous, current) => {
		const numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);

	return new Array(min + 1).join(' ');
}

function getRelativePath(from, to) {
	const fromParts = from.split(/[/\\]/);
	const toParts = to.split(/[/\\]/);

	fromParts.pop(); // get dirname

	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}

	if (fromParts.length) {
		let i = fromParts.length;
		while (i--) fromParts[i] = '..';
	}

	return fromParts.concat(toParts).join('/');
}

const toString = Object.prototype.toString;

function isObject(thing) {
	return toString.call(thing) === '[object Object]';
}

function getLocator(source) {
	const originalLines = source.split('\n');
	const lineOffsets = [];

	for (let i = 0, pos = 0; i < originalLines.length; i++) {
		lineOffsets.push(pos);
		pos += originalLines[i].length + 1;
	}

	return function locate(index) {
		let i = 0;
		let j = lineOffsets.length;
		while (i < j) {
			const m = (i + j) >> 1;
			if (index < lineOffsets[m]) {
				j = m;
			} else {
				i = m + 1;
			}
		}
		const line = i - 1;
		const column = index - lineOffsets[line];
		return { line, column };
	};
}

const wordRegex = /\w/;

class Mappings {
	constructor(hires) {
		this.hires = hires;
		this.generatedCodeLine = 0;
		this.generatedCodeColumn = 0;
		this.raw = [];
		this.rawSegments = this.raw[this.generatedCodeLine] = [];
		this.pending = null;
	}

	addEdit(sourceIndex, content, loc, nameIndex) {
		if (content.length) {
			const contentLengthMinusOne = content.length - 1;
			let contentLineEnd = content.indexOf('\n', 0);
			let previousContentLineEnd = -1;
			// Loop through each line in the content and add a segment, but stop if the last line is empty,
			// else code afterwards would fill one line too many
			while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
				const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
				if (nameIndex >= 0) {
					segment.push(nameIndex);
				}
				this.rawSegments.push(segment);

				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;

				previousContentLineEnd = contentLineEnd;
				contentLineEnd = content.indexOf('\n', contentLineEnd + 1);
			}

			const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
			if (nameIndex >= 0) {
				segment.push(nameIndex);
			}
			this.rawSegments.push(segment);

			this.advance(content.slice(previousContentLineEnd + 1));
		} else if (this.pending) {
			this.rawSegments.push(this.pending);
			this.advance(content);
		}

		this.pending = null;
	}

	addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
		let originalCharIndex = chunk.start;
		let first = true;
		// when iterating each char, check if it's in a word boundary
		let charInHiresBoundary = false;

		while (originalCharIndex < chunk.end) {
			if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
				const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];

				if (this.hires === 'boundary') {
					// in hires "boundary", group segments per word boundary than per char
					if (wordRegex.test(original[originalCharIndex])) {
						// for first char in the boundary found, start the boundary by pushing a segment
						if (!charInHiresBoundary) {
							this.rawSegments.push(segment);
							charInHiresBoundary = true;
						}
					} else {
						// for non-word char, end the boundary by pushing a segment
						this.rawSegments.push(segment);
						charInHiresBoundary = false;
					}
				} else {
					this.rawSegments.push(segment);
				}
			}

			if (original[originalCharIndex] === '\n') {
				loc.line += 1;
				loc.column = 0;
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				first = true;
			} else {
				loc.column += 1;
				this.generatedCodeColumn += 1;
				first = false;
			}

			originalCharIndex += 1;
		}

		this.pending = null;
	}

	advance(str) {
		if (!str) return;

		const lines = str.split('\n');

		if (lines.length > 1) {
			for (let i = 0; i < lines.length - 1; i++) {
				this.generatedCodeLine++;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
			}
			this.generatedCodeColumn = 0;
		}

		this.generatedCodeColumn += lines[lines.length - 1].length;
	}
}

const n$1 = '\n';

const warned = {
	insertLeft: false,
	insertRight: false,
	storeName: false,
};

let MagicString$1 = class MagicString {
	constructor(string, options = {}) {
		const chunk = new Chunk(0, string.length, string);

		Object.defineProperties(this, {
			original: { writable: true, value: string },
			outro: { writable: true, value: '' },
			intro: { writable: true, value: '' },
			firstChunk: { writable: true, value: chunk },
			lastChunk: { writable: true, value: chunk },
			lastSearchedChunk: { writable: true, value: chunk },
			byStart: { writable: true, value: {} },
			byEnd: { writable: true, value: {} },
			filename: { writable: true, value: options.filename },
			indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
			sourcemapLocations: { writable: true, value: new BitSet() },
			storedNames: { writable: true, value: {} },
			indentStr: { writable: true, value: undefined },
			ignoreList: { writable: true, value: options.ignoreList },
		});

		this.byStart[0] = chunk;
		this.byEnd[string.length] = chunk;
	}

	addSourcemapLocation(char) {
		this.sourcemapLocations.add(char);
	}

	append(content) {
		if (typeof content !== 'string') throw new TypeError('outro content must be a string');

		this.outro += content;
		return this;
	}

	appendLeft(index, content) {
		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byEnd[index];

		if (chunk) {
			chunk.appendLeft(content);
		} else {
			this.intro += content;
		}
		return this;
	}

	appendRight(index, content) {
		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byStart[index];

		if (chunk) {
			chunk.appendRight(content);
		} else {
			this.outro += content;
		}
		return this;
	}

	clone() {
		const cloned = new MagicString(this.original, { filename: this.filename });

		let originalChunk = this.firstChunk;
		let clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());

		while (originalChunk) {
			cloned.byStart[clonedChunk.start] = clonedChunk;
			cloned.byEnd[clonedChunk.end] = clonedChunk;

			const nextOriginalChunk = originalChunk.next;
			const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();

			if (nextClonedChunk) {
				clonedChunk.next = nextClonedChunk;
				nextClonedChunk.previous = clonedChunk;

				clonedChunk = nextClonedChunk;
			}

			originalChunk = nextOriginalChunk;
		}

		cloned.lastChunk = clonedChunk;

		if (this.indentExclusionRanges) {
			cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
		}

		cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);

		cloned.intro = this.intro;
		cloned.outro = this.outro;

		return cloned;
	}

	generateDecodedMap(options) {
		options = options || {};

		const sourceIndex = 0;
		const names = Object.keys(this.storedNames);
		const mappings = new Mappings(options.hires);

		const locate = getLocator(this.original);

		if (this.intro) {
			mappings.advance(this.intro);
		}

		this.firstChunk.eachNext((chunk) => {
			const loc = locate(chunk.start);

			if (chunk.intro.length) mappings.advance(chunk.intro);

			if (chunk.edited) {
				mappings.addEdit(
					sourceIndex,
					chunk.content,
					loc,
					chunk.storeName ? names.indexOf(chunk.original) : -1,
				);
			} else {
				mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
			}

			if (chunk.outro.length) mappings.advance(chunk.outro);
		});

		return {
			file: options.file ? options.file.split(/[/\\]/).pop() : undefined,
			sources: [
				options.source ? getRelativePath(options.file || '', options.source) : options.file || '',
			],
			sourcesContent: options.includeContent ? [this.original] : undefined,
			names,
			mappings: mappings.raw,
			x_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined,
		};
	}

	generateMap(options) {
		return new SourceMap(this.generateDecodedMap(options));
	}

	_ensureindentStr() {
		if (this.indentStr === undefined) {
			this.indentStr = guessIndent(this.original);
		}
	}

	_getRawIndentString() {
		this._ensureindentStr();
		return this.indentStr;
	}

	getIndentString() {
		this._ensureindentStr();
		return this.indentStr === null ? '\t' : this.indentStr;
	}

	indent(indentStr, options) {
		const pattern = /^[^\r\n]/gm;

		if (isObject(indentStr)) {
			options = indentStr;
			indentStr = undefined;
		}

		if (indentStr === undefined) {
			this._ensureindentStr();
			indentStr = this.indentStr || '\t';
		}

		if (indentStr === '') return this; // noop

		options = options || {};

		// Process exclusion ranges
		const isExcluded = {};

		if (options.exclude) {
			const exclusions =
				typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
			exclusions.forEach((exclusion) => {
				for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
					isExcluded[i] = true;
				}
			});
		}

		let shouldIndentNextCharacter = options.indentStart !== false;
		const replacer = (match) => {
			if (shouldIndentNextCharacter) return `${indentStr}${match}`;
			shouldIndentNextCharacter = true;
			return match;
		};

		this.intro = this.intro.replace(pattern, replacer);

		let charIndex = 0;
		let chunk = this.firstChunk;

		while (chunk) {
			const end = chunk.end;

			if (chunk.edited) {
				if (!isExcluded[charIndex]) {
					chunk.content = chunk.content.replace(pattern, replacer);

					if (chunk.content.length) {
						shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
					}
				}
			} else {
				charIndex = chunk.start;

				while (charIndex < end) {
					if (!isExcluded[charIndex]) {
						const char = this.original[charIndex];

						if (char === '\n') {
							shouldIndentNextCharacter = true;
						} else if (char !== '\r' && shouldIndentNextCharacter) {
							shouldIndentNextCharacter = false;

							if (charIndex === chunk.start) {
								chunk.prependRight(indentStr);
							} else {
								this._splitChunk(chunk, charIndex);
								chunk = chunk.next;
								chunk.prependRight(indentStr);
							}
						}
					}

					charIndex += 1;
				}
			}

			charIndex = chunk.end;
			chunk = chunk.next;
		}

		this.outro = this.outro.replace(pattern, replacer);

		return this;
	}

	insert() {
		throw new Error(
			'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)',
		);
	}

	insertLeft(index, content) {
		if (!warned.insertLeft) {
			console.warn(
				'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead',
			); // eslint-disable-line no-console
			warned.insertLeft = true;
		}

		return this.appendLeft(index, content);
	}

	insertRight(index, content) {
		if (!warned.insertRight) {
			console.warn(
				'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead',
			); // eslint-disable-line no-console
			warned.insertRight = true;
		}

		return this.prependRight(index, content);
	}

	move(start, end, index) {
		if (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');

		this._split(start);
		this._split(end);
		this._split(index);

		const first = this.byStart[start];
		const last = this.byEnd[end];

		const oldLeft = first.previous;
		const oldRight = last.next;

		const newRight = this.byStart[index];
		if (!newRight && last === this.lastChunk) return this;
		const newLeft = newRight ? newRight.previous : this.lastChunk;

		if (oldLeft) oldLeft.next = oldRight;
		if (oldRight) oldRight.previous = oldLeft;

		if (newLeft) newLeft.next = first;
		if (newRight) newRight.previous = last;

		if (!first.previous) this.firstChunk = last.next;
		if (!last.next) {
			this.lastChunk = first.previous;
			this.lastChunk.next = null;
		}

		first.previous = newLeft;
		last.next = newRight || null;

		if (!newLeft) this.firstChunk = first;
		if (!newRight) this.lastChunk = last;
		return this;
	}

	overwrite(start, end, content, options) {
		options = options || {};
		return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });
	}

	update(start, end, content, options) {
		if (typeof content !== 'string') throw new TypeError('replacement content must be a string');

		while (start < 0) start += this.original.length;
		while (end < 0) end += this.original.length;

		if (end > this.original.length) throw new Error('end is out of bounds');
		if (start === end)
			throw new Error(
				'Cannot overwrite a zero-length range – use appendLeft or prependRight instead',
			);

		this._split(start);
		this._split(end);

		if (options === true) {
			if (!warned.storeName) {
				console.warn(
					'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string',
				); // eslint-disable-line no-console
				warned.storeName = true;
			}

			options = { storeName: true };
		}
		const storeName = options !== undefined ? options.storeName : false;
		const overwrite = options !== undefined ? options.overwrite : false;

		if (storeName) {
			const original = this.original.slice(start, end);
			Object.defineProperty(this.storedNames, original, {
				writable: true,
				value: true,
				enumerable: true,
			});
		}

		const first = this.byStart[start];
		const last = this.byEnd[end];

		if (first) {
			let chunk = first;
			while (chunk !== last) {
				if (chunk.next !== this.byStart[chunk.end]) {
					throw new Error('Cannot overwrite across a split point');
				}
				chunk = chunk.next;
				chunk.edit('', false);
			}

			first.edit(content, storeName, !overwrite);
		} else {
			// must be inserting at the end
			const newChunk = new Chunk(start, end, '').edit(content, storeName);

			// TODO last chunk in the array may not be the last chunk, if it's moved...
			last.next = newChunk;
			newChunk.previous = last;
		}
		return this;
	}

	prepend(content) {
		if (typeof content !== 'string') throw new TypeError('outro content must be a string');

		this.intro = content + this.intro;
		return this;
	}

	prependLeft(index, content) {
		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byEnd[index];

		if (chunk) {
			chunk.prependLeft(content);
		} else {
			this.intro = content + this.intro;
		}
		return this;
	}

	prependRight(index, content) {
		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byStart[index];

		if (chunk) {
			chunk.prependRight(content);
		} else {
			this.outro = content + this.outro;
		}
		return this;
	}

	remove(start, end) {
		while (start < 0) start += this.original.length;
		while (end < 0) end += this.original.length;

		if (start === end) return this;

		if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
		if (start > end) throw new Error('end must be greater than start');

		this._split(start);
		this._split(end);

		let chunk = this.byStart[start];

		while (chunk) {
			chunk.intro = '';
			chunk.outro = '';
			chunk.edit('');

			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}

	reset(start, end) {
		while (start < 0) start += this.original.length;
		while (end < 0) end += this.original.length;

		if (start === end) return this;

		if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
		if (start > end) throw new Error('end must be greater than start');

		this._split(start);
		this._split(end);

		let chunk = this.byStart[start];

		while (chunk) {
			chunk.reset();

			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}

	lastChar() {
		if (this.outro.length) return this.outro[this.outro.length - 1];
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
			if (chunk.content.length) return chunk.content[chunk.content.length - 1];
			if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
		} while ((chunk = chunk.previous));
		if (this.intro.length) return this.intro[this.intro.length - 1];
		return '';
	}

	lastLine() {
		let lineIndex = this.outro.lastIndexOf(n$1);
		if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
		let lineStr = this.outro;
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length > 0) {
				lineIndex = chunk.outro.lastIndexOf(n$1);
				if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.outro + lineStr;
			}

			if (chunk.content.length > 0) {
				lineIndex = chunk.content.lastIndexOf(n$1);
				if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.content + lineStr;
			}

			if (chunk.intro.length > 0) {
				lineIndex = chunk.intro.lastIndexOf(n$1);
				if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.intro + lineStr;
			}
		} while ((chunk = chunk.previous));
		lineIndex = this.intro.lastIndexOf(n$1);
		if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
		return this.intro + lineStr;
	}

	slice(start = 0, end = this.original.length) {
		while (start < 0) start += this.original.length;
		while (end < 0) end += this.original.length;

		let result = '';

		// find start chunk
		let chunk = this.firstChunk;
		while (chunk && (chunk.start > start || chunk.end <= start)) {
			// found end chunk before start
			if (chunk.start < end && chunk.end >= end) {
				return result;
			}

			chunk = chunk.next;
		}

		if (chunk && chunk.edited && chunk.start !== start)
			throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);

		const startChunk = chunk;
		while (chunk) {
			if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
				result += chunk.intro;
			}

			const containsEnd = chunk.start < end && chunk.end >= end;
			if (containsEnd && chunk.edited && chunk.end !== end)
				throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);

			const sliceStart = startChunk === chunk ? start - chunk.start : 0;
			const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;

			result += chunk.content.slice(sliceStart, sliceEnd);

			if (chunk.outro && (!containsEnd || chunk.end === end)) {
				result += chunk.outro;
			}

			if (containsEnd) {
				break;
			}

			chunk = chunk.next;
		}

		return result;
	}

	// TODO deprecate this? not really very useful
	snip(start, end) {
		const clone = this.clone();
		clone.remove(0, start);
		clone.remove(end, clone.original.length);

		return clone;
	}

	_split(index) {
		if (this.byStart[index] || this.byEnd[index]) return;

		let chunk = this.lastSearchedChunk;
		const searchForward = index > chunk.end;

		while (chunk) {
			if (chunk.contains(index)) return this._splitChunk(chunk, index);

			chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
		}
	}

	_splitChunk(chunk, index) {
		if (chunk.edited && chunk.content.length) {
			// zero-length edited chunks are a special case (overlapping replacements)
			const loc = getLocator(this.original)(index);
			throw new Error(
				`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – "${chunk.original}")`,
			);
		}

		const newChunk = chunk.split(index);

		this.byEnd[index] = chunk;
		this.byStart[index] = newChunk;
		this.byEnd[newChunk.end] = newChunk;

		if (chunk === this.lastChunk) this.lastChunk = newChunk;

		this.lastSearchedChunk = chunk;
		return true;
	}

	toString() {
		let str = this.intro;

		let chunk = this.firstChunk;
		while (chunk) {
			str += chunk.toString();
			chunk = chunk.next;
		}

		return str + this.outro;
	}

	isEmpty() {
		let chunk = this.firstChunk;
		do {
			if (
				(chunk.intro.length && chunk.intro.trim()) ||
				(chunk.content.length && chunk.content.trim()) ||
				(chunk.outro.length && chunk.outro.trim())
			)
				return false;
		} while ((chunk = chunk.next));
		return true;
	}

	length() {
		let chunk = this.firstChunk;
		let length = 0;
		do {
			length += chunk.intro.length + chunk.content.length + chunk.outro.length;
		} while ((chunk = chunk.next));
		return length;
	}

	trimLines() {
		return this.trim('[\\r\\n]');
	}

	trim(charType) {
		return this.trimStart(charType).trimEnd(charType);
	}

	trimEndAborted(charType) {
		const rx = new RegExp((charType || '\\s') + '+$');

		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) return true;

		let chunk = this.lastChunk;

		do {
			const end = chunk.end;
			const aborted = chunk.trimEnd(rx);

			// if chunk was trimmed, we have a new lastChunk
			if (chunk.end !== end) {
				if (this.lastChunk === chunk) {
					this.lastChunk = chunk.next;
				}

				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}

			if (aborted) return true;
			chunk = chunk.previous;
		} while (chunk);

		return false;
	}

	trimEnd(charType) {
		this.trimEndAborted(charType);
		return this;
	}
	trimStartAborted(charType) {
		const rx = new RegExp('^' + (charType || '\\s') + '+');

		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) return true;

		let chunk = this.firstChunk;

		do {
			const end = chunk.end;
			const aborted = chunk.trimStart(rx);

			if (chunk.end !== end) {
				// special case...
				if (chunk === this.lastChunk) this.lastChunk = chunk.next;

				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}

			if (aborted) return true;
			chunk = chunk.next;
		} while (chunk);

		return false;
	}

	trimStart(charType) {
		this.trimStartAborted(charType);
		return this;
	}

	hasChanged() {
		return this.original !== this.toString();
	}

	_replaceRegexp(searchValue, replacement) {
		function getReplacement(match, str) {
			if (typeof replacement === 'string') {
				return replacement.replace(/\$(\$|&|\d+)/g, (_, i) => {
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter
					if (i === '$') return '$';
					if (i === '&') return match[0];
					const num = +i;
					if (num < match.length) return match[+i];
					return `$${i}`;
				});
			} else {
				return replacement(...match, match.index, str, match.groups);
			}
		}
		function matchAll(re, str) {
			let match;
			const matches = [];
			while ((match = re.exec(str))) {
				matches.push(match);
			}
			return matches;
		}
		if (searchValue.global) {
			const matches = matchAll(searchValue, this.original);
			matches.forEach((match) => {
				if (match.index != null) {
					const replacement = getReplacement(match, this.original);
					if (replacement !== match[0]) {
						this.overwrite(
							match.index,
							match.index + match[0].length,
							replacement
						);
					}
				}
			});
		} else {
			const match = this.original.match(searchValue);
			if (match && match.index != null) {
				const replacement = getReplacement(match, this.original);
				if (replacement !== match[0]) {
					this.overwrite(
						match.index,
						match.index + match[0].length,
						replacement
					);
				}
			}
		}
		return this;
	}

	_replaceString(string, replacement) {
		const { original } = this;
		const index = original.indexOf(string);

		if (index !== -1) {
			this.overwrite(index, index + string.length, replacement);
		}

		return this;
	}

	replace(searchValue, replacement) {
		if (typeof searchValue === 'string') {
			return this._replaceString(searchValue, replacement);
		}

		return this._replaceRegexp(searchValue, replacement);
	}

	_replaceAllString(string, replacement) {
		const { original } = this;
		const stringLength = string.length;
		for (
			let index = original.indexOf(string);
			index !== -1;
			index = original.indexOf(string, index + stringLength)
		) {
			const previous = original.slice(index, index + stringLength);
			if (previous !== replacement)
				this.overwrite(index, index + stringLength, replacement);
		}

		return this;
	}

	replaceAll(searchValue, replacement) {
		if (typeof searchValue === 'string') {
			return this._replaceAllString(searchValue, replacement);
		}

		if (!searchValue.global) {
			throw new TypeError(
				'MagicString.prototype.replaceAll called with a non-global RegExp argument',
			);
		}

		return this._replaceRegexp(searchValue, replacement);
	}
};

const hasOwnProp = Object.prototype.hasOwnProperty;

class Bundle {
	constructor(options = {}) {
		this.intro = options.intro || '';
		this.separator = options.separator !== undefined ? options.separator : '\n';
		this.sources = [];
		this.uniqueSources = [];
		this.uniqueSourceIndexByFilename = {};
	}

	addSource(source) {
		if (source instanceof MagicString$1) {
			return this.addSource({
				content: source,
				filename: source.filename,
				separator: this.separator,
			});
		}

		if (!isObject(source) || !source.content) {
			throw new Error(
				'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`',
			);
		}

		['filename', 'ignoreList', 'indentExclusionRanges', 'separator'].forEach((option) => {
			if (!hasOwnProp.call(source, option)) source[option] = source.content[option];
		});

		if (source.separator === undefined) {
			// TODO there's a bunch of this sort of thing, needs cleaning up
			source.separator = this.separator;
		}

		if (source.filename) {
			if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
				this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
				this.uniqueSources.push({ filename: source.filename, content: source.content.original });
			} else {
				const uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
				if (source.content.original !== uniqueSource.content) {
					throw new Error(`Illegal source: same filename (${source.filename}), different contents`);
				}
			}
		}

		this.sources.push(source);
		return this;
	}

	append(str, options) {
		this.addSource({
			content: new MagicString$1(str),
			separator: (options && options.separator) || '',
		});

		return this;
	}

	clone() {
		const bundle = new Bundle({
			intro: this.intro,
			separator: this.separator,
		});

		this.sources.forEach((source) => {
			bundle.addSource({
				filename: source.filename,
				content: source.content.clone(),
				separator: source.separator,
			});
		});

		return bundle;
	}

	generateDecodedMap(options = {}) {
		const names = [];
		let x_google_ignoreList = undefined;
		this.sources.forEach((source) => {
			Object.keys(source.content.storedNames).forEach((name) => {
				if (!~names.indexOf(name)) names.push(name);
			});
		});

		const mappings = new Mappings(options.hires);

		if (this.intro) {
			mappings.advance(this.intro);
		}

		this.sources.forEach((source, i) => {
			if (i > 0) {
				mappings.advance(this.separator);
			}

			const sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;
			const magicString = source.content;
			const locate = getLocator(magicString.original);

			if (magicString.intro) {
				mappings.advance(magicString.intro);
			}

			magicString.firstChunk.eachNext((chunk) => {
				const loc = locate(chunk.start);

				if (chunk.intro.length) mappings.advance(chunk.intro);

				if (source.filename) {
					if (chunk.edited) {
						mappings.addEdit(
							sourceIndex,
							chunk.content,
							loc,
							chunk.storeName ? names.indexOf(chunk.original) : -1,
						);
					} else {
						mappings.addUneditedChunk(
							sourceIndex,
							chunk,
							magicString.original,
							loc,
							magicString.sourcemapLocations,
						);
					}
				} else {
					mappings.advance(chunk.content);
				}

				if (chunk.outro.length) mappings.advance(chunk.outro);
			});

			if (magicString.outro) {
				mappings.advance(magicString.outro);
			}

			if (source.ignoreList && sourceIndex !== -1) {
				if (x_google_ignoreList === undefined) {
					x_google_ignoreList = [];
				}
				x_google_ignoreList.push(sourceIndex);
			}
		});

		return {
			file: options.file ? options.file.split(/[/\\]/).pop() : undefined,
			sources: this.uniqueSources.map((source) => {
				return options.file ? getRelativePath(options.file, source.filename) : source.filename;
			}),
			sourcesContent: this.uniqueSources.map((source) => {
				return options.includeContent ? source.content : null;
			}),
			names,
			mappings: mappings.raw,
			x_google_ignoreList,
		};
	}

	generateMap(options) {
		return new SourceMap(this.generateDecodedMap(options));
	}

	getIndentString() {
		const indentStringCounts = {};

		this.sources.forEach((source) => {
			const indentStr = source.content._getRawIndentString();

			if (indentStr === null) return;

			if (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;
			indentStringCounts[indentStr] += 1;
		});

		return (
			Object.keys(indentStringCounts).sort((a, b) => {
				return indentStringCounts[a] - indentStringCounts[b];
			})[0] || '\t'
		);
	}

	indent(indentStr) {
		if (!arguments.length) {
			indentStr = this.getIndentString();
		}

		if (indentStr === '') return this; // noop

		let trailingNewline = !this.intro || this.intro.slice(-1) === '\n';

		this.sources.forEach((source, i) => {
			const separator = source.separator !== undefined ? source.separator : this.separator;
			const indentStart = trailingNewline || (i > 0 && /\r?\n$/.test(separator));

			source.content.indent(indentStr, {
				exclude: source.indentExclusionRanges,
				indentStart, //: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
			});

			trailingNewline = source.content.lastChar() === '\n';
		});

		if (this.intro) {
			this.intro =
				indentStr +
				this.intro.replace(/^[^\n]/gm, (match, index) => {
					return index > 0 ? indentStr + match : match;
				});
		}

		return this;
	}

	prepend(str) {
		this.intro = str + this.intro;
		return this;
	}

	toString() {
		const body = this.sources
			.map((source, i) => {
				const separator = source.separator !== undefined ? source.separator : this.separator;
				const str = (i > 0 ? separator : '') + source.content.toString();

				return str;
			})
			.join('');

		return this.intro + body;
	}

	isEmpty() {
		if (this.intro.length && this.intro.trim()) return false;
		if (this.sources.some((source) => !source.content.isEmpty())) return false;
		return true;
	}

	length() {
		return this.sources.reduce(
			(length, source) => length + source.content.length(),
			this.intro.length,
		);
	}

	trimLines() {
		return this.trim('[\\r\\n]');
	}

	trim(charType) {
		return this.trimStart(charType).trimEnd(charType);
	}

	trimStart(charType) {
		const rx = new RegExp('^' + (charType || '\\s') + '+');
		this.intro = this.intro.replace(rx, '');

		if (!this.intro) {
			let source;
			let i = 0;

			do {
				source = this.sources[i++];
				if (!source) {
					break;
				}
			} while (!source.content.trimStartAborted(charType));
		}

		return this;
	}

	trimEnd(charType) {
		const rx = new RegExp((charType || '\\s') + '+$');

		let source;
		let i = this.sources.length - 1;

		do {
			source = this.sources[i--];
			if (!source) {
				this.intro = this.intro.replace(rx, '');
				break;
			}
		} while (!source.content.trimEndAborted(charType));

		return this;
	}
}

MagicString$1.Bundle = Bundle;
MagicString$1.SourceMap = SourceMap;
MagicString$1.default = MagicString$1; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121

var magicString_cjs = MagicString$1;

const core$i = dist$p;
const MagicString = magicString_cjs;

function _interopDefaultCompat$4 (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const MagicString__default = /*#__PURE__*/_interopDefaultCompat$4(MagicString);

function getBracket(str, open, close) {
  if (str === "")
    return;
  const l = str.length;
  let parenthesis = 0;
  let opened = false;
  let openAt = 0;
  for (let i = 0; i < l; i++) {
    switch (str[i]) {
      case open:
        if (!opened) {
          opened = true;
          openAt = i;
        }
        parenthesis++;
        break;
      case close:
        --parenthesis;
        if (parenthesis < 0)
          return;
        if (parenthesis === 0) {
          return [
            str.slice(openAt, i + 1),
            str.slice(i + 1),
            str.slice(0, openAt)
          ];
        }
        break;
    }
  }
}
function getStringComponent(str, open, close, separators) {
  if (str === "")
    return;
  if (core$i.isString(separators))
    separators = [separators];
  if (separators.length === 0)
    return;
  const l = str.length;
  let parenthesis = 0;
  for (let i = 0; i < l; i++) {
    switch (str[i]) {
      case open:
        parenthesis++;
        break;
      case close:
        if (--parenthesis < 0)
          return;
        break;
      default:
        for (const separator of separators) {
          const separatorLength = separator.length;
          if (separatorLength && separator === str.slice(i, i + separatorLength) && parenthesis === 0) {
            if (i === 0 || i === l - separatorLength)
              return;
            return [
              str.slice(0, i),
              str.slice(i + separatorLength)
            ];
          }
        }
    }
  }
  return [
    str,
    ""
  ];
}
function getStringComponents(str, separators, limit) {
  limit = limit ?? 10;
  const components = [];
  let i = 0;
  while (str !== "") {
    if (++i > limit)
      return;
    const componentPair = getStringComponent(str, "(", ")", separators);
    if (!componentPair)
      return;
    const [component, rest] = componentPair;
    components.push(component);
    str = rest;
  }
  if (components.length > 0)
    return components;
}

const cssColorFunctions = ["hsl", "hsla", "hwb", "lab", "lch", "oklab", "oklch", "rgb", "rgba"];
const alphaPlaceholders = ["%alpha", "<alpha-value>"];
const alphaPlaceholdersRE = new RegExp(alphaPlaceholders.map((v) => core$i.escapeRegExp(v)).join("|"));
function hex2rgba(hex = "") {
  const color = parseHexColor(hex);
  if (color != null) {
    const { components, alpha } = color;
    if (alpha == null)
      return components;
    return [...components, alpha];
  }
}
function parseCssColor(str = "") {
  const color = parseColor$1(str);
  if (color == null || color === false)
    return;
  const { type: casedType, components, alpha } = color;
  const type = casedType.toLowerCase();
  if (components.length === 0)
    return;
  if (cssColorFunctions.includes(type) && ![1, 3].includes(components.length))
    return;
  return {
    type,
    components: components.map((c) => typeof c === "string" ? c.trim() : c),
    alpha: typeof alpha === "string" ? alpha.trim() : alpha
  };
}
function colorOpacityToString(color) {
  const alpha = color.alpha ?? 1;
  return typeof alpha === "string" && alphaPlaceholders.includes(alpha) ? 1 : alpha;
}
function colorToString(color, alphaOverride) {
  if (typeof color === "string")
    return color.replace(alphaPlaceholdersRE, `${alphaOverride ?? 1}`);
  const { components } = color;
  let { alpha, type } = color;
  alpha = alphaOverride ?? alpha;
  type = type.toLowerCase();
  if (["hsla", "rgba"].includes(type))
    return `${type}(${components.join(", ")}${alpha == null ? "" : `, ${alpha}`})`;
  alpha = alpha == null ? "" : ` / ${alpha}`;
  if (cssColorFunctions.includes(type))
    return `${type}(${components.join(" ")}${alpha})`;
  return `color(${type} ${components.join(" ")}${alpha})`;
}
function parseColor$1(str) {
  if (!str)
    return;
  let color = parseHexColor(str);
  if (color != null)
    return color;
  color = cssColorKeyword(str);
  if (color != null)
    return color;
  color = parseCssCommaColorFunction(str);
  if (color != null)
    return color;
  color = parseCssSpaceColorFunction(str);
  if (color != null)
    return color;
  color = parseCssColorFunction(str);
  if (color != null)
    return color;
}
function parseHexColor(str) {
  const [, body] = str.match(/^#([\da-f]+)$/i) || [];
  if (!body)
    return;
  switch (body.length) {
    case 3:
    case 4:
      const digits = Array.from(body, (s) => Number.parseInt(s, 16)).map((n) => n << 4 | n);
      return {
        type: "rgb",
        components: digits.slice(0, 3),
        alpha: body.length === 3 ? void 0 : Math.round(digits[3] / 255 * 100) / 100
      };
    case 6:
    case 8:
      const value = Number.parseInt(body, 16);
      return {
        type: "rgb",
        components: body.length === 6 ? [value >> 16 & 255, value >> 8 & 255, value & 255] : [value >> 24 & 255, value >> 16 & 255, value >> 8 & 255],
        alpha: body.length === 6 ? void 0 : Math.round((value & 255) / 255 * 100) / 100
      };
  }
}
function cssColorKeyword(str) {
  const color = {
    rebeccapurple: [102, 51, 153, 1]
  }[str];
  if (color != null) {
    return {
      type: "rgb",
      components: color.slice(0, 3),
      alpha: color[3]
    };
  }
}
function parseCssCommaColorFunction(color) {
  const match = color.match(/^(rgb|rgba|hsl|hsla)\((.+)\)$/i);
  if (!match)
    return;
  const [, type, componentString] = match;
  const components = getStringComponents(componentString, ",", 5);
  if (components) {
    if ([3, 4].includes(components.length)) {
      return {
        type,
        components: components.slice(0, 3),
        alpha: components[3]
      };
    } else if (components.length !== 1) {
      return false;
    }
  }
}
const cssColorFunctionsRe = new RegExp(`^(${cssColorFunctions.join("|")})\\((.+)\\)$`, "i");
function parseCssSpaceColorFunction(color) {
  const match = color.match(cssColorFunctionsRe);
  if (!match)
    return;
  const [, fn, componentString] = match;
  const parsed = parseCssSpaceColorValues(`${fn} ${componentString}`);
  if (parsed) {
    const { alpha, components: [type, ...components] } = parsed;
    return {
      type,
      components,
      alpha
    };
  }
}
function parseCssColorFunction(color) {
  const match = color.match(/^color\((.+)\)$/);
  if (!match)
    return;
  const parsed = parseCssSpaceColorValues(match[1]);
  if (parsed) {
    const { alpha, components: [type, ...components] } = parsed;
    return {
      type,
      components,
      alpha
    };
  }
}
function parseCssSpaceColorValues(componentString) {
  const components = getStringComponents(componentString, " ");
  if (!components)
    return;
  let totalComponents = components.length;
  if (components[totalComponents - 2] === "/") {
    return {
      components: components.slice(0, totalComponents - 2),
      alpha: components[totalComponents - 1]
    };
  }
  if (components[totalComponents - 2] != null && (components[totalComponents - 2].endsWith("/") || components[totalComponents - 1].startsWith("/"))) {
    const removed = components.splice(totalComponents - 2);
    components.push(removed.join(" "));
    --totalComponents;
  }
  const withAlpha = getStringComponents(components[totalComponents - 1], "/", 2);
  if (!withAlpha)
    return;
  if (withAlpha.length === 1 || withAlpha[withAlpha.length - 1] === "")
    return { components };
  const alpha = withAlpha.pop();
  components[totalComponents - 1] = withAlpha.join("/");
  return {
    components,
    alpha
  };
}

function createValueHandler(handlers) {
  const handler = function(str) {
    const s = this.__options?.sequence || [];
    this.__options.sequence = [];
    for (const n of s) {
      const res = handlers[n](str);
      if (res != null)
        return res;
    }
  };
  function addProcessor(that, name) {
    if (!that.__options) {
      that.__options = {
        sequence: []
      };
    }
    that.__options.sequence.push(name);
    return that;
  }
  for (const name of Object.keys(handlers)) {
    Object.defineProperty(handler, name, {
      enumerable: true,
      get() {
        return addProcessor(this, name);
      }
    });
  }
  return handler;
}

function variantMatcher(name, handler) {
  let re;
  return {
    name,
    match(input, ctx) {
      if (!re)
        re = new RegExp(`^${core$i.escapeRegExp(name)}(?:${ctx.generator.config.separators.join("|")})`);
      const match = input.match(re);
      if (match) {
        return {
          matcher: input.slice(match[0].length),
          handle: (input2, next) => next({
            ...input2,
            ...handler(input2)
          })
        };
      }
    },
    autocomplete: `${name}:`
  };
}
function variantParentMatcher(name, parent) {
  let re;
  return {
    name,
    match(input, ctx) {
      if (!re)
        re = new RegExp(`^${core$i.escapeRegExp(name)}(?:${ctx.generator.config.separators.join("|")})`);
      const match = input.match(re);
      if (match) {
        return {
          matcher: input.slice(match[0].length),
          handle: (input2, next) => next({
            ...input2,
            parent: `${input2.parent ? `${input2.parent} $$ ` : ""}${parent}`
          })
        };
      }
    },
    autocomplete: `${name}:`
  };
}
function variantGetBracket(prefix, matcher, separators) {
  if (matcher.startsWith(`${prefix}[`)) {
    const [match, rest] = getBracket(matcher.slice(prefix.length), "[", "]") ?? [];
    if (match && rest) {
      for (const separator of separators) {
        if (rest.startsWith(separator))
          return [match, rest.slice(separator.length), separator];
      }
      return [match, rest, ""];
    }
  }
}
function variantGetParameter(prefix, matcher, separators) {
  if (matcher.startsWith(prefix)) {
    const body = variantGetBracket(prefix, matcher, separators);
    if (body) {
      const [label = "", rest = body[1]] = variantGetParameter("/", body[1], separators) ?? [];
      return [body[0], rest, label];
    }
    for (const separator of separators.filter((x) => x !== "/")) {
      const pos = matcher.indexOf(separator, prefix.length);
      if (pos !== -1) {
        const labelPos = matcher.indexOf("/", prefix.length);
        const unlabelled = labelPos === -1 || pos <= labelPos;
        return [
          matcher.slice(prefix.length, unlabelled ? pos : labelPos),
          matcher.slice(pos + separator.length),
          unlabelled ? "" : matcher.slice(labelPos + 1, pos)
        ];
      }
    }
  }
}

const themeFnRE = /theme\(\s*['"]?(.*?)['"]?\s*\)/g;
function hasThemeFn(str) {
  return str.includes("theme(") && str.includes(")");
}
function transformThemeFn(code, theme, throwOnMissing = true) {
  const matches = Array.from(code.toString().matchAll(themeFnRE));
  if (!matches.length)
    return code;
  const s = new MagicString__default(code);
  for (const match of matches) {
    const rawArg = match[1];
    if (!rawArg)
      throw new Error("theme() expect exact one argument, but got 0");
    const [rawKey, alpha] = rawArg.split("/");
    const keys = rawKey.trim().split(".");
    let value = keys.reduce((t, k) => t?.[k], theme);
    if (typeof value === "string") {
      if (alpha) {
        const color = parseCssColor(value);
        if (color)
          value = colorToString(color, alpha);
      }
      s.overwrite(
        match.index,
        match.index + match[0].length,
        value
      );
    } else if (throwOnMissing) {
      throw new Error(`theme of "${rawArg}" did not found`);
    }
  }
  return s.toString();
}

dist$k.colorOpacityToString = colorOpacityToString;
dist$k.colorToString = colorToString;
dist$k.createValueHandler = createValueHandler;
dist$k.getBracket = getBracket;
dist$k.getStringComponent = getStringComponent;
dist$k.getStringComponents = getStringComponents;
dist$k.hasThemeFn = hasThemeFn;
dist$k.hex2rgba = hex2rgba;
dist$k.parseCssColor = parseCssColor;
dist$k.themeFnRE = themeFnRE;
dist$k.transformThemeFn = transformThemeFn;
dist$k.variantGetBracket = variantGetBracket;
dist$k.variantGetParameter = variantGetParameter;
dist$k.variantMatcher = variantMatcher;
dist$k.variantParentMatcher = variantParentMatcher;

const core$h = dist$p;
const ruleUtils$5 = dist$k;

const directionMap = {
  "l": ["-left"],
  "r": ["-right"],
  "t": ["-top"],
  "b": ["-bottom"],
  "s": ["-inline-start"],
  "e": ["-inline-end"],
  "x": ["-left", "-right"],
  "y": ["-top", "-bottom"],
  "": [""],
  "bs": ["-block-start"],
  "be": ["-block-end"],
  "is": ["-inline-start"],
  "ie": ["-inline-end"],
  "block": ["-block-start", "-block-end"],
  "inline": ["-inline-start", "-inline-end"]
};
const insetMap = {
  ...directionMap,
  s: ["-inset-inline-start"],
  start: ["-inset-inline-start"],
  e: ["-inset-inline-end"],
  end: ["-inset-inline-end"],
  bs: ["-inset-block-start"],
  be: ["-inset-block-end"],
  is: ["-inset-inline-start"],
  ie: ["-inset-inline-end"],
  block: ["-inset-block-start", "-inset-block-end"],
  inline: ["-inset-inline-start", "-inset-inline-end"]
};
const cornerMap = {
  "l": ["-top-left", "-bottom-left"],
  "r": ["-top-right", "-bottom-right"],
  "t": ["-top-left", "-top-right"],
  "b": ["-bottom-left", "-bottom-right"],
  "tl": ["-top-left"],
  "lt": ["-top-left"],
  "tr": ["-top-right"],
  "rt": ["-top-right"],
  "bl": ["-bottom-left"],
  "lb": ["-bottom-left"],
  "br": ["-bottom-right"],
  "rb": ["-bottom-right"],
  "": [""],
  "bs": ["-start-start", "-start-end"],
  "be": ["-end-start", "-end-end"],
  "s": ["-end-start", "-start-start"],
  "is": ["-end-start", "-start-start"],
  "e": ["-start-end", "-end-end"],
  "ie": ["-start-end", "-end-end"],
  "ss": ["-start-start"],
  "bs-is": ["-start-start"],
  "is-bs": ["-start-start"],
  "se": ["-start-end"],
  "bs-ie": ["-start-end"],
  "ie-bs": ["-start-end"],
  "es": ["-end-start"],
  "be-is": ["-end-start"],
  "is-be": ["-end-start"],
  "ee": ["-end-end"],
  "be-ie": ["-end-end"],
  "ie-be": ["-end-end"]
};
const xyzMap = {
  "x": ["-x"],
  "y": ["-y"],
  "z": ["-z"],
  "": ["-x", "-y"]
};
const xyzArray = ["x", "y", "z"];
const basePositionMap = [
  "top",
  "top center",
  "top left",
  "top right",
  "bottom",
  "bottom center",
  "bottom left",
  "bottom right",
  "left",
  "left center",
  "left top",
  "left bottom",
  "right",
  "right center",
  "right top",
  "right bottom",
  "center",
  "center top",
  "center bottom",
  "center left",
  "center right",
  "center center"
];
const positionMap = Object.assign(
  {},
  ...basePositionMap.map((p) => ({ [p.replace(/ /, "-")]: p })),
  ...basePositionMap.map((p) => ({ [p.replace(/\b(\w)\w+/g, "$1").replace(/ /, "")]: p }))
);
const globalKeywords = [
  "inherit",
  "initial",
  "revert",
  "revert-layer",
  "unset"
];
const cssMathFnRE = /^(calc|clamp|min|max)\s*\((.+)\)(.*)/;

const numberWithUnitRE = /^(-?\d*(?:\.\d+)?)(px|pt|pc|%|r?(?:em|ex|lh|cap|ch|ic)|(?:[sld]?v|cq)(?:[whib]|min|max)|in|cm|mm|rpx)?$/i;
const numberRE$1 = /^(-?\d*(?:\.\d+)?)$/i;
const unitOnlyRE = /^(px|[sld]?v[wh])$/i;
const unitOnlyMap = {
  px: 1,
  vw: 100,
  vh: 100,
  svw: 100,
  svh: 100,
  dvw: 100,
  dvh: 100,
  lvh: 100,
  lvw: 100
};
const bracketTypeRe = /^\[(color|length|size|position|quoted|string):/i;
const splitComma = /,(?![^()]*\))/g;

const cssProps = [
  // basic props
  "color",
  "border-color",
  "background-color",
  "flex-grow",
  "flex",
  "flex-shrink",
  "caret-color",
  "font",
  "gap",
  "opacity",
  "visibility",
  "z-index",
  "font-weight",
  "zoom",
  "text-shadow",
  "transform",
  "box-shadow",
  // positions
  "background-position",
  "left",
  "right",
  "top",
  "bottom",
  "object-position",
  // sizes
  "max-height",
  "min-height",
  "max-width",
  "min-width",
  "height",
  "width",
  "border-width",
  "margin",
  "padding",
  "outline-width",
  "outline-offset",
  "font-size",
  "line-height",
  "text-indent",
  "vertical-align",
  "border-spacing",
  "letter-spacing",
  "word-spacing",
  // enhances
  "stroke",
  "filter",
  "backdrop-filter",
  "fill",
  "mask",
  "mask-size",
  "mask-border",
  "clip-path",
  "clip",
  "border-radius"
];
function round(n) {
  return n.toFixed(10).replace(/\.0+$/, "").replace(/(\.\d+?)0+$/, "$1");
}
function numberWithUnit(str) {
  const match = str.match(numberWithUnitRE);
  if (!match)
    return;
  const [, n, unit] = match;
  const num = Number.parseFloat(n);
  if (unit && !Number.isNaN(num))
    return `${round(num)}${unit}`;
}
function auto(str) {
  if (str === "auto" || str === "a")
    return "auto";
}
function rem(str) {
  if (!str)
    return;
  if (unitOnlyRE.test(str))
    return `${unitOnlyMap[str]}${str}`;
  const match = str.match(numberWithUnitRE);
  if (!match)
    return;
  const [, n, unit] = match;
  const num = Number.parseFloat(n);
  if (!Number.isNaN(num)) {
    if (num === 0)
      return "0";
    return unit ? `${round(num)}${unit}` : `${round(num / 4)}rem`;
  }
}
function px(str) {
  if (unitOnlyRE.test(str))
    return `${unitOnlyMap[str]}${str}`;
  const match = str.match(numberWithUnitRE);
  if (!match)
    return;
  const [, n, unit] = match;
  const num = Number.parseFloat(n);
  if (!Number.isNaN(num))
    return unit ? `${round(num)}${unit}` : `${round(num)}px`;
}
function number$1(str) {
  if (!numberRE$1.test(str))
    return;
  const num = Number.parseFloat(str);
  if (!Number.isNaN(num))
    return round(num);
}
function percent(str) {
  if (str.endsWith("%"))
    str = str.slice(0, -1);
  if (!numberRE$1.test(str))
    return;
  const num = Number.parseFloat(str);
  if (!Number.isNaN(num))
    return `${round(num / 100)}`;
}
function fraction(str) {
  if (!str)
    return;
  if (str === "full")
    return "100%";
  const [left, right] = str.split("/");
  const num = Number.parseFloat(left) / Number.parseFloat(right);
  if (!Number.isNaN(num)) {
    if (num === 0)
      return "0";
    return `${round(num * 100)}%`;
  }
}
function bracketWithType(str, requiredType) {
  if (str && str.startsWith("[") && str.endsWith("]")) {
    let base;
    let hintedType;
    const match = str.match(bracketTypeRe);
    if (!match) {
      base = str.slice(1, -1);
    } else {
      if (!requiredType)
        hintedType = match[1];
      base = str.slice(match[0].length, -1);
    }
    if (!base)
      return;
    if (base === '=""')
      return;
    if (base.startsWith("--"))
      base = `var(${base})`;
    let curly = 0;
    for (const i of base) {
      if (i === "[") {
        curly += 1;
      } else if (i === "]") {
        curly -= 1;
        if (curly < 0)
          return;
      }
    }
    if (curly)
      return;
    switch (hintedType) {
      case "string":
        return base.replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_");
      case "quoted":
        return base.replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_").replace(/(["\\])/g, "\\$1").replace(/^(.+)$/, '"$1"');
    }
    return base.replace(/(url\(.*?\))/g, (v) => v.replace(/_/g, "\\_")).replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_").replace(/(?:calc|clamp|max|min)\((.*)/g, (match2) => {
      const vars = [];
      return match2.replace(/var\((--.+?)[,)]/g, (match3, g1) => {
        vars.push(g1);
        return match3.replace(g1, "--un-calc");
      }).replace(/(-?\d*\.?\d(?!\b-\d.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ").replace(/--un-calc/g, () => vars.shift());
    });
  }
}
function bracket(str) {
  return bracketWithType(str);
}
function bracketOfColor(str) {
  return bracketWithType(str, "color");
}
function bracketOfLength(str) {
  return bracketWithType(str, "length");
}
function bracketOfPosition(str) {
  return bracketWithType(str, "position");
}
function cssvar(str) {
  if (/^\$[^\s'"`;{}]/.test(str)) {
    const [name, defaultValue] = str.slice(1).split(",");
    return `var(--${core$h.escapeSelector(name)}${defaultValue ? `, ${defaultValue}` : ""})`;
  }
}
function time$1(str) {
  const match = str.match(/^(-?[0-9.]+)(s|ms)?$/i);
  if (!match)
    return;
  const [, n, unit] = match;
  const num = Number.parseFloat(n);
  if (!Number.isNaN(num)) {
    if (num === 0 && !unit)
      return "0s";
    return unit ? `${round(num)}${unit}` : `${round(num)}ms`;
  }
}
function degree(str) {
  const match = str.match(/^(-?[0-9.]+)(deg|rad|grad|turn)?$/i);
  if (!match)
    return;
  const [, n, unit] = match;
  const num = Number.parseFloat(n);
  if (!Number.isNaN(num)) {
    if (num === 0)
      return "0";
    return unit ? `${round(num)}${unit}` : `${round(num)}deg`;
  }
}
function global$1(str) {
  if (globalKeywords.includes(str))
    return str;
}
function properties$4(str) {
  if (str.split(",").every((prop) => cssProps.includes(prop)))
    return str;
}
function position$2(str) {
  if (["top", "left", "right", "bottom", "center"].includes(str))
    return str;
}

const valueHandlers = {
  __proto__: null,
  auto: auto,
  bracket: bracket,
  bracketOfColor: bracketOfColor,
  bracketOfLength: bracketOfLength,
  bracketOfPosition: bracketOfPosition,
  cssvar: cssvar,
  degree: degree,
  fraction: fraction,
  global: global$1,
  number: number$1,
  numberWithUnit: numberWithUnit,
  percent: percent,
  position: position$2,
  properties: properties$4,
  px: px,
  rem: rem,
  time: time$1
};

const handler = ruleUtils$5.createValueHandler(valueHandlers);
const h = handler;

const CONTROL_MINI_NO_NEGATIVE = "$$mini-no-negative";
function directionSize(propertyPrefix) {
  return ([_, direction, size], { theme }) => {
    const v = theme.spacing?.[size || "DEFAULT"] ?? h.bracket.cssvar.global.auto.fraction.rem(size);
    if (v != null)
      return directionMap[direction].map((i) => [`${propertyPrefix}${i}`, v]);
  };
}
function getThemeColorForKey(theme, colors, key = "colors") {
  let obj = theme[key];
  let index = -1;
  for (const c of colors) {
    index += 1;
    if (obj && typeof obj !== "string") {
      const camel = colors.slice(index).join("-").replace(/(-[a-z])/g, (n) => n.slice(1).toUpperCase());
      if (obj[camel])
        return obj[camel];
      if (obj[c]) {
        obj = obj[c];
        continue;
      }
    }
    return void 0;
  }
  return obj;
}
function getThemeColor(theme, colors, key) {
  return getThemeColorForKey(theme, colors, key) || getThemeColorForKey(theme, colors, "colors");
}
function splitShorthand(body, type) {
  const [front, rest] = ruleUtils$5.getStringComponent(body, "[", "]", ["/", ":"]) ?? [];
  if (front != null) {
    const match = (front.match(bracketTypeRe) ?? [])[1];
    if (match == null || match === type)
      return [front, rest];
  }
}
function parseColor(body, theme, key) {
  const split = splitShorthand(body, "color");
  if (!split)
    return;
  const [main, opacity] = split;
  const colors = main.replace(/([a-z])([0-9])/g, "$1-$2").split(/-/g);
  const [name] = colors;
  if (!name)
    return;
  let color;
  const bracket = h.bracketOfColor(main);
  const bracketOrMain = bracket || main;
  if (h.numberWithUnit(bracketOrMain))
    return;
  if (/^#[\da-fA-F]+$/.test(bracketOrMain))
    color = bracketOrMain;
  else if (/^hex-[\da-fA-F]+$/.test(bracketOrMain))
    color = `#${bracketOrMain.slice(4)}`;
  else if (main.startsWith("$"))
    color = h.cssvar(main);
  color = color || bracket;
  if (!color) {
    const colorData = getThemeColor(theme, [main], key);
    if (typeof colorData === "string")
      color = colorData;
  }
  let no = "DEFAULT";
  if (!color) {
    let colorData;
    const [scale] = colors.slice(-1);
    if (/^\d+$/.test(scale)) {
      no = scale;
      colorData = getThemeColor(theme, colors.slice(0, -1), key);
      if (!colorData || typeof colorData === "string")
        color = void 0;
      else
        color = colorData[no];
    } else {
      colorData = getThemeColor(theme, colors, key);
      if (!colorData && colors.length <= 2) {
        [, no = no] = colors;
        colorData = getThemeColor(theme, [name], key);
      }
      if (typeof colorData === "string")
        color = colorData;
      else if (no && colorData)
        color = colorData[no];
    }
  }
  return {
    opacity,
    name,
    no,
    color,
    cssColor: ruleUtils$5.parseCssColor(color),
    alpha: h.bracket.cssvar.percent(opacity ?? "")
  };
}
function colorResolver(property, varName, key, shouldPass) {
  return ([, body], { theme }) => {
    const data = parseColor(body, theme, key);
    if (!data)
      return;
    const { alpha, color, cssColor } = data;
    const css = {};
    if (cssColor) {
      if (alpha != null) {
        css[property] = ruleUtils$5.colorToString(cssColor, alpha);
      } else {
        const opacityVar = `--un-${varName}-opacity`;
        const result = ruleUtils$5.colorToString(cssColor, `var(${opacityVar})`);
        if (result.includes(opacityVar))
          css[opacityVar] = ruleUtils$5.colorOpacityToString(cssColor);
        css[property] = result;
      }
    } else if (color) {
      if (alpha != null) {
        css[property] = ruleUtils$5.colorToString(color, alpha);
      } else {
        const opacityVar = `--un-${varName}-opacity`;
        const result = ruleUtils$5.colorToString(color, `var(${opacityVar})`);
        if (result.includes(opacityVar))
          css[opacityVar] = 1;
        css[property] = result;
      }
    }
    if (shouldPass?.(css) !== false)
      return css;
  };
}
function colorableShadows(shadows, colorVar) {
  const colored = [];
  shadows = core$h.toArray(shadows);
  for (let i = 0; i < shadows.length; i++) {
    const components = ruleUtils$5.getStringComponents(shadows[i], " ", 6);
    if (!components || components.length < 3)
      return shadows;
    let isInset = false;
    const pos = components.indexOf("inset");
    if (pos !== -1) {
      components.splice(pos, 1);
      isInset = true;
    }
    let colorVarValue = "";
    if (ruleUtils$5.parseCssColor(components.at(0))) {
      const color = ruleUtils$5.parseCssColor(components.shift());
      if (color)
        colorVarValue = `, ${ruleUtils$5.colorToString(color)}`;
    } else if (ruleUtils$5.parseCssColor(components.at(-1))) {
      const color = ruleUtils$5.parseCssColor(components.pop());
      if (color)
        colorVarValue = `, ${ruleUtils$5.colorToString(color)}`;
    }
    colored.push(`${isInset ? "inset " : ""}${components.join(" ")} var(${colorVar}${colorVarValue})`);
  }
  return colored;
}
function hasParseableColor(color, theme, key) {
  return color != null && !!parseColor(color, theme, key)?.color;
}
function resolveBreakpoints({ theme, generator }, key = "breakpoints") {
  let breakpoints;
  if (generator.userConfig && generator.userConfig.theme)
    breakpoints = generator.userConfig.theme[key];
  if (!breakpoints)
    breakpoints = theme[key];
  return breakpoints ? Object.entries(breakpoints).sort((a, b) => Number.parseInt(a[1].replace(/[a-z]+/gi, "")) - Number.parseInt(b[1].replace(/[a-z]+/gi, ""))).map(([point, size]) => ({ point, size })) : void 0;
}
function resolveVerticalBreakpoints(context) {
  return resolveBreakpoints(context, "verticalBreakpoints");
}
function makeGlobalStaticRules(prefix, property) {
  return globalKeywords.map((keyword) => [`${prefix}-${keyword}`, { [property ?? prefix]: keyword }]);
}
function isCSSMathFn(value) {
  return value != null && cssMathFnRE.test(value);
}
function isSize(str) {
  if (str[0] === "[" && str.slice(-1) === "]")
    str = str.slice(1, -1);
  return cssMathFnRE.test(str) || numberWithUnitRE.test(str);
}
function transformXYZ(d, v, name) {
  const values = v.split(splitComma);
  if (d || !d && values.length === 1)
    return xyzMap[d].map((i) => [`--un-${name}${i}`, v]);
  return values.map((v2, i) => [`--un-${name}-${xyzArray[i]}`, v2]);
}

presetMini_DahJgnb1.CONTROL_MINI_NO_NEGATIVE = CONTROL_MINI_NO_NEGATIVE;
presetMini_DahJgnb1.colorResolver = colorResolver;
presetMini_DahJgnb1.colorableShadows = colorableShadows;
presetMini_DahJgnb1.cornerMap = cornerMap;
presetMini_DahJgnb1.cssMathFnRE = cssMathFnRE;
presetMini_DahJgnb1.directionMap = directionMap;
presetMini_DahJgnb1.directionSize = directionSize;
presetMini_DahJgnb1.globalKeywords = globalKeywords;
presetMini_DahJgnb1.h = h;
presetMini_DahJgnb1.handler = handler;
presetMini_DahJgnb1.hasParseableColor = hasParseableColor;
presetMini_DahJgnb1.insetMap = insetMap;
presetMini_DahJgnb1.isCSSMathFn = isCSSMathFn;
presetMini_DahJgnb1.isSize = isSize;
presetMini_DahJgnb1.makeGlobalStaticRules = makeGlobalStaticRules;
presetMini_DahJgnb1.parseColor = parseColor;
presetMini_DahJgnb1.positionMap = positionMap;
presetMini_DahJgnb1.resolveBreakpoints = resolveBreakpoints;
presetMini_DahJgnb1.resolveVerticalBreakpoints = resolveVerticalBreakpoints;
presetMini_DahJgnb1.splitShorthand = splitShorthand;
presetMini_DahJgnb1.transformXYZ = transformXYZ;
presetMini_DahJgnb1.valueHandlers = valueHandlers;
presetMini_DahJgnb1.xyzArray = xyzArray;
presetMini_DahJgnb1.xyzMap = xyzMap;

var presetMini_St8sZgQd = {};

var colors$4 = {};

const colors$3 = {
  inherit: "inherit",
  current: "currentColor",
  transparent: "transparent",
  black: "#000",
  white: "#fff",
  rose: {
    50: "#fff1f2",
    100: "#ffe4e6",
    200: "#fecdd3",
    300: "#fda4af",
    400: "#fb7185",
    500: "#f43f5e",
    600: "#e11d48",
    700: "#be123c",
    800: "#9f1239",
    900: "#881337",
    950: "#4c0519"
  },
  pink: {
    50: "#fdf2f8",
    100: "#fce7f3",
    200: "#fbcfe8",
    300: "#f9a8d4",
    400: "#f472b6",
    500: "#ec4899",
    600: "#db2777",
    700: "#be185d",
    800: "#9d174d",
    900: "#831843",
    950: "#500724"
  },
  fuchsia: {
    50: "#fdf4ff",
    100: "#fae8ff",
    200: "#f5d0fe",
    300: "#f0abfc",
    400: "#e879f9",
    500: "#d946ef",
    600: "#c026d3",
    700: "#a21caf",
    800: "#86198f",
    900: "#701a75",
    950: "#4a044e"
  },
  purple: {
    50: "#faf5ff",
    100: "#f3e8ff",
    200: "#e9d5ff",
    300: "#d8b4fe",
    400: "#c084fc",
    500: "#a855f7",
    600: "#9333ea",
    700: "#7e22ce",
    800: "#6b21a8",
    900: "#581c87",
    950: "#3b0764"
  },
  violet: {
    50: "#f5f3ff",
    100: "#ede9fe",
    200: "#ddd6fe",
    300: "#c4b5fd",
    400: "#a78bfa",
    500: "#8b5cf6",
    600: "#7c3aed",
    700: "#6d28d9",
    800: "#5b21b6",
    900: "#4c1d95",
    950: "#2e1065"
  },
  indigo: {
    50: "#eef2ff",
    100: "#e0e7ff",
    200: "#c7d2fe",
    300: "#a5b4fc",
    400: "#818cf8",
    500: "#6366f1",
    600: "#4f46e5",
    700: "#4338ca",
    800: "#3730a3",
    900: "#312e81",
    950: "#1e1b4b"
  },
  blue: {
    50: "#eff6ff",
    100: "#dbeafe",
    200: "#bfdbfe",
    300: "#93c5fd",
    400: "#60a5fa",
    500: "#3b82f6",
    600: "#2563eb",
    700: "#1d4ed8",
    800: "#1e40af",
    900: "#1e3a8a",
    950: "#172554"
  },
  sky: {
    50: "#f0f9ff",
    100: "#e0f2fe",
    200: "#bae6fd",
    300: "#7dd3fc",
    400: "#38bdf8",
    500: "#0ea5e9",
    600: "#0284c7",
    700: "#0369a1",
    800: "#075985",
    900: "#0c4a6e",
    950: "#082f49"
  },
  cyan: {
    50: "#ecfeff",
    100: "#cffafe",
    200: "#a5f3fc",
    300: "#67e8f9",
    400: "#22d3ee",
    500: "#06b6d4",
    600: "#0891b2",
    700: "#0e7490",
    800: "#155e75",
    900: "#164e63",
    950: "#083344"
  },
  teal: {
    50: "#f0fdfa",
    100: "#ccfbf1",
    200: "#99f6e4",
    300: "#5eead4",
    400: "#2dd4bf",
    500: "#14b8a6",
    600: "#0d9488",
    700: "#0f766e",
    800: "#115e59",
    900: "#134e4a",
    950: "#042f2e"
  },
  emerald: {
    50: "#ecfdf5",
    100: "#d1fae5",
    200: "#a7f3d0",
    300: "#6ee7b7",
    400: "#34d399",
    500: "#10b981",
    600: "#059669",
    700: "#047857",
    800: "#065f46",
    900: "#064e3b",
    950: "#022c22"
  },
  green: {
    50: "#f0fdf4",
    100: "#dcfce7",
    200: "#bbf7d0",
    300: "#86efac",
    400: "#4ade80",
    500: "#22c55e",
    600: "#16a34a",
    700: "#15803d",
    800: "#166534",
    900: "#14532d",
    950: "#052e16"
  },
  lime: {
    50: "#f7fee7",
    100: "#ecfccb",
    200: "#d9f99d",
    300: "#bef264",
    400: "#a3e635",
    500: "#84cc16",
    600: "#65a30d",
    700: "#4d7c0f",
    800: "#3f6212",
    900: "#365314",
    950: "#1a2e05"
  },
  yellow: {
    50: "#fefce8",
    100: "#fef9c3",
    200: "#fef08a",
    300: "#fde047",
    400: "#facc15",
    500: "#eab308",
    600: "#ca8a04",
    700: "#a16207",
    800: "#854d0e",
    900: "#713f12",
    950: "#422006"
  },
  amber: {
    50: "#fffbeb",
    100: "#fef3c7",
    200: "#fde68a",
    300: "#fcd34d",
    400: "#fbbf24",
    500: "#f59e0b",
    600: "#d97706",
    700: "#b45309",
    800: "#92400e",
    900: "#78350f",
    950: "#451a03"
  },
  orange: {
    50: "#fff7ed",
    100: "#ffedd5",
    200: "#fed7aa",
    300: "#fdba74",
    400: "#fb923c",
    500: "#f97316",
    600: "#ea580c",
    700: "#c2410c",
    800: "#9a3412",
    900: "#7c2d12",
    950: "#431407"
  },
  red: {
    50: "#fef2f2",
    100: "#fee2e2",
    200: "#fecaca",
    300: "#fca5a5",
    400: "#f87171",
    500: "#ef4444",
    600: "#dc2626",
    700: "#b91c1c",
    800: "#991b1b",
    900: "#7f1d1d",
    950: "#450a0a"
  },
  gray: {
    50: "#f9fafb",
    100: "#f3f4f6",
    200: "#e5e7eb",
    300: "#d1d5db",
    400: "#9ca3af",
    500: "#6b7280",
    600: "#4b5563",
    700: "#374151",
    800: "#1f2937",
    900: "#111827",
    950: "#030712"
  },
  slate: {
    50: "#f8fafc",
    100: "#f1f5f9",
    200: "#e2e8f0",
    300: "#cbd5e1",
    400: "#94a3b8",
    500: "#64748b",
    600: "#475569",
    700: "#334155",
    800: "#1e293b",
    900: "#0f172a",
    950: "#020617"
  },
  zinc: {
    50: "#fafafa",
    100: "#f4f4f5",
    200: "#e4e4e7",
    300: "#d4d4d8",
    400: "#a1a1aa",
    500: "#71717a",
    600: "#52525b",
    700: "#3f3f46",
    800: "#27272a",
    900: "#18181b",
    950: "#09090b"
  },
  neutral: {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#e5e5e5",
    300: "#d4d4d4",
    400: "#a3a3a3",
    500: "#737373",
    600: "#525252",
    700: "#404040",
    800: "#262626",
    900: "#171717",
    950: "#0a0a0a"
  },
  stone: {
    50: "#fafaf9",
    100: "#f5f5f4",
    200: "#e7e5e4",
    300: "#d6d3d1",
    400: "#a8a29e",
    500: "#78716c",
    600: "#57534e",
    700: "#44403c",
    800: "#292524",
    900: "#1c1917",
    950: "#0c0a09"
  },
  light: {
    50: "#fdfdfd",
    100: "#fcfcfc",
    200: "#fafafa",
    300: "#f8f9fa",
    400: "#f6f6f6",
    500: "#f2f2f2",
    600: "#f1f3f5",
    700: "#e9ecef",
    800: "#dee2e6",
    900: "#dde1e3",
    950: "#d8dcdf"
  },
  dark: {
    50: "#4a4a4a",
    100: "#3c3c3c",
    200: "#323232",
    300: "#2d2d2d",
    400: "#222222",
    500: "#1f1f1f",
    600: "#1c1c1e",
    700: "#1b1b1b",
    800: "#181818",
    900: "#0f0f0f",
    950: "#080808"
  },
  get lightblue() {
    return this.sky;
  },
  get lightBlue() {
    return this.sky;
  },
  get warmgray() {
    return this.stone;
  },
  get warmGray() {
    return this.stone;
  },
  get truegray() {
    return this.neutral;
  },
  get trueGray() {
    return this.neutral;
  },
  get coolgray() {
    return this.gray;
  },
  get coolGray() {
    return this.gray;
  },
  get bluegray() {
    return this.slate;
  },
  get blueGray() {
    return this.slate;
  }
};
Object.values(colors$3).forEach((color) => {
  if (typeof color !== "string" && color !== void 0) {
    color.DEFAULT = color.DEFAULT || color[400];
    Object.keys(color).forEach((key) => {
      const short = +key / 100;
      if (short === Math.round(short))
        color[short] = color[key];
    });
  }
});

colors$4.colors = colors$3;

var presetMini_mjThnwTD = {};

const utilities$3 = presetMini_DahJgnb1;

const cursorValues = ["auto", "default", "none", "context-menu", "help", "pointer", "progress", "wait", "cell", "crosshair", "text", "vertical-text", "alias", "copy", "move", "no-drop", "not-allowed", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out"];
const containValues = ["none", "strict", "content", "size", "inline-size", "layout", "style", "paint"];
const varEmpty = " ";
const displays = [
  ["inline", { display: "inline" }],
  ["block", { display: "block" }],
  ["inline-block", { display: "inline-block" }],
  ["contents", { display: "contents" }],
  ["flow-root", { display: "flow-root" }],
  ["list-item", { display: "list-item" }],
  ["hidden", { display: "none" }],
  [/^display-(.+)$/, ([, c]) => ({ display: utilities$3.h.bracket.cssvar.global(c) })]
];
const appearances = [
  ["visible", { visibility: "visible" }],
  ["invisible", { visibility: "hidden" }],
  ["backface-visible", { "backface-visibility": "visible" }],
  ["backface-hidden", { "backface-visibility": "hidden" }],
  ...utilities$3.makeGlobalStaticRules("backface", "backface-visibility")
];
const cursors = [
  [/^cursor-(.+)$/, ([, c]) => ({ cursor: utilities$3.h.bracket.cssvar.global(c) })],
  ...cursorValues.map((v) => [`cursor-${v}`, { cursor: v }])
];
const contains = [
  [/^contain-(.*)$/, ([, d]) => {
    if (utilities$3.h.bracket(d) != null) {
      return {
        contain: utilities$3.h.bracket(d).split(" ").map((e) => utilities$3.h.cssvar.fraction(e) ?? e).join(" ")
      };
    }
    return containValues.includes(d) ? { contain: d } : void 0;
  }]
];
const pointerEvents = [
  ["pointer-events-auto", { "pointer-events": "auto" }],
  ["pointer-events-none", { "pointer-events": "none" }],
  ...utilities$3.makeGlobalStaticRules("pointer-events")
];
const resizes = [
  ["resize-x", { resize: "horizontal" }],
  ["resize-y", { resize: "vertical" }],
  ["resize", { resize: "both" }],
  ["resize-none", { resize: "none" }],
  ...utilities$3.makeGlobalStaticRules("resize")
];
const userSelects = [
  ["select-auto", { "-webkit-user-select": "auto", "user-select": "auto" }],
  ["select-all", { "-webkit-user-select": "all", "user-select": "all" }],
  ["select-text", { "-webkit-user-select": "text", "user-select": "text" }],
  ["select-none", { "-webkit-user-select": "none", "user-select": "none" }],
  ...utilities$3.makeGlobalStaticRules("select", "user-select")
];
const whitespaces = [
  [
    /^(?:whitespace-|ws-)([-\w]+)$/,
    ([, v]) => ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces", ...utilities$3.globalKeywords].includes(v) ? { "white-space": v } : void 0,
    { autocomplete: "(whitespace|ws)-(normal|nowrap|pre|pre-line|pre-wrap|break-spaces)" }
  ]
];
const contentVisibility = [
  [/^intrinsic-size-(.+)$/, ([, d]) => ({ "contain-intrinsic-size": utilities$3.h.bracket.cssvar.global.fraction.rem(d) }), { autocomplete: "intrinsic-size-<num>" }],
  ["content-visibility-visible", { "content-visibility": "visible" }],
  ["content-visibility-hidden", { "content-visibility": "hidden" }],
  ["content-visibility-auto", { "content-visibility": "auto" }],
  ...utilities$3.makeGlobalStaticRules("content-visibility")
];
const contents = [
  [/^content-(.+)$/, ([, v]) => ({ content: utilities$3.h.bracket.cssvar(v) })],
  ["content-empty", { content: '""' }],
  ["content-none", { content: "none" }]
];
const breaks = [
  ["break-normal", { "overflow-wrap": "normal", "word-break": "normal" }],
  ["break-words", { "overflow-wrap": "break-word" }],
  ["break-all", { "word-break": "break-all" }],
  ["break-keep", { "word-break": "keep-all" }],
  ["break-anywhere", { "overflow-wrap": "anywhere" }]
];
const textWraps = [
  ["text-wrap", { "text-wrap": "wrap" }],
  ["text-nowrap", { "text-wrap": "nowrap" }],
  ["text-balance", { "text-wrap": "balance" }],
  ["text-pretty", { "text-wrap": "pretty" }]
];
const textOverflows = [
  ["truncate", { "overflow": "hidden", "text-overflow": "ellipsis", "white-space": "nowrap" }],
  ["text-truncate", { "overflow": "hidden", "text-overflow": "ellipsis", "white-space": "nowrap" }],
  ["text-ellipsis", { "text-overflow": "ellipsis" }],
  ["text-clip", { "text-overflow": "clip" }]
];
const textTransforms$1 = [
  ["case-upper", { "text-transform": "uppercase" }],
  ["case-lower", { "text-transform": "lowercase" }],
  ["case-capital", { "text-transform": "capitalize" }],
  ["case-normal", { "text-transform": "none" }],
  ...utilities$3.makeGlobalStaticRules("case", "text-transform")
];
const fontStyles = [
  ["italic", { "font-style": "italic" }],
  ["not-italic", { "font-style": "normal" }],
  ["font-italic", { "font-style": "italic" }],
  ["font-not-italic", { "font-style": "normal" }],
  ["oblique", { "font-style": "oblique" }],
  ["not-oblique", { "font-style": "normal" }],
  ["font-oblique", { "font-style": "oblique" }],
  ["font-not-oblique", { "font-style": "normal" }]
];
const fontSmoothings = [
  ["antialiased", {
    "-webkit-font-smoothing": "antialiased",
    "-moz-osx-font-smoothing": "grayscale"
  }],
  ["subpixel-antialiased", {
    "-webkit-font-smoothing": "auto",
    "-moz-osx-font-smoothing": "auto"
  }]
];

const ringBase = {
  "--un-ring-inset": varEmpty,
  "--un-ring-offset-width": "0px",
  "--un-ring-offset-color": "#fff",
  "--un-ring-width": "0px",
  "--un-ring-color": "rgb(147 197 253 / 0.5)",
  "--un-shadow": "0 0 rgb(0 0 0 / 0)"
};
const rings = [
  // ring
  [/^ring(?:-(.+))?$/, ([, d], { theme }) => {
    const value = theme.ringWidth?.[d || "DEFAULT"] ?? utilities$3.h.px(d || "1");
    if (value) {
      return {
        "--un-ring-width": value,
        "--un-ring-offset-shadow": "var(--un-ring-inset) 0 0 0 var(--un-ring-offset-width) var(--un-ring-offset-color)",
        "--un-ring-shadow": "var(--un-ring-inset) 0 0 0 calc(var(--un-ring-width) + var(--un-ring-offset-width)) var(--un-ring-color)",
        "box-shadow": "var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow)"
      };
    }
  }, { autocomplete: "ring-$ringWidth" }],
  // size
  [/^ring-(?:width-|size-)(.+)$/, handleWidth$3, { autocomplete: "ring-(width|size)-$lineWidth" }],
  // offset size
  ["ring-offset", { "--un-ring-offset-width": "1px" }],
  [/^ring-offset-(?:width-|size-)?(.+)$/, ([, d], { theme }) => ({ "--un-ring-offset-width": theme.lineWidth?.[d] ?? utilities$3.h.bracket.cssvar.px(d) }), { autocomplete: "ring-offset-(width|size)-$lineWidth" }],
  // colors
  [/^ring-(.+)$/, handleColorOrWidth$3, { autocomplete: "ring-$colors" }],
  [/^ring-op(?:acity)?-?(.+)$/, ([, opacity]) => ({ "--un-ring-opacity": utilities$3.h.bracket.percent.cssvar(opacity) }), { autocomplete: "ring-(op|opacity)-<percent>" }],
  // offset color
  [/^ring-offset-(.+)$/, utilities$3.colorResolver("--un-ring-offset-color", "ring-offset", "borderColor"), { autocomplete: "ring-offset-$colors" }],
  [/^ring-offset-op(?:acity)?-?(.+)$/, ([, opacity]) => ({ "--un-ring-offset-opacity": utilities$3.h.bracket.percent.cssvar(opacity) }), { autocomplete: "ring-offset-(op|opacity)-<percent>" }],
  // style
  ["ring-inset", { "--un-ring-inset": "inset" }]
];
function handleWidth$3([, b], { theme }) {
  return { "--un-ring-width": theme.ringWidth?.[b] ?? utilities$3.h.bracket.cssvar.px(b) };
}
function handleColorOrWidth$3(match, ctx) {
  if (utilities$3.isCSSMathFn(utilities$3.h.bracket(match[1])))
    return handleWidth$3(match, ctx);
  return utilities$3.colorResolver("--un-ring-color", "ring", "borderColor")(match, ctx);
}

const boxShadowsBase = {
  "--un-ring-offset-shadow": "0 0 rgb(0 0 0 / 0)",
  "--un-ring-shadow": "0 0 rgb(0 0 0 / 0)",
  "--un-shadow-inset": varEmpty,
  "--un-shadow": "0 0 rgb(0 0 0 / 0)"
};
const boxShadows = [
  // color
  [/^shadow(?:-(.+))?$/, (match, context) => {
    const [, d] = match;
    const { theme } = context;
    const v = theme.boxShadow?.[d || "DEFAULT"];
    const c = d ? utilities$3.h.bracket.cssvar(d) : void 0;
    if ((v != null || c != null) && !utilities$3.hasParseableColor(c, theme, "shadowColor")) {
      return {
        "--un-shadow": utilities$3.colorableShadows(v || c, "--un-shadow-color").join(","),
        "box-shadow": "var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow)"
      };
    }
    return utilities$3.colorResolver("--un-shadow-color", "shadow", "shadowColor")(match, context);
  }, { autocomplete: ["shadow-$colors", "shadow-$boxShadow"] }],
  [/^shadow-op(?:acity)?-?(.+)$/, ([, opacity]) => ({ "--un-shadow-opacity": utilities$3.h.bracket.percent.cssvar(opacity) }), { autocomplete: "shadow-(op|opacity)-<percent>" }],
  // inset
  ["shadow-inset", { "--un-shadow-inset": "inset" }]
];

const transformValues = [
  "translate",
  "rotate",
  "scale"
];
const transformCpu = [
  "translateX(var(--un-translate-x))",
  "translateY(var(--un-translate-y))",
  "translateZ(var(--un-translate-z))",
  "rotate(var(--un-rotate))",
  "rotateX(var(--un-rotate-x))",
  "rotateY(var(--un-rotate-y))",
  "rotateZ(var(--un-rotate-z))",
  "skewX(var(--un-skew-x))",
  "skewY(var(--un-skew-y))",
  "scaleX(var(--un-scale-x))",
  "scaleY(var(--un-scale-y))",
  "scaleZ(var(--un-scale-z))"
].join(" ");
const transformGpu = [
  "translate3d(var(--un-translate-x), var(--un-translate-y), var(--un-translate-z))",
  "rotate(var(--un-rotate))",
  "rotateX(var(--un-rotate-x))",
  "rotateY(var(--un-rotate-y))",
  "rotateZ(var(--un-rotate-z))",
  "skewX(var(--un-skew-x))",
  "skewY(var(--un-skew-y))",
  "scaleX(var(--un-scale-x))",
  "scaleY(var(--un-scale-y))",
  "scaleZ(var(--un-scale-z))"
].join(" ");
const transformBase = {
  // transform
  "--un-rotate": 0,
  "--un-rotate-x": 0,
  "--un-rotate-y": 0,
  "--un-rotate-z": 0,
  "--un-scale-x": 1,
  "--un-scale-y": 1,
  "--un-scale-z": 1,
  "--un-skew-x": 0,
  "--un-skew-y": 0,
  "--un-translate-x": 0,
  "--un-translate-y": 0,
  "--un-translate-z": 0
};
const transforms = [
  // origins
  [/^(?:transform-)?origin-(.+)$/, ([, s]) => ({ "transform-origin": utilities$3.positionMap[s] ?? utilities$3.h.bracket.cssvar(s) }), { autocomplete: [`transform-origin-(${Object.keys(utilities$3.positionMap).join("|")})`, `origin-(${Object.keys(utilities$3.positionMap).join("|")})`] }],
  // perspectives
  [/^(?:transform-)?perspect(?:ive)?-(.+)$/, ([, s]) => {
    const v = utilities$3.h.bracket.cssvar.px.numberWithUnit(s);
    if (v != null) {
      return {
        "-webkit-perspective": v,
        "perspective": v
      };
    }
  }],
  // skip 1 & 2 letters shortcut
  [/^(?:transform-)?perspect(?:ive)?-origin-(.+)$/, ([, s]) => {
    const v = utilities$3.h.bracket.cssvar(s) ?? (s.length >= 3 ? utilities$3.positionMap[s] : void 0);
    if (v != null) {
      return {
        "-webkit-perspective-origin": v,
        "perspective-origin": v
      };
    }
  }],
  // modifiers
  [/^(?:transform-)?translate-()(.+)$/, handleTranslate],
  [/^(?:transform-)?translate-([xyz])-(.+)$/, handleTranslate],
  [/^(?:transform-)?rotate-()(.+)$/, handleRotate],
  [/^(?:transform-)?rotate-([xyz])-(.+)$/, handleRotate],
  [/^(?:transform-)?skew-()(.+)$/, handleSkew],
  [/^(?:transform-)?skew-([xy])-(.+)$/, handleSkew, { autocomplete: ["transform-skew-(x|y)-<percent>", "skew-(x|y)-<percent>"] }],
  [/^(?:transform-)?scale-()(.+)$/, handleScale],
  [/^(?:transform-)?scale-([xyz])-(.+)$/, handleScale, { autocomplete: [`transform-(${transformValues.join("|")})-<percent>`, `transform-(${transformValues.join("|")})-(x|y|z)-<percent>`, `(${transformValues.join("|")})-<percent>`, `(${transformValues.join("|")})-(x|y|z)-<percent>`] }],
  // style
  [/^(?:transform-)?preserve-3d$/, () => ({ "transform-style": "preserve-3d" })],
  [/^(?:transform-)?preserve-flat$/, () => ({ "transform-style": "flat" })],
  // base
  ["transform", { transform: transformCpu }],
  ["transform-cpu", { transform: transformCpu }],
  ["transform-gpu", { transform: transformGpu }],
  ["transform-none", { transform: "none" }],
  ...utilities$3.makeGlobalStaticRules("transform")
];
function handleTranslate([, d, b], { theme }) {
  const v = theme.spacing?.[b] ?? utilities$3.h.bracket.cssvar.fraction.rem(b);
  if (v != null) {
    return [
      ...utilities$3.transformXYZ(d, v, "translate"),
      ["transform", transformCpu]
    ];
  }
}
function handleScale([, d, b]) {
  const v = utilities$3.h.bracket.cssvar.fraction.percent(b);
  if (v != null) {
    return [
      ...utilities$3.transformXYZ(d, v, "scale"),
      ["transform", transformCpu]
    ];
  }
}
function handleRotate([, d = "", b]) {
  const v = utilities$3.h.bracket.cssvar.degree(b);
  if (v != null) {
    if (d) {
      return {
        "--un-rotate": 0,
        [`--un-rotate-${d}`]: v,
        "transform": transformCpu
      };
    } else {
      return {
        "--un-rotate-x": 0,
        "--un-rotate-y": 0,
        "--un-rotate-z": 0,
        "--un-rotate": v,
        "transform": transformCpu
      };
    }
  }
}
function handleSkew([, d, b]) {
  const v = utilities$3.h.bracket.cssvar.degree(b);
  if (v != null) {
    return [
      ...utilities$3.transformXYZ(d, v, "skew"),
      ["transform", transformCpu]
    ];
  }
}

presetMini_mjThnwTD.appearances = appearances;
presetMini_mjThnwTD.boxShadows = boxShadows;
presetMini_mjThnwTD.boxShadowsBase = boxShadowsBase;
presetMini_mjThnwTD.breaks = breaks;
presetMini_mjThnwTD.contains = contains;
presetMini_mjThnwTD.contentVisibility = contentVisibility;
presetMini_mjThnwTD.contents = contents;
presetMini_mjThnwTD.cursors = cursors;
presetMini_mjThnwTD.displays = displays;
presetMini_mjThnwTD.fontSmoothings = fontSmoothings;
presetMini_mjThnwTD.fontStyles = fontStyles;
presetMini_mjThnwTD.pointerEvents = pointerEvents;
presetMini_mjThnwTD.resizes = resizes;
presetMini_mjThnwTD.ringBase = ringBase;
presetMini_mjThnwTD.rings = rings;
presetMini_mjThnwTD.textOverflows = textOverflows;
presetMini_mjThnwTD.textTransforms = textTransforms$1;
presetMini_mjThnwTD.textWraps = textWraps;
presetMini_mjThnwTD.transformBase = transformBase;
presetMini_mjThnwTD.transforms = transforms;
presetMini_mjThnwTD.userSelects = userSelects;
presetMini_mjThnwTD.varEmpty = varEmpty;
presetMini_mjThnwTD.whitespaces = whitespaces;

const colors$2 = colors$4;
const transform$3 = presetMini_mjThnwTD;

const fontFamily = {
  sans: [
    "ui-sans-serif",
    "system-ui",
    "-apple-system",
    "BlinkMacSystemFont",
    '"Segoe UI"',
    "Roboto",
    '"Helvetica Neue"',
    "Arial",
    '"Noto Sans"',
    "sans-serif",
    '"Apple Color Emoji"',
    '"Segoe UI Emoji"',
    '"Segoe UI Symbol"',
    '"Noto Color Emoji"'
  ].join(","),
  serif: [
    "ui-serif",
    "Georgia",
    "Cambria",
    '"Times New Roman"',
    "Times",
    "serif"
  ].join(","),
  mono: [
    "ui-monospace",
    "SFMono-Regular",
    "Menlo",
    "Monaco",
    "Consolas",
    '"Liberation Mono"',
    '"Courier New"',
    "monospace"
  ].join(",")
};
const fontSize = {
  "xs": ["0.75rem", "1rem"],
  "sm": ["0.875rem", "1.25rem"],
  "base": ["1rem", "1.5rem"],
  "lg": ["1.125rem", "1.75rem"],
  "xl": ["1.25rem", "1.75rem"],
  "2xl": ["1.5rem", "2rem"],
  "3xl": ["1.875rem", "2.25rem"],
  "4xl": ["2.25rem", "2.5rem"],
  "5xl": ["3rem", "1"],
  "6xl": ["3.75rem", "1"],
  "7xl": ["4.5rem", "1"],
  "8xl": ["6rem", "1"],
  "9xl": ["8rem", "1"]
};
const textIndent = {
  "DEFAULT": "1.5rem",
  "xs": "0.5rem",
  "sm": "1rem",
  "md": "1.5rem",
  "lg": "2rem",
  "xl": "2.5rem",
  "2xl": "3rem",
  "3xl": "4rem"
};
const textStrokeWidth = {
  DEFAULT: "1.5rem",
  none: "0",
  sm: "thin",
  md: "medium",
  lg: "thick"
};
const textShadow = {
  DEFAULT: ["0 0 1px rgb(0 0 0 / 0.2)", "0 0 1px rgb(1 0 5 / 0.1)"],
  none: "0 0 rgb(0 0 0 / 0)",
  sm: "1px 1px 3px rgb(36 37 47 / 0.25)",
  md: ["0 1px 2px rgb(30 29 39 / 0.19)", "1px 2px 4px rgb(54 64 147 / 0.18)"],
  lg: ["3px 3px 6px rgb(0 0 0 / 0.26)", "0 0 5px rgb(15 3 86 / 0.22)"],
  xl: ["1px 1px 3px rgb(0 0 0 / 0.29)", "2px 4px 7px rgb(73 64 125 / 0.35)"]
};
const lineHeight = {
  none: "1",
  tight: "1.25",
  snug: "1.375",
  normal: "1.5",
  relaxed: "1.625",
  loose: "2"
};
const letterSpacing = {
  tighter: "-0.05em",
  tight: "-0.025em",
  normal: "0em",
  wide: "0.025em",
  wider: "0.05em",
  widest: "0.1em"
};
const fontWeight = {
  thin: "100",
  extralight: "200",
  light: "300",
  normal: "400",
  medium: "500",
  semibold: "600",
  bold: "700",
  extrabold: "800",
  black: "900"
  // int[0, 900] -> int
};
const wordSpacing = letterSpacing;

const breakpoints = {
  "sm": "640px",
  "md": "768px",
  "lg": "1024px",
  "xl": "1280px",
  "2xl": "1536px"
};
const verticalBreakpoints = { ...breakpoints };
const lineWidth = {
  DEFAULT: "1px",
  none: "0"
};
const spacing = {
  "DEFAULT": "1rem",
  "none": "0",
  "xs": "0.75rem",
  "sm": "0.875rem",
  "lg": "1.125rem",
  "xl": "1.25rem",
  "2xl": "1.5rem",
  "3xl": "1.875rem",
  "4xl": "2.25rem",
  "5xl": "3rem",
  "6xl": "3.75rem",
  "7xl": "4.5rem",
  "8xl": "6rem",
  "9xl": "8rem"
};
const duration = {
  DEFAULT: "150ms",
  none: "0s",
  75: "75ms",
  100: "100ms",
  150: "150ms",
  200: "200ms",
  300: "300ms",
  500: "500ms",
  700: "700ms",
  1e3: "1000ms"
};
const borderRadius = {
  "DEFAULT": "0.25rem",
  "none": "0",
  "sm": "0.125rem",
  "md": "0.375rem",
  "lg": "0.5rem",
  "xl": "0.75rem",
  "2xl": "1rem",
  "3xl": "1.5rem",
  "full": "9999px"
};
const boxShadow = {
  "DEFAULT": ["var(--un-shadow-inset) 0 1px 3px 0 rgb(0 0 0 / 0.1)", "var(--un-shadow-inset) 0 1px 2px -1px rgb(0 0 0 / 0.1)"],
  "none": "0 0 rgb(0 0 0 / 0)",
  "sm": "var(--un-shadow-inset) 0 1px 2px 0 rgb(0 0 0 / 0.05)",
  "md": ["var(--un-shadow-inset) 0 4px 6px -1px rgb(0 0 0 / 0.1)", "var(--un-shadow-inset) 0 2px 4px -2px rgb(0 0 0 / 0.1)"],
  "lg": ["var(--un-shadow-inset) 0 10px 15px -3px rgb(0 0 0 / 0.1)", "var(--un-shadow-inset) 0 4px 6px -4px rgb(0 0 0 / 0.1)"],
  "xl": ["var(--un-shadow-inset) 0 20px 25px -5px rgb(0 0 0 / 0.1)", "var(--un-shadow-inset) 0 8px 10px -6px rgb(0 0 0 / 0.1)"],
  "2xl": "var(--un-shadow-inset) 0 25px 50px -12px rgb(0 0 0 / 0.25)",
  "inner": "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)"
};
const easing = {
  "DEFAULT": "cubic-bezier(0.4, 0, 0.2, 1)",
  "linear": "linear",
  "in": "cubic-bezier(0.4, 0, 1, 1)",
  "out": "cubic-bezier(0, 0, 0.2, 1)",
  "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
};
const ringWidth = {
  DEFAULT: "1px",
  none: "0"
};
const zIndex = {
  auto: "auto"
};
const media$2 = {
  mouse: "(hover) and (pointer: fine)"
};

const blur = {
  "DEFAULT": "8px",
  "0": "0",
  "sm": "4px",
  "md": "12px",
  "lg": "16px",
  "xl": "24px",
  "2xl": "40px",
  "3xl": "64px"
};
const dropShadow = {
  "DEFAULT": ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
  "sm": "0 1px 1px rgb(0 0 0 / 0.05)",
  "md": ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
  "lg": ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
  "xl": ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
  "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
  "none": "0 0 rgb(0 0 0 / 0)"
};

const baseSize = {
  "xs": "20rem",
  "sm": "24rem",
  "md": "28rem",
  "lg": "32rem",
  "xl": "36rem",
  "2xl": "42rem",
  "3xl": "48rem",
  "4xl": "56rem",
  "5xl": "64rem",
  "6xl": "72rem",
  "7xl": "80rem",
  "prose": "65ch"
};
const width$1 = {
  auto: "auto",
  ...baseSize,
  screen: "100vw"
};
const maxWidth = {
  none: "none",
  ...baseSize,
  screen: "100vw"
};
const height$1 = {
  auto: "auto",
  ...baseSize,
  screen: "100vh"
};
const maxHeight = {
  none: "none",
  ...baseSize,
  screen: "100vh"
};
const containers = Object.fromEntries(Object.entries(baseSize).map(([k, v]) => [k, `(min-width: ${v})`]));

const preflightBase = {
  ...transform$3.transformBase,
  ...transform$3.boxShadowsBase,
  ...transform$3.ringBase
};

const theme$3 = {
  width: width$1,
  height: height$1,
  maxWidth,
  maxHeight,
  minWidth: maxWidth,
  minHeight: maxHeight,
  inlineSize: width$1,
  blockSize: height$1,
  maxInlineSize: maxWidth,
  maxBlockSize: maxHeight,
  minInlineSize: maxWidth,
  minBlockSize: maxHeight,
  colors: colors$2.colors,
  fontFamily,
  fontSize,
  fontWeight,
  breakpoints,
  verticalBreakpoints,
  borderRadius,
  lineHeight,
  letterSpacing,
  wordSpacing,
  boxShadow,
  textIndent,
  textShadow,
  textStrokeWidth,
  blur,
  dropShadow,
  easing,
  lineWidth,
  spacing,
  duration,
  ringWidth,
  preflightBase,
  containers,
  zIndex,
  media: media$2
};

presetMini_St8sZgQd.baseSize = baseSize;
presetMini_St8sZgQd.blur = blur;
presetMini_St8sZgQd.borderRadius = borderRadius;
presetMini_St8sZgQd.boxShadow = boxShadow;
presetMini_St8sZgQd.breakpoints = breakpoints;
presetMini_St8sZgQd.containers = containers;
presetMini_St8sZgQd.dropShadow = dropShadow;
presetMini_St8sZgQd.duration = duration;
presetMini_St8sZgQd.easing = easing;
presetMini_St8sZgQd.fontFamily = fontFamily;
presetMini_St8sZgQd.fontSize = fontSize;
presetMini_St8sZgQd.fontWeight = fontWeight;
presetMini_St8sZgQd.height = height$1;
presetMini_St8sZgQd.letterSpacing = letterSpacing;
presetMini_St8sZgQd.lineHeight = lineHeight;
presetMini_St8sZgQd.lineWidth = lineWidth;
presetMini_St8sZgQd.maxHeight = maxHeight;
presetMini_St8sZgQd.maxWidth = maxWidth;
presetMini_St8sZgQd.media = media$2;
presetMini_St8sZgQd.preflightBase = preflightBase;
presetMini_St8sZgQd.ringWidth = ringWidth;
presetMini_St8sZgQd.spacing = spacing;
presetMini_St8sZgQd.textIndent = textIndent;
presetMini_St8sZgQd.textShadow = textShadow;
presetMini_St8sZgQd.textStrokeWidth = textStrokeWidth;
presetMini_St8sZgQd.theme = theme$3;
presetMini_St8sZgQd.verticalBreakpoints = verticalBreakpoints;
presetMini_St8sZgQd.width = width$1;
presetMini_St8sZgQd.wordSpacing = wordSpacing;
presetMini_St8sZgQd.zIndex = zIndex;

var presetMini_D_Gfuejm = {};

const utilities$2 = presetMini_DahJgnb1;
const ruleUtils$4 = dist$k;
const core$g = dist$p;
const transform$2 = presetMini_mjThnwTD;

const verticalAlignAlias = {
  "mid": "middle",
  "base": "baseline",
  "btm": "bottom",
  "baseline": "baseline",
  "top": "top",
  "start": "top",
  "middle": "middle",
  "bottom": "bottom",
  "end": "bottom",
  "text-top": "text-top",
  "text-bottom": "text-bottom",
  "sub": "sub",
  "super": "super",
  ...Object.fromEntries(utilities$2.globalKeywords.map((x) => [x, x]))
};
const verticalAligns = [
  [
    /^(?:vertical|align|v)-([-\w]+%?)$/,
    ([, v]) => ({ "vertical-align": verticalAlignAlias[v] ?? utilities$2.h.numberWithUnit(v) }),
    {
      autocomplete: [
        `(vertical|align|v)-(${Object.keys(verticalAlignAlias).join("|")})`,
        "(vertical|align|v)-<percentage>"
      ]
    }
  ]
];
const textAligns = ["center", "left", "right", "justify", "start", "end"].map((v) => [`text-${v}`, { "text-align": v }]);

const outline$1 = [
  // size
  [/^outline-(?:width-|size-)?(.+)$/, handleWidth$2, { autocomplete: "outline-(width|size)-<num>" }],
  // color
  [/^outline-(?:color-)?(.+)$/, handleColorOrWidth$2, { autocomplete: "outline-$colors" }],
  // offset
  [/^outline-offset-(.+)$/, ([, d], { theme }) => ({ "outline-offset": theme.lineWidth?.[d] ?? utilities$2.h.bracket.cssvar.global.px(d) }), { autocomplete: "outline-(offset)-<num>" }],
  // style
  ["outline", { "outline-style": "solid" }],
  ...["auto", "dashed", "dotted", "double", "hidden", "solid", "groove", "ridge", "inset", "outset", ...utilities$2.globalKeywords].map((v) => [`outline-${v}`, { "outline-style": v }]),
  ["outline-none", { "outline": "2px solid transparent", "outline-offset": "2px" }]
];
function handleWidth$2([, b], { theme }) {
  return { "outline-width": theme.lineWidth?.[b] ?? utilities$2.h.bracket.cssvar.global.px(b) };
}
function handleColorOrWidth$2(match, ctx) {
  if (utilities$2.isCSSMathFn(utilities$2.h.bracket(match[1])))
    return handleWidth$2(match, ctx);
  return utilities$2.colorResolver("outline-color", "outline-color", "borderColor")(match, ctx);
}
const appearance$1 = [
  ["appearance-auto", { "-webkit-appearance": "auto", "appearance": "auto" }],
  ["appearance-none", { "-webkit-appearance": "none", "appearance": "none" }]
];
function willChangeProperty(prop) {
  return utilities$2.h.properties.auto.global(prop) ?? {
    contents: "contents",
    scroll: "scroll-position"
  }[prop];
}
const willChange = [
  [/^will-change-(.+)/, ([, p]) => ({ "will-change": willChangeProperty(p) })]
];

const borderStyles = ["solid", "dashed", "dotted", "double", "hidden", "none", "groove", "ridge", "inset", "outset", ...utilities$2.globalKeywords];
const borders = [
  // compound
  [/^(?:border|b)()(?:-(.+))?$/, handlerBorderSize, { autocomplete: "(border|b)-<directions>" }],
  [/^(?:border|b)-([xy])(?:-(.+))?$/, handlerBorderSize],
  [/^(?:border|b)-([rltbse])(?:-(.+))?$/, handlerBorderSize],
  [/^(?:border|b)-(block|inline)(?:-(.+))?$/, handlerBorderSize],
  [/^(?:border|b)-([bi][se])(?:-(.+))?$/, handlerBorderSize],
  // size
  [/^(?:border|b)-()(?:width|size)-(.+)$/, handlerBorderSize, { autocomplete: ["(border|b)-<num>", "(border|b)-<directions>-<num>"] }],
  [/^(?:border|b)-([xy])-(?:width|size)-(.+)$/, handlerBorderSize],
  [/^(?:border|b)-([rltbse])-(?:width|size)-(.+)$/, handlerBorderSize],
  [/^(?:border|b)-(block|inline)-(?:width|size)-(.+)$/, handlerBorderSize],
  [/^(?:border|b)-([bi][se])-(?:width|size)-(.+)$/, handlerBorderSize],
  // colors
  [/^(?:border|b)-()(?:color-)?(.+)$/, handlerBorderColorOrSize, { autocomplete: ["(border|b)-$colors", "(border|b)-<directions>-$colors"] }],
  [/^(?:border|b)-([xy])-(?:color-)?(.+)$/, handlerBorderColorOrSize],
  [/^(?:border|b)-([rltbse])-(?:color-)?(.+)$/, handlerBorderColorOrSize],
  [/^(?:border|b)-(block|inline)-(?:color-)?(.+)$/, handlerBorderColorOrSize],
  [/^(?:border|b)-([bi][se])-(?:color-)?(.+)$/, handlerBorderColorOrSize],
  // opacity
  [/^(?:border|b)-()op(?:acity)?-?(.+)$/, handlerBorderOpacity, { autocomplete: "(border|b)-(op|opacity)-<percent>" }],
  [/^(?:border|b)-([xy])-op(?:acity)?-?(.+)$/, handlerBorderOpacity],
  [/^(?:border|b)-([rltbse])-op(?:acity)?-?(.+)$/, handlerBorderOpacity],
  [/^(?:border|b)-(block|inline)-op(?:acity)?-?(.+)$/, handlerBorderOpacity],
  [/^(?:border|b)-([bi][se])-op(?:acity)?-?(.+)$/, handlerBorderOpacity],
  // radius
  [/^(?:border-|b-)?(?:rounded|rd)()(?:-(.+))?$/, handlerRounded, { autocomplete: ["(border|b)-(rounded|rd)", "(border|b)-(rounded|rd)-<num>", "(rounded|rd)", "(rounded|rd)-<num>"] }],
  [/^(?:border-|b-)?(?:rounded|rd)-([rltbse])(?:-(.+))?$/, handlerRounded],
  [/^(?:border-|b-)?(?:rounded|rd)-([rltb]{2})(?:-(.+))?$/, handlerRounded],
  [/^(?:border-|b-)?(?:rounded|rd)-([bise][se])(?:-(.+))?$/, handlerRounded],
  [/^(?:border-|b-)?(?:rounded|rd)-([bi][se]-[bi][se])(?:-(.+))?$/, handlerRounded],
  // style
  [/^(?:border|b)-(?:style-)?()(.+)$/, handlerBorderStyle, { autocomplete: ["(border|b)-style", `(border|b)-(${borderStyles.join("|")})`, "(border|b)-<directions>-style", `(border|b)-<directions>-(${borderStyles.join("|")})`, `(border|b)-<directions>-style-(${borderStyles.join("|")})`, `(border|b)-style-(${borderStyles.join("|")})`] }],
  [/^(?:border|b)-([xy])-(?:style-)?(.+)$/, handlerBorderStyle],
  [/^(?:border|b)-([rltbse])-(?:style-)?(.+)$/, handlerBorderStyle],
  [/^(?:border|b)-(block|inline)-(?:style-)?(.+)$/, handlerBorderStyle],
  [/^(?:border|b)-([bi][se])-(?:style-)?(.+)$/, handlerBorderStyle]
];
function transformBorderColor(color, alpha, direction) {
  if (alpha != null) {
    return {
      [`border${direction}-color`]: ruleUtils$4.colorToString(color, alpha)
    };
  }
  if (direction === "") {
    const object = {};
    const opacityVar = `--un-border-opacity`;
    const result = ruleUtils$4.colorToString(color, `var(${opacityVar})`);
    if (result.includes(opacityVar))
      object[opacityVar] = typeof color === "string" ? 1 : ruleUtils$4.colorOpacityToString(color);
    object["border-color"] = result;
    return object;
  } else {
    const object = {};
    const opacityVar = "--un-border-opacity";
    const opacityDirectionVar = `--un-border${direction}-opacity`;
    const result = ruleUtils$4.colorToString(color, `var(${opacityDirectionVar})`);
    if (result.includes(opacityDirectionVar)) {
      object[opacityVar] = typeof color === "string" ? 1 : ruleUtils$4.colorOpacityToString(color);
      object[opacityDirectionVar] = `var(${opacityVar})`;
    }
    object[`border${direction}-color`] = result;
    return object;
  }
}
function borderColorResolver(direction) {
  return ([, body], theme) => {
    const data = utilities$2.parseColor(body, theme, "borderColor");
    if (!data)
      return;
    const { alpha, color, cssColor } = data;
    if (cssColor)
      return transformBorderColor(cssColor, alpha, direction);
    else if (color)
      return transformBorderColor(color, alpha, direction);
  };
}
function handlerBorderSize([, a = "", b], { theme }) {
  const v = theme.lineWidth?.[b || "DEFAULT"] ?? utilities$2.h.bracket.cssvar.global.px(b || "1");
  if (a in utilities$2.directionMap && v != null)
    return utilities$2.directionMap[a].map((i) => [`border${i}-width`, v]);
}
function handlerBorderColorOrSize([, a = "", b], ctx) {
  if (a in utilities$2.directionMap) {
    if (utilities$2.isCSSMathFn(utilities$2.h.bracket(b)))
      return handlerBorderSize(["", a, b], ctx);
    if (utilities$2.hasParseableColor(b, ctx.theme, "borderColor")) {
      return Object.assign(
        {},
        ...utilities$2.directionMap[a].map((i) => borderColorResolver(i)(["", b], ctx.theme))
      );
    }
  }
}
function handlerBorderOpacity([, a = "", opacity]) {
  const v = utilities$2.h.bracket.percent.cssvar(opacity);
  if (a in utilities$2.directionMap && v != null)
    return utilities$2.directionMap[a].map((i) => [`--un-border${i}-opacity`, v]);
}
function handlerRounded([, a = "", s], { theme }) {
  const v = theme.borderRadius?.[s || "DEFAULT"] || utilities$2.h.bracket.cssvar.global.fraction.rem(s || "1");
  if (a in utilities$2.cornerMap && v != null)
    return utilities$2.cornerMap[a].map((i) => [`border${i}-radius`, v]);
}
function handlerBorderStyle([, a = "", s]) {
  if (borderStyles.includes(s) && a in utilities$2.directionMap)
    return utilities$2.directionMap[a].map((i) => [`border${i}-style`, s]);
}

const opacity$1 = [
  [/^op(?:acity)?-?(.+)$/, ([, d]) => ({ opacity: utilities$2.h.bracket.percent.cssvar(d) })]
];
const bgUrlRE = /^\[url\(.+\)\]$/;
const bgLengthRE = /^\[(length|size):.+\]$/;
const bgPositionRE = /^\[position:.+\]$/;
const bgGradientRE = /^\[(linear|conic|radial)-gradient\(.+\)\]$/;
const bgColors = [
  [/^bg-(.+)$/, (...args) => {
    const d = args[0][1];
    if (bgUrlRE.test(d))
      return { "--un-url": utilities$2.h.bracket(d), "background-image": "var(--un-url)" };
    if (bgLengthRE.test(d) && utilities$2.h.bracketOfLength(d) != null)
      return { "background-size": utilities$2.h.bracketOfLength(d).split(" ").map((e) => utilities$2.h.fraction.auto.px.cssvar(e) ?? e).join(" ") };
    if ((utilities$2.isSize(d) || bgPositionRE.test(d)) && utilities$2.h.bracketOfPosition(d) != null)
      return { "background-position": utilities$2.h.bracketOfPosition(d).split(" ").map((e) => utilities$2.h.position.fraction.auto.px.cssvar(e) ?? e).join(" ") };
    if (bgGradientRE.test(d))
      return { "background-image": utilities$2.h.bracket(d) };
    return utilities$2.colorResolver("background-color", "bg", "backgroundColor")(...args);
  }, { autocomplete: "bg-$colors" }],
  [/^bg-op(?:acity)?-?(.+)$/, ([, opacity2]) => ({ "--un-bg-opacity": utilities$2.h.bracket.percent.cssvar(opacity2) }), { autocomplete: "bg-(op|opacity)-<percent>" }]
];
const colorScheme = [
  [/^color-scheme-(\w+)$/, ([, v]) => ({ "color-scheme": v })]
];

const containerParent = [
  [/^@container(?:\/(\w+))?(?:-(normal))?$/, ([, l, v]) => {
    core$g.warnOnce("The container query rule is experimental and may not follow semver.");
    return {
      "container-type": v ?? "inline-size",
      "container-name": l
    };
  }]
];

const decorationStyles = ["solid", "double", "dotted", "dashed", "wavy", ...utilities$2.globalKeywords];
const textDecorations = [
  [/^(?:decoration-)?(underline|overline|line-through)$/, ([, s]) => ({ "text-decoration-line": s }), { autocomplete: "decoration-(underline|overline|line-through)" }],
  // size
  [/^(?:underline|decoration)-(?:size-)?(.+)$/, handleWidth$1, { autocomplete: "(underline|decoration)-<num>" }],
  [/^(?:underline|decoration)-(auto|from-font)$/, ([, s]) => ({ "text-decoration-thickness": s }), { autocomplete: "(underline|decoration)-(auto|from-font)" }],
  // colors
  [/^(?:underline|decoration)-(.+)$/, handleColorOrWidth$1, { autocomplete: "(underline|decoration)-$colors" }],
  [/^(?:underline|decoration)-op(?:acity)?-?(.+)$/, ([, opacity]) => ({ "--un-line-opacity": utilities$2.h.bracket.percent.cssvar(opacity) }), { autocomplete: "(underline|decoration)-(op|opacity)-<percent>" }],
  // offset
  [/^(?:underline|decoration)-offset-(.+)$/, ([, s], { theme }) => ({ "text-underline-offset": theme.lineWidth?.[s] ?? utilities$2.h.auto.bracket.cssvar.global.px(s) }), { autocomplete: "(underline|decoration)-(offset)-<num>" }],
  // style
  ...decorationStyles.map((v) => [`underline-${v}`, { "text-decoration-style": v }]),
  ...decorationStyles.map((v) => [`decoration-${v}`, { "text-decoration-style": v }]),
  ["no-underline", { "text-decoration": "none" }],
  ["decoration-none", { "text-decoration": "none" }]
];
function handleWidth$1([, b], { theme }) {
  return { "text-decoration-thickness": theme.lineWidth?.[b] ?? utilities$2.h.bracket.cssvar.global.px(b) };
}
function handleColorOrWidth$1(match, ctx) {
  if (utilities$2.isCSSMathFn(utilities$2.h.bracket(match[1])))
    return handleWidth$1(match, ctx);
  const result = utilities$2.colorResolver("text-decoration-color", "line", "borderColor")(match, ctx);
  if (result) {
    return {
      "-webkit-text-decoration-color": result["text-decoration-color"],
      ...result
    };
  }
}

const transitionPropertyGroup = {
  all: "all",
  colors: ["color", "background-color", "border-color", "outline-color", "text-decoration-color", "fill", "stroke"].join(","),
  none: "none",
  opacity: "opacity",
  shadow: "box-shadow",
  transform: "transform"
};
function transitionProperty(prop) {
  return utilities$2.h.properties(prop) ?? transitionPropertyGroup[prop];
}
const transitions = [
  // transition
  [
    /^transition(?:-([a-z-]+(?:,[a-z-]+)*))?(?:-(\d+))?$/,
    ([, prop, d], { theme }) => {
      const p = prop != null ? transitionProperty(prop) : [transitionPropertyGroup.colors, "opacity", "box-shadow", "transform", "filter", "backdrop-filter"].join(",");
      if (p) {
        const duration = theme.duration?.[d || "DEFAULT"] ?? utilities$2.h.time(d || "150");
        return {
          "transition-property": p,
          "transition-timing-function": "cubic-bezier(0.4, 0, 0.2, 1)",
          "transition-duration": duration
        };
      }
    },
    { autocomplete: `transition-(${Object.keys(transitionPropertyGroup).join("|")})` }
  ],
  // timings
  [
    /^(?:transition-)?duration-(.+)$/,
    ([, d], { theme }) => ({ "transition-duration": theme.duration?.[d || "DEFAULT"] ?? utilities$2.h.bracket.cssvar.time(d) }),
    { autocomplete: ["transition-duration-$duration", "duration-$duration"] }
  ],
  [
    /^(?:transition-)?delay-(.+)$/,
    ([, d], { theme }) => ({ "transition-delay": theme.duration?.[d || "DEFAULT"] ?? utilities$2.h.bracket.cssvar.time(d) }),
    { autocomplete: ["transition-delay-$duration", "delay-$duration"] }
  ],
  [
    /^(?:transition-)?ease(?:-(.+))?$/,
    ([, d], { theme }) => ({ "transition-timing-function": theme.easing?.[d || "DEFAULT"] ?? utilities$2.h.bracket.cssvar(d) }),
    { autocomplete: ["transition-ease-(linear|in|out|in-out|DEFAULT)", "ease-(linear|in|out|in-out|DEFAULT)"] }
  ],
  // props
  [
    /^(?:transition-)?property-(.+)$/,
    ([, v]) => ({ "transition-property": utilities$2.h.bracket.global(v) || transitionProperty(v) }),
    { autocomplete: [`transition-property-(${[...utilities$2.globalKeywords, ...Object.keys(transitionPropertyGroup)].join("|")})`] }
  ],
  // none
  ["transition-none", { transition: "none" }],
  ...utilities$2.makeGlobalStaticRules("transition")
];

const flex$2 = [
  // display
  ["flex", { display: "flex" }],
  ["inline-flex", { display: "inline-flex" }],
  ["flex-inline", { display: "inline-flex" }],
  // flex
  [/^flex-(.*)$/, ([, d]) => ({ flex: utilities$2.h.bracket(d) != null ? utilities$2.h.bracket(d).split(" ").map((e) => utilities$2.h.cssvar.fraction(e) ?? e).join(" ") : utilities$2.h.cssvar.fraction(d) })],
  ["flex-1", { flex: "1 1 0%" }],
  ["flex-auto", { flex: "1 1 auto" }],
  ["flex-initial", { flex: "0 1 auto" }],
  ["flex-none", { flex: "none" }],
  // shrink/grow/basis
  [/^(?:flex-)?shrink(?:-(.*))?$/, ([, d = ""]) => ({ "flex-shrink": utilities$2.h.bracket.cssvar.number(d) ?? 1 }), { autocomplete: ["flex-shrink-<num>", "shrink-<num>"] }],
  [/^(?:flex-)?grow(?:-(.*))?$/, ([, d = ""]) => ({ "flex-grow": utilities$2.h.bracket.cssvar.number(d) ?? 1 }), { autocomplete: ["flex-grow-<num>", "grow-<num>"] }],
  [/^(?:flex-)?basis-(.+)$/, ([, d], { theme }) => ({ "flex-basis": theme.spacing?.[d] ?? utilities$2.h.bracket.cssvar.auto.fraction.rem(d) }), { autocomplete: ["flex-basis-$spacing", "basis-$spacing"] }],
  // directions
  ["flex-row", { "flex-direction": "row" }],
  ["flex-row-reverse", { "flex-direction": "row-reverse" }],
  ["flex-col", { "flex-direction": "column" }],
  ["flex-col-reverse", { "flex-direction": "column-reverse" }],
  // wraps
  ["flex-wrap", { "flex-wrap": "wrap" }],
  ["flex-wrap-reverse", { "flex-wrap": "wrap-reverse" }],
  ["flex-nowrap", { "flex-wrap": "nowrap" }]
];

const fonts = [
  // text
  [/^text-(.+)$/, handleText, { autocomplete: "text-$fontSize" }],
  // text size
  [/^(?:text|font)-size-(.+)$/, handleSize, { autocomplete: "text-size-$fontSize" }],
  // text colors
  [/^text-(?:color-)?(.+)$/, handlerColorOrSize, { autocomplete: "text-$colors" }],
  // colors
  [/^(?:color|c)-(.+)$/, utilities$2.colorResolver("color", "text", "textColor"), { autocomplete: "(color|c)-$colors" }],
  // style
  [/^(?:text|color|c)-(.+)$/, ([, v]) => utilities$2.globalKeywords.includes(v) ? { color: v } : void 0, { autocomplete: `(text|color|c)-(${utilities$2.globalKeywords.join("|")})` }],
  // opacity
  [/^(?:text|color|c)-op(?:acity)?-?(.+)$/, ([, opacity]) => ({ "--un-text-opacity": utilities$2.h.bracket.percent.cssvar(opacity) }), { autocomplete: "(text|color|c)-(op|opacity)-<percent>" }],
  // weights
  [
    /^(?:font|fw)-?([^-]+)$/,
    ([, s], { theme }) => ({ "font-weight": theme.fontWeight?.[s] || utilities$2.h.bracket.global.number(s) }),
    {
      autocomplete: [
        "(font|fw)-(100|200|300|400|500|600|700|800|900)",
        "(font|fw)-$fontWeight"
      ]
    }
  ],
  // leadings
  [
    /^(?:font-)?(?:leading|lh|line-height)-(.+)$/,
    ([, s], { theme }) => ({ "line-height": handleThemeByKey(s, theme, "lineHeight") }),
    { autocomplete: "(leading|lh|line-height)-$lineHeight" }
  ],
  // synthesis
  ["font-synthesis-weight", { "font-synthesis": "weight" }],
  ["font-synthesis-style", { "font-synthesis": "style" }],
  ["font-synthesis-small-caps", { "font-synthesis": "small-caps" }],
  ["font-synthesis-none", { "font-synthesis": "none" }],
  [/^font-synthesis-(.+)$/, ([, s]) => ({ "font-synthesis": utilities$2.h.bracket.cssvar.global(s) })],
  // tracking
  [
    /^(?:font-)?tracking-(.+)$/,
    ([, s], { theme }) => ({ "letter-spacing": theme.letterSpacing?.[s] || utilities$2.h.bracket.cssvar.global.rem(s) }),
    { autocomplete: "tracking-$letterSpacing" }
  ],
  // word-spacing
  [
    /^(?:font-)?word-spacing-(.+)$/,
    ([, s], { theme }) => ({ "word-spacing": theme.wordSpacing?.[s] || utilities$2.h.bracket.cssvar.global.rem(s) }),
    { autocomplete: "word-spacing-$wordSpacing" }
  ],
  // stretch
  ["font-stretch-normal", { "font-stretch": "normal" }],
  ["font-stretch-ultra-condensed", { "font-stretch": "ultra-condensed" }],
  ["font-stretch-extra-condensed", { "font-stretch": "extra-condensed" }],
  ["font-stretch-condensed", { "font-stretch": "condensed" }],
  ["font-stretch-semi-condensed", { "font-stretch": "semi-condensed" }],
  ["font-stretch-semi-expanded", { "font-stretch": "semi-expanded" }],
  ["font-stretch-expanded", { "font-stretch": "expanded" }],
  ["font-stretch-extra-expanded", { "font-stretch": "extra-expanded" }],
  ["font-stretch-ultra-expanded", { "font-stretch": "ultra-expanded" }],
  [
    /^font-stretch-(.+)$/,
    ([, s]) => ({ "font-stretch": utilities$2.h.bracket.cssvar.fraction.global(s) }),
    { autocomplete: "font-stretch-<percentage>" }
  ],
  // family
  [
    /^font-(.+)$/,
    ([, d], { theme }) => ({ "font-family": theme.fontFamily?.[d] || utilities$2.h.bracket.cssvar.global(d) }),
    { autocomplete: "font-$fontFamily" }
  ]
];
const tabSizes = [
  [/^tab(?:-(.+))?$/, ([, s]) => {
    const v = utilities$2.h.bracket.cssvar.global.number(s || "4");
    if (v != null) {
      return {
        "-moz-tab-size": v,
        "-o-tab-size": v,
        "tab-size": v
      };
    }
  }]
];
const textIndents = [
  [/^indent(?:-(.+))?$/, ([, s], { theme }) => ({ "text-indent": theme.textIndent?.[s || "DEFAULT"] || utilities$2.h.bracket.cssvar.global.fraction.rem(s) }), { autocomplete: "indent-$textIndent" }]
];
const textStrokes = [
  // widths
  [/^text-stroke(?:-(.+))?$/, ([, s], { theme }) => ({ "-webkit-text-stroke-width": theme.textStrokeWidth?.[s || "DEFAULT"] || utilities$2.h.bracket.cssvar.px(s) }), { autocomplete: "text-stroke-$textStrokeWidth" }],
  // colors
  [/^text-stroke-(.+)$/, utilities$2.colorResolver("-webkit-text-stroke-color", "text-stroke", "borderColor"), { autocomplete: "text-stroke-$colors" }],
  [/^text-stroke-op(?:acity)?-?(.+)$/, ([, opacity]) => ({ "--un-text-stroke-opacity": utilities$2.h.bracket.percent.cssvar(opacity) }), { autocomplete: "text-stroke-(op|opacity)-<percent>" }]
];
const textShadows = [
  [/^text-shadow(?:-(.+))?$/, ([, s], { theme }) => {
    const v = theme.textShadow?.[s || "DEFAULT"];
    if (v != null) {
      return {
        "--un-text-shadow": utilities$2.colorableShadows(v, "--un-text-shadow-color").join(","),
        "text-shadow": "var(--un-text-shadow)"
      };
    }
    return { "text-shadow": utilities$2.h.bracket.cssvar.global(s) };
  }, { autocomplete: "text-shadow-$textShadow" }],
  // colors
  [/^text-shadow-color-(.+)$/, utilities$2.colorResolver("--un-text-shadow-color", "text-shadow", "shadowColor"), { autocomplete: "text-shadow-color-$colors" }],
  [/^text-shadow-color-op(?:acity)?-?(.+)$/, ([, opacity]) => ({ "--un-text-shadow-opacity": utilities$2.h.bracket.percent.cssvar(opacity) }), { autocomplete: "text-shadow-color-(op|opacity)-<percent>" }]
];
function handleThemeByKey(s, theme, key) {
  return theme[key]?.[s] || utilities$2.h.bracket.cssvar.global.rem(s);
}
function handleSize([, s], { theme }) {
  const themed = core$g.toArray(theme.fontSize?.[s]);
  const size = themed?.[0] ?? utilities$2.h.bracket.cssvar.global.rem(s);
  if (size != null)
    return { "font-size": size };
}
function handlerColorOrSize(match, ctx) {
  if (utilities$2.isCSSMathFn(utilities$2.h.bracket(match[1])))
    return handleSize(match, ctx);
  return utilities$2.colorResolver("color", "text", "textColor")(match, ctx);
}
function handleText([, s = "base"], { theme }) {
  const split = utilities$2.splitShorthand(s, "length");
  if (!split)
    return;
  const [size, leading] = split;
  const sizePairs = core$g.toArray(theme.fontSize?.[size]);
  const lineHeight = leading ? handleThemeByKey(leading, theme, "lineHeight") : void 0;
  if (sizePairs?.[0]) {
    const [fontSize2, height, letterSpacing] = sizePairs;
    if (typeof height === "object") {
      return {
        "font-size": fontSize2,
        ...height
      };
    }
    return {
      "font-size": fontSize2,
      "line-height": lineHeight ?? height ?? "1",
      "letter-spacing": letterSpacing ? handleThemeByKey(letterSpacing, theme, "letterSpacing") : void 0
    };
  }
  const fontSize = utilities$2.h.bracketOfLength.rem(size);
  if (lineHeight && fontSize) {
    return {
      "font-size": fontSize,
      "line-height": lineHeight
    };
  }
  return { "font-size": utilities$2.h.bracketOfLength.rem(s) };
}

const directions = {
  "": "",
  "x": "column-",
  "y": "row-",
  "col": "column-",
  "row": "row-"
};
function handleGap([, d = "", s], { theme }) {
  const v = theme.spacing?.[s] ?? utilities$2.h.bracket.cssvar.global.rem(s);
  if (v != null) {
    return {
      [`${directions[d]}gap`]: v
    };
  }
}
const gaps = [
  [/^(?:flex-|grid-)?gap-?()(.+)$/, handleGap, { autocomplete: ["gap-$spacing", "gap-<num>"] }],
  [/^(?:flex-|grid-)?gap-([xy])-?(.+)$/, handleGap, { autocomplete: ["gap-(x|y)-$spacing", "gap-(x|y)-<num>"] }],
  [/^(?:flex-|grid-)?gap-(col|row)-?(.+)$/, handleGap, { autocomplete: ["gap-(col|row)-$spacing", "gap-(col|row)-<num>"] }]
];

function rowCol(s) {
  return s.replace("col", "column");
}
function rowColTheme(s) {
  return s[0] === "r" ? "Row" : "Column";
}
function autoDirection(c, theme, prop) {
  const v = theme[`gridAuto${rowColTheme(c)}`]?.[prop];
  if (v != null)
    return v;
  switch (prop) {
    case "min":
      return "min-content";
    case "max":
      return "max-content";
    case "fr":
      return "minmax(0,1fr)";
  }
  return utilities$2.h.bracket.cssvar.auto.rem(prop);
}
const grids = [
  // displays
  ["grid", { display: "grid" }],
  ["inline-grid", { display: "inline-grid" }],
  // global
  [/^(?:grid-)?(row|col)-(.+)$/, ([, c, v], { theme }) => ({
    [`grid-${rowCol(c)}`]: theme[`grid${rowColTheme(c)}`]?.[v] ?? utilities$2.h.bracket.cssvar.auto(v)
  })],
  // span
  [/^(?:grid-)?(row|col)-span-(.+)$/, ([, c, s]) => {
    if (s === "full")
      return { [`grid-${rowCol(c)}`]: "1/-1" };
    const v = utilities$2.h.bracket.number(s);
    if (v != null)
      return { [`grid-${rowCol(c)}`]: `span ${v}/span ${v}` };
  }, { autocomplete: "(grid-row|grid-col|row|col)-span-<num>" }],
  // starts & ends
  [/^(?:grid-)?(row|col)-start-(.+)$/, ([, c, v]) => ({ [`grid-${rowCol(c)}-start`]: utilities$2.h.bracket.cssvar(v) ?? v })],
  [/^(?:grid-)?(row|col)-end-(.+)$/, ([, c, v]) => ({ [`grid-${rowCol(c)}-end`]: utilities$2.h.bracket.cssvar(v) ?? v }), { autocomplete: "(grid-row|grid-col|row|col)-(start|end)-<num>" }],
  // auto flows
  [/^(?:grid-)?auto-(rows|cols)-(.+)$/, ([, c, v], { theme }) => ({ [`grid-auto-${rowCol(c)}`]: autoDirection(c, theme, v) }), { autocomplete: "(grid-auto|auto)-(rows|cols)-<num>" }],
  // grid-auto-flow, auto-flow: uno
  // grid-flow: wind
  [/^(?:grid-auto-flow|auto-flow|grid-flow)-(.+)$/, ([, v]) => ({ "grid-auto-flow": utilities$2.h.bracket.cssvar(v) })],
  [/^(?:grid-auto-flow|auto-flow|grid-flow)-(row|col|dense|row-dense|col-dense)$/, ([, v]) => ({ "grid-auto-flow": rowCol(v).replace("-", " ") }), { autocomplete: ["(grid-auto-flow|auto-flow|grid-flow)-(row|col|dense|row-dense|col-dense)"] }],
  // templates
  [/^(?:grid-)?(rows|cols)-(.+)$/, ([, c, v], { theme }) => ({
    [`grid-template-${rowCol(c)}`]: theme[`gridTemplate${rowColTheme(c)}`]?.[v] ?? utilities$2.h.bracket.cssvar(v)
  })],
  [/^(?:grid-)?(rows|cols)-minmax-([\w.-]+)$/, ([, c, d]) => ({ [`grid-template-${rowCol(c)}`]: `repeat(auto-fill,minmax(${d},1fr))` })],
  [/^(?:grid-)?(rows|cols)-(\d+)$/, ([, c, d]) => ({ [`grid-template-${rowCol(c)}`]: `repeat(${d},minmax(0,1fr))` }), { autocomplete: "(grid-rows|grid-cols|rows|cols)-<num>" }],
  // areas
  [/^grid-area(s)?-(.+)$/, ([, s, v]) => {
    if (s != null)
      return { "grid-template-areas": utilities$2.h.cssvar(v) ?? v.split("-").map((s2) => `"${utilities$2.h.bracket(s2)}"`).join(" ") };
    return { "grid-area": utilities$2.h.bracket.cssvar(v) };
  }],
  // template none
  ["grid-rows-none", { "grid-template-rows": "none" }],
  ["grid-cols-none", { "grid-template-columns": "none" }],
  // template subgrid
  ["grid-rows-subgrid", { "grid-template-rows": "subgrid" }],
  ["grid-cols-subgrid", { "grid-template-columns": "subgrid" }]
];

const overflowValues = [
  "auto",
  "hidden",
  "clip",
  "visible",
  "scroll",
  "overlay",
  ...utilities$2.globalKeywords
];
const overflows = [
  [/^(?:overflow|of)-(.+)$/, ([, v]) => overflowValues.includes(v) ? { overflow: v } : void 0, { autocomplete: [`(overflow|of)-(${overflowValues.join("|")})`, `(overflow|of)-(x|y)-(${overflowValues.join("|")})`] }],
  [/^(?:overflow|of)-([xy])-(.+)$/, ([, d, v]) => overflowValues.includes(v) ? { [`overflow-${d}`]: v } : void 0]
];

const positions = [
  [/^(?:position-|pos-)?(relative|absolute|fixed|sticky)$/, ([, v]) => ({ position: v }), {
    autocomplete: [
      "(position|pos)-<position>",
      "(position|pos)-<globalKeyword>",
      "<position>"
    ]
  }],
  [/^(?:position-|pos-)([-\w]+)$/, ([, v]) => utilities$2.globalKeywords.includes(v) ? { position: v } : void 0],
  [/^(?:position-|pos-)?(static)$/, ([, v]) => ({ position: v })]
];
const justifies = [
  // contents
  ["justify-start", { "justify-content": "flex-start" }],
  ["justify-end", { "justify-content": "flex-end" }],
  ["justify-center", { "justify-content": "center" }],
  ["justify-between", { "justify-content": "space-between" }],
  ["justify-around", { "justify-content": "space-around" }],
  ["justify-evenly", { "justify-content": "space-evenly" }],
  ["justify-stretch", { "justify-content": "stretch" }],
  ["justify-left", { "justify-content": "left" }],
  ["justify-right", { "justify-content": "right" }],
  ...utilities$2.makeGlobalStaticRules("justify", "justify-content"),
  // items
  ["justify-items-start", { "justify-items": "start" }],
  ["justify-items-end", { "justify-items": "end" }],
  ["justify-items-center", { "justify-items": "center" }],
  ["justify-items-stretch", { "justify-items": "stretch" }],
  ...utilities$2.makeGlobalStaticRules("justify-items"),
  // selfs
  ["justify-self-auto", { "justify-self": "auto" }],
  ["justify-self-start", { "justify-self": "start" }],
  ["justify-self-end", { "justify-self": "end" }],
  ["justify-self-center", { "justify-self": "center" }],
  ["justify-self-stretch", { "justify-self": "stretch" }],
  ...utilities$2.makeGlobalStaticRules("justify-self")
];
const orders = [
  [/^order-(.+)$/, ([, v]) => ({ order: utilities$2.h.bracket.cssvar.number(v) })],
  ["order-first", { order: "-9999" }],
  ["order-last", { order: "9999" }],
  ["order-none", { order: "0" }]
];
const alignments = [
  // contents
  ["content-center", { "align-content": "center" }],
  ["content-start", { "align-content": "flex-start" }],
  ["content-end", { "align-content": "flex-end" }],
  ["content-between", { "align-content": "space-between" }],
  ["content-around", { "align-content": "space-around" }],
  ["content-evenly", { "align-content": "space-evenly" }],
  ...utilities$2.makeGlobalStaticRules("content", "align-content"),
  // items
  ["items-start", { "align-items": "flex-start" }],
  ["items-end", { "align-items": "flex-end" }],
  ["items-center", { "align-items": "center" }],
  ["items-baseline", { "align-items": "baseline" }],
  ["items-stretch", { "align-items": "stretch" }],
  ...utilities$2.makeGlobalStaticRules("items", "align-items"),
  // selfs
  ["self-auto", { "align-self": "auto" }],
  ["self-start", { "align-self": "flex-start" }],
  ["self-end", { "align-self": "flex-end" }],
  ["self-center", { "align-self": "center" }],
  ["self-stretch", { "align-self": "stretch" }],
  ["self-baseline", { "align-self": "baseline" }],
  ...utilities$2.makeGlobalStaticRules("self", "align-self")
];
const placements = [
  // contents
  ["place-content-center", { "place-content": "center" }],
  ["place-content-start", { "place-content": "start" }],
  ["place-content-end", { "place-content": "end" }],
  ["place-content-between", { "place-content": "space-between" }],
  ["place-content-around", { "place-content": "space-around" }],
  ["place-content-evenly", { "place-content": "space-evenly" }],
  ["place-content-stretch", { "place-content": "stretch" }],
  ...utilities$2.makeGlobalStaticRules("place-content"),
  // items
  ["place-items-start", { "place-items": "start" }],
  ["place-items-end", { "place-items": "end" }],
  ["place-items-center", { "place-items": "center" }],
  ["place-items-stretch", { "place-items": "stretch" }],
  ...utilities$2.makeGlobalStaticRules("place-items"),
  // selfs
  ["place-self-auto", { "place-self": "auto" }],
  ["place-self-start", { "place-self": "start" }],
  ["place-self-end", { "place-self": "end" }],
  ["place-self-center", { "place-self": "center" }],
  ["place-self-stretch", { "place-self": "stretch" }],
  ...utilities$2.makeGlobalStaticRules("place-self")
];
const flexGridJustifiesAlignments = [...justifies, ...alignments, ...placements].flatMap(([k, v]) => [
  [`flex-${k}`, v],
  [`grid-${k}`, v]
]);
function handleInsetValue(v, { theme }) {
  return theme.spacing?.[v] ?? utilities$2.h.bracket.cssvar.global.auto.fraction.rem(v);
}
function handleInsetValues([, d, v], ctx) {
  const r = handleInsetValue(v, ctx);
  if (r != null && d in utilities$2.insetMap)
    return utilities$2.insetMap[d].map((i) => [i.slice(1), r]);
}
const insets = [
  [
    /^(?:position-|pos-)?inset-(.+)$/,
    ([, v], ctx) => ({ inset: handleInsetValue(v, ctx) }),
    {
      autocomplete: [
        "(position|pos)-inset-<directions>-$spacing",
        "(position|pos)-inset-(block|inline)-$spacing",
        "(position|pos)-inset-(bs|be|is|ie)-$spacing",
        "(position|pos)-(top|left|right|bottom)-$spacing"
      ]
    }
  ],
  [/^(?:position-|pos-)?(start|end)-(.+)$/, handleInsetValues],
  [/^(?:position-|pos-)?inset-([xy])-(.+)$/, handleInsetValues],
  [/^(?:position-|pos-)?inset-([rltbse])-(.+)$/, handleInsetValues],
  [/^(?:position-|pos-)?inset-(block|inline)-(.+)$/, handleInsetValues],
  [/^(?:position-|pos-)?inset-([bi][se])-(.+)$/, handleInsetValues],
  [/^(?:position-|pos-)?(top|left|right|bottom)-(.+)$/, ([, d, v], ctx) => ({ [d]: handleInsetValue(v, ctx) })]
];
const floats = [
  // floats
  ["float-left", { float: "left" }],
  ["float-right", { float: "right" }],
  ["float-none", { float: "none" }],
  ...utilities$2.makeGlobalStaticRules("float"),
  // clears
  ["clear-left", { clear: "left" }],
  ["clear-right", { clear: "right" }],
  ["clear-both", { clear: "both" }],
  ["clear-none", { clear: "none" }],
  ...utilities$2.makeGlobalStaticRules("clear")
];
const zIndexes = [
  [/^(?:position-|pos-)?z([\d.]+)$/, ([, v]) => ({ "z-index": utilities$2.h.number(v) })],
  [/^(?:position-|pos-)?z-(.+)$/, ([, v], { theme }) => ({ "z-index": theme.zIndex?.[v] ?? utilities$2.h.bracket.cssvar.global.auto.number(v) }), { autocomplete: "z-<num>" }]
];
const boxSizing = [
  ["box-border", { "box-sizing": "border-box" }],
  ["box-content", { "box-sizing": "content-box" }],
  ...utilities$2.makeGlobalStaticRules("box", "box-sizing")
];

const sizeMapping = {
  h: "height",
  w: "width",
  inline: "inline-size",
  block: "block-size"
};
function getPropName(minmax, hw) {
  return `${minmax || ""}${sizeMapping[hw]}`;
}
function getSizeValue(minmax, hw, theme, prop) {
  const str = getPropName(minmax, hw).replace(/-(\w)/g, (_, p) => p.toUpperCase());
  const v = theme[str]?.[prop];
  if (v != null)
    return v;
  switch (prop) {
    case "fit":
    case "max":
    case "min":
      return `${prop}-content`;
  }
  return utilities$2.h.bracket.cssvar.global.auto.fraction.rem(prop);
}
const sizes = [
  [/^size-(min-|max-)?(.+)$/, ([, m, s], { theme }) => ({ [getPropName(m, "w")]: getSizeValue(m, "w", theme, s), [getPropName(m, "h")]: getSizeValue(m, "h", theme, s) })],
  [/^(?:size-)?(min-|max-)?([wh])-?(.+)$/, ([, m, w, s], { theme }) => ({ [getPropName(m, w)]: getSizeValue(m, w, theme, s) })],
  [/^(?:size-)?(min-|max-)?(block|inline)-(.+)$/, ([, m, w, s], { theme }) => ({ [getPropName(m, w)]: getSizeValue(m, w, theme, s) }), {
    autocomplete: [
      "(w|h)-$width|height|maxWidth|maxHeight|minWidth|minHeight|inlineSize|blockSize|maxInlineSize|maxBlockSize|minInlineSize|minBlockSize",
      "(block|inline)-$width|height|maxWidth|maxHeight|minWidth|minHeight|inlineSize|blockSize|maxInlineSize|maxBlockSize|minInlineSize|minBlockSize",
      "(max|min)-(w|h|block|inline)",
      "(max|min)-(w|h|block|inline)-$width|height|maxWidth|maxHeight|minWidth|minHeight|inlineSize|blockSize|maxInlineSize|maxBlockSize|minInlineSize|minBlockSize",
      "(w|h)-full",
      "(max|min)-(w|h)-full"
    ]
  }],
  [/^(?:size-)?(min-|max-)?(h)-screen-(.+)$/, ([, m, h2, p], context) => ({ [getPropName(m, h2)]: handleBreakpoint(context, p, "verticalBreakpoints") })],
  [/^(?:size-)?(min-|max-)?(w)-screen-(.+)$/, ([, m, w, p], context) => ({ [getPropName(m, w)]: handleBreakpoint(context, p) }), {
    autocomplete: [
      "(w|h)-screen",
      "(min|max)-(w|h)-screen",
      "h-screen-$verticalBreakpoints",
      "(min|max)-h-screen-$verticalBreakpoints",
      "w-screen-$breakpoints",
      "(min|max)-w-screen-$breakpoints"
    ]
  }]
];
function handleBreakpoint(context, point, key = "breakpoints") {
  const bp = utilities$2.resolveBreakpoints(context, key);
  if (bp)
    return bp.find((i) => i.point === point)?.size;
}
function getAspectRatio(prop) {
  if (/^\d+\/\d+$/.test(prop))
    return prop;
  switch (prop) {
    case "square":
      return "1/1";
    case "video":
      return "16/9";
  }
  return utilities$2.h.bracket.cssvar.global.auto.number(prop);
}
const aspectRatio = [
  [/^(?:size-)?aspect-(?:ratio-)?(.+)$/, ([, d]) => ({ "aspect-ratio": getAspectRatio(d) }), { autocomplete: ["aspect-(square|video|ratio)", "aspect-ratio-(square|video)"] }]
];

const paddings = [
  [/^pa?()-?(-?.+)$/, utilities$2.directionSize("padding"), { autocomplete: ["(m|p)<num>", "(m|p)-<num>"] }],
  [/^p-?xy()()$/, utilities$2.directionSize("padding"), { autocomplete: "(m|p)-(xy)" }],
  [/^p-?([xy])(?:-?(-?.+))?$/, utilities$2.directionSize("padding")],
  [/^p-?([rltbse])(?:-?(-?.+))?$/, utilities$2.directionSize("padding"), { autocomplete: "(m|p)<directions>-<num>" }],
  [/^p-(block|inline)(?:-(-?.+))?$/, utilities$2.directionSize("padding"), { autocomplete: "(m|p)-(block|inline)-<num>" }],
  [/^p-?([bi][se])(?:-?(-?.+))?$/, utilities$2.directionSize("padding"), { autocomplete: "(m|p)-(bs|be|is|ie)-<num>" }]
];
const margins = [
  [/^ma?()-?(-?.+)$/, utilities$2.directionSize("margin")],
  [/^m-?xy()()$/, utilities$2.directionSize("margin")],
  [/^m-?([xy])(?:-?(-?.+))?$/, utilities$2.directionSize("margin")],
  [/^m-?([rltbse])(?:-?(-?.+))?$/, utilities$2.directionSize("margin")],
  [/^m-(block|inline)(?:-(-?.+))?$/, utilities$2.directionSize("margin")],
  [/^m-?([bi][se])(?:-?(-?.+))?$/, utilities$2.directionSize("margin")]
];

const variablesAbbrMap$1 = {
  backface: "backface-visibility",
  break: "word-break",
  case: "text-transform",
  content: "align-content",
  fw: "font-weight",
  items: "align-items",
  justify: "justify-content",
  select: "user-select",
  self: "align-self",
  vertical: "vertical-align",
  visible: "visibility",
  whitespace: "white-space",
  ws: "white-space"
};
const cssVariables$1 = [
  [/^(.+?)-(\$.+)$/, ([, name, varname]) => {
    const prop = variablesAbbrMap$1[name];
    if (prop)
      return { [prop]: utilities$2.h.cssvar(varname) };
  }]
];
const cssProperty = [
  [/^\[(.*)\]$/, ([_, body]) => {
    if (!body.includes(":"))
      return;
    const [prop, ...rest] = body.split(":");
    const value = rest.join(":");
    if (!isURI(body) && /^[a-z-]+$/.test(prop) && isValidCSSBody(value)) {
      const parsed = utilities$2.h.bracket(`[${value}]`);
      if (parsed)
        return { [prop]: parsed };
    }
  }]
];
function isValidCSSBody(body) {
  let i = 0;
  function findUntil(c) {
    while (i < body.length) {
      i += 1;
      const char = body[i];
      if (char === c)
        return true;
    }
    return false;
  }
  for (i = 0; i < body.length; i++) {
    const c = body[i];
    if ("\"`'".includes(c)) {
      if (!findUntil(c))
        return false;
    } else if (c === "(") {
      if (!findUntil(")"))
        return false;
    } else if ("[]{}:".includes(c)) {
      return false;
    }
  }
  return true;
}
function isURI(declaration) {
  if (!declaration.includes("://"))
    return false;
  try {
    return new URL(declaration).host !== "";
  } catch (err) {
    return false;
  }
}

const questionMark = [
  [
    /^(where|\?)$/,
    (_, { constructCSS, generator }) => {
      if (generator.userConfig.envMode === "dev")
        return `@keyframes __un_qm{0%{box-shadow:inset 4px 4px #ff1e90, inset -4px -4px #ff1e90}100%{box-shadow:inset 8px 8px #3399ff, inset -8px -8px #3399ff}}
${constructCSS({ animation: "__un_qm 0.5s ease-in-out alternate infinite" })}`;
    }
  ]
];

const svgUtilities = [
  // fills
  [/^fill-(.+)$/, utilities$2.colorResolver("fill", "fill", "backgroundColor"), { autocomplete: "fill-$colors" }],
  [/^fill-op(?:acity)?-?(.+)$/, ([, opacity]) => ({ "--un-fill-opacity": utilities$2.h.bracket.percent.cssvar(opacity) }), { autocomplete: "fill-(op|opacity)-<percent>" }],
  ["fill-none", { fill: "none" }],
  // stroke size
  [/^stroke-(?:width-|size-)?(.+)$/, handleWidth, { autocomplete: ["stroke-width-$lineWidth", "stroke-size-$lineWidth"] }],
  // stroke dash
  [/^stroke-dash-(.+)$/, ([, s]) => ({ "stroke-dasharray": utilities$2.h.bracket.cssvar.number(s) }), { autocomplete: "stroke-dash-<num>" }],
  [/^stroke-offset-(.+)$/, ([, s], { theme }) => ({ "stroke-dashoffset": theme.lineWidth?.[s] ?? utilities$2.h.bracket.cssvar.px.numberWithUnit(s) }), { autocomplete: "stroke-offset-$lineWidth" }],
  // stroke colors
  [/^stroke-(.+)$/, handleColorOrWidth, { autocomplete: "stroke-$colors" }],
  [/^stroke-op(?:acity)?-?(.+)$/, ([, opacity]) => ({ "--un-stroke-opacity": utilities$2.h.bracket.percent.cssvar(opacity) }), { autocomplete: "stroke-(op|opacity)-<percent>" }],
  // line cap
  ["stroke-cap-square", { "stroke-linecap": "square" }],
  ["stroke-cap-round", { "stroke-linecap": "round" }],
  ["stroke-cap-auto", { "stroke-linecap": "butt" }],
  // line join
  ["stroke-join-arcs", { "stroke-linejoin": "arcs" }],
  ["stroke-join-bevel", { "stroke-linejoin": "bevel" }],
  ["stroke-join-clip", { "stroke-linejoin": "miter-clip" }],
  ["stroke-join-round", { "stroke-linejoin": "round" }],
  ["stroke-join-auto", { "stroke-linejoin": "miter" }],
  // none
  ["stroke-none", { stroke: "none" }]
];
function handleWidth([, b], { theme }) {
  return { "stroke-width": theme.lineWidth?.[b] ?? utilities$2.h.bracket.cssvar.fraction.px.number(b) };
}
function handleColorOrWidth(match, ctx) {
  if (utilities$2.isCSSMathFn(utilities$2.h.bracket(match[1])))
    return handleWidth(match, ctx);
  return utilities$2.colorResolver("stroke", "stroke", "borderColor")(match, ctx);
}

const rules$2 = [
  cssVariables$1,
  cssProperty,
  paddings,
  margins,
  transform$2.displays,
  opacity$1,
  bgColors,
  colorScheme,
  svgUtilities,
  borders,
  transform$2.contentVisibility,
  transform$2.contents,
  fonts,
  tabSizes,
  textIndents,
  transform$2.textOverflows,
  textDecorations,
  textStrokes,
  textShadows,
  transform$2.textTransforms,
  textAligns,
  transform$2.fontStyles,
  transform$2.fontSmoothings,
  transform$2.boxShadows,
  transform$2.rings,
  flex$2,
  grids,
  gaps,
  positions,
  sizes,
  aspectRatio,
  transform$2.cursors,
  transform$2.appearances,
  transform$2.pointerEvents,
  transform$2.resizes,
  verticalAligns,
  transform$2.userSelects,
  transform$2.whitespaces,
  transform$2.breaks,
  overflows,
  outline$1,
  appearance$1,
  orders,
  justifies,
  alignments,
  placements,
  flexGridJustifiesAlignments,
  insets,
  floats,
  zIndexes,
  boxSizing,
  transitions,
  transform$2.transforms,
  willChange,
  containerParent,
  transform$2.contains,
  transform$2.textWraps,
  // should be the last
  questionMark
].flat(1);

presetMini_D_Gfuejm.alignments = alignments;
presetMini_D_Gfuejm.appearance = appearance$1;
presetMini_D_Gfuejm.aspectRatio = aspectRatio;
presetMini_D_Gfuejm.bgColors = bgColors;
presetMini_D_Gfuejm.borderStyles = borderStyles;
presetMini_D_Gfuejm.borders = borders;
presetMini_D_Gfuejm.boxSizing = boxSizing;
presetMini_D_Gfuejm.colorScheme = colorScheme;
presetMini_D_Gfuejm.containerParent = containerParent;
presetMini_D_Gfuejm.cssProperty = cssProperty;
presetMini_D_Gfuejm.cssVariables = cssVariables$1;
presetMini_D_Gfuejm.flex = flex$2;
presetMini_D_Gfuejm.flexGridJustifiesAlignments = flexGridJustifiesAlignments;
presetMini_D_Gfuejm.floats = floats;
presetMini_D_Gfuejm.fonts = fonts;
presetMini_D_Gfuejm.gaps = gaps;
presetMini_D_Gfuejm.grids = grids;
presetMini_D_Gfuejm.handlerBorderStyle = handlerBorderStyle;
presetMini_D_Gfuejm.insets = insets;
presetMini_D_Gfuejm.justifies = justifies;
presetMini_D_Gfuejm.margins = margins;
presetMini_D_Gfuejm.opacity = opacity$1;
presetMini_D_Gfuejm.orders = orders;
presetMini_D_Gfuejm.outline = outline$1;
presetMini_D_Gfuejm.overflows = overflows;
presetMini_D_Gfuejm.paddings = paddings;
presetMini_D_Gfuejm.placements = placements;
presetMini_D_Gfuejm.positions = positions;
presetMini_D_Gfuejm.questionMark = questionMark;
presetMini_D_Gfuejm.rules = rules$2;
presetMini_D_Gfuejm.sizes = sizes;
presetMini_D_Gfuejm.svgUtilities = svgUtilities;
presetMini_D_Gfuejm.tabSizes = tabSizes;
presetMini_D_Gfuejm.textAligns = textAligns;
presetMini_D_Gfuejm.textDecorations = textDecorations;
presetMini_D_Gfuejm.textIndents = textIndents;
presetMini_D_Gfuejm.textShadows = textShadows;
presetMini_D_Gfuejm.textStrokes = textStrokes;
presetMini_D_Gfuejm.transitions = transitions;
presetMini_D_Gfuejm.verticalAligns = verticalAligns;
presetMini_D_Gfuejm.willChange = willChange;
presetMini_D_Gfuejm.zIndexes = zIndexes;

var presetMini_YtS7XCIs = {};

const utilities$1 = presetMini_DahJgnb1;
const ruleUtils$3 = dist$k;
const core$f = dist$p;

const variantAria = {
  name: "aria",
  match(matcher, ctx) {
    const variant = ruleUtils$3.variantGetParameter("aria-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const aria = utilities$1.h.bracket(match) ?? ctx.theme.aria?.[match] ?? "";
      if (aria) {
        return {
          matcher: rest,
          selector: (s) => `${s}[aria-${aria}]`
        };
      }
    }
  }
};

function calcMaxWidthBySize$1(size) {
  const value = size.match(/^-?[0-9]+\.?[0-9]*/)?.[0] || "";
  const unit = size.slice(value.length);
  if (unit === "px") {
    const maxWidth = Number.parseFloat(value) - 0.1;
    return Number.isNaN(maxWidth) ? size : `${maxWidth}${unit}`;
  }
  return `calc(${size} - 0.1px)`;
}
function variantBreakpoints() {
  const regexCache = {};
  return {
    name: "breakpoints",
    match(matcher, context) {
      const variantEntries = (utilities$1.resolveBreakpoints(context) ?? []).map(({ point, size }, idx) => [point, size, idx]);
      for (const [point, size, idx] of variantEntries) {
        if (!regexCache[point])
          regexCache[point] = new RegExp(`^((?:([al]t-|[<~]|max-))?${point}(?:${context.generator.config.separators.join("|")}))`);
        const match = matcher.match(regexCache[point]);
        if (!match)
          continue;
        const [, pre] = match;
        const m = matcher.slice(pre.length);
        if (m === "container")
          continue;
        const isLtPrefix = pre.startsWith("lt-") || pre.startsWith("<") || pre.startsWith("max-");
        const isAtPrefix = pre.startsWith("at-") || pre.startsWith("~");
        let order = 3e3;
        if (isLtPrefix) {
          order -= idx + 1;
          return {
            matcher: m,
            handle: (input, next) => next({
              ...input,
              parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (max-width: ${calcMaxWidthBySize$1(size)})`,
              parentOrder: order
            })
          };
        }
        order += idx + 1;
        if (isAtPrefix && idx < variantEntries.length - 1) {
          return {
            matcher: m,
            handle: (input, next) => next({
              ...input,
              parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (min-width: ${size}) and (max-width: ${calcMaxWidthBySize$1(variantEntries[idx + 1][1])})`,
              parentOrder: order
            })
          };
        }
        return {
          matcher: m,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (min-width: ${size})`,
            parentOrder: order
          })
        };
      }
    },
    multiPass: true,
    autocomplete: "(at-|lt-|max-|)$breakpoints:"
  };
}

function scopeMatcher(name, combinator) {
  return {
    name: `combinator:${name}`,
    match(matcher, ctx) {
      if (!matcher.startsWith(name))
        return;
      const separators = ctx.generator.config.separators;
      let body = ruleUtils$3.variantGetBracket(`${name}-`, matcher, separators);
      if (!body) {
        for (const separator of separators) {
          if (matcher.startsWith(`${name}${separator}`)) {
            body = ["", matcher.slice(name.length + separator.length)];
            break;
          }
        }
        if (!body)
          return;
      }
      let bracketValue = utilities$1.h.bracket(body[0]) ?? "";
      if (bracketValue === "")
        bracketValue = "*";
      return {
        matcher: body[1],
        selector: (s) => `${s}${combinator}${bracketValue}`
      };
    },
    multiPass: true
  };
}
const variantCombinators$1 = [
  scopeMatcher("all", " "),
  scopeMatcher("children", ">"),
  scopeMatcher("next", "+"),
  scopeMatcher("sibling", "+"),
  scopeMatcher("siblings", "~")
];

const variantContainerQuery = {
  name: "@",
  match(matcher, ctx) {
    if (matcher.startsWith("@container"))
      return;
    const variant = ruleUtils$3.variantGetParameter("@", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest, label] = variant;
      const unbracket = utilities$1.h.bracket(match);
      let container;
      if (unbracket) {
        const minWidth = utilities$1.h.numberWithUnit(unbracket);
        if (minWidth)
          container = `(min-width: ${minWidth})`;
      } else {
        container = ctx.theme.containers?.[match] ?? "";
      }
      if (container) {
        core$f.warnOnce("The container query variant is experimental and may not follow semver.");
        let order = 1e3 + Object.keys(ctx.theme.containers ?? {}).indexOf(match);
        if (label)
          order += 1e3;
        return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@container${label ? ` ${label} ` : " "}${container}`,
            parentOrder: order
          })
        };
      }
    }
  },
  multiPass: true
};

function variantColorsMediaOrClass(options = {}) {
  if (options?.dark === "class" || typeof options.dark === "object") {
    const { dark = ".dark", light = ".light" } = typeof options.dark === "string" ? {} : options.dark;
    return [
      ruleUtils$3.variantMatcher("dark", (input) => ({ prefix: `${dark} $$ ${input.prefix}` })),
      ruleUtils$3.variantMatcher("light", (input) => ({ prefix: `${light} $$ ${input.prefix}` }))
    ];
  }
  return [
    ruleUtils$3.variantParentMatcher("dark", "@media (prefers-color-scheme: dark)"),
    ruleUtils$3.variantParentMatcher("light", "@media (prefers-color-scheme: light)")
  ];
}

const variantDataAttribute = {
  name: "data",
  match(matcher, ctx) {
    const variant = ruleUtils$3.variantGetParameter("data-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const dataAttribute = utilities$1.h.bracket(match) ?? ctx.theme.data?.[match] ?? "";
      if (dataAttribute) {
        return {
          matcher: rest,
          selector: (s) => `${s}[data-${dataAttribute}]`
        };
      }
    }
  }
};
function taggedData(tagName) {
  return {
    name: `${tagName}-data`,
    match(matcher, ctx) {
      const variant = ruleUtils$3.variantGetParameter(`${tagName}-data-`, matcher, ctx.generator.config.separators);
      if (variant) {
        const [match, rest] = variant;
        const dataAttribute = utilities$1.h.bracket(match) ?? ctx.theme.data?.[match] ?? "";
        if (dataAttribute) {
          return {
            matcher: `${tagName}-[[data-${dataAttribute}]]:${rest}`
          };
        }
      }
    }
  };
}
const variantTaggedDataAttributes = [
  taggedData("group"),
  taggedData("peer"),
  taggedData("parent"),
  taggedData("previous")
];

const variantLanguageDirections = [
  ruleUtils$3.variantMatcher("rtl", (input) => ({ prefix: `[dir="rtl"] $$ ${input.prefix}` })),
  ruleUtils$3.variantMatcher("ltr", (input) => ({ prefix: `[dir="ltr"] $$ ${input.prefix}` }))
];

const variantSelector = {
  name: "selector",
  match(matcher, ctx) {
    const variant = ruleUtils$3.variantGetBracket("selector-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const selector = utilities$1.h.bracket(match);
      if (selector) {
        return {
          matcher: rest,
          selector: () => selector
        };
      }
    }
  }
};
const variantCssLayer = {
  name: "layer",
  match(matcher, ctx) {
    const variant = ruleUtils$3.variantGetParameter("layer-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const layer = utilities$1.h.bracket(match) ?? match;
      if (layer) {
        return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@layer ${layer}`
          })
        };
      }
    }
  }
};
const variantInternalLayer = {
  name: "uno-layer",
  match(matcher, ctx) {
    const variant = ruleUtils$3.variantGetParameter("uno-layer-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const layer = utilities$1.h.bracket(match) ?? match;
      if (layer) {
        return {
          matcher: rest,
          layer
        };
      }
    }
  }
};
const variantScope = {
  name: "scope",
  match(matcher, ctx) {
    const variant = ruleUtils$3.variantGetBracket("scope-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      const scope = utilities$1.h.bracket(match);
      if (scope) {
        return {
          matcher: rest,
          selector: (s) => `${scope} $$ ${s}`
        };
      }
    }
  }
};
const variantVariables = {
  name: "variables",
  match(matcher, ctx) {
    if (!matcher.startsWith("["))
      return;
    const [match, rest] = ruleUtils$3.getBracket(matcher, "[", "]") ?? [];
    if (!(match && rest))
      return;
    let newMatcher;
    for (const separator of ctx.generator.config.separators) {
      if (rest.startsWith(separator)) {
        newMatcher = rest.slice(separator.length);
        break;
      }
    }
    if (newMatcher == null)
      return;
    const variant = utilities$1.h.bracket(match) ?? "";
    const useParent = variant.startsWith("@");
    if (!(useParent || variant.includes("&")))
      return;
    return {
      matcher: newMatcher,
      handle(input, next) {
        const updates = useParent ? {
          parent: `${input.parent ? `${input.parent} $$ ` : ""}${variant}`
        } : {
          selector: variant.replace(/&/g, input.selector)
        };
        return next({
          ...input,
          ...updates
        });
      }
    };
  },
  multiPass: true
};
const variantTheme = {
  name: "theme-variables",
  match(matcher, ctx) {
    if (!ruleUtils$3.hasThemeFn(matcher))
      return;
    return {
      matcher,
      handle(input, next) {
        return next({
          ...input,
          //  entries: [ [ '--css-spacing', '28px' ] ],
          entries: JSON.parse(ruleUtils$3.transformThemeFn(JSON.stringify(input.entries), ctx.theme))
        });
      }
    };
  }
};

const anchoredNumberRE = /^-?[0-9.]+(?:[a-z]+|%)?$/;
const numberRE = /-?[0-9.]+(?:[a-z]+|%)?/;
const ignoreProps = [
  /\b(opacity|color|flex|backdrop-filter|^filter|transform)\b/
];
function negateMathFunction(value) {
  const match = value.match(utilities$1.cssMathFnRE);
  if (match) {
    const [fnBody, rest] = ruleUtils$3.getStringComponent(`(${match[2]})${match[3]}`, "(", ")", " ") ?? [];
    if (fnBody)
      return `calc(${match[1]}${fnBody} * -1)${rest ? ` ${rest}` : ""}`;
  }
}
const negateFunctionBodyRE = /\b(hue-rotate)\s*(\(.*)/;
function negateFunctionBody(value) {
  const match = value.match(negateFunctionBodyRE);
  if (match) {
    const [fnBody, rest] = ruleUtils$3.getStringComponent(match[2], "(", ")", " ") ?? [];
    if (fnBody) {
      const body = anchoredNumberRE.test(fnBody.slice(1, -1)) ? fnBody.replace(numberRE, (i) => i.startsWith("-") ? i.slice(1) : `-${i}`) : `(calc(${fnBody} * -1))`;
      return `${match[1]}${body}${rest ? ` ${rest}` : ""}`;
    }
  }
}
const variantNegative = {
  name: "negative",
  match(matcher) {
    if (!matcher.startsWith("-"))
      return;
    return {
      matcher: matcher.slice(1),
      body: (body) => {
        if (body.find((v) => v[0] === utilities$1.CONTROL_MINI_NO_NEGATIVE))
          return;
        let changed = false;
        body.forEach((v) => {
          const value = v[1]?.toString();
          if (!value || value === "0")
            return;
          if (ignoreProps.some((i) => i.test(v[0])))
            return;
          const negatedFn = negateMathFunction(value);
          if (negatedFn) {
            v[1] = negatedFn;
            changed = true;
            return;
          }
          const negatedBody = negateFunctionBody(value);
          if (negatedBody) {
            v[1] = negatedBody;
            changed = true;
            return;
          }
          if (anchoredNumberRE.test(value)) {
            v[1] = value.replace(numberRE, (i) => i.startsWith("-") ? i.slice(1) : `-${i}`);
            changed = true;
          }
        });
        if (changed)
          return body;
        return [];
      }
    };
  }
};

function variantImportant() {
  let re;
  return {
    name: "important",
    match(matcher, ctx) {
      if (!re)
        re = new RegExp(`^(important(?:${ctx.generator.config.separators.join("|")})|!)`);
      let base;
      const match = matcher.match(re);
      if (match)
        base = matcher.slice(match[0].length);
      else if (matcher.endsWith("!"))
        base = matcher.slice(0, -1);
      if (base) {
        return {
          matcher: base,
          body: (body) => {
            body.forEach((v) => {
              if (v[1])
                v[1] += " !important";
            });
            return body;
          }
        };
      }
    }
  };
}

const variantPrint = ruleUtils$3.variantParentMatcher("print", "@media print");
const variantCustomMedia = {
  name: "media",
  match(matcher, ctx) {
    const variant = ruleUtils$3.variantGetParameter("media-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      let media = utilities$1.h.bracket(match) ?? "";
      if (media === "")
        media = ctx.theme.media?.[match] ?? "";
      if (media) {
        return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@media ${media}`
          })
        };
      }
    }
  },
  multiPass: true
};

const variantSupports = {
  name: "supports",
  match(matcher, ctx) {
    const variant = ruleUtils$3.variantGetParameter("supports-", matcher, ctx.generator.config.separators);
    if (variant) {
      const [match, rest] = variant;
      let supports = utilities$1.h.bracket(match) ?? "";
      if (supports === "")
        supports = ctx.theme.supports?.[match] ?? "";
      if (supports) {
        return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@supports ${supports}`
          })
        };
      }
    }
  },
  multiPass: true
};

const PseudoClasses = Object.fromEntries([
  // pseudo elements part 1
  ["first-letter", "::first-letter"],
  ["first-line", "::first-line"],
  // location
  "any-link",
  "link",
  "visited",
  "target",
  ["open", "[open]"],
  // forms
  "default",
  "checked",
  "indeterminate",
  "placeholder-shown",
  "autofill",
  "optional",
  "required",
  "valid",
  "invalid",
  "user-valid",
  "user-invalid",
  "in-range",
  "out-of-range",
  "read-only",
  "read-write",
  // content
  "empty",
  // interactions
  "focus-within",
  "hover",
  "focus",
  "focus-visible",
  "active",
  "enabled",
  "disabled",
  "popover-open",
  // tree-structural
  "root",
  "empty",
  ["even-of-type", ":nth-of-type(even)"],
  ["even", ":nth-child(even)"],
  ["odd-of-type", ":nth-of-type(odd)"],
  ["odd", ":nth-child(odd)"],
  "first-of-type",
  ["first", ":first-child"],
  "last-of-type",
  ["last", ":last-child"],
  "only-child",
  "only-of-type",
  // pseudo elements part 2
  ["backdrop-element", "::backdrop"],
  ["placeholder", "::placeholder"],
  ["before", "::before"],
  ["after", "::after"],
  ["selection", "::selection"],
  ["marker", "::marker"],
  ["file", "::file-selector-button"]
].map((key) => Array.isArray(key) ? key : [key, `:${key}`]));
const PseudoClassesKeys = Object.keys(PseudoClasses);
const PseudoClassesColon = Object.fromEntries([
  ["backdrop", "::backdrop"]
].map((key) => Array.isArray(key) ? key : [key, `:${key}`]));
const PseudoClassesColonKeys = Object.keys(PseudoClassesColon);
const PseudoClassFunctions = [
  "not",
  "is",
  "where",
  "has"
];
const PseudoClassesStr = Object.entries(PseudoClasses).filter(([, pseudo]) => !pseudo.startsWith("::")).map(([key]) => key).sort((a, b) => b.length - a.length).join("|");
const PseudoClassesColonStr = Object.entries(PseudoClassesColon).filter(([, pseudo]) => !pseudo.startsWith("::")).map(([key]) => key).sort((a, b) => b.length - a.length).join("|");
const PseudoClassFunctionsStr = PseudoClassFunctions.join("|");
function taggedPseudoClassMatcher(tag, parent, combinator) {
  const rawRE = new RegExp(`^(${core$f.escapeRegExp(parent)}:)(\\S+)${core$f.escapeRegExp(combinator)}\\1`);
  let splitRE;
  let pseudoRE;
  let pseudoColonRE;
  let pseudoVarRE;
  const matchBracket = (input) => {
    const body = ruleUtils$3.variantGetBracket(`${tag}-`, input, []);
    if (!body)
      return;
    const [match, rest] = body;
    const bracketValue = utilities$1.h.bracket(match);
    if (bracketValue == null)
      return;
    const label = rest.split(splitRE, 1)?.[0] ?? "";
    const prefix = `${parent}${core$f.escapeSelector(label)}`;
    return [
      label,
      input.slice(input.length - (rest.length - label.length - 1)),
      bracketValue.includes("&") ? bracketValue.replace(/&/g, prefix) : `${prefix}${bracketValue}`
    ];
  };
  const matchPseudo = (input) => {
    const match = input.match(pseudoRE) || input.match(pseudoColonRE);
    if (!match)
      return;
    const [original, fn, pseudoKey] = match;
    const label = match[3] ?? "";
    let pseudo = PseudoClasses[pseudoKey] || PseudoClassesColon[pseudoKey] || `:${pseudoKey}`;
    if (fn)
      pseudo = `:${fn}(${pseudo})`;
    return [
      label,
      input.slice(original.length),
      `${parent}${core$f.escapeSelector(label)}${pseudo}`,
      pseudoKey
    ];
  };
  const matchPseudoVar = (input) => {
    const match = input.match(pseudoVarRE);
    if (!match)
      return;
    const [original, fn, pseudoValue] = match;
    const label = match[3] ?? "";
    const pseudo = `:${fn}(${pseudoValue})`;
    return [
      label,
      input.slice(original.length),
      `${parent}${core$f.escapeSelector(label)}${pseudo}`
    ];
  };
  return {
    name: `pseudo:${tag}`,
    match(input, ctx) {
      if (!(splitRE && pseudoRE && pseudoColonRE)) {
        splitRE = new RegExp(`(?:${ctx.generator.config.separators.join("|")})`);
        pseudoRE = new RegExp(`^${tag}-(?:(?:(${PseudoClassFunctionsStr})-)?(${PseudoClassesStr}))(?:(/\\w+))?(?:${ctx.generator.config.separators.join("|")})`);
        pseudoColonRE = new RegExp(`^${tag}-(?:(?:(${PseudoClassFunctionsStr})-)?(${PseudoClassesColonStr}))(?:(/\\w+))?(?:${ctx.generator.config.separators.filter((x) => x !== "-").join("|")})`);
        pseudoVarRE = new RegExp(`^${tag}-(?:(${PseudoClassFunctionsStr})-)?\\[(.+)\\](?:(/\\w+))?(?:${ctx.generator.config.separators.filter((x) => x !== "-").join("|")})`);
      }
      if (!input.startsWith(tag))
        return;
      const result = matchBracket(input) || matchPseudo(input) || matchPseudoVar(input);
      if (!result)
        return;
      const [label, matcher, prefix, pseudoName = ""] = result;
      if (label !== "")
        core$f.warnOnce("The labeled variant is experimental and may not follow semver.");
      return {
        matcher,
        handle: (input2, next) => next({
          ...input2,
          prefix: `${prefix}${combinator}${input2.prefix}`.replace(rawRE, "$1$2:"),
          sort: PseudoClassesKeys.indexOf(pseudoName) ?? PseudoClassesColonKeys.indexOf(pseudoName)
        })
      };
    },
    multiPass: true
  };
}
const excludedPseudo = [
  "::-webkit-resizer",
  "::-webkit-scrollbar",
  "::-webkit-scrollbar-button",
  "::-webkit-scrollbar-corner",
  "::-webkit-scrollbar-thumb",
  "::-webkit-scrollbar-track",
  "::-webkit-scrollbar-track-piece",
  "::file-selector-button"
];
const PseudoClassesAndElementsStr = Object.entries(PseudoClasses).map(([key]) => key).sort((a, b) => b.length - a.length).join("|");
const PseudoClassesAndElementsColonStr = Object.entries(PseudoClassesColon).map(([key]) => key).sort((a, b) => b.length - a.length).join("|");
function variantPseudoClassesAndElements() {
  let PseudoClassesAndElementsRE;
  let PseudoClassesAndElementsColonRE;
  return {
    name: "pseudo",
    match(input, ctx) {
      if (!(PseudoClassesAndElementsRE && PseudoClassesAndElementsRE)) {
        PseudoClassesAndElementsRE = new RegExp(`^(${PseudoClassesAndElementsStr})(?:${ctx.generator.config.separators.join("|")})`);
        PseudoClassesAndElementsColonRE = new RegExp(`^(${PseudoClassesAndElementsColonStr})(?:${ctx.generator.config.separators.filter((x) => x !== "-").join("|")})`);
      }
      const match = input.match(PseudoClassesAndElementsRE) || input.match(PseudoClassesAndElementsColonRE);
      if (match) {
        const pseudo = PseudoClasses[match[1]] || PseudoClassesColon[match[1]] || `:${match[1]}`;
        let index = PseudoClassesKeys.indexOf(match[1]);
        if (index === -1)
          index = PseudoClassesColonKeys.indexOf(match[1]);
        if (index === -1)
          index = void 0;
        return {
          matcher: input.slice(match[0].length),
          handle: (input2, next) => {
            const selectors = pseudo.startsWith("::") && !excludedPseudo.includes(pseudo) ? {
              pseudo: `${input2.pseudo}${pseudo}`
            } : {
              selector: `${input2.selector}${pseudo}`
            };
            return next({
              ...input2,
              ...selectors,
              sort: index,
              noMerge: true
            });
          }
        };
      }
    },
    multiPass: true,
    autocomplete: `(${PseudoClassesAndElementsStr}|${PseudoClassesAndElementsColonStr}):`
  };
}
function variantPseudoClassFunctions() {
  let PseudoClassFunctionsRE;
  let PseudoClassColonFunctionsRE;
  let PseudoClassVarFunctionRE;
  return {
    match(input, ctx) {
      if (!(PseudoClassFunctionsRE && PseudoClassColonFunctionsRE)) {
        PseudoClassFunctionsRE = new RegExp(`^(${PseudoClassFunctionsStr})-(${PseudoClassesStr})(?:${ctx.generator.config.separators.join("|")})`);
        PseudoClassColonFunctionsRE = new RegExp(`^(${PseudoClassFunctionsStr})-(${PseudoClassesColonStr})(?:${ctx.generator.config.separators.filter((x) => x !== "-").join("|")})`);
        PseudoClassVarFunctionRE = new RegExp(`^(${PseudoClassFunctionsStr})-(\\[.+\\])(?:${ctx.generator.config.separators.filter((x) => x !== "-").join("|")})`);
      }
      const match = input.match(PseudoClassFunctionsRE) || input.match(PseudoClassColonFunctionsRE) || input.match(PseudoClassVarFunctionRE);
      if (match) {
        const fn = match[1];
        const fnVal = ruleUtils$3.getBracket(match[2], "[", "]");
        const pseudo = fnVal ? utilities$1.h.bracket(match[2]) : PseudoClasses[match[2]] || PseudoClassesColon[match[2]] || `:${match[2]}`;
        return {
          matcher: input.slice(match[0].length),
          selector: (s) => `${s}:${fn}(${pseudo})`
        };
      }
    },
    multiPass: true,
    autocomplete: `(${PseudoClassFunctionsStr})-(${PseudoClassesStr}|${PseudoClassesColonStr}):`
  };
}
function variantTaggedPseudoClasses(options = {}) {
  const attributify = !!options?.attributifyPseudo;
  let firstPrefix = options?.prefix ?? "";
  firstPrefix = (Array.isArray(firstPrefix) ? firstPrefix : [firstPrefix]).filter(Boolean)[0] ?? "";
  const tagWithPrefix = (tag, combinator) => taggedPseudoClassMatcher(tag, attributify ? `[${firstPrefix}${tag}=""]` : `.${firstPrefix}${tag}`, combinator);
  return [
    tagWithPrefix("group", " "),
    tagWithPrefix("peer", "~"),
    tagWithPrefix("parent", ">"),
    tagWithPrefix("previous", "+")
  ];
}
const PartClassesRE = /(part-\[(.+)]:)(.+)/;
const variantPartClasses = {
  match(input) {
    const match = input.match(PartClassesRE);
    if (match) {
      const part = `part(${match[2]})`;
      return {
        matcher: input.slice(match[1].length),
        selector: (s) => `${s}::${part}`
      };
    }
  },
  multiPass: true
};

function variants$3(options) {
  return [
    variantAria,
    variantDataAttribute,
    variantCssLayer,
    variantSelector,
    variantInternalLayer,
    variantNegative,
    variantImportant(),
    variantSupports,
    variantPrint,
    variantCustomMedia,
    variantBreakpoints(),
    ...variantCombinators$1,
    variantPseudoClassesAndElements(),
    variantPseudoClassFunctions(),
    ...variantTaggedPseudoClasses(options),
    variantPartClasses,
    ...variantColorsMediaOrClass(options),
    ...variantLanguageDirections,
    variantScope,
    variantContainerQuery,
    variantVariables,
    ...variantTaggedDataAttributes,
    variantTheme
  ];
}

presetMini_YtS7XCIs.calcMaxWidthBySize = calcMaxWidthBySize$1;
presetMini_YtS7XCIs.variantAria = variantAria;
presetMini_YtS7XCIs.variantBreakpoints = variantBreakpoints;
presetMini_YtS7XCIs.variantColorsMediaOrClass = variantColorsMediaOrClass;
presetMini_YtS7XCIs.variantCombinators = variantCombinators$1;
presetMini_YtS7XCIs.variantContainerQuery = variantContainerQuery;
presetMini_YtS7XCIs.variantCssLayer = variantCssLayer;
presetMini_YtS7XCIs.variantCustomMedia = variantCustomMedia;
presetMini_YtS7XCIs.variantDataAttribute = variantDataAttribute;
presetMini_YtS7XCIs.variantImportant = variantImportant;
presetMini_YtS7XCIs.variantInternalLayer = variantInternalLayer;
presetMini_YtS7XCIs.variantLanguageDirections = variantLanguageDirections;
presetMini_YtS7XCIs.variantNegative = variantNegative;
presetMini_YtS7XCIs.variantPartClasses = variantPartClasses;
presetMini_YtS7XCIs.variantPrint = variantPrint;
presetMini_YtS7XCIs.variantPseudoClassFunctions = variantPseudoClassFunctions;
presetMini_YtS7XCIs.variantPseudoClassesAndElements = variantPseudoClassesAndElements;
presetMini_YtS7XCIs.variantScope = variantScope;
presetMini_YtS7XCIs.variantSelector = variantSelector;
presetMini_YtS7XCIs.variantSupports = variantSupports;
presetMini_YtS7XCIs.variantTaggedDataAttributes = variantTaggedDataAttributes;
presetMini_YtS7XCIs.variantTaggedPseudoClasses = variantTaggedPseudoClasses;
presetMini_YtS7XCIs.variantTheme = variantTheme;
presetMini_YtS7XCIs.variantVariables = variantVariables;
presetMini_YtS7XCIs.variants = variants$3;

Object.defineProperty(dist$m, '__esModule', { value: true });

const core$e = dist$p;
const extractorArbitraryVariants = dist$l;
const utilities = presetMini_DahJgnb1;
const _default$6 = presetMini_St8sZgQd;
const _default$1$1 = presetMini_D_Gfuejm;
const _default$2$1 = presetMini_YtS7XCIs;
const colors$1 = colors$4;



const preflights = [
  {
    layer: "preflights",
    getCSS(ctx) {
      if (ctx.theme.preflightBase) {
        const css = core$e.entriesToCss(Object.entries(ctx.theme.preflightBase));
        const roots = core$e.toArray(ctx.theme.preflightRoot ?? ["*,::before,::after", "::backdrop"]);
        return roots.map((root) => `${root}{${css}}`).join("");
      }
    }
  }
];

const shorthands = {
  position: [
    "relative",
    "absolute",
    "fixed",
    "sticky",
    "static"
  ],
  globalKeyword: utilities.globalKeywords
};

const presetMini$1 = core$e.definePreset((options = {}) => {
  options.dark = options.dark ?? "class";
  options.attributifyPseudo = options.attributifyPseudo ?? false;
  options.preflight = options.preflight ?? true;
  options.variablePrefix = options.variablePrefix ?? "un-";
  return {
    name: "@unocss/preset-mini",
    theme: _default$6.theme,
    rules: _default$1$1.rules,
    variants: _default$2$1.variants(options),
    options,
    prefix: options.prefix,
    postprocess: VarPrefixPostprocessor(options.variablePrefix),
    preflights: options.preflight ? normalizePreflights(preflights, options.variablePrefix) : [],
    extractorDefault: options.arbitraryVariants === false ? void 0 : extractorArbitraryVariants.extractorArbitraryVariants,
    autocomplete: {
      shorthands
    }
  };
});
function VarPrefixPostprocessor(prefix) {
  if (prefix !== "un-") {
    return (obj) => {
      obj.entries.forEach((i) => {
        i[0] = i[0].replace(/^--un-/, `--${prefix}`);
        if (typeof i[1] === "string")
          i[1] = i[1].replace(/var\(--un-/g, `var(--${prefix}`);
      });
    };
  }
}
function normalizePreflights(preflights3, variablePrefix) {
  if (variablePrefix !== "un-") {
    return preflights3.map((p) => ({
      ...p,
      getCSS: /* @__PURE__ */ (() => async (ctx) => {
        const css = await p.getCSS(ctx);
        if (css)
          return css.replace(/--un-/g, `--${variablePrefix}`);
      })()
    }));
  }
  return preflights3;
}

dist$m.parseColor = utilities.parseColor;
dist$m.theme = _default$6.theme;
dist$m.colors = colors$1.colors;
dist$m.VarPrefixPostprocessor = VarPrefixPostprocessor;
dist$m.default = presetMini$1;
dist$m.normalizePreflights = normalizePreflights;
dist$m.preflights = preflights;
dist$m.presetMini = presetMini$1;

var utils$c = {};

(function (exports) {

	const utilities = presetMini_DahJgnb1;
	const ruleUtils = dist$k;




	exports.CONTROL_MINI_NO_NEGATIVE = utilities.CONTROL_MINI_NO_NEGATIVE;
	exports.colorResolver = utilities.colorResolver;
	exports.colorableShadows = utilities.colorableShadows;
	exports.cornerMap = utilities.cornerMap;
	exports.cssMathFnRE = utilities.cssMathFnRE;
	exports.directionMap = utilities.directionMap;
	exports.directionSize = utilities.directionSize;
	exports.globalKeywords = utilities.globalKeywords;
	exports.h = utilities.h;
	exports.handler = utilities.handler;
	exports.hasParseableColor = utilities.hasParseableColor;
	exports.insetMap = utilities.insetMap;
	exports.isCSSMathFn = utilities.isCSSMathFn;
	exports.isSize = utilities.isSize;
	exports.makeGlobalStaticRules = utilities.makeGlobalStaticRules;
	exports.parseColor = utilities.parseColor;
	exports.positionMap = utilities.positionMap;
	exports.resolveBreakpoints = utilities.resolveBreakpoints;
	exports.resolveVerticalBreakpoints = utilities.resolveVerticalBreakpoints;
	exports.splitShorthand = utilities.splitShorthand;
	exports.transformXYZ = utilities.transformXYZ;
	exports.valueHandlers = utilities.valueHandlers;
	exports.xyzArray = utilities.xyzArray;
	exports.xyzMap = utilities.xyzMap;
	Object.prototype.hasOwnProperty.call(ruleUtils, '__proto__') &&
		!Object.prototype.hasOwnProperty.call(exports, '__proto__') &&
		Object.defineProperty(exports, '__proto__', {
			enumerable: true,
			value: ruleUtils['__proto__']
		});

	Object.keys(ruleUtils).forEach(function (k) {
		if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) exports[k] = ruleUtils[k];
	}); 
} (utils$c));

var rules$1 = {};

const _default$5 = presetMini_D_Gfuejm;
const transform$1 = presetMini_mjThnwTD;






rules$1.alignments = _default$5.alignments;
rules$1.appearance = _default$5.appearance;
rules$1.aspectRatio = _default$5.aspectRatio;
rules$1.bgColors = _default$5.bgColors;
rules$1.borderStyles = _default$5.borderStyles;
rules$1.borders = _default$5.borders;
rules$1.boxSizing = _default$5.boxSizing;
rules$1.colorScheme = _default$5.colorScheme;
rules$1.containerParent = _default$5.containerParent;
rules$1.cssProperty = _default$5.cssProperty;
rules$1.cssVariables = _default$5.cssVariables;
rules$1.flex = _default$5.flex;
rules$1.flexGridJustifiesAlignments = _default$5.flexGridJustifiesAlignments;
rules$1.floats = _default$5.floats;
rules$1.fonts = _default$5.fonts;
rules$1.gaps = _default$5.gaps;
rules$1.grids = _default$5.grids;
rules$1.handlerBorderStyle = _default$5.handlerBorderStyle;
rules$1.insets = _default$5.insets;
rules$1.justifies = _default$5.justifies;
rules$1.margins = _default$5.margins;
rules$1.opacity = _default$5.opacity;
rules$1.orders = _default$5.orders;
rules$1.outline = _default$5.outline;
rules$1.overflows = _default$5.overflows;
rules$1.paddings = _default$5.paddings;
rules$1.placements = _default$5.placements;
rules$1.positions = _default$5.positions;
rules$1.questionMark = _default$5.questionMark;
rules$1.rules = _default$5.rules;
rules$1.sizes = _default$5.sizes;
rules$1.svgUtilities = _default$5.svgUtilities;
rules$1.tabSizes = _default$5.tabSizes;
rules$1.textAligns = _default$5.textAligns;
rules$1.textDecorations = _default$5.textDecorations;
rules$1.textIndents = _default$5.textIndents;
rules$1.textShadows = _default$5.textShadows;
rules$1.textStrokes = _default$5.textStrokes;
rules$1.transitions = _default$5.transitions;
rules$1.verticalAligns = _default$5.verticalAligns;
rules$1.willChange = _default$5.willChange;
rules$1.zIndexes = _default$5.zIndexes;
rules$1.appearances = transform$1.appearances;
rules$1.boxShadows = transform$1.boxShadows;
rules$1.boxShadowsBase = transform$1.boxShadowsBase;
rules$1.breaks = transform$1.breaks;
rules$1.contains = transform$1.contains;
rules$1.contentVisibility = transform$1.contentVisibility;
rules$1.contents = transform$1.contents;
rules$1.cursors = transform$1.cursors;
rules$1.displays = transform$1.displays;
rules$1.fontSmoothings = transform$1.fontSmoothings;
rules$1.fontStyles = transform$1.fontStyles;
rules$1.pointerEvents = transform$1.pointerEvents;
rules$1.resizes = transform$1.resizes;
rules$1.ringBase = transform$1.ringBase;
rules$1.rings = transform$1.rings;
rules$1.textOverflows = transform$1.textOverflows;
rules$1.textTransforms = transform$1.textTransforms;
rules$1.textWraps = transform$1.textWraps;
rules$1.transformBase = transform$1.transformBase;
rules$1.transforms = transform$1.transforms;
rules$1.userSelects = transform$1.userSelects;
rules$1.varEmpty = transform$1.varEmpty;
rules$1.whitespaces = transform$1.whitespaces;

var theme$2 = {};

const colors = colors$4;
const _default$4 = presetMini_St8sZgQd;







theme$2.colors = colors.colors;
theme$2.baseSize = _default$4.baseSize;
theme$2.blur = _default$4.blur;
theme$2.borderRadius = _default$4.borderRadius;
theme$2.boxShadow = _default$4.boxShadow;
theme$2.breakpoints = _default$4.breakpoints;
theme$2.containers = _default$4.containers;
theme$2.dropShadow = _default$4.dropShadow;
theme$2.duration = _default$4.duration;
theme$2.easing = _default$4.easing;
theme$2.fontFamily = _default$4.fontFamily;
theme$2.fontSize = _default$4.fontSize;
theme$2.fontWeight = _default$4.fontWeight;
theme$2.height = _default$4.height;
theme$2.letterSpacing = _default$4.letterSpacing;
theme$2.lineHeight = _default$4.lineHeight;
theme$2.lineWidth = _default$4.lineWidth;
theme$2.maxHeight = _default$4.maxHeight;
theme$2.maxWidth = _default$4.maxWidth;
theme$2.media = _default$4.media;
theme$2.preflightBase = _default$4.preflightBase;
theme$2.ringWidth = _default$4.ringWidth;
theme$2.spacing = _default$4.spacing;
theme$2.textIndent = _default$4.textIndent;
theme$2.textShadow = _default$4.textShadow;
theme$2.textStrokeWidth = _default$4.textStrokeWidth;
theme$2.theme = _default$4.theme;
theme$2.verticalBreakpoints = _default$4.verticalBreakpoints;
theme$2.width = _default$4.width;
theme$2.wordSpacing = _default$4.wordSpacing;
theme$2.zIndex = _default$4.zIndex;

var variants$2 = {};

const _default$3 = presetMini_YtS7XCIs;






variants$2.calcMaxWidthBySize = _default$3.calcMaxWidthBySize;
variants$2.variantAria = _default$3.variantAria;
variants$2.variantBreakpoints = _default$3.variantBreakpoints;
variants$2.variantColorsMediaOrClass = _default$3.variantColorsMediaOrClass;
variants$2.variantCombinators = _default$3.variantCombinators;
variants$2.variantContainerQuery = _default$3.variantContainerQuery;
variants$2.variantCssLayer = _default$3.variantCssLayer;
variants$2.variantCustomMedia = _default$3.variantCustomMedia;
variants$2.variantDataAttribute = _default$3.variantDataAttribute;
variants$2.variantImportant = _default$3.variantImportant;
variants$2.variantInternalLayer = _default$3.variantInternalLayer;
variants$2.variantLanguageDirections = _default$3.variantLanguageDirections;
variants$2.variantNegative = _default$3.variantNegative;
variants$2.variantPartClasses = _default$3.variantPartClasses;
variants$2.variantPrint = _default$3.variantPrint;
variants$2.variantPseudoClassFunctions = _default$3.variantPseudoClassFunctions;
variants$2.variantPseudoClassesAndElements = _default$3.variantPseudoClassesAndElements;
variants$2.variantScope = _default$3.variantScope;
variants$2.variantSelector = _default$3.variantSelector;
variants$2.variantSupports = _default$3.variantSupports;
variants$2.variantTaggedDataAttributes = _default$3.variantTaggedDataAttributes;
variants$2.variantTaggedPseudoClasses = _default$3.variantTaggedPseudoClasses;
variants$2.variantTheme = _default$3.variantTheme;
variants$2.variantVariables = _default$3.variantVariables;
variants$2.variants = _default$3.variants;

Object.defineProperty(dist$n, '__esModule', { value: true });

const core$d = dist$p;
const presetMini = dist$m;
const utils$b = utils$c;
const _ = rules$1;
const theme$1 = theme$2;
const ruleUtils$2 = dist$k;
const variants$1 = variants$2;

function _interopDefaultCompat$3 (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

function _interopNamespaceCompat$1(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  const n = Object.create(null);
  if (e) {
    for (const k in e) {
      n[k] = e[k];
    }
  }
  n.default = e;
  return n;
}

const presetMini__default = /*#__PURE__*/_interopDefaultCompat$3(presetMini);
const ___namespace = /*#__PURE__*/_interopNamespaceCompat$1(_);

const animations = [
  [/^(?:animate-)?keyframes-(.+)$/, ([, name], { theme }) => {
    const kf = theme.animation?.keyframes?.[name];
    if (kf) {
      return [
        `@keyframes ${name}${kf}`,
        { animation: name }
      ];
    }
  }, { autocomplete: ["animate-keyframes-$animation.keyframes", "keyframes-$animation.keyframes"] }],
  [/^animate-(.+)$/, ([, name], { theme }) => {
    const kf = theme.animation?.keyframes?.[name];
    if (kf) {
      const duration = theme.animation?.durations?.[name] ?? "1s";
      const timing = theme.animation?.timingFns?.[name] ?? "linear";
      const count = theme.animation?.counts?.[name] ?? 1;
      const props = theme.animation?.properties?.[name];
      return [
        `@keyframes ${name}${kf}`,
        {
          animation: `${name} ${duration} ${timing} ${count}`,
          ...props
        }
      ];
    }
    return { animation: utils$b.h.bracket.cssvar(name) };
  }, { autocomplete: "animate-$animation.keyframes" }],
  [/^animate-name-(.+)/, ([, d]) => ({ "animation-name": utils$b.h.bracket.cssvar(d) ?? d })],
  // timings
  [/^animate-duration-(.+)$/, ([, d], { theme }) => ({ "animation-duration": theme.duration?.[d || "DEFAULT"] ?? utils$b.h.bracket.cssvar.time(d) }), { autocomplete: ["animate-duration", "animate-duration-$duration"] }],
  [/^animate-delay-(.+)$/, ([, d], { theme }) => ({ "animation-delay": theme.duration?.[d || "DEFAULT"] ?? utils$b.h.bracket.cssvar.time(d) }), { autocomplete: ["animate-delay", "animate-delay-$duration"] }],
  [/^animate-ease(?:-(.+))?$/, ([, d], { theme }) => ({ "animation-timing-function": theme.easing?.[d || "DEFAULT"] ?? utils$b.h.bracket.cssvar(d) }), { autocomplete: ["animate-ease", "animate-ease-$easing"] }],
  // fill mode
  [/^animate-(fill-mode-|fill-|mode-)?(.+)$/, ([, t, d]) => ["none", "forwards", "backwards", "both", ...[t ? utils$b.globalKeywords : []]].includes(d) ? { "animation-fill-mode": d } : void 0, {
    autocomplete: [
      "animate-(fill|mode|fill-mode)",
      "animate-(fill|mode|fill-mode)-(none|forwards|backwards|both|inherit|initial|revert|revert-layer|unset)",
      "animate-(none|forwards|backwards|both|inherit|initial|revert|revert-layer|unset)"
    ]
  }],
  // direction
  [/^animate-(direction-)?(.+)$/, ([, t, d]) => ["normal", "reverse", "alternate", "alternate-reverse", ...[t ? utils$b.globalKeywords : []]].includes(d) ? { "animation-direction": d } : void 0, {
    autocomplete: [
      "animate-direction",
      "animate-direction-(normal|reverse|alternate|alternate-reverse|inherit|initial|revert|revert-layer|unset)",
      "animate-(normal|reverse|alternate|alternate-reverse|inherit|initial|revert|revert-layer|unset)"
    ]
  }],
  // others
  [/^animate-(?:iteration-count-|iteration-|count-)(.+)$/, ([, d]) => ({ "animation-iteration-count": utils$b.h.bracket.cssvar(d) ?? d.replace(/\-/g, ",") }), { autocomplete: ["animate-(iteration|count|iteration-count)", "animate-(iteration|count|iteration-count)-<num>"] }],
  [/^animate-(play-state-|play-|state-)?(.+)$/, ([, t, d]) => ["paused", "running", ...[t ? utils$b.globalKeywords : []]].includes(d) ? { "animation-play-state": d } : void 0, {
    autocomplete: [
      "animate-(play|state|play-state)",
      "animate-(play|state|play-state)-(paused|running|inherit|initial|revert|revert-layer|unset)",
      "animate-(paused|running|inherit|initial|revert|revert-layer|unset)"
    ]
  }],
  ["animate-none", { animation: "none" }],
  ...utils$b.makeGlobalStaticRules("animate", "animation")
];

function bgGradientToValue(cssColor) {
  if (cssColor)
    return ruleUtils$2.colorToString(cssColor, 0);
  return "rgb(255 255 255 / 0)";
}
function bgGradientColorValue(mode, cssColor, color, alpha) {
  if (cssColor) {
    if (alpha != null)
      return ruleUtils$2.colorToString(cssColor, alpha);
    else
      return ruleUtils$2.colorToString(cssColor, `var(--un-${mode}-opacity, ${ruleUtils$2.colorOpacityToString(cssColor)})`);
  }
  return ruleUtils$2.colorToString(color, alpha);
}
function bgGradientColorResolver() {
  return ([, mode, body], { theme }) => {
    const data = utils$b.parseColor(body, theme, "backgroundColor");
    if (!data)
      return;
    const { alpha, color, cssColor } = data;
    if (!color)
      return;
    const colorString = bgGradientColorValue(mode, cssColor, color, alpha);
    switch (mode) {
      case "from":
        return {
          "--un-gradient-from-position": "0%",
          "--un-gradient-from": `${colorString} var(--un-gradient-from-position)`,
          "--un-gradient-to-position": "100%",
          "--un-gradient-to": `${bgGradientToValue(cssColor)} var(--un-gradient-to-position)`,
          "--un-gradient-stops": "var(--un-gradient-from), var(--un-gradient-to)"
        };
      case "via":
        return {
          "--un-gradient-via-position": "50%",
          "--un-gradient-to": bgGradientToValue(cssColor),
          "--un-gradient-stops": `var(--un-gradient-from), ${colorString} var(--un-gradient-via-position), var(--un-gradient-to)`
        };
      case "to":
        return {
          "--un-gradient-to-position": "100%",
          "--un-gradient-to": `${colorString} var(--un-gradient-to-position)`
        };
    }
  };
}
function bgGradientPositionResolver() {
  return ([, mode, body]) => {
    return {
      [`--un-gradient-${mode}-position`]: `${Number(utils$b.h.bracket.cssvar.percent(body)) * 100}%`
    };
  };
}
const backgroundStyles = [
  // gradients
  [/^bg-gradient-(.+)$/, ([, d]) => ({ "--un-gradient": utils$b.h.bracket(d) }), {
    autocomplete: ["bg-gradient", "bg-gradient-(from|to|via)", "bg-gradient-(from|to|via)-$colors", "bg-gradient-(from|to|via)-(op|opacity)", "bg-gradient-(from|to|via)-(op|opacity)-<percent>"]
  }],
  [/^(?:bg-gradient-)?stops-(\[.+\])$/, ([, s]) => ({ "--un-gradient-stops": utils$b.h.bracket(s) })],
  [/^(?:bg-gradient-)?(from)-(.+)$/, bgGradientColorResolver()],
  [/^(?:bg-gradient-)?(via)-(.+)$/, bgGradientColorResolver()],
  [/^(?:bg-gradient-)?(to)-(.+)$/, bgGradientColorResolver()],
  [/^(?:bg-gradient-)?(from|via|to)-op(?:acity)?-?(.+)$/, ([, position, opacity]) => ({ [`--un-${position}-opacity`]: utils$b.h.bracket.percent(opacity) })],
  [/^(from|via|to)-([\d\.]+)%$/, bgGradientPositionResolver()],
  // images
  [/^bg-gradient-((?:repeating-)?(?:linear|radial|conic))$/, ([, s]) => ({
    "background-image": `${s}-gradient(var(--un-gradient, var(--un-gradient-stops, rgb(255 255 255 / 0))))`
  }), { autocomplete: ["bg-gradient-repeating", "bg-gradient-(linear|radial|conic)", "bg-gradient-repeating-(linear|radial|conic)"] }],
  // ignore any center position
  [/^bg-gradient-to-([rltb]{1,2})$/, ([, d]) => {
    if (d in utils$b.positionMap) {
      return {
        "--un-gradient-shape": `to ${utils$b.positionMap[d]}`,
        "--un-gradient": "var(--un-gradient-shape), var(--un-gradient-stops)",
        "background-image": "linear-gradient(var(--un-gradient))"
      };
    }
  }, { autocomplete: `bg-gradient-to-(${Object.keys(utils$b.positionMap).filter((k) => k.length <= 2 && Array.from(k).every((c) => "rltb".includes(c))).join("|")})` }],
  [/^(?:bg-gradient-)?shape-(.+)$/, ([, d]) => {
    const v = d in utils$b.positionMap ? `to ${utils$b.positionMap[d]}` : utils$b.h.bracket(d);
    if (v != null) {
      return {
        "--un-gradient-shape": v,
        "--un-gradient": "var(--un-gradient-shape), var(--un-gradient-stops)"
      };
    }
  }, { autocomplete: ["bg-gradient-shape", `bg-gradient-shape-(${Object.keys(utils$b.positionMap).join("|")})`, `shape-(${Object.keys(utils$b.positionMap).join("|")})`] }],
  ["bg-none", { "background-image": "none" }],
  ["box-decoration-slice", { "box-decoration-break": "slice" }],
  ["box-decoration-clone", { "box-decoration-break": "clone" }],
  ...utils$b.makeGlobalStaticRules("box-decoration", "box-decoration-break"),
  // size
  ["bg-auto", { "background-size": "auto" }],
  ["bg-cover", { "background-size": "cover" }],
  ["bg-contain", { "background-size": "contain" }],
  // attachments
  ["bg-fixed", { "background-attachment": "fixed" }],
  ["bg-local", { "background-attachment": "local" }],
  ["bg-scroll", { "background-attachment": "scroll" }],
  // clips
  ["bg-clip-border", { "-webkit-background-clip": "border-box", "background-clip": "border-box" }],
  ["bg-clip-content", { "-webkit-background-clip": "content-box", "background-clip": "content-box" }],
  ["bg-clip-padding", { "-webkit-background-clip": "padding-box", "background-clip": "padding-box" }],
  ["bg-clip-text", { "-webkit-background-clip": "text", "background-clip": "text" }],
  ...utils$b.globalKeywords.map((keyword) => [`bg-clip-${keyword}`, {
    "-webkit-background-clip": keyword,
    "background-clip": keyword
  }]),
  // positions
  // skip 1 & 2 letters shortcut
  [/^bg-([-\w]{3,})$/, ([, s]) => ({ "background-position": utils$b.positionMap[s] })],
  // repeats
  ["bg-repeat", { "background-repeat": "repeat" }],
  ["bg-no-repeat", { "background-repeat": "no-repeat" }],
  ["bg-repeat-x", { "background-repeat": "repeat-x" }],
  ["bg-repeat-y", { "background-repeat": "repeat-y" }],
  ["bg-repeat-round", { "background-repeat": "round" }],
  ["bg-repeat-space", { "background-repeat": "space" }],
  ...utils$b.makeGlobalStaticRules("bg-repeat", "background-repeat"),
  // origins
  ["bg-origin-border", { "background-origin": "border-box" }],
  ["bg-origin-padding", { "background-origin": "padding-box" }],
  ["bg-origin-content", { "background-origin": "content-box" }],
  ...utils$b.makeGlobalStaticRules("bg-origin", "background-origin")
];

const listStyles = {
  "disc": "disc",
  "circle": "circle",
  "square": "square",
  "decimal": "decimal",
  "zero-decimal": "decimal-leading-zero",
  "greek": "lower-greek",
  "roman": "lower-roman",
  "upper-roman": "upper-roman",
  "alpha": "lower-alpha",
  "upper-alpha": "upper-alpha",
  "latin": "lower-latin",
  "upper-latin": "upper-latin"
};
const listStyle = [
  // base
  [/^list-(.+?)(?:-(outside|inside))?$/, ([, alias, position]) => {
    const style = listStyles[alias];
    if (style) {
      if (position) {
        return {
          "list-style-position": position,
          "list-style-type": style
        };
      }
      return { "list-style-type": style };
    }
  }, { autocomplete: [`list-(${Object.keys(listStyles).join("|")})`, `list-(${Object.keys(listStyles).join("|")})-(outside|inside)`] }],
  // styles
  ["list-outside", { "list-style-position": "outside" }],
  ["list-inside", { "list-style-position": "inside" }],
  ["list-none", { "list-style-type": "none" }],
  // image
  [/^list-image-(.+)$/, ([, d]) => {
    if (/^\[url\(.+\)\]$/.test(d))
      return { "list-style-image": utils$b.h.bracket(d) };
  }],
  ["list-image-none", { "list-style-image": "none" }],
  ...utils$b.makeGlobalStaticRules("list", "list-style-type")
];
const accents = [
  [/^accent-(.+)$/, utils$b.colorResolver("accent-color", "accent", "accentColor"), { autocomplete: "accent-$colors" }],
  [/^accent-op(?:acity)?-?(.+)$/, ([, d]) => ({ "--un-accent-opacity": utils$b.h.bracket.percent(d) }), { autocomplete: ["accent-(op|opacity)", "accent-(op|opacity)-<percent>"] }]
];
const carets = [
  [/^caret-(.+)$/, utils$b.colorResolver("caret-color", "caret", "textColor"), { autocomplete: "caret-$colors" }],
  [/^caret-op(?:acity)?-?(.+)$/, ([, d]) => ({ "--un-caret-opacity": utils$b.h.bracket.percent(d) }), { autocomplete: ["caret-(op|opacity)", "caret-(op|opacity)-<percent>"] }]
];
const imageRenderings = [
  ["image-render-auto", { "image-rendering": "auto" }],
  ["image-render-edge", { "image-rendering": "crisp-edges" }],
  ["image-render-pixel", [
    ["-ms-interpolation-mode", "nearest-neighbor"],
    ["image-rendering", "-webkit-optimize-contrast"],
    ["image-rendering", "-moz-crisp-edges"],
    ["image-rendering", "-o-pixelated"],
    ["image-rendering", "pixelated"]
  ]]
];
const overscrolls = [
  ["overscroll-auto", { "overscroll-behavior": "auto" }],
  ["overscroll-contain", { "overscroll-behavior": "contain" }],
  ["overscroll-none", { "overscroll-behavior": "none" }],
  ...utils$b.makeGlobalStaticRules("overscroll", "overscroll-behavior"),
  ["overscroll-x-auto", { "overscroll-behavior-x": "auto" }],
  ["overscroll-x-contain", { "overscroll-behavior-x": "contain" }],
  ["overscroll-x-none", { "overscroll-behavior-x": "none" }],
  ...utils$b.makeGlobalStaticRules("overscroll-x", "overscroll-behavior-x"),
  ["overscroll-y-auto", { "overscroll-behavior-y": "auto" }],
  ["overscroll-y-contain", { "overscroll-behavior-y": "contain" }],
  ["overscroll-y-none", { "overscroll-behavior-y": "none" }],
  ...utils$b.makeGlobalStaticRules("overscroll-y", "overscroll-behavior-y")
];
const scrollBehaviors = [
  ["scroll-auto", { "scroll-behavior": "auto" }],
  ["scroll-smooth", { "scroll-behavior": "smooth" }],
  ...utils$b.makeGlobalStaticRules("scroll", "scroll-behavior")
];

const columns$1 = [
  [/^columns-(.+)$/, ([, v]) => ({ columns: utils$b.h.bracket.global.number.auto.numberWithUnit(v) }), { autocomplete: "columns-<num>" }],
  // break before
  ["break-before-auto", { "break-before": "auto" }],
  ["break-before-avoid", { "break-before": "avoid" }],
  ["break-before-all", { "break-before": "all" }],
  ["break-before-avoid-page", { "break-before": "avoid-page" }],
  ["break-before-page", { "break-before": "page" }],
  ["break-before-left", { "break-before": "left" }],
  ["break-before-right", { "break-before": "right" }],
  ["break-before-column", { "break-before": "column" }],
  ...utils$b.makeGlobalStaticRules("break-before"),
  // break inside
  ["break-inside-auto", { "break-inside": "auto" }],
  ["break-inside-avoid", { "break-inside": "avoid" }],
  ["break-inside-avoid-page", { "break-inside": "avoid-page" }],
  ["break-inside-avoid-column", { "break-inside": "avoid-column" }],
  ...utils$b.makeGlobalStaticRules("break-inside"),
  // break after
  ["break-after-auto", { "break-after": "auto" }],
  ["break-after-avoid", { "break-after": "avoid" }],
  ["break-after-all", { "break-after": "all" }],
  ["break-after-avoid-page", { "break-after": "avoid-page" }],
  ["break-after-page", { "break-after": "page" }],
  ["break-after-left", { "break-after": "left" }],
  ["break-after-right", { "break-after": "right" }],
  ["break-after-column", { "break-after": "column" }],
  ...utils$b.makeGlobalStaticRules("break-after")
];

const queryMatcher = /@media \(min-width: (.+)\)/;
const container = [
  [
    /^__container$/,
    (m, context) => {
      const { theme, variantHandlers } = context;
      const themePadding = theme.container?.padding;
      let padding;
      if (core$d.isString(themePadding))
        padding = themePadding;
      else
        padding = themePadding?.DEFAULT;
      const themeMaxWidth = theme.container?.maxWidth;
      let maxWidth;
      for (const v of variantHandlers) {
        const query = v.handle?.({}, (x) => x)?.parent;
        if (core$d.isString(query)) {
          const match = query.match(queryMatcher)?.[1];
          if (match) {
            const bp = utils$b.resolveBreakpoints(context) ?? [];
            const matchBp = bp.find((i) => i.size === match)?.point;
            if (!themeMaxWidth)
              maxWidth = match;
            else if (matchBp)
              maxWidth = themeMaxWidth?.[matchBp];
            if (matchBp && !core$d.isString(themePadding))
              padding = themePadding?.[matchBp] ?? padding;
          }
        }
      }
      const css = {
        "max-width": maxWidth
      };
      if (!variantHandlers.length)
        css.width = "100%";
      if (theme.container?.center) {
        css["margin-left"] = "auto";
        css["margin-right"] = "auto";
      }
      if (themePadding) {
        css["padding-left"] = padding;
        css["padding-right"] = padding;
      }
      return css;
    },
    { internal: true }
  ]
];
const containerShortcuts = [
  [/^(?:(\w+)[:-])?container$/, ([, bp], context) => {
    let points = (utils$b.resolveBreakpoints(context) ?? []).map((i) => i.point);
    if (bp) {
      if (!points.includes(bp))
        return;
      points = points.slice(points.indexOf(bp));
    }
    const shortcuts = points.map((p) => `${p}:__container`);
    if (!bp)
      shortcuts.unshift("__container");
    return shortcuts;
  }]
];

const filterBase = {
  "--un-blur": _.varEmpty,
  "--un-brightness": _.varEmpty,
  "--un-contrast": _.varEmpty,
  "--un-drop-shadow": _.varEmpty,
  "--un-grayscale": _.varEmpty,
  "--un-hue-rotate": _.varEmpty,
  "--un-invert": _.varEmpty,
  "--un-saturate": _.varEmpty,
  "--un-sepia": _.varEmpty
};
const filterProperty = "var(--un-blur) var(--un-brightness) var(--un-contrast) var(--un-drop-shadow) var(--un-grayscale) var(--un-hue-rotate) var(--un-invert) var(--un-saturate) var(--un-sepia)";
const backdropFilterBase = {
  "--un-backdrop-blur": _.varEmpty,
  "--un-backdrop-brightness": _.varEmpty,
  "--un-backdrop-contrast": _.varEmpty,
  "--un-backdrop-grayscale": _.varEmpty,
  "--un-backdrop-hue-rotate": _.varEmpty,
  "--un-backdrop-invert": _.varEmpty,
  "--un-backdrop-opacity": _.varEmpty,
  "--un-backdrop-saturate": _.varEmpty,
  "--un-backdrop-sepia": _.varEmpty
};
const backdropFilterProperty = "var(--un-backdrop-blur) var(--un-backdrop-brightness) var(--un-backdrop-contrast) var(--un-backdrop-grayscale) var(--un-backdrop-hue-rotate) var(--un-backdrop-invert) var(--un-backdrop-opacity) var(--un-backdrop-saturate) var(--un-backdrop-sepia)";
function percentWithDefault(str) {
  let v = utils$b.h.bracket.cssvar(str || "");
  if (v != null)
    return v;
  v = str ? utils$b.h.percent(str) : "1";
  if (v != null && Number.parseFloat(v) <= 1)
    return v;
}
function toFilter(varName, resolver) {
  return ([, b, s], { theme }) => {
    const value = resolver(s, theme) ?? (s === "none" ? "0" : "");
    if (value !== "") {
      if (b) {
        return {
          [`--un-${b}${varName}`]: `${varName}(${value})`,
          "-webkit-backdrop-filter": backdropFilterProperty,
          "backdrop-filter": backdropFilterProperty
        };
      } else {
        return {
          [`--un-${varName}`]: `${varName}(${value})`,
          filter: filterProperty
        };
      }
    }
  };
}
function dropShadowResolver([, s], { theme }) {
  let v = theme.dropShadow?.[s || "DEFAULT"];
  if (v != null) {
    const shadows = utils$b.colorableShadows(v, "--un-drop-shadow-color");
    return {
      "--un-drop-shadow": `drop-shadow(${shadows.join(") drop-shadow(")})`,
      "filter": filterProperty
    };
  }
  v = utils$b.h.bracket.cssvar(s);
  if (v != null) {
    return {
      "--un-drop-shadow": `drop-shadow(${v})`,
      "filter": filterProperty
    };
  }
}
const filters = [
  // filters
  [/^(?:(backdrop-)|filter-)?blur(?:-(.+))?$/, toFilter("blur", (s, theme) => theme.blur?.[s || "DEFAULT"] || utils$b.h.bracket.cssvar.px(s)), { autocomplete: ["(backdrop|filter)-blur-$blur", "blur-$blur", "filter-blur"] }],
  [/^(?:(backdrop-)|filter-)?brightness-(.+)$/, toFilter("brightness", (s) => utils$b.h.bracket.cssvar.percent(s)), { autocomplete: ["(backdrop|filter)-brightness-<percent>", "brightness-<percent>"] }],
  [/^(?:(backdrop-)|filter-)?contrast-(.+)$/, toFilter("contrast", (s) => utils$b.h.bracket.cssvar.percent(s)), { autocomplete: ["(backdrop|filter)-contrast-<percent>", "contrast-<percent>"] }],
  // drop-shadow only on filter
  [/^(?:filter-)?drop-shadow(?:-(.+))?$/, dropShadowResolver, {
    autocomplete: [
      "filter-drop",
      "filter-drop-shadow",
      "filter-drop-shadow-color",
      "drop-shadow",
      "drop-shadow-color",
      "filter-drop-shadow-$dropShadow",
      "drop-shadow-$dropShadow",
      "filter-drop-shadow-color-$colors",
      "drop-shadow-color-$colors",
      "filter-drop-shadow-color-(op|opacity)",
      "drop-shadow-color-(op|opacity)",
      "filter-drop-shadow-color-(op|opacity)-<percent>",
      "drop-shadow-color-(op|opacity)-<percent>"
    ]
  }],
  [/^(?:filter-)?drop-shadow-color-(.+)$/, utils$b.colorResolver("--un-drop-shadow-color", "drop-shadow", "shadowColor")],
  [/^(?:filter-)?drop-shadow-color-op(?:acity)?-?(.+)$/, ([, opacity]) => ({ "--un-drop-shadow-opacity": utils$b.h.bracket.percent(opacity) })],
  [/^(?:(backdrop-)|filter-)?grayscale(?:-(.+))?$/, toFilter("grayscale", percentWithDefault), { autocomplete: ["(backdrop|filter)-grayscale", "(backdrop|filter)-grayscale-<percent>", "grayscale-<percent>"] }],
  [/^(?:(backdrop-)|filter-)?hue-rotate-(.+)$/, toFilter("hue-rotate", (s) => utils$b.h.bracket.cssvar.degree(s))],
  [/^(?:(backdrop-)|filter-)?invert(?:-(.+))?$/, toFilter("invert", percentWithDefault), { autocomplete: ["(backdrop|filter)-invert", "(backdrop|filter)-invert-<percent>", "invert-<percent>"] }],
  // opacity only on backdrop-filter
  [/^(backdrop-)op(?:acity)-(.+)$/, toFilter("opacity", (s) => utils$b.h.bracket.cssvar.percent(s)), { autocomplete: ["backdrop-(op|opacity)", "backdrop-(op|opacity)-<percent>"] }],
  [/^(?:(backdrop-)|filter-)?saturate-(.+)$/, toFilter("saturate", (s) => utils$b.h.bracket.cssvar.percent(s)), { autocomplete: ["(backdrop|filter)-saturate", "(backdrop|filter)-saturate-<percent>", "saturate-<percent>"] }],
  [/^(?:(backdrop-)|filter-)?sepia(?:-(.+))?$/, toFilter("sepia", percentWithDefault), { autocomplete: ["(backdrop|filter)-sepia", "(backdrop|filter)-sepia-<percent>", "sepia-<percent>"] }],
  // base
  ["filter", { filter: filterProperty }],
  ["backdrop-filter", {
    "-webkit-backdrop-filter": backdropFilterProperty,
    "backdrop-filter": backdropFilterProperty
  }],
  // nones
  ["filter-none", { filter: "none" }],
  ["backdrop-filter-none", {
    "-webkit-backdrop-filter": "none",
    "backdrop-filter": "none"
  }],
  ...utils$b.globalKeywords.map((keyword) => [`filter-${keyword}`, { filter: keyword }]),
  ...utils$b.globalKeywords.map((keyword) => [`backdrop-filter-${keyword}`, {
    "-webkit-backdrop-filter": keyword,
    "backdrop-filter": keyword
  }])
];

const spaces = [
  [/^space-([xy])-(-?.+)$/, handlerSpace, { autocomplete: ["space-(x|y|block|inline)", "space-(x|y|block|inline)-reverse", "space-(x|y|block|inline)-$spacing"] }],
  [/^space-([xy])-reverse$/, ([, d]) => ({ [`--un-space-${d}-reverse`]: 1 })],
  [/^space-(block|inline)-(-?.+)$/, handlerSpace],
  [/^space-(block|inline)-reverse$/, ([, d]) => ({ [`--un-space-${d}-reverse`]: 1 })]
];
function handlerSpace([, d, s], { theme }) {
  let v = theme.spacing?.[s || "DEFAULT"] ?? utils$b.h.bracket.cssvar.auto.fraction.rem(s || "1");
  if (v != null) {
    if (v === "0")
      v = "0px";
    const results = utils$b.directionMap[d].map((item) => {
      const key = `margin${item}`;
      const value = item.endsWith("right") || item.endsWith("bottom") ? `calc(${v} * var(--un-space-${d}-reverse))` : `calc(${v} * calc(1 - var(--un-space-${d}-reverse)))`;
      return [key, value];
    });
    if (results) {
      return [
        [`--un-space-${d}-reverse`, 0],
        ...results
      ];
    }
  }
}

const textTransforms = [
  // tailwind compat
  ["uppercase", { "text-transform": "uppercase" }],
  ["lowercase", { "text-transform": "lowercase" }],
  ["capitalize", { "text-transform": "capitalize" }],
  ["normal-case", { "text-transform": "none" }]
];
const hyphens$1 = [
  ...["manual", "auto", "none", ...utils$b.globalKeywords].map((keyword) => [`hyphens-${keyword}`, {
    "-webkit-hyphens": keyword,
    "-ms-hyphens": keyword,
    "hyphens": keyword
  }])
];
const writingModes = [
  ["write-vertical-right", { "writing-mode": "vertical-rl" }],
  ["write-vertical-left", { "writing-mode": "vertical-lr" }],
  ["write-normal", { "writing-mode": "horizontal-tb" }],
  ...utils$b.makeGlobalStaticRules("write", "writing-mode")
];
const writingOrientations = [
  ["write-orient-mixed", { "text-orientation": "mixed" }],
  ["write-orient-sideways", { "text-orientation": "sideways" }],
  ["write-orient-upright", { "text-orientation": "upright" }],
  ...utils$b.makeGlobalStaticRules("write-orient", "text-orientation")
];
const screenReadersAccess = [
  [
    "sr-only",
    {
      "position": "absolute",
      "width": "1px",
      "height": "1px",
      "padding": "0",
      "margin": "-1px",
      "overflow": "hidden",
      "clip": "rect(0,0,0,0)",
      "white-space": "nowrap",
      "border-width": 0
    }
  ],
  [
    "not-sr-only",
    {
      "position": "static",
      "width": "auto",
      "height": "auto",
      "padding": "0",
      "margin": "0",
      "overflow": "visible",
      "clip": "auto",
      "white-space": "normal"
    }
  ]
];
const isolations = [
  ["isolate", { isolation: "isolate" }],
  ["isolate-auto", { isolation: "auto" }],
  ["isolation-auto", { isolation: "auto" }]
];
const objectPositions = [
  // object fit
  ["object-cover", { "object-fit": "cover" }],
  ["object-contain", { "object-fit": "contain" }],
  ["object-fill", { "object-fit": "fill" }],
  ["object-scale-down", { "object-fit": "scale-down" }],
  ["object-none", { "object-fit": "none" }],
  // object position
  [/^object-(.+)$/, ([, d]) => {
    if (utils$b.positionMap[d])
      return { "object-position": utils$b.positionMap[d] };
    if (utils$b.h.bracketOfPosition(d) != null)
      return { "object-position": utils$b.h.bracketOfPosition(d).split(" ").map((e) => utils$b.h.position.fraction.auto.px.cssvar(e) ?? e).join(" ") };
  }, { autocomplete: `object-(${Object.keys(utils$b.positionMap).join("|")})` }]
];
const backgroundBlendModes = [
  ["bg-blend-multiply", { "background-blend-mode": "multiply" }],
  ["bg-blend-screen", { "background-blend-mode": "screen" }],
  ["bg-blend-overlay", { "background-blend-mode": "overlay" }],
  ["bg-blend-darken", { "background-blend-mode": "darken" }],
  ["bg-blend-lighten", { "background-blend-mode": "lighten" }],
  ["bg-blend-color-dodge", { "background-blend-mode": "color-dodge" }],
  ["bg-blend-color-burn", { "background-blend-mode": "color-burn" }],
  ["bg-blend-hard-light", { "background-blend-mode": "hard-light" }],
  ["bg-blend-soft-light", { "background-blend-mode": "soft-light" }],
  ["bg-blend-difference", { "background-blend-mode": "difference" }],
  ["bg-blend-exclusion", { "background-blend-mode": "exclusion" }],
  ["bg-blend-hue", { "background-blend-mode": "hue" }],
  ["bg-blend-saturation", { "background-blend-mode": "saturation" }],
  ["bg-blend-color", { "background-blend-mode": "color" }],
  ["bg-blend-luminosity", { "background-blend-mode": "luminosity" }],
  ["bg-blend-normal", { "background-blend-mode": "normal" }],
  ...utils$b.makeGlobalStaticRules("bg-blend", "background-blend")
];
const mixBlendModes = [
  ["mix-blend-multiply", { "mix-blend-mode": "multiply" }],
  ["mix-blend-screen", { "mix-blend-mode": "screen" }],
  ["mix-blend-overlay", { "mix-blend-mode": "overlay" }],
  ["mix-blend-darken", { "mix-blend-mode": "darken" }],
  ["mix-blend-lighten", { "mix-blend-mode": "lighten" }],
  ["mix-blend-color-dodge", { "mix-blend-mode": "color-dodge" }],
  ["mix-blend-color-burn", { "mix-blend-mode": "color-burn" }],
  ["mix-blend-hard-light", { "mix-blend-mode": "hard-light" }],
  ["mix-blend-soft-light", { "mix-blend-mode": "soft-light" }],
  ["mix-blend-difference", { "mix-blend-mode": "difference" }],
  ["mix-blend-exclusion", { "mix-blend-mode": "exclusion" }],
  ["mix-blend-hue", { "mix-blend-mode": "hue" }],
  ["mix-blend-saturation", { "mix-blend-mode": "saturation" }],
  ["mix-blend-color", { "mix-blend-mode": "color" }],
  ["mix-blend-luminosity", { "mix-blend-mode": "luminosity" }],
  ["mix-blend-plus-lighter", { "mix-blend-mode": "plus-lighter" }],
  ["mix-blend-normal", { "mix-blend-mode": "normal" }],
  ...utils$b.makeGlobalStaticRules("mix-blend")
];
const dynamicViewportHeight = [
  ["min-h-dvh", { "min-height": "100dvh" }],
  ["min-h-svh", { "min-height": "100svh" }],
  ["min-h-lvh", { "min-height": "100lvh" }],
  ["h-dvh", { height: "100dvh" }],
  ["h-svh", { height: "100svh" }],
  ["h-lvh", { height: "100lvh" }],
  ["max-h-dvh", { "max-height": "100dvh" }],
  ["max-h-svh", { "max-height": "100svh" }],
  ["max-h-lvh", { "max-height": "100lvh" }]
];

const borderSpacingBase = {
  "--un-border-spacing-x": 0,
  "--un-border-spacing-y": 0
};
const borderSpacingProperty = "var(--un-border-spacing-x) var(--un-border-spacing-y)";
const tables = [
  // displays
  ["inline-table", { display: "inline-table" }],
  ["table", { display: "table" }],
  ["table-caption", { display: "table-caption" }],
  ["table-cell", { display: "table-cell" }],
  ["table-column", { display: "table-column" }],
  ["table-column-group", { display: "table-column-group" }],
  ["table-footer-group", { display: "table-footer-group" }],
  ["table-header-group", { display: "table-header-group" }],
  ["table-row", { display: "table-row" }],
  ["table-row-group", { display: "table-row-group" }],
  // layouts
  ["border-collapse", { "border-collapse": "collapse" }],
  ["border-separate", { "border-collapse": "separate" }],
  [/^border-spacing-(.+)$/, ([, s], { theme }) => {
    const v = theme.spacing?.[s] ?? utils$b.h.bracket.cssvar.global.auto.fraction.rem(s);
    if (v != null) {
      return {
        "--un-border-spacing-x": v,
        "--un-border-spacing-y": v,
        "border-spacing": borderSpacingProperty
      };
    }
  }, { autocomplete: ["border-spacing", "border-spacing-$spacing"] }],
  [/^border-spacing-([xy])-(.+)$/, ([, d, s], { theme }) => {
    const v = theme.spacing?.[s] ?? utils$b.h.bracket.cssvar.global.auto.fraction.rem(s);
    if (v != null) {
      return {
        [`--un-border-spacing-${d}`]: v,
        "border-spacing": borderSpacingProperty
      };
    }
  }, { autocomplete: ["border-spacing-(x|y)", "border-spacing-(x|y)-$spacing"] }],
  ["caption-top", { "caption-side": "top" }],
  ["caption-bottom", { "caption-side": "bottom" }],
  ["table-auto", { "table-layout": "auto" }],
  ["table-fixed", { "table-layout": "fixed" }],
  ["table-empty-cells-visible", { "empty-cells": "show" }],
  ["table-empty-cells-hidden", { "empty-cells": "hide" }]
];

const variablesAbbrMap = {
  "bg-blend": "background-blend-mode",
  "bg-clip": "-webkit-background-clip",
  "bg-gradient": "linear-gradient",
  "bg-image": "background-image",
  "bg-origin": "background-origin",
  "bg-position": "background-position",
  "bg-repeat": "background-repeat",
  "bg-size": "background-size",
  "mix-blend": "mix-blend-mode",
  "object": "object-fit",
  "object-position": "object-position",
  "write": "writing-mode",
  "write-orient": "text-orientation"
};
const cssVariables = [
  [/^(.+?)-(\$.+)$/, ([, name, varname]) => {
    const prop = variablesAbbrMap[name];
    if (prop)
      return { [prop]: utils$b.h.cssvar(varname) };
  }]
];

const divides = [
  // divides
  [/^divide-?([xy])$/, handlerDivide, { autocomplete: ["divide-(x|y|block|inline)", "divide-(x|y|block|inline)-reverse", "divide-(x|y|block|inline)-$lineWidth"] }],
  [/^divide-?([xy])-?(-?.+)$/, handlerDivide],
  [/^divide-?([xy])-reverse$/, ([, d]) => ({ [`--un-divide-${d}-reverse`]: 1 })],
  [/^divide-(block|inline)$/, handlerDivide],
  [/^divide-(block|inline)-(-?.+)$/, handlerDivide],
  [/^divide-(block|inline)-reverse$/, ([, d]) => ({ [`--un-divide-${d}-reverse`]: 1 })],
  // color & opacity
  [/^divide-(.+)$/, utils$b.colorResolver("border-color", "divide", "borderColor"), { autocomplete: "divide-$colors" }],
  [/^divide-op(?:acity)?-?(.+)$/, ([, opacity]) => ({ "--un-divide-opacity": utils$b.h.bracket.percent(opacity) }), { autocomplete: ["divide-(op|opacity)", "divide-(op|opacity)-<percent>"] }],
  // styles
  ..._.borderStyles.map((style) => [`divide-${style}`, { "border-style": style }])
];
function handlerDivide([, d, s], { theme }) {
  let v = theme.lineWidth?.[s || "DEFAULT"] ?? utils$b.h.bracket.cssvar.px(s || "1");
  if (v != null) {
    if (v === "0")
      v = "0px";
    const results = utils$b.directionMap[d].map((item) => {
      const key = `border${item}-width`;
      const value = item.endsWith("right") || item.endsWith("bottom") ? `calc(${v} * var(--un-divide-${d}-reverse))` : `calc(${v} * calc(1 - var(--un-divide-${d}-reverse)))`;
      return [key, value];
    });
    if (results) {
      return [
        [`--un-divide-${d}-reverse`, 0],
        ...results
      ];
    }
  }
}

const lineClamps = [
  [/^line-clamp-(\d+)$/, ([, v]) => ({
    "overflow": "hidden",
    "display": "-webkit-box",
    "-webkit-box-orient": "vertical",
    "-webkit-line-clamp": v,
    "line-clamp": v
  }), { autocomplete: ["line-clamp", "line-clamp-<num>"] }],
  ...["none", ...utils$b.globalKeywords].map((keyword) => [`line-clamp-${keyword}`, {
    "overflow": "visible",
    "display": "block",
    "-webkit-box-orient": "horizontal",
    "-webkit-line-clamp": keyword,
    "line-clamp": keyword
  }])
];

const fontVariantNumericBase = {
  "--un-ordinal": _.varEmpty,
  "--un-slashed-zero": _.varEmpty,
  "--un-numeric-figure": _.varEmpty,
  "--un-numeric-spacing": _.varEmpty,
  "--un-numeric-fraction": _.varEmpty
};
function toEntries(entry) {
  return {
    ...entry,
    "font-variant-numeric": "var(--un-ordinal) var(--un-slashed-zero) var(--un-numeric-figure) var(--un-numeric-spacing) var(--un-numeric-fraction)"
  };
}
const fontVariantNumeric = [
  [/^ordinal$/, () => toEntries({ "--un-ordinal": "ordinal" }), { autocomplete: "ordinal" }],
  [/^slashed-zero$/, () => toEntries({ "--un-slashed-zero": "slashed-zero" }), { autocomplete: "slashed-zero" }],
  [/^lining-nums$/, () => toEntries({ "--un-numeric-figure": "lining-nums" }), { autocomplete: "lining-nums" }],
  [/^oldstyle-nums$/, () => toEntries({ "--un-numeric-figure": "oldstyle-nums" }), { autocomplete: "oldstyle-nums" }],
  [/^proportional-nums$/, () => toEntries({ "--un-numeric-spacing": "proportional-nums" }), { autocomplete: "proportional-nums" }],
  [/^tabular-nums$/, () => toEntries({ "--un-numeric-spacing": "tabular-nums" }), { autocomplete: "tabular-nums" }],
  [/^diagonal-fractions$/, () => toEntries({ "--un-numeric-fraction": "diagonal-fractions" }), { autocomplete: "diagonal-fractions" }],
  [/^stacked-fractions$/, () => toEntries({ "--un-numeric-fraction": "stacked-fractions" }), { autocomplete: "stacked-fractions" }],
  ["normal-nums", { "font-variant-numeric": "normal" }]
];

const touchActionBase = {
  "--un-pan-x": _.varEmpty,
  "--un-pan-y": _.varEmpty,
  "--un-pinch-zoom": _.varEmpty
};
const touchActionProperty = "var(--un-pan-x) var(--un-pan-y) var(--un-pinch-zoom)";
const touchActions = [
  [/^touch-pan-(x|left|right)$/, ([, d]) => ({
    "--un-pan-x": `pan-${d}`,
    "touch-action": touchActionProperty
  }), { autocomplete: ["touch-pan", "touch-pan-(x|left|right|y|up|down)"] }],
  [/^touch-pan-(y|up|down)$/, ([, d]) => ({
    "--un-pan-y": `pan-${d}`,
    "touch-action": touchActionProperty
  })],
  ["touch-pinch-zoom", {
    "--un-pinch-zoom": "pinch-zoom",
    "touch-action": touchActionProperty
  }],
  ["touch-auto", { "touch-action": "auto" }],
  ["touch-manipulation", { "touch-action": "manipulation" }],
  ["touch-none", { "touch-action": "none" }],
  ...utils$b.makeGlobalStaticRules("touch", "touch-action")
];

const scrollSnapTypeBase = {
  "--un-scroll-snap-strictness": "proximity"
};
const scrolls = [
  // snap type
  [/^snap-(x|y)$/, ([, d]) => ({
    "scroll-snap-type": `${d} var(--un-scroll-snap-strictness)`
  }), { autocomplete: "snap-(x|y|both)" }],
  [/^snap-both$/, () => ({
    "scroll-snap-type": "both var(--un-scroll-snap-strictness)"
  })],
  ["snap-mandatory", { "--un-scroll-snap-strictness": "mandatory" }],
  ["snap-proximity", { "--un-scroll-snap-strictness": "proximity" }],
  ["snap-none", { "scroll-snap-type": "none" }],
  // snap align
  ["snap-start", { "scroll-snap-align": "start" }],
  ["snap-end", { "scroll-snap-align": "end" }],
  ["snap-center", { "scroll-snap-align": "center" }],
  ["snap-align-none", { "scroll-snap-align": "none" }],
  // snap stop
  ["snap-normal", { "scroll-snap-stop": "normal" }],
  ["snap-always", { "scroll-snap-stop": "always" }],
  // scroll margin
  [/^scroll-ma?()-?(-?.+)$/, utils$b.directionSize("scroll-margin"), {
    autocomplete: [
      "scroll-(m|p|ma|pa|block|inline)",
      "scroll-(m|p|ma|pa|block|inline)-$spacing",
      "scroll-(m|p|ma|pa|block|inline)-(x|y|r|l|t|b|bs|be|is|ie)",
      "scroll-(m|p|ma|pa|block|inline)-(x|y|r|l|t|b|bs|be|is|ie)-$spacing"
    ]
  }],
  [/^scroll-m-?([xy])-?(-?.+)$/, utils$b.directionSize("scroll-margin")],
  [/^scroll-m-?([rltb])-?(-?.+)$/, utils$b.directionSize("scroll-margin")],
  [/^scroll-m-(block|inline)-(-?.+)$/, utils$b.directionSize("scroll-margin")],
  [/^scroll-m-?([bi][se])-?(-?.+)$/, utils$b.directionSize("scroll-margin")],
  // scroll padding
  [/^scroll-pa?()-?(-?.+)$/, utils$b.directionSize("scroll-padding")],
  [/^scroll-p-?([xy])-?(-?.+)$/, utils$b.directionSize("scroll-padding")],
  [/^scroll-p-?([rltb])-?(-?.+)$/, utils$b.directionSize("scroll-padding")],
  [/^scroll-p-(block|inline)-(-?.+)$/, utils$b.directionSize("scroll-padding")],
  [/^scroll-p-?([bi][se])-?(-?.+)$/, utils$b.directionSize("scroll-padding")]
];

const placeholders = [
  // The prefix `$ ` is intentional. This rule is not to be matched directly from user-generated token.
  // See variants/placeholder.
  [/^\$ placeholder-(.+)$/, utils$b.colorResolver("color", "placeholder", "accentColor"), { autocomplete: "placeholder-$colors" }],
  [/^\$ placeholder-op(?:acity)?-?(.+)$/, ([, opacity]) => ({ "--un-placeholder-opacity": utils$b.h.bracket.percent(opacity) }), { autocomplete: ["placeholder-(op|opacity)", "placeholder-(op|opacity)-<percent>"] }]
];

const viewTransition = [
  [/^view-transition-([\w_-]+)$/, ([, name]) => {
    return { "view-transition-name": name };
  }]
];

const rules = [
  ___namespace.cssVariables,
  cssVariables,
  ___namespace.cssProperty,
  container,
  ___namespace.contains,
  screenReadersAccess,
  ___namespace.pointerEvents,
  ___namespace.appearances,
  ___namespace.positions,
  ___namespace.insets,
  lineClamps,
  isolations,
  ___namespace.zIndexes,
  ___namespace.orders,
  ___namespace.grids,
  ___namespace.floats,
  ___namespace.margins,
  ___namespace.boxSizing,
  ___namespace.displays,
  ___namespace.aspectRatio,
  ___namespace.sizes,
  ___namespace.flex,
  tables,
  ___namespace.transforms,
  animations,
  ___namespace.cursors,
  touchActions,
  ___namespace.userSelects,
  ___namespace.resizes,
  scrolls,
  listStyle,
  ___namespace.appearance,
  columns$1,
  ___namespace.placements,
  ___namespace.alignments,
  ___namespace.justifies,
  ___namespace.gaps,
  ___namespace.flexGridJustifiesAlignments,
  spaces,
  divides,
  ___namespace.overflows,
  overscrolls,
  scrollBehaviors,
  ___namespace.textOverflows,
  ___namespace.whitespaces,
  ___namespace.breaks,
  ___namespace.borders,
  ___namespace.bgColors,
  backgroundStyles,
  ___namespace.svgUtilities,
  objectPositions,
  ___namespace.paddings,
  ___namespace.textAligns,
  ___namespace.textIndents,
  ___namespace.textWraps,
  ___namespace.verticalAligns,
  ___namespace.fonts,
  ___namespace.textTransforms,
  textTransforms,
  ___namespace.fontStyles,
  fontVariantNumeric,
  ___namespace.textDecorations,
  ___namespace.fontSmoothings,
  ___namespace.tabSizes,
  ___namespace.textStrokes,
  ___namespace.textShadows,
  hyphens$1,
  writingModes,
  writingOrientations,
  carets,
  accents,
  ___namespace.opacity,
  backgroundBlendModes,
  mixBlendModes,
  ___namespace.boxShadows,
  ___namespace.outline,
  ___namespace.rings,
  imageRenderings,
  filters,
  ___namespace.transitions,
  ___namespace.willChange,
  ___namespace.contentVisibility,
  ___namespace.contents,
  placeholders,
  ___namespace.containerParent,
  viewTransition,
  dynamicViewportHeight,
  // should be the last
  ___namespace.questionMark
].flat(1);

const shortcuts = [
  ...containerShortcuts
];

const theme = {
  ...theme$1.theme,
  aria: {
    busy: 'busy="true"',
    checked: 'checked="true"',
    disabled: 'disabled="true"',
    expanded: 'expanded="true"',
    hidden: 'hidden="true"',
    pressed: 'pressed="true"',
    readonly: 'readonly="true"',
    required: 'required="true"',
    selected: 'selected="true"'
  },
  animation: {
    keyframes: {
      "pulse": "{0%, 100% {opacity:1} 50% {opacity:.5}}",
      "bounce": "{0%, 100% {transform:translateY(-25%);animation-timing-function:cubic-bezier(0.8,0,1,1)} 50% {transform:translateY(0);animation-timing-function:cubic-bezier(0,0,0.2,1)}}",
      "spin": "{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}",
      "ping": "{0%{transform:scale(1);opacity:1}75%,100%{transform:scale(2);opacity:0}}",
      "bounce-alt": "{from,20%,53%,80%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1);transform:translate3d(0,0,0)}40%,43%{animation-timing-function:cubic-bezier(0.755,0.05,0.855,0.06);transform:translate3d(0,-30px,0)}70%{animation-timing-function:cubic-bezier(0.755,0.05,0.855,0.06);transform:translate3d(0,-15px,0)}90%{transform:translate3d(0,-4px,0)}}",
      "flash": "{from,50%,to{opacity:1}25%,75%{opacity:0}}",
      "pulse-alt": "{from{transform:scale3d(1,1,1)}50%{transform:scale3d(1.05,1.05,1.05)}to{transform:scale3d(1,1,1)}}",
      "rubber-band": "{from{transform:scale3d(1,1,1)}30%{transform:scale3d(1.25,0.75,1)}40%{transform:scale3d(0.75,1.25,1)}50%{transform:scale3d(1.15,0.85,1)}65%{transform:scale3d(0.95,1.05,1)}75%{transform:scale3d(1.05,0.95,1)}to{transform:scale3d(1,1,1)}}",
      "shake-x": "{from,to{transform:translate3d(0,0,0)}10%,30%,50%,70%,90%{transform:translate3d(-10px,0,0)}20%,40%,60%,80%{transform:translate3d(10px,0,0)}}",
      "shake-y": "{from,to{transform:translate3d(0,0,0)}10%,30%,50%,70%,90%{transform:translate3d(0,-10px,0)}20%,40%,60%,80%{transform:translate3d(0,10px,0)}}",
      "head-shake": "{0%{transform:translateX(0)}6.5%{transform:translateX(-6px) rotateY(-9deg)}18.5%{transform:translateX(5px) rotateY(7deg)}31.5%{transform:translateX(-3px) rotateY(-5deg)}43.5%{transform:translateX(2px) rotateY(3deg)}50%{transform:translateX(0)}}",
      "swing": "{20%{transform:rotate3d(0,0,1,15deg)}40%{transform:rotate3d(0,0,1,-10deg)}60%{transform:rotate3d(0,0,1,5deg)}80%{transform:rotate3d(0,0,1,-5deg)}to{transform:rotate3d(0,0,1,0deg)}}",
      "tada": "{from{transform:scale3d(1,1,1)}10%,20%{transform:scale3d(0.9,0.9,0.9) rotate3d(0,0,1,-3deg)}30%,50%,70%,90%{transform:scale3d(1.1,1.1,1.1) rotate3d(0,0,1,3deg)}40%,60%,80%{transform:scale3d(1.1,1.1,1.1) rotate3d(0,0,1,-3deg)}to{transform:scale3d(1,1,1)}}",
      "wobble": "{from{transform:translate3d(0,0,0)}15%{transform:translate3d(-25%,0,0) rotate3d(0,0,1,-5deg)}30%{transform:translate3d(20%,0,0) rotate3d(0,0,1,3deg)}45%{transform:translate3d(-15%,0,0) rotate3d(0,0,1,-3deg)}60%{transform:translate3d(10%,0,0) rotate3d(0,0,1,2deg)}75%{transform:translate3d(-5%,0,0) rotate3d(0,0,1,-1deg)}to{transform:translate3d(0,0,0)}}",
      "jello": "{from,11.1%,to{transform:translate3d(0,0,0)}22.2%{transform:skewX(-12.5deg) skewY(-12.5deg)}33.3%{transform:skewX(6.25deg) skewY(6.25deg)}44.4%{transform:skewX(-3.125deg)skewY(-3.125deg)}55.5%{transform:skewX(1.5625deg) skewY(1.5625deg)}66.6%{transform:skewX(-0.78125deg) skewY(-0.78125deg)}77.7%{transform:skewX(0.390625deg) skewY(0.390625deg)}88.8%{transform:skewX(-0.1953125deg) skewY(-0.1953125deg)}}",
      "heart-beat": "{0%{transform:scale(1)}14%{transform:scale(1.3)}28%{transform:scale(1)}42%{transform:scale(1.3)}70%{transform:scale(1)}}",
      "hinge": "{0%{transform-origin:top left;animation-timing-function:ease-in-out}20%,60%{transform:rotate3d(0,0,1,80deg);transform-origin:top left;animation-timing-function:ease-in-out}40%,80%{transform:rotate3d(0,0,1,60deg);transform-origin:top left;animation-timing-function:ease-in-out}to{transform:translate3d(0,700px,0);opacity:0}}",
      "jack-in-the-box": "{from{opacity:0;transform-origin:center bottom;transform:scale(0.1) rotate(30deg)}50%{transform:rotate(-10deg)}70%{transform:rotate(3deg)}to{transform:scale(1)}}",
      "light-speed-in-left": "{from{opacity:0;transform:translate3d(-100%,0,0) skewX(-30deg)}60%{opacity:1;transform:skewX(20deg)}80%{transform:skewX(-5deg)}to{transform:translate3d(0,0,0)}}",
      "light-speed-in-right": "{from{opacity:0;transform:translate3d(100%,0,0) skewX(-30deg)}60%{opacity:1;transform:skewX(20deg)}80%{transform:skewX(-5deg)}to{transform:translate3d(0,0,0)}}",
      "light-speed-out-left": "{from{opacity:1}to{opacity:0;transform:translate3d(-100%,0,0) skewX(30deg)}}",
      "light-speed-out-right": "{from{opacity:1}to{opacity:0;transform:translate3d(100%,0,0) skewX(30deg)}}",
      "flip": "{from{transform:perspective(400px) scale3d(1,1,1) translate3d(0,0,0) rotate3d(0,1,0,-360deg);animation-timing-function:ease-out}40%{transform:perspective(400px) scale3d(1,1,1) translate3d(0,0,150px) rotate3d(0,1,0,-190deg);animation-timing-function:ease-out}50%{transform:perspective(400px) scale3d(1,1,1) translate3d(0,0,150px) rotate3d(0,1,0,-170deg);animation-timing-function:ease-in}80%{transform:perspective(400px) scale3d(0.95,0.95,0.95) translate3d(0,0,0) rotate3d(0,1,0,0deg);animation-timing-function:ease-in}to{transform:perspective(400px) scale3d(1,1,1) translate3d(0,0,0) rotate3d(0,1,0,0deg);animation-timing-function:ease-in}}",
      "flip-in-x": "{from{transform:perspective(400px) rotate3d(1,0,0,90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotate3d(1,0,0,-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotate3d(1,0,0,10deg);opacity:1}80%{transform:perspective(400px) rotate3d(1,0,0,-5deg)}to{transform:perspective(400px)}}",
      "flip-in-y": "{from{transform:perspective(400px) rotate3d(0,1,0,90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotate3d(0,1,0,-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotate3d(0,1,0,10deg);opacity:1}80%{transform:perspective(400px) rotate3d(0,1,0,-5deg)}to{transform:perspective(400px)}}",
      "flip-out-x": "{from{transform:perspective(400px)}30%{transform:perspective(400px) rotate3d(1,0,0,-20deg);opacity:1}to{transform:perspective(400px) rotate3d(1,0,0,90deg);opacity:0}}",
      "flip-out-y": "{from{transform:perspective(400px)}30%{transform:perspective(400px) rotate3d(0,1,0,-15deg);opacity:1}to{transform:perspective(400px) rotate3d(0,1,0,90deg);opacity:0}}",
      "rotate-in": "{from{transform-origin:center;transform:rotate3d(0,0,1,-200deg);opacity:0}to{transform-origin:center;transform:translate3d(0,0,0);opacity:1}}",
      "rotate-in-down-left": "{from{transform-origin:left bottom;transform:rotate3d(0,0,1,-45deg);opacity:0}to{transform-origin:left bottom;transform:translate3d(0,0,0);opacity:1}}",
      "rotate-in-down-right": "{from{transform-origin:right bottom;transform:rotate3d(0,0,1,45deg);opacity:0}to{transform-origin:right bottom;transform:translate3d(0,0,0);opacity:1}}",
      "rotate-in-up-left": "{from{transform-origin:left top;transform:rotate3d(0,0,1,45deg);opacity:0}to{transform-origin:left top;transform:translate3d(0,0,0);opacity:1}}",
      "rotate-in-up-right": "{from{transform-origin:right bottom;transform:rotate3d(0,0,1,-90deg);opacity:0}to{transform-origin:right bottom;transform:translate3d(0,0,0);opacity:1}}",
      "rotate-out": "{from{transform-origin:center;opacity:1}to{transform-origin:center;transform:rotate3d(0,0,1,200deg);opacity:0}}",
      "rotate-out-down-left": "{from{transform-origin:left bottom;opacity:1}to{transform-origin:left bottom;transform:rotate3d(0,0,1,45deg);opacity:0}}",
      "rotate-out-down-right": "{from{transform-origin:right bottom;opacity:1}to{transform-origin:right bottom;transform:rotate3d(0,0,1,-45deg);opacity:0}}",
      "rotate-out-up-left": "{from{transform-origin:left bottom;opacity:1}to{transform-origin:left bottom;transform:rotate3d(0,0,1,-45deg);opacity:0}}",
      "rotate-out-up-right": "{from{transform-origin:right bottom;opacity:1}to{transform-origin:left bottom;transform:rotate3d(0,0,1,90deg);opacity:0}}",
      "roll-in": "{from{opacity:0;transform:translate3d(-100%,0,0) rotate3d(0,0,1,-120deg)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "roll-out": "{from{opacity:1}to{opacity:0;transform:translate3d(100%,0,0) rotate3d(0,0,1,120deg)}}",
      "zoom-in": "{from{opacity:0;transform:scale3d(0.3,0.3,0.3)}50%{opacity:1}}",
      "zoom-in-down": "{from{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(0,-1000px,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}60%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(0,60px,0);animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
      "zoom-in-left": "{from{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(-1000px,0,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}60%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(10px,0,0);animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
      "zoom-in-right": "{from{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(1000px,0,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}60%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(-10px,0,0);animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
      "zoom-in-up": "{from{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(0,1000px,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}60%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(0,-60px,0);animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
      "zoom-out": "{from{opacity:1}50%{opacity:0;transform:scale3d(0.3,0.3,0.3)}to{opacity:0}}",
      "zoom-out-down": "{40%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(0,-60px,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}to{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(0,2000px,0);transform-origin:center bottom;animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
      "zoom-out-left": "{40%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(42px,0,0)}to{opacity:0;transform:scale(0.1) translate3d(-2000px,0,0);transform-origin:left center}}",
      "zoom-out-right": "{40%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(-42px,0,0)}to{opacity:0;transform:scale(0.1) translate3d(2000px,0,0);transform-origin:right center}}",
      "zoom-out-up": "{40%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(0,60px,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}to{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(0,-2000px,0);transform-origin:center bottom;animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
      "bounce-in": "{from,20%,40%,60%,80%,to{animation-timing-function:ease-in-out}0%{opacity:0;transform:scale3d(0.3,0.3,0.3)}20%{transform:scale3d(1.1,1.1,1.1)}40%{transform:scale3d(0.9,0.9,0.9)}60%{transform:scale3d(1.03,1.03,1.03);opacity:1}80%{transform:scale3d(0.97,0.97,0.97)}to{opacity:1;transform:scale3d(1,1,1)}}",
      "bounce-in-down": "{from,60%,75%,90%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1)}0%{opacity:0;transform:translate3d(0,-3000px,0)}60%{opacity:1;transform:translate3d(0,25px,0)}75%{transform:translate3d(0,-10px,0)}90%{transform:translate3d(0,5px,0)}to{transform:translate3d(0,0,0)}}",
      "bounce-in-left": "{from,60%,75%,90%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1)}0%{opacity:0;transform:translate3d(-3000px,0,0)}60%{opacity:1;transform:translate3d(25px,0,0)}75%{transform:translate3d(-10px,0,0)}90%{transform:translate3d(5px,0,0)}to{transform:translate3d(0,0,0)}}",
      "bounce-in-right": "{from,60%,75%,90%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1)}0%{opacity:0;transform:translate3d(3000px,0,0)}60%{opacity:1;transform:translate3d(-25px,0,0)}75%{transform:translate3d(10px,0,0)}90%{transform:translate3d(-5px,0,0)}to{transform:translate3d(0,0,0)}}",
      "bounce-in-up": "{from,60%,75%,90%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1)}0%{opacity:0;transform:translate3d(0,3000px,0)}60%{opacity:1;transform:translate3d(0,-20px,0)}75%{transform:translate3d(0,10px,0)}90%{transform:translate3d(0,-5px,0)}to{transform:translate3d(0,0,0)}}",
      "bounce-out": "{20%{transform:scale3d(0.9,0.9,0.9)}50%,55%{opacity:1;transform:scale3d(1.1,1.1,1.1)}to{opacity:0;transform:scale3d(0.3,0.3,0.3)}}",
      "bounce-out-down": "{20%{transform:translate3d(0,10px,0)}40%,45%{opacity:1;transform:translate3d(0,-20px,0)}to{opacity:0;transform:translate3d(0,2000px,0)}}",
      "bounce-out-left": "{20%{opacity:1;transform:translate3d(20px,0,0)}to{opacity:0;transform:translate3d(-2000px,0,0)}}",
      "bounce-out-right": "{20%{opacity:1;transform:translate3d(-20px,0,0)}to{opacity:0;transform:translate3d(2000px,0,0)}}",
      "bounce-out-up": "{20%{transform:translate3d(0,-10px,0)}40%,45%{opacity:1;transform:translate3d(0,20px,0)}to{opacity:0;transform:translate3d(0,-2000px,0)}}",
      "slide-in-down": "{from{transform:translate3d(0,-100%,0);visibility:visible}to{transform:translate3d(0,0,0)}}",
      "slide-in-left": "{from{transform:translate3d(-100%,0,0);visibility:visible}to{transform:translate3d(0,0,0)}}",
      "slide-in-right": "{from{transform:translate3d(100%,0,0);visibility:visible}to{transform:translate3d(0,0,0)}}",
      "slide-in-up": "{from{transform:translate3d(0,100%,0);visibility:visible}to{transform:translate3d(0,0,0)}}",
      "slide-out-down": "{from{transform:translate3d(0,0,0)}to{visibility:hidden;transform:translate3d(0,100%,0)}}",
      "slide-out-left": "{from{transform:translate3d(0,0,0)}to{visibility:hidden;transform:translate3d(-100%,0,0)}}",
      "slide-out-right": "{from{transform:translate3d(0,0,0)}to{visibility:hidden;transform:translate3d(100%,0,0)}}",
      "slide-out-up": "{from{transform:translate3d(0,0,0)}to{visibility:hidden;transform:translate3d(0,-100%,0)}}",
      "fade-in": "{from{opacity:0}to{opacity:1}}",
      "fade-in-down": "{from{opacity:0;transform:translate3d(0,-100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-down-big": "{from{opacity:0;transform:translate3d(0,-2000px,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-left": "{from{opacity:0;transform:translate3d(-100%,0,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-left-big": "{from{opacity:0;transform:translate3d(-2000px,0,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-right": "{from{opacity:0;transform:translate3d(100%,0,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-right-big": "{from{opacity:0;transform:translate3d(2000px,0,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-up": "{from{opacity:0;transform:translate3d(0,100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-up-big": "{from{opacity:0;transform:translate3d(0,2000px,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-top-left": "{from{opacity:0;transform:translate3d(-100%,-100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-top-right": "{from{opacity:0;transform:translate3d(100%,-100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-bottom-left": "{from{opacity:0;transform:translate3d(-100%,100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-in-bottom-right": "{from{opacity:0;transform:translate3d(100%,100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
      "fade-out": "{from{opacity:1}to{opacity:0}}",
      "fade-out-down": "{from{opacity:1}to{opacity:0;transform:translate3d(0,100%,0)}}",
      "fade-out-down-big": "{from{opacity:1}to{opacity:0;transform:translate3d(0,2000px,0)}}",
      "fade-out-left": "{from{opacity:1}to{opacity:0;transform:translate3d(-100%,0,0)}}",
      "fade-out-left-big": "{from{opacity:1}to{opacity:0;transform:translate3d(-2000px,0,0)}}",
      "fade-out-right": "{from{opacity:1}to{opacity:0;transform:translate3d(100%,0,0)}}",
      "fade-out-right-big": "{from{opacity:1}to{opacity:0;transform:translate3d(2000px,0,0)}}",
      "fade-out-up": "{from{opacity:1}to{opacity:0;transform:translate3d(0,-100%,0)}}",
      "fade-out-up-big": "{from{opacity:1}to{opacity:0;transform:translate3d(0,-2000px,0)}}",
      "fade-out-top-left": "{from{opacity:1;transform:translate3d(0,0,0)}to{opacity:0;transform:translate3d(-100%,-100%,0)}}",
      "fade-out-top-right": "{from{opacity:1;transform:translate3d(0,0,0)}to{opacity:0;transform:translate3d(100%,-100%,0)}}",
      "fade-out-bottom-left": "{from{opacity:1;transform:translate3d(0,0,0)}to{opacity:0;transform:translate3d(-100%,100%,0)}}",
      "fade-out-bottom-right": "{from{opacity:1;transform:translate3d(0,0,0)}to{opacity:0;transform:translate3d(100%,100%,0)}}",
      "back-in-up": "{0%{opacity:0.7;transform:translateY(1200px) scale(0.7)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:1;transform:scale(1)}}",
      "back-in-down": "{0%{opacity:0.7;transform:translateY(-1200px) scale(0.7)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:1;transform:scale(1)}}",
      "back-in-right": "{0%{opacity:0.7;transform:translateX(2000px) scale(0.7)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:1;transform:scale(1)}}",
      "back-in-left": "{0%{opacity:0.7;transform:translateX(-2000px) scale(0.7)}80%{opacity:0.7;transform:translateX(0px) scale(0.7)}100%{opacity:1;transform:scale(1)}}",
      "back-out-up": "{0%{opacity:1;transform:scale(1)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:0.7;transform:translateY(-700px) scale(0.7)}}",
      "back-out-down": "{0%{opacity:1;transform:scale(1)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:0.7;transform:translateY(700px) scale(0.7)}}",
      "back-out-right": "{0%{opacity:1;transform:scale(1)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:0.7;transform:translateX(2000px) scale(0.7)}}",
      "back-out-left": "{0%{opacity:1;transform:scale(1)}80%{opacity:0.7;transform:translateX(-2000px) scale(0.7)}100%{opacity:0.7;transform:translateY(-700px) scale(0.7)}}"
    },
    durations: {
      "pulse": "2s",
      "heart-beat": "1.3s",
      "bounce-in": "0.75s",
      "bounce-out": "0.75s",
      "flip-out-x": "0.75s",
      "flip-out-y": "0.75s",
      "hinge": "2s"
    },
    timingFns: {
      "pulse": "cubic-bezier(0.4,0,.6,1)",
      "ping": "cubic-bezier(0,0,.2,1)",
      "head-shake": "ease-in-out",
      "heart-beat": "ease-in-out",
      "pulse-alt": "ease-in-out",
      "light-speed-in-left": "ease-out",
      "light-speed-in-right": "ease-out",
      "light-speed-out-left": "ease-in",
      "light-speed-out-right": "ease-in"
    },
    properties: {
      "bounce-alt": { "transform-origin": "center bottom" },
      "jello": { "transform-origin": "center" },
      "swing": { "transform-origin": "top center" },
      "flip": { "backface-visibility": "visible" },
      "flip-in-x": { "backface-visibility": "visible !important" },
      "flip-in-y": { "backface-visibility": "visible !important" },
      "flip-out-x": { "backface-visibility": "visible !important" },
      "flip-out-y": { "backface-visibility": "visible !important" },
      "rotate-in": { "transform-origin": "center" },
      "rotate-in-down-left": { "transform-origin": "left bottom" },
      "rotate-in-down-right": { "transform-origin": "right bottom" },
      "rotate-in-up-left": { "transform-origin": "left bottom" },
      "rotate-in-up-right": { "transform-origin": "right bottom" },
      "rotate-out": { "transform-origin": "center" },
      "rotate-out-down-left": { "transform-origin": "left bottom" },
      "rotate-out-down-right": { "transform-origin": "right bottom" },
      "rotate-out-up-left": { "transform-origin": "left bottom" },
      "rotate-out-up-right": { "transform-origin": "right bottom" },
      "hinge": { "transform-origin": "top left" },
      "zoom-out-down": { "transform-origin": "center bottom" },
      "zoom-out-left": { "transform-origin": "left center" },
      "zoom-out-right": { "transform-origin": "right center" },
      "zoom-out-up": { "transform-origin": "center bottom" }
    },
    counts: {
      "spin": "infinite",
      "ping": "infinite",
      "pulse": "infinite",
      "pulse-alt": "infinite",
      "bounce": "infinite",
      "bounce-alt": "infinite"
    }
  },
  media: {
    portrait: "(orientation: portrait)",
    landscape: "(orientation: landscape)",
    os_dark: "(prefers-color-scheme: dark)",
    os_light: "(prefers-color-scheme: light)",
    motion_ok: "(prefers-reduced-motion: no-preference)",
    motion_not_ok: "(prefers-reduced-motion: reduce)",
    high_contrast: "(prefers-contrast: high)",
    low_contrast: "(prefers-contrast: low)",
    opacity_ok: "(prefers-reduced-transparency: no-preference)",
    opacity_not_ok: "(prefers-reduced-transparency: reduce)",
    use_data_ok: "(prefers-reduced-data: no-preference)",
    use_data_not_ok: "(prefers-reduced-data: reduce)",
    touch: "(hover: none) and (pointer: coarse)",
    stylus: "(hover: none) and (pointer: fine)",
    pointer: "(hover) and (pointer: coarse)",
    mouse: "(hover) and (pointer: fine)",
    hd_color: "(dynamic-range: high)"
  },
  supports: {
    grid: "(display: grid)"
  },
  preflightBase: {
    ..._.transformBase,
    ...touchActionBase,
    ...scrollSnapTypeBase,
    ...fontVariantNumericBase,
    ...borderSpacingBase,
    ..._.boxShadowsBase,
    ..._.ringBase,
    ...filterBase,
    ...backdropFilterBase
  }
};

const variantCombinators = [
  utils$b.variantMatcher("svg", (input) => ({ selector: `${input.selector} svg` }))
];

const variantColorsScheme = [
  utils$b.variantMatcher(".dark", (input) => ({ prefix: `.dark $$ ${input.prefix}` })),
  utils$b.variantMatcher(".light", (input) => ({ prefix: `.light $$ ${input.prefix}` })),
  utils$b.variantParentMatcher("@dark", "@media (prefers-color-scheme: dark)"),
  utils$b.variantParentMatcher("@light", "@media (prefers-color-scheme: light)")
];

const variantContrasts = [
  utils$b.variantParentMatcher("contrast-more", "@media (prefers-contrast: more)"),
  utils$b.variantParentMatcher("contrast-less", "@media (prefers-contrast: less)")
];
const variantMotions = [
  utils$b.variantParentMatcher("motion-reduce", "@media (prefers-reduced-motion: reduce)"),
  utils$b.variantParentMatcher("motion-safe", "@media (prefers-reduced-motion: no-preference)")
];
const variantOrientations = [
  utils$b.variantParentMatcher("landscape", "@media (orientation: landscape)"),
  utils$b.variantParentMatcher("portrait", "@media (orientation: portrait)")
];

const variantSpaceAndDivide = (matcher) => {
  if (matcher.startsWith("_"))
    return;
  if (/space-([xy])-(-?.+)$/.test(matcher) || /divide-/.test(matcher)) {
    return {
      matcher,
      selector: (input) => {
        const not = ">:not([hidden])~:not([hidden])";
        return input.includes(not) ? input : `${input}${not}`;
      }
    };
  }
};
const variantStickyHover = [
  ruleUtils$2.variantMatcher("@hover", (input) => ({
    parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (hover: hover) and (pointer: fine)`,
    selector: `${input.selector || ""}:hover`
  }))
];

const placeholderModifier = (input, { theme }) => {
  const m = input.match(/^(.*)\b(placeholder-)(.+)$/);
  if (m) {
    const [, pre = "", p, body] = m;
    if (utils$b.hasParseableColor(body, theme, "accentColor") || hasOpacityValue(body)) {
      return {
        // Append `placeholder-$ ` (with space!) to the rule to be matched.
        // The `placeholder-` is added for placeholder variant processing, and
        // the `$ ` is added for rule matching after `placeholder-` is removed by the variant.
        // See rules/placeholder.
        matcher: `${pre}placeholder-$ ${p}${body}`
      };
    }
  }
};
function hasOpacityValue(body) {
  const match = body.match(/^op(?:acity)?-?(.+)$/);
  if (match && match[1] != null)
    return utils$b.h.bracket.percent(match[1]) != null;
  return false;
}

function variants(options) {
  return [
    placeholderModifier,
    variantSpaceAndDivide,
    ...variants$1.variants(options),
    ...variantContrasts,
    ...variantOrientations,
    ...variantMotions,
    ...variantCombinators,
    ...variantColorsScheme,
    ...variantStickyHover
  ];
}

function important(option) {
  if (option == null || option === false)
    return [];
  const wrapWithIs = (selector) => {
    if (selector.startsWith(":is(") && selector.endsWith(")"))
      return selector;
    if (selector.includes("::"))
      return selector.replace(/(.*)(::.*)/, ":is($1)$2");
    return `:is(${selector})`;
  };
  return [
    option === true ? (util) => {
      util.entries.forEach((i) => {
        if (i[1] != null && !String(i[1]).endsWith("!important"))
          i[1] += " !important";
      });
    } : (util) => {
      if (!util.selector.startsWith(option))
        util.selector = `${option} ${wrapWithIs(util.selector)}`;
    }
  ];
}

function postprocessors(options) {
  return [
    ...core$d.toArray(presetMini__default(options).postprocess),
    ...important(options.important)
  ];
}

const presetWind$1 = core$d.definePreset((options = {}) => {
  options.important = options.important ?? false;
  return {
    ...presetMini.presetMini(options),
    name: "@unocss/preset-wind",
    theme,
    rules,
    shortcuts,
    variants: variants(options),
    postprocess: postprocessors(options)
  };
});

dist$n.colors = presetMini.colors;
dist$n.preflights = presetMini.preflights;
dist$n.default = presetWind$1;
dist$n.presetWind = presetWind$1;
dist$n.rules = rules;
dist$n.shortcuts = shortcuts;
dist$n.theme = theme;
dist$n.variants = variants;

Object.defineProperty(dist$o, '__esModule', { value: true });

const core$c = dist$p;
const presetWind = dist$n;
const ruleUtils$1 = dist$k;

function mixComponent(v1, v2, w) {
  return `calc(${v2} + (${v1} - ${v2}) * ${w} / 100)`;
}
function mixColor(color1, color2, weight) {
  const colors = [color1, color2];
  const cssColors = [];
  for (let c = 0; c < 2; c++) {
    const color = typeof colors[c] === "string" ? ruleUtils$1.parseCssColor(colors[c]) : colors[c];
    if (!color || !["rgb", "rgba"].includes(color.type))
      return;
    cssColors.push(color);
  }
  const newComponents = [];
  for (let x = 0; x < 3; x++)
    newComponents.push(mixComponent(cssColors[0].components[x], cssColors[1].components[x], weight));
  return {
    type: "rgb",
    components: newComponents,
    alpha: mixComponent(cssColors[0].alpha ?? 1, cssColors[1].alpha ?? 1, weight)
  };
}
function tint(color, weight) {
  return mixColor("#fff", color, weight);
}
function shade(color, weight) {
  return mixColor("#000", color, weight);
}
function shift(color, weight) {
  const num = Number.parseFloat(`${weight}`);
  if (!Number.isNaN(num))
    return num > 0 ? shade(color, weight) : tint(color, -num);
}
const fns = { tint, shade, shift };
function variantColorMix() {
  let re;
  return {
    name: "mix",
    match(matcher, ctx) {
      if (!re)
        re = new RegExp(`^mix-(tint|shade|shift)-(-?\\d{1,3})(?:${ctx.generator.config.separators.join("|")})`);
      const m = matcher.match(re);
      if (m) {
        return {
          matcher: matcher.slice(m[0].length),
          body: (body) => {
            body.forEach((v) => {
              if (v[1]) {
                const color = ruleUtils$1.parseCssColor(`${v[1]}`);
                if (color) {
                  const mixed = fns[m[1]](color, m[2]);
                  if (mixed)
                    v[1] = ruleUtils$1.colorToString(mixed);
                }
              }
            });
            return body;
          }
        };
      }
    }
  };
}

const presetUno = core$c.definePreset((options = {}) => {
  const wind = presetWind.presetWind(options);
  return {
    ...wind,
    name: "@unocss/preset-uno",
    variants: [
      ...wind.variants,
      variantColorMix()
    ]
  };
});

dist$o.default = presetUno;
dist$o.presetUno = presetUno;

var dist$j = {};

Object.defineProperty(dist$j, '__esModule', { value: true });

const core$b = dist$p;

const variantsRE = /^(?!.*\[(?:[^:]+):(?:.+)\]$)((?:.+:)?!?)?(.*)$/;
function variantAttributify(options = {}) {
  const prefix = options.prefix ?? "un-";
  const prefixedOnly = options.prefixedOnly ?? false;
  const trueToNonValued = options.trueToNonValued ?? false;
  let variantsValueRE;
  return {
    name: "attributify",
    match(input, { generator }) {
      const match = core$b.isAttributifySelector(input);
      if (!match)
        return;
      let name = match[1];
      if (name.startsWith(prefix))
        name = name.slice(prefix.length);
      else if (prefixedOnly)
        return;
      const content = match[2];
      const [, variants = "", body = content] = content.match(variantsRE) || [];
      if (body === "~" || trueToNonValued && body === "true" || !body)
        return `${variants}${name}`;
      if (variantsValueRE == null) {
        const separators = generator?.config?.separators?.join("|");
        if (separators)
          variantsValueRE = new RegExp(`^(.*\\](?:${separators}))(\\[[^\\]]+?\\])$`);
        else
          variantsValueRE = false;
      }
      if (variantsValueRE) {
        const [, bodyVariant, bracketValue] = content.match(variantsValueRE) || [];
        if (bracketValue)
          return `${bodyVariant}${variants}${name}-${bracketValue}`;
      }
      return `${variants}${name}-${body}`;
    }
  };
}

const elementRE$1 = /(<\w[\w:\.$-]*\s)((?:'[^>]*?'|"[^>]*?"|`[^>]*?`|\{[^>]*?\}|[^>]*?)*)/g;
const valuedAttributeRE$1 = /([?]|(?!\d|-{2}|-\d)[a-zA-Z0-9\u00A0-\uFFFF-_:%-]+)(?:=("[^"]*|'[^']*))?/g;
const splitterRE$1 = /[\s'"`;>]+/;
function autocompleteExtractorAttributify(options) {
  return {
    name: "attributify",
    extract: ({ content, cursor }) => {
      const matchedElements = content.matchAll(elementRE$1);
      let attrs;
      let elPos = 0;
      for (const match of matchedElements) {
        const [, prefix, content2] = match;
        const currentPos2 = match.index + prefix.length;
        if (cursor > currentPos2 && cursor <= currentPos2 + content2.length) {
          elPos = currentPos2;
          attrs = content2;
          break;
        }
      }
      if (!attrs)
        return null;
      const matchedAttributes = attrs.matchAll(valuedAttributeRE$1);
      let attrsPos = 0;
      let attrName;
      let attrValues;
      for (const match of matchedAttributes) {
        const [matched, name, rawValues] = match;
        const currentPos2 = elPos + match.index;
        if (cursor > currentPos2 && cursor <= currentPos2 + matched.length) {
          attrsPos = currentPos2;
          attrName = name;
          attrValues = rawValues?.slice(1);
          break;
        }
      }
      if (!attrName)
        return null;
      if (attrName === "class" || attrName === "className" || attrName === ":class")
        return null;
      const hasPrefix = !!options?.prefix && attrName.startsWith(options.prefix);
      if (options?.prefixedOnly && !hasPrefix)
        return null;
      const attrNameWithoutPrefix = hasPrefix ? attrName.slice(options.prefix.length) : attrName;
      if (attrValues === void 0) {
        return {
          extracted: attrNameWithoutPrefix,
          resolveReplacement(suggestion) {
            const startOffset = hasPrefix ? options.prefix.length : 0;
            return {
              start: attrsPos + startOffset,
              end: attrsPos + attrName.length,
              replacement: suggestion
            };
          }
        };
      }
      const attrValuePos = attrsPos + attrName.length + 2;
      let matchSplit = splitterRE$1.exec(attrValues);
      let currentPos = 0;
      let value;
      while (matchSplit) {
        const [matched] = matchSplit;
        if (cursor > attrValuePos + currentPos && cursor <= attrValuePos + currentPos + matchSplit.index) {
          value = attrValues.slice(currentPos, currentPos + matchSplit.index);
          break;
        }
        currentPos += matchSplit.index + matched.length;
        matchSplit = splitterRE$1.exec(attrValues.slice(currentPos));
      }
      if (value === void 0)
        value = attrValues.slice(currentPos);
      const [, variants = "", body] = value.match(variantsRE) || [];
      return {
        extracted: `${variants}${attrNameWithoutPrefix}-${body}`,
        transformSuggestions(suggestions) {
          return suggestions.filter((v) => v.startsWith(`${variants}${attrNameWithoutPrefix}-`)).map((v) => variants + v.slice(variants.length + attrNameWithoutPrefix.length + 1));
        },
        resolveReplacement(suggestion) {
          return {
            start: currentPos + attrValuePos,
            end: currentPos + attrValuePos + value.length,
            replacement: variants + suggestion.slice(variants.length + attrNameWithoutPrefix.length + 1)
          };
        }
      };
    }
  };
}

const strippedPrefixes = [
  "v-bind:",
  ":"
];
const splitterRE = /[\s'"`;]+/g;
const elementRE$2 = /<[^>\s]*\s((?:'.*?'|".*?"|`.*?`|\{.*?\}|=>|[^>]*?)*)/g;
const valuedAttributeRE$2 = /([?]|(?!\d|-{2}|-\d)[a-zA-Z0-9\u00A0-\uFFFF-_:!%-.~<]+)=?(?:["]([^"]*)["]|[']([^']*)[']|[{]([^}]*)[}])?/gms;
const defaultIgnoreAttributes = ["placeholder", "fill", "opacity", "stroke-opacity"];
function extractorAttributify(options) {
  const ignoreAttributes = options?.ignoreAttributes ?? defaultIgnoreAttributes;
  const nonValuedAttribute = options?.nonValuedAttribute ?? true;
  const trueToNonValued = options?.trueToNonValued ?? false;
  return {
    name: "@unocss/preset-attributify/extractor",
    extract({ code }) {
      return Array.from(code.matchAll(elementRE$2)).flatMap((match) => Array.from((match[1] || "").matchAll(valuedAttributeRE$2))).flatMap(([, name, ...contents]) => {
        const content = contents.filter(Boolean).join("");
        if (ignoreAttributes.includes(name))
          return [];
        for (const prefix of strippedPrefixes) {
          if (name.startsWith(prefix)) {
            name = name.slice(prefix.length);
            break;
          }
        }
        if (!content) {
          if (core$b.isValidSelector(name) && nonValuedAttribute !== false) {
            const result = [`[${name}=""]`];
            if (trueToNonValued)
              result.push(`[${name}="true"]`);
            return result;
          }
          return [];
        }
        if (["class", "className"].includes(name)) {
          return content.split(splitterRE).filter(core$b.isValidSelector);
        } else if (elementRE$2.test(content)) {
          elementRE$2.lastIndex = 0;
          return this.extract({ code: content });
        } else {
          if (options?.prefixedOnly && options.prefix && !name.startsWith(options.prefix))
            return [];
          return content.split(splitterRE).filter((v) => Boolean(v) && v !== ":").map((v) => `[${name}~="${v}"]`);
        }
      });
    }
  };
}

const presetAttributify = core$b.definePreset((options = {}) => {
  options.strict = options.strict ?? false;
  options.prefix = options.prefix ?? "un-";
  options.prefixedOnly = options.prefixedOnly ?? false;
  options.nonValuedAttribute = options.nonValuedAttribute ?? true;
  options.ignoreAttributes = options.ignoreAttributes ?? defaultIgnoreAttributes;
  const variants = [
    variantAttributify(options)
  ];
  const extractors = [
    extractorAttributify(options)
  ];
  const autocompleteExtractors = [
    autocompleteExtractorAttributify(options)
  ];
  return {
    name: "@unocss/preset-attributify",
    enforce: "post",
    variants,
    extractors,
    options,
    autocomplete: {
      extractors: autocompleteExtractors
    },
    extractorDefault: options.strict ? false : void 0
  };
});

dist$j.autocompleteExtractorAttributify = autocompleteExtractorAttributify;
dist$j.default = presetAttributify;
dist$j.defaultIgnoreAttributes = defaultIgnoreAttributes;
dist$j.extractorAttributify = extractorAttributify;
dist$j.presetAttributify = presetAttributify;
dist$j.variantAttributify = variantAttributify;
dist$j.variantsRE = variantsRE;

var dist$i = {};

Object.defineProperty(dist$i, '__esModule', { value: true });

const core$a = dist$p;

const MARKER = "__TAGIFY__";
const htmlTagRE = /<([\w\d-:]+)/g;
function extractorTagify(options) {
  const {
    prefix = "",
    excludedTags = ["b", /^h\d+$/, "table"]
  } = options;
  return {
    name: "tagify",
    extract({ code }) {
      return Array.from(code.matchAll(htmlTagRE)).filter(({ 1: match }) => {
        for (const exclude of excludedTags) {
          if (typeof exclude === "string") {
            if (match === exclude)
              return false;
          } else {
            if (exclude.test(match))
              return false;
          }
        }
        return match.startsWith(prefix);
      }).map(([, matched]) => `${MARKER}${matched}`);
    }
  };
}

function variantTagify(options) {
  const { extraProperties } = options;
  const prefix = `${MARKER}${options.prefix ?? ""}`;
  return {
    name: "tagify",
    match(input) {
      if (!input.startsWith(prefix))
        return;
      const matcher = input.slice(prefix.length);
      const handler = {
        matcher,
        selector: (i) => i.slice(MARKER.length + 1)
      };
      if (extraProperties) {
        if (typeof extraProperties === "function")
          handler.body = (entries) => [...entries, ...Object.entries(extraProperties(matcher) ?? {})];
        else
          handler.body = (entries) => [...entries, ...Object.entries(extraProperties)];
      }
      return handler;
    }
  };
}

const presetTagify = core$a.definePreset((options = {}) => {
  const {
    defaultExtractor = true
  } = options;
  const variants = [
    variantTagify(options)
  ];
  const extractors = [
    extractorTagify(options)
  ];
  return {
    name: "@unocss/preset-tagify",
    variants,
    extractors,
    extractorDefault: defaultExtractor ? void 0 : false
  };
});

dist$i.MARKER = MARKER;
dist$i.default = presetTagify;
dist$i.extractorTagify = extractorTagify;
dist$i.htmlTagRE = htmlTagRE;
dist$i.presetTagify = presetTagify;
dist$i.variantTagify = variantTagify;

var dist$h = {};

var presetIcons_DDHG4xNZ = {};

var node$2 = {};

var native = {};

Object.defineProperty(native,"__esModule",{value:!0});const Blob=globalThis.Blob,File=globalThis.File,FormData=globalThis.FormData,Headers$1=globalThis.Headers,Request=globalThis.Request,Response=globalThis.Response,AbortController$1=globalThis.AbortController,fetch$2=globalThis.fetch||(()=>{throw new Error("[node-fetch-native] Failed to fetch: `globalThis.fetch` is not available!")});native.AbortController=AbortController$1,native.Blob=Blob,native.File=File,native.FormData=FormData,native.Headers=Headers$1,native.Request=Request,native.Response=Response,native.default=fetch$2,native.fetch=fetch$2;

var ofetch_897a6909 = {};

var dist$g = {};

Object.defineProperty(dist$g, '__esModule', { value: true });

const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
const JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr$2(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  const _value = value.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    value[0] === '"' && value.endsWith('"') && !value.includes("\\")
  ) {
    return _value.slice(1, -1);
  }
  if (_value.length <= 9) {
    const _lval = _value.toLowerCase();
    if (_lval === "true") {
      return true;
    }
    if (_lval === "false") {
      return false;
    }
    if (_lval === "undefined") {
      return void 0;
    }
    if (_lval === "null") {
      return null;
    }
    if (_lval === "nan") {
      return Number.NaN;
    }
    if (_lval === "infinity") {
      return Number.POSITIVE_INFINITY;
    }
    if (_lval === "-infinity") {
      return Number.NEGATIVE_INFINITY;
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}
function safeDestr$1(value, options = {}) {
  return destr$2(value, { ...options, strict: true });
}

dist$g.default = destr$2;
dist$g.destr = destr$2;
dist$g.safeDestr = safeDestr$1;

const { destr: destr$1, safeDestr } = dist$g;

// Allow mixed default and named exports
destr$1.destr = destr$1;
destr$1.safeDestr = safeDestr;

var lib = destr$1;

var dist$f = {};

const n = /[^\0-\x7E]/;
const t = /[\x2E\u3002\uFF0E\uFF61]/g;
const o = {
  overflow: "Overflow Error",
  "not-basic": "Illegal Input",
  "invalid-input": "Invalid Input"
};
const e = Math.floor;
const r = String.fromCharCode;
function s(n2) {
  throw new RangeError(o[n2]);
}
const c = function(n2, t2) {
  return n2 + 22 + 75 * (n2 < 26) - ((t2 != 0) << 5);
};
const u = function(n2, t2, o2) {
  let r2 = 0;
  for (n2 = o2 ? e(n2 / 700) : n2 >> 1, n2 += e(n2 / t2); n2 > 455; r2 += 36) {
    n2 = e(n2 / 35);
  }
  return e(r2 + 36 * n2 / (n2 + 38));
};
function toASCII(o2) {
  return function(n2, o3) {
    const e2 = n2.split("@");
    let r2 = "";
    e2.length > 1 && (r2 = e2[0] + "@", n2 = e2[1]);
    const s2 = function(n3, t2) {
      const o4 = [];
      let e3 = n3.length;
      for (; e3--; ) {
        o4[e3] = t2(n3[e3]);
      }
      return o4;
    }((n2 = n2.replace(t, ".")).split("."), o3).join(".");
    return r2 + s2;
  }(o2, function(t2) {
    return n.test(t2) ? "xn--" + function(n2) {
      const t3 = [];
      const o3 = (n2 = function(n3) {
        const t4 = [];
        let o4 = 0;
        const e2 = n3.length;
        for (; o4 < e2; ) {
          const r2 = n3.charCodeAt(o4++);
          if (r2 >= 55296 && r2 <= 56319 && o4 < e2) {
            const e3 = n3.charCodeAt(o4++);
            (64512 & e3) == 56320 ? t4.push(((1023 & r2) << 10) + (1023 & e3) + 65536) : (t4.push(r2), o4--);
          } else {
            t4.push(r2);
          }
        }
        return t4;
      }(n2)).length;
      let f = 128;
      let i = 0;
      let l = 72;
      for (const o4 of n2) {
        o4 < 128 && t3.push(r(o4));
      }
      const h = t3.length;
      let p = h;
      for (h && t3.push("-"); p < o3; ) {
        let o4 = 2147483647;
        for (const t4 of n2) {
          t4 >= f && t4 < o4 && (o4 = t4);
        }
        const a = p + 1;
        o4 - f > e((2147483647 - i) / a) && s("overflow"), i += (o4 - f) * a, f = o4;
        for (const o5 of n2) {
          if (o5 < f && ++i > 2147483647 && s("overflow"), o5 == f) {
            let n3 = i;
            for (let o6 = 36; ; o6 += 36) {
              const s2 = o6 <= l ? 1 : o6 >= l + 26 ? 26 : o6 - l;
              if (n3 < s2) {
                break;
              }
              const u2 = n3 - s2;
              const f2 = 36 - s2;
              t3.push(r(c(s2 + u2 % f2, 0))), n3 = e(u2 / f2);
            }
            t3.push(r(c(n3, 0))), l = u(i, a, p == h), i = 0, ++p;
          }
        }
        ++i, ++f;
      }
      return t3.join("");
    }(t2) : t2;
  });
}

const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_CARET_RE = /%5e/gi;
const ENC_BACKTICK_RE = /%60/gi;
const ENC_CURLY_OPEN_RE = /%7b/gi;
const ENC_PIPE_RE = /%7c/gi;
const ENC_CURLY_CLOSE_RE = /%7d/gi;
const ENC_SPACE_RE = /%20/gi;
const ENC_SLASH_RE = /%2f/gi;
const ENC_ENC_SLASH_RE = /%252f/gi;
function encode$3(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|");
}
function encodeHash(text) {
  return encode$3(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(input) {
  return encode$3(typeof input === "string" ? input : JSON.stringify(input)).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CARET_RE, "^").replace(SLASH_RE, "%2F");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodePath(text) {
  return encode$3(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F").replace(ENC_ENC_SLASH_RE, "%2F").replace(AMPERSAND_RE, "%26").replace(PLUS_RE, "%2B");
}
function encodeParam(text) {
  return encodePath(text).replace(SLASH_RE, "%2F");
}
function decode$3(text = "") {
  try {
    return decodeURIComponent("" + text);
  } catch {
    return "" + text;
  }
}
function decodePath(text) {
  return decode$3(text.replace(ENC_SLASH_RE, "%252F"));
}
function decodeQueryKey(text) {
  return decode$3(text.replace(PLUS_RE, " "));
}
function decodeQueryValue(text) {
  return decode$3(text.replace(PLUS_RE, " "));
}
function encodeHost(name = "") {
  return toASCII(name);
}

function parseQuery(parametersString = "") {
  const object = {};
  if (parametersString[0] === "?") {
    parametersString = parametersString.slice(1);
  }
  for (const parameter of parametersString.split("&")) {
    const s = parameter.match(/([^=]+)=?(.*)/) || [];
    if (s.length < 2) {
      continue;
    }
    const key = decodeQueryKey(s[1]);
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = decodeQueryValue(s[2] || "");
    if (object[key] === void 0) {
      object[key] = value;
    } else if (Array.isArray(object[key])) {
      object[key].push(value);
    } else {
      object[key] = [object[key], value];
    }
  }
  return object;
}
function encodeQueryItem(key, value) {
  if (typeof value === "number" || typeof value === "boolean") {
    value = String(value);
  }
  if (!value) {
    return encodeQueryKey(key);
  }
  if (Array.isArray(value)) {
    return value.map((_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`).join("&");
  }
  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;
}
function stringifyQuery(query) {
  return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).filter(Boolean).join("&");
}

const PROTOCOL_STRICT_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/;
const PROTOCOL_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{2})?/;
const PROTOCOL_RELATIVE_REGEX = /^([/\\]\s*){2,}[^/\\]/;
const PROTOCOL_SCRIPT_RE = /^[\s\0]*(blob|data|javascript|vbscript):$/i;
const TRAILING_SLASH_RE = /\/$|\/\?|\/#/;
const JOIN_LEADING_SLASH_RE = /^\.?\//;
function isRelative(inputString) {
  return ["./", "../"].some((string_) => inputString.startsWith(string_));
}
function hasProtocol(inputString, opts = {}) {
  if (typeof opts === "boolean") {
    opts = { acceptRelative: opts };
  }
  if (opts.strict) {
    return PROTOCOL_STRICT_REGEX.test(inputString);
  }
  return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);
}
function isScriptProtocol(protocol) {
  return !!protocol && PROTOCOL_SCRIPT_RE.test(protocol);
}
function hasTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return input.endsWith("/");
  }
  return TRAILING_SLASH_RE.test(input);
}
function withoutTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || "/";
  }
  if (!hasTrailingSlash(input, true)) {
    return input || "/";
  }
  let path = input;
  let fragment = "";
  const fragmentIndex = input.indexOf("#");
  if (fragmentIndex >= 0) {
    path = input.slice(0, fragmentIndex);
    fragment = input.slice(fragmentIndex);
  }
  const [s0, ...s] = path.split("?");
  const cleanPath = s0.endsWith("/") ? s0.slice(0, -1) : s0;
  return (cleanPath || "/") + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
}
function withTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return input.endsWith("/") ? input : input + "/";
  }
  if (hasTrailingSlash(input, true)) {
    return input || "/";
  }
  let path = input;
  let fragment = "";
  const fragmentIndex = input.indexOf("#");
  if (fragmentIndex >= 0) {
    path = input.slice(0, fragmentIndex);
    fragment = input.slice(fragmentIndex);
    if (!path) {
      return fragment;
    }
  }
  const [s0, ...s] = path.split("?");
  return s0 + "/" + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
}
function hasLeadingSlash(input = "") {
  return input.startsWith("/");
}
function withoutLeadingSlash(input = "") {
  return (hasLeadingSlash(input) ? input.slice(1) : input) || "/";
}
function withLeadingSlash(input = "") {
  return hasLeadingSlash(input) ? input : "/" + input;
}
function cleanDoubleSlashes(input = "") {
  return input.split("://").map((string_) => string_.replace(/\/{2,}/g, "/")).join("://");
}
function withBase(input, base) {
  if (isEmptyURL(base) || hasProtocol(input)) {
    return input;
  }
  const _base = withoutTrailingSlash(base);
  if (input.startsWith(_base)) {
    return input;
  }
  return joinURL(_base, input);
}
function withoutBase(input, base) {
  if (isEmptyURL(base)) {
    return input;
  }
  const _base = withoutTrailingSlash(base);
  if (!input.startsWith(_base)) {
    return input;
  }
  const trimmed = input.slice(_base.length);
  return trimmed[0] === "/" ? trimmed : "/" + trimmed;
}
function withQuery(input, query) {
  const parsed = parseURL(input);
  const mergedQuery = { ...parseQuery(parsed.search), ...query };
  parsed.search = stringifyQuery(mergedQuery);
  return stringifyParsedURL(parsed);
}
function getQuery(input) {
  return parseQuery(parseURL(input).search);
}
function isEmptyURL(url) {
  return !url || url === "/";
}
function isNonEmptyURL(url) {
  return url && url !== "/";
}
function joinURL(base, ...input) {
  let url = base || "";
  for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {
    if (url) {
      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, "");
      url = withTrailingSlash(url) + _segment;
    } else {
      url = segment;
    }
  }
  return url;
}
function joinRelativeURL(..._input) {
  const JOIN_SEGMENT_SPLIT_RE = /\/(?!\/)/;
  const input = _input.filter(Boolean);
  const segments = [];
  let segmentsDepth = 0;
  for (const i of input) {
    if (!i || i === "/") {
      continue;
    }
    for (const [sindex, s] of i.split(JOIN_SEGMENT_SPLIT_RE).entries()) {
      if (!s || s === ".") {
        continue;
      }
      if (s === "..") {
        if (segments.length === 1 && hasProtocol(segments[0])) {
          continue;
        }
        segments.pop();
        segmentsDepth--;
        continue;
      }
      if (sindex === 1 && segments[segments.length - 1]?.endsWith(":/")) {
        segments[segments.length - 1] += "/" + s;
        continue;
      }
      segments.push(s);
      segmentsDepth++;
    }
  }
  let url = segments.join("/");
  if (segmentsDepth >= 0) {
    if (input[0]?.startsWith("/") && !url.startsWith("/")) {
      url = "/" + url;
    } else if (input[0]?.startsWith("./") && !url.startsWith("./")) {
      url = "./" + url;
    }
  } else {
    url = "../".repeat(-1 * segmentsDepth) + url;
  }
  if (input[input.length - 1]?.endsWith("/") && !url.endsWith("/")) {
    url += "/";
  }
  return url;
}
function withHttp(input) {
  return withProtocol(input, "http://");
}
function withHttps(input) {
  return withProtocol(input, "https://");
}
function withoutProtocol(input) {
  return withProtocol(input, "");
}
function withProtocol(input, protocol) {
  const match = input.match(PROTOCOL_REGEX);
  if (!match) {
    return protocol + input;
  }
  return protocol + input.slice(match[0].length);
}
function normalizeURL(input) {
  const parsed = parseURL(input);
  parsed.pathname = encodePath(decodePath(parsed.pathname));
  parsed.hash = encodeHash(decode$3(parsed.hash));
  parsed.host = encodeHost(decode$3(parsed.host));
  parsed.search = stringifyQuery(parseQuery(parsed.search));
  return stringifyParsedURL(parsed);
}
function resolveURL(base = "", ...inputs) {
  if (typeof base !== "string") {
    throw new TypeError(
      `URL input should be string received ${typeof base} (${base})`
    );
  }
  const filteredInputs = inputs.filter((input) => isNonEmptyURL(input));
  if (filteredInputs.length === 0) {
    return base;
  }
  const url = parseURL(base);
  for (const inputSegment of filteredInputs) {
    const urlSegment = parseURL(inputSegment);
    if (urlSegment.pathname) {
      url.pathname = withTrailingSlash(url.pathname) + withoutLeadingSlash(urlSegment.pathname);
    }
    if (urlSegment.hash && urlSegment.hash !== "#") {
      url.hash = urlSegment.hash;
    }
    if (urlSegment.search && urlSegment.search !== "?") {
      if (url.search && url.search !== "?") {
        const queryString = stringifyQuery({
          ...parseQuery(url.search),
          ...parseQuery(urlSegment.search)
        });
        url.search = queryString.length > 0 ? "?" + queryString : "";
      } else {
        url.search = urlSegment.search;
      }
    }
  }
  return stringifyParsedURL(url);
}
function isSamePath(p1, p2) {
  return decode$3(withoutTrailingSlash(p1)) === decode$3(withoutTrailingSlash(p2));
}
function isEqual(a, b, options = {}) {
  if (!options.trailingSlash) {
    a = withTrailingSlash(a);
    b = withTrailingSlash(b);
  }
  if (!options.leadingSlash) {
    a = withLeadingSlash(a);
    b = withLeadingSlash(b);
  }
  if (!options.encoding) {
    a = decode$3(a);
    b = decode$3(b);
  }
  return a === b;
}
function withFragment(input, hash) {
  if (!hash || hash === "#") {
    return input;
  }
  const parsed = parseURL(input);
  parsed.hash = hash === "" ? "" : "#" + encodeHash(hash);
  return stringifyParsedURL(parsed);
}
function withoutFragment(input) {
  return stringifyParsedURL({ ...parseURL(input), hash: "" });
}
function withoutHost(input) {
  const parsed = parseURL(input);
  return (parsed.pathname || "/") + parsed.search + parsed.hash;
}

const protocolRelative = Symbol.for("ufo:protocolRelative");
function parseURL(input = "", defaultProto) {
  const _specialProtoMatch = input.match(
    /^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i
  );
  if (_specialProtoMatch) {
    const [, _proto, _pathname = ""] = _specialProtoMatch;
    return {
      protocol: _proto.toLowerCase(),
      pathname: _pathname,
      href: _proto + _pathname,
      auth: "",
      host: "",
      search: "",
      hash: ""
    };
  }
  if (!hasProtocol(input, { acceptRelative: true })) {
    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);
  }
  const [, protocol = "", auth, hostAndPath = ""] = input.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [];
  const [, host = "", path = ""] = hostAndPath.match(/([^#/?]*)(.*)?/) || [];
  const { pathname, search, hash } = parsePath(
    path.replace(/\/(?=[A-Za-z]:)/, "")
  );
  return {
    protocol: protocol.toLowerCase(),
    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : "",
    host,
    pathname,
    search,
    hash,
    [protocolRelative]: !protocol
  };
}
function parsePath(input = "") {
  const [pathname = "", search = "", hash = ""] = (input.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
  return {
    pathname,
    search,
    hash
  };
}
function parseAuth(input = "") {
  const [username, password] = input.split(":");
  return {
    username: decode$3(username),
    password: decode$3(password)
  };
}
function parseHost(input = "") {
  const [hostname, port] = (input.match(/([^/:]*):?(\d+)?/) || []).splice(1);
  return {
    hostname: decode$3(hostname),
    port
  };
}
function stringifyParsedURL(parsed) {
  const pathname = parsed.pathname || "";
  const search = parsed.search ? (parsed.search.startsWith("?") ? "" : "?") + parsed.search : "";
  const hash = parsed.hash || "";
  const auth = parsed.auth ? parsed.auth + "@" : "";
  const host = parsed.host || "";
  const proto = parsed.protocol || parsed[protocolRelative] ? (parsed.protocol || "") + "//" : "";
  return proto + auth + host + pathname + search + hash;
}
const FILENAME_STRICT_REGEX = /\/([^/]+\.[^/]+)$/;
const FILENAME_REGEX = /\/([^/]+)$/;
function parseFilename(input = "", { strict }) {
  const { pathname } = parseURL(input);
  const matches = strict ? pathname.match(FILENAME_STRICT_REGEX) : pathname.match(FILENAME_REGEX);
  return matches ? matches[1] : void 0;
}

var __defProp$3 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class $URL {
  constructor(input = "") {
    __publicField$1(this, "protocol");
    __publicField$1(this, "host");
    __publicField$1(this, "auth");
    __publicField$1(this, "pathname");
    __publicField$1(this, "query", {});
    __publicField$1(this, "hash");
    if (typeof input !== "string") {
      throw new TypeError(
        `URL input should be string received ${typeof input} (${input})`
      );
    }
    const parsed = parseURL(input);
    this.protocol = decode$3(parsed.protocol);
    this.host = decode$3(parsed.host);
    this.auth = decode$3(parsed.auth);
    this.pathname = decodePath(parsed.pathname);
    this.query = parseQuery(parsed.search);
    this.hash = decode$3(parsed.hash);
  }
  get hostname() {
    return parseHost(this.host).hostname;
  }
  get port() {
    return parseHost(this.host).port || "";
  }
  get username() {
    return parseAuth(this.auth).username;
  }
  get password() {
    return parseAuth(this.auth).password || "";
  }
  get hasProtocol() {
    return this.protocol.length;
  }
  get isAbsolute() {
    return this.hasProtocol || this.pathname[0] === "/";
  }
  get search() {
    const q = stringifyQuery(this.query);
    return q.length > 0 ? "?" + q : "";
  }
  get searchParams() {
    const p = new URLSearchParams();
    for (const name in this.query) {
      const value = this.query[name];
      if (Array.isArray(value)) {
        for (const v of value) {
          p.append(name, v);
        }
      } else {
        p.append(
          name,
          typeof value === "string" ? value : JSON.stringify(value)
        );
      }
    }
    return p;
  }
  get origin() {
    return (this.protocol ? this.protocol + "//" : "") + encodeHost(this.host);
  }
  get fullpath() {
    return encodePath(this.pathname) + this.search + encodeHash(this.hash);
  }
  get encodedAuth() {
    if (!this.auth) {
      return "";
    }
    const { username, password } = parseAuth(this.auth);
    return encodeURIComponent(username) + (password ? ":" + encodeURIComponent(password) : "");
  }
  get href() {
    const auth = this.encodedAuth;
    const originWithAuth = (this.protocol ? this.protocol + "//" : "") + (auth ? auth + "@" : "") + encodeHost(this.host);
    return this.hasProtocol && this.isAbsolute ? originWithAuth + this.fullpath : this.fullpath;
  }
  append(url) {
    if (url.hasProtocol) {
      throw new Error("Cannot append a URL with protocol");
    }
    Object.assign(this.query, url.query);
    if (url.pathname) {
      this.pathname = withTrailingSlash(this.pathname) + withoutLeadingSlash(url.pathname);
    }
    if (url.hash) {
      this.hash = url.hash;
    }
  }
  toJSON() {
    return this.href;
  }
  toString() {
    return this.href;
  }
}
function createURL(input) {
  return new $URL(input);
}

dist$f.$URL = $URL;
dist$f.cleanDoubleSlashes = cleanDoubleSlashes;
dist$f.createURL = createURL;
dist$f.decode = decode$3;
dist$f.decodePath = decodePath;
dist$f.decodeQueryKey = decodeQueryKey;
dist$f.decodeQueryValue = decodeQueryValue;
dist$f.encode = encode$3;
dist$f.encodeHash = encodeHash;
dist$f.encodeHost = encodeHost;
dist$f.encodeParam = encodeParam;
dist$f.encodePath = encodePath;
dist$f.encodeQueryItem = encodeQueryItem;
dist$f.encodeQueryKey = encodeQueryKey;
dist$f.encodeQueryValue = encodeQueryValue;
dist$f.getQuery = getQuery;
dist$f.hasLeadingSlash = hasLeadingSlash;
dist$f.hasProtocol = hasProtocol;
dist$f.hasTrailingSlash = hasTrailingSlash;
dist$f.isEmptyURL = isEmptyURL;
dist$f.isEqual = isEqual;
dist$f.isNonEmptyURL = isNonEmptyURL;
dist$f.isRelative = isRelative;
dist$f.isSamePath = isSamePath;
dist$f.isScriptProtocol = isScriptProtocol;
dist$f.joinRelativeURL = joinRelativeURL;
dist$f.joinURL = joinURL;
dist$f.normalizeURL = normalizeURL;
dist$f.parseAuth = parseAuth;
dist$f.parseFilename = parseFilename;
dist$f.parseHost = parseHost;
dist$f.parsePath = parsePath;
dist$f.parseQuery = parseQuery;
dist$f.parseURL = parseURL;
dist$f.resolveURL = resolveURL;
dist$f.stringifyParsedURL = stringifyParsedURL;
dist$f.stringifyQuery = stringifyQuery;
dist$f.withBase = withBase;
dist$f.withFragment = withFragment;
dist$f.withHttp = withHttp;
dist$f.withHttps = withHttps;
dist$f.withLeadingSlash = withLeadingSlash;
dist$f.withProtocol = withProtocol;
dist$f.withQuery = withQuery;
dist$f.withTrailingSlash = withTrailingSlash;
dist$f.withoutBase = withoutBase;
dist$f.withoutFragment = withoutFragment;
dist$f.withoutHost = withoutHost;
dist$f.withoutLeadingSlash = withoutLeadingSlash;
dist$f.withoutProtocol = withoutProtocol;
dist$f.withoutTrailingSlash = withoutTrailingSlash;

const destr = lib;
const ufo = dist$f;

function _interopDefaultCompat$2 (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const destr__default = /*#__PURE__*/_interopDefaultCompat$2(destr);

class FetchError extends Error {
  constructor(message, opts) {
    super(message, opts);
    this.name = "FetchError";
    if (opts?.cause && !this.cause) {
      this.cause = opts.cause;
    }
  }
}
function createFetchError(ctx) {
  const errorMessage = ctx.error?.message || ctx.error?.toString() || "";
  const method = ctx.request?.method || ctx.options?.method || "GET";
  const url = ctx.request?.url || String(ctx.request) || "/";
  const requestStr = `[${method}] ${JSON.stringify(url)}`;
  const statusStr = ctx.response ? `${ctx.response.status} ${ctx.response.statusText}` : "<no response>";
  const message = `${requestStr}: ${statusStr}${errorMessage ? ` ${errorMessage}` : ""}`;
  const fetchError = new FetchError(
    message,
    ctx.error ? { cause: ctx.error } : void 0
  );
  for (const key of ["request", "options", "response"]) {
    Object.defineProperty(fetchError, key, {
      get() {
        return ctx[key];
      }
    });
  }
  for (const [key, refKey] of [
    ["data", "_data"],
    ["status", "status"],
    ["statusCode", "status"],
    ["statusText", "statusText"],
    ["statusMessage", "statusText"]
  ]) {
    Object.defineProperty(fetchError, key, {
      get() {
        return ctx.response && ctx.response[refKey];
      }
    });
  }
  return fetchError;
}

const payloadMethods = new Set(
  Object.freeze(["PATCH", "POST", "PUT", "DELETE"])
);
function isPayloadMethod(method = "GET") {
  return payloadMethods.has(method.toUpperCase());
}
function isJSONSerializable(value) {
  if (value === void 0) {
    return false;
  }
  const t = typeof value;
  if (t === "string" || t === "number" || t === "boolean" || t === null) {
    return true;
  }
  if (t !== "object") {
    return false;
  }
  if (Array.isArray(value)) {
    return true;
  }
  if (value.buffer) {
    return false;
  }
  return value.constructor && value.constructor.name === "Object" || typeof value.toJSON === "function";
}
const textTypes = /* @__PURE__ */ new Set([
  "image/svg",
  "application/xml",
  "application/xhtml",
  "application/html"
]);
const JSON_RE = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function detectResponseType(_contentType = "") {
  if (!_contentType) {
    return "json";
  }
  const contentType = _contentType.split(";").shift() || "";
  if (JSON_RE.test(contentType)) {
    return "json";
  }
  if (textTypes.has(contentType) || contentType.startsWith("text/")) {
    return "text";
  }
  return "blob";
}
function mergeFetchOptions(input, defaults, Headers = globalThis.Headers) {
  const merged = {
    ...defaults,
    ...input
  };
  if (defaults?.params && input?.params) {
    merged.params = {
      ...defaults?.params,
      ...input?.params
    };
  }
  if (defaults?.query && input?.query) {
    merged.query = {
      ...defaults?.query,
      ...input?.query
    };
  }
  if (defaults?.headers && input?.headers) {
    merged.headers = new Headers(defaults?.headers || {});
    for (const [key, value] of new Headers(input?.headers || {})) {
      merged.headers.set(key, value);
    }
  }
  return merged;
}

const retryStatusCodes = /* @__PURE__ */ new Set([
  408,
  // Request Timeout
  409,
  // Conflict
  425,
  // Too Early
  429,
  // Too Many Requests
  500,
  // Internal Server Error
  502,
  // Bad Gateway
  503,
  // Service Unavailable
  504
  //  Gateway Timeout
]);
const nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);
function createFetch(globalOptions = {}) {
  const {
    fetch = globalThis.fetch,
    Headers = globalThis.Headers,
    AbortController = globalThis.AbortController
  } = globalOptions;
  async function onError(context) {
    const isAbort = context.error && context.error.name === "AbortError" && !context.options.timeout || false;
    if (context.options.retry !== false && !isAbort) {
      let retries;
      if (typeof context.options.retry === "number") {
        retries = context.options.retry;
      } else {
        retries = isPayloadMethod(context.options.method) ? 0 : 1;
      }
      const responseCode = context.response && context.response.status || 500;
      if (retries > 0 && (Array.isArray(context.options.retryStatusCodes) ? context.options.retryStatusCodes.includes(responseCode) : retryStatusCodes.has(responseCode))) {
        const retryDelay = context.options.retryDelay || 0;
        if (retryDelay > 0) {
          await new Promise((resolve) => setTimeout(resolve, retryDelay));
        }
        return $fetchRaw(context.request, {
          ...context.options,
          retry: retries - 1
        });
      }
    }
    const error = createFetchError(context);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(error, $fetchRaw);
    }
    throw error;
  }
  const $fetchRaw = async function $fetchRaw2(_request, _options = {}) {
    const context = {
      request: _request,
      options: mergeFetchOptions(_options, globalOptions.defaults, Headers),
      response: void 0,
      error: void 0
    };
    context.options.method = context.options.method?.toUpperCase();
    if (context.options.onRequest) {
      await context.options.onRequest(context);
    }
    if (typeof context.request === "string") {
      if (context.options.baseURL) {
        context.request = ufo.withBase(context.request, context.options.baseURL);
      }
      if (context.options.query || context.options.params) {
        context.request = ufo.withQuery(context.request, {
          ...context.options.params,
          ...context.options.query
        });
      }
    }
    if (context.options.body && isPayloadMethod(context.options.method)) {
      if (isJSONSerializable(context.options.body)) {
        context.options.body = typeof context.options.body === "string" ? context.options.body : JSON.stringify(context.options.body);
        context.options.headers = new Headers(context.options.headers || {});
        if (!context.options.headers.has("content-type")) {
          context.options.headers.set("content-type", "application/json");
        }
        if (!context.options.headers.has("accept")) {
          context.options.headers.set("accept", "application/json");
        }
      } else if (
        // ReadableStream Body
        "pipeTo" in context.options.body && typeof context.options.body.pipeTo === "function" || // Node.js Stream Body
        typeof context.options.body.pipe === "function"
      ) {
        if (!("duplex" in context.options)) {
          context.options.duplex = "half";
        }
      }
    }
    let abortTimeout;
    if (!context.options.signal && context.options.timeout) {
      const controller = new AbortController();
      abortTimeout = setTimeout(
        () => controller.abort(),
        context.options.timeout
      );
      context.options.signal = controller.signal;
    }
    try {
      context.response = await fetch(
        context.request,
        context.options
      );
    } catch (error) {
      context.error = error;
      if (context.options.onRequestError) {
        await context.options.onRequestError(context);
      }
      return await onError(context);
    } finally {
      if (abortTimeout) {
        clearTimeout(abortTimeout);
      }
    }
    const hasBody = context.response.body && !nullBodyResponses.has(context.response.status) && context.options.method !== "HEAD";
    if (hasBody) {
      const responseType = (context.options.parseResponse ? "json" : context.options.responseType) || detectResponseType(context.response.headers.get("content-type") || "");
      switch (responseType) {
        case "json": {
          const data = await context.response.text();
          const parseFunction = context.options.parseResponse || destr__default;
          context.response._data = parseFunction(data);
          break;
        }
        case "stream": {
          context.response._data = context.response.body;
          break;
        }
        default: {
          context.response._data = await context.response[responseType]();
        }
      }
    }
    if (context.options.onResponse) {
      await context.options.onResponse(context);
    }
    if (!context.options.ignoreResponseError && context.response.status >= 400 && context.response.status < 600) {
      if (context.options.onResponseError) {
        await context.options.onResponseError(context);
      }
      return await onError(context);
    }
    return context.response;
  };
  const $fetch = async function $fetch2(request, options) {
    const r = await $fetchRaw(request, options);
    return r._data;
  };
  $fetch.raw = $fetchRaw;
  $fetch.native = (...args) => fetch(...args);
  $fetch.create = (defaultOptions = {}) => createFetch({
    ...globalOptions,
    defaults: {
      ...globalOptions.defaults,
      ...defaultOptions
    }
  });
  return $fetch;
}

ofetch_897a6909.FetchError = FetchError;
ofetch_897a6909.createFetch = createFetch;
ofetch_897a6909.createFetchError = createFetchError;

const http = require$$0$2;
const https = require$$1;
const nodeFetch = native;
const fetch$1 = ofetch_897a6909;



function _interopDefaultCompat$1 (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const http__default = /*#__PURE__*/_interopDefaultCompat$1(http);
const https__default = /*#__PURE__*/_interopDefaultCompat$1(https);
const nodeFetch__default = /*#__PURE__*/_interopDefaultCompat$1(nodeFetch);

function createNodeFetch() {
  const useKeepAlive = JSON.parse(process.env.FETCH_KEEP_ALIVE || "false");
  if (!useKeepAlive) {
    return nodeFetch__default;
  }
  const agentOptions = { keepAlive: true };
  const httpAgent = new http__default.Agent(agentOptions);
  const httpsAgent = new https__default.Agent(agentOptions);
  const nodeFetchOptions = {
    agent(parsedURL) {
      return parsedURL.protocol === "http:" ? httpAgent : httpsAgent;
    }
  };
  return function nodeFetchWithKeepAlive(input, init) {
    return nodeFetch__default(input, { ...nodeFetchOptions, ...init });
  };
}
const fetch = globalThis.fetch || createNodeFetch();
const Headers = globalThis.Headers || nodeFetch.Headers;
const AbortController = globalThis.AbortController || nodeFetch.AbortController;
const ofetch$1 = fetch$1.createFetch({ fetch, Headers, AbortController });
const $fetch = ofetch$1;

node$2.FetchError = fetch$1.FetchError;
node$2.createFetch = fetch$1.createFetch;
node$2.createFetchError = fetch$1.createFetchError;
node$2.$fetch = $fetch;
node$2.AbortController = AbortController;
node$2.Headers = Headers;
node$2.createNodeFetch = createNodeFetch;
node$2.fetch = fetch;
node$2.ofetch = ofetch$1;

var presetIcons_De8FRNb6 = {};

const core$9 = dist$p;

const defaultIconDimensions = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
);
const defaultIconTransformations = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false
});
const defaultIconProps = Object.freeze({
  ...defaultIconDimensions,
  ...defaultIconTransformations
});
const defaultExtendedIconProps = Object.freeze({
  ...defaultIconProps,
  body: "",
  hidden: false
});

const defaultIconSizeCustomisations = Object.freeze({
  width: null,
  height: null
});
const defaultIconCustomisations = Object.freeze({
  // Dimensions
  ...defaultIconSizeCustomisations,
  // Transformations
  ...defaultIconTransformations
});

function mergeIconTransformations(obj1, obj2) {
  const result = {};
  if (!obj1.hFlip !== !obj2.hFlip) {
    result.hFlip = true;
  }
  if (!obj1.vFlip !== !obj2.vFlip) {
    result.vFlip = true;
  }
  const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;
  if (rotate) {
    result.rotate = rotate;
  }
  return result;
}

function mergeIconData(parent, child) {
  const result = mergeIconTransformations(parent, child);
  for (const key in defaultExtendedIconProps) {
    if (key in defaultIconTransformations) {
      if (key in parent && !(key in result)) {
        result[key] = defaultIconTransformations[key];
      }
    } else if (key in child) {
      result[key] = child[key];
    } else if (key in parent) {
      result[key] = parent[key];
    }
  }
  return result;
}

function getIconsTree(data, names) {
  const icons = data.icons;
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  const resolved = /* @__PURE__ */ Object.create(null);
  function resolve(name) {
    if (icons[name]) {
      return resolved[name] = [];
    }
    if (!(name in resolved)) {
      resolved[name] = null;
      const parent = aliases[name] && aliases[name].parent;
      const value = parent && resolve(parent);
      if (value) {
        resolved[name] = [parent].concat(value);
      }
    }
    return resolved[name];
  }
  (names || Object.keys(icons).concat(Object.keys(aliases))).forEach(resolve);
  return resolved;
}

function internalGetIconData(data, name, tree) {
  const icons = data.icons;
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  let currentProps = {};
  function parse(name2) {
    currentProps = mergeIconData(
      icons[name2] || aliases[name2],
      currentProps
    );
  }
  parse(name);
  tree.forEach(parse);
  return mergeIconData(data, currentProps);
}
function getIconData(data, name) {
  if (data.icons[name]) {
    return internalGetIconData(data, name, []);
  }
  const tree = getIconsTree(data, [name])[name];
  return tree ? internalGetIconData(data, name, tree) : null;
}

const unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
const unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function calculateSize(size, ratio, precision) {
  if (ratio === 1) {
    return size;
  }
  precision = precision || 100;
  if (typeof size === "number") {
    return Math.ceil(size * ratio * precision) / precision;
  }
  if (typeof size !== "string") {
    return size;
  }
  const oldParts = size.split(unitsSplit);
  if (oldParts === null || !oldParts.length) {
    return size;
  }
  const newParts = [];
  let code = oldParts.shift();
  let isNumber = unitsTest.test(code);
  while (true) {
    if (isNumber) {
      const num = parseFloat(code);
      if (isNaN(num)) {
        newParts.push(code);
      } else {
        newParts.push(Math.ceil(num * ratio * precision) / precision);
      }
    } else {
      newParts.push(code);
    }
    code = oldParts.shift();
    if (code === void 0) {
      return newParts.join("");
    }
    isNumber = !isNumber;
  }
}

function splitSVGDefs(content, tag = "defs") {
  let defs = "";
  const index = content.indexOf("<" + tag);
  while (index >= 0) {
    const start = content.indexOf(">", index);
    const end = content.indexOf("</" + tag);
    if (start === -1 || end === -1) {
      break;
    }
    const endEnd = content.indexOf(">", end);
    if (endEnd === -1) {
      break;
    }
    defs += content.slice(start + 1, end).trim();
    content = content.slice(0, index).trim() + content.slice(endEnd + 1);
  }
  return {
    defs,
    content
  };
}
function mergeDefsAndContent(defs, content) {
  return defs ? "<defs>" + defs + "</defs>" + content : content;
}
function wrapSVGContent(body, start, end) {
  const split = splitSVGDefs(body);
  return mergeDefsAndContent(split.defs, start + split.content + end);
}

const isUnsetKeyword = (value) => value === "unset" || value === "undefined" || value === "none";
function iconToSVG(icon, customisations) {
  const fullIcon = {
    ...defaultIconProps,
    ...icon
  };
  const fullCustomisations = {
    ...defaultIconCustomisations,
    ...customisations
  };
  const box = {
    left: fullIcon.left,
    top: fullIcon.top,
    width: fullIcon.width,
    height: fullIcon.height
  };
  let body = fullIcon.body;
  [fullIcon, fullCustomisations].forEach((props) => {
    const transformations = [];
    const hFlip = props.hFlip;
    const vFlip = props.vFlip;
    let rotation = props.rotate;
    if (hFlip) {
      if (vFlip) {
        rotation += 2;
      } else {
        transformations.push(
          "translate(" + (box.width + box.left).toString() + " " + (0 - box.top).toString() + ")"
        );
        transformations.push("scale(-1 1)");
        box.top = box.left = 0;
      }
    } else if (vFlip) {
      transformations.push(
        "translate(" + (0 - box.left).toString() + " " + (box.height + box.top).toString() + ")"
      );
      transformations.push("scale(1 -1)");
      box.top = box.left = 0;
    }
    let tempValue;
    if (rotation < 0) {
      rotation -= Math.floor(rotation / 4) * 4;
    }
    rotation = rotation % 4;
    switch (rotation) {
      case 1:
        tempValue = box.height / 2 + box.top;
        transformations.unshift(
          "rotate(90 " + tempValue.toString() + " " + tempValue.toString() + ")"
        );
        break;
      case 2:
        transformations.unshift(
          "rotate(180 " + (box.width / 2 + box.left).toString() + " " + (box.height / 2 + box.top).toString() + ")"
        );
        break;
      case 3:
        tempValue = box.width / 2 + box.left;
        transformations.unshift(
          "rotate(-90 " + tempValue.toString() + " " + tempValue.toString() + ")"
        );
        break;
    }
    if (rotation % 2 === 1) {
      if (box.left !== box.top) {
        tempValue = box.left;
        box.left = box.top;
        box.top = tempValue;
      }
      if (box.width !== box.height) {
        tempValue = box.width;
        box.width = box.height;
        box.height = tempValue;
      }
    }
    if (transformations.length) {
      body = wrapSVGContent(
        body,
        '<g transform="' + transformations.join(" ") + '">',
        "</g>"
      );
    }
  });
  const customisationsWidth = fullCustomisations.width;
  const customisationsHeight = fullCustomisations.height;
  const boxWidth = box.width;
  const boxHeight = box.height;
  let width;
  let height;
  if (customisationsWidth === null) {
    height = customisationsHeight === null ? "1em" : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
    width = calculateSize(height, boxWidth / boxHeight);
  } else {
    width = customisationsWidth === "auto" ? boxWidth : customisationsWidth;
    height = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
  }
  const attributes = {};
  const setAttr = (prop, value) => {
    if (!isUnsetKeyword(value)) {
      attributes[prop] = value.toString();
    }
  };
  setAttr("width", width);
  setAttr("height", height);
  const viewBox = [box.left, box.top, boxWidth, boxHeight];
  attributes.viewBox = viewBox.join(" ");
  return {
    attributes,
    viewBox,
    body
  };
}

function encodeSVGforURL(svg) {
  return svg.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}

function encodeSvgForCss(svg) {
  let useSvg = svg.startsWith("<svg>") ? svg.replace("<svg>", "<svg >") : svg;
  if (!useSvg.includes(" xmlns:xlink=") && useSvg.includes(" xlink:")) {
    useSvg = useSvg.replace(
      "<svg ",
      '<svg xmlns:xlink="http://www.w3.org/1999/xlink" '
    );
  }
  if (!useSvg.includes(" xmlns=")) {
    useSvg = useSvg.replace(
      "<svg ",
      '<svg xmlns="http://www.w3.org/2000/svg" '
    );
  }
  return encodeSVGforURL(useSvg);
}

function trimSVG(str) {
  return str.replace(/(['"])\s*\n\s*([^>\\/\s])/g, "$1 $2").replace(/(["';{}><])\s*\n\s*/g, "$1").replace(/\s*\n\s*/g, " ").replace(/\s+"/g, '"').replace(/="\s+/g, '="').replace(/(\s)+\/>/g, "/>").trim();
}

const svgWidthRegex = /\swidth\s*=\s*["']([\w.]+)["']/;
const svgHeightRegex = /\sheight\s*=\s*["']([\w.]+)["']/;
const svgTagRegex = /<svg\s+/;
function configureSvgSize(svg, props, scale) {
  const svgNode = svg.slice(0, svg.indexOf(">"));
  const check = (prop, regex) => {
    const result = regex.exec(svgNode);
    const isSet = result != null;
    const propValue = props[prop];
    if (!propValue && !isUnsetKeyword(propValue)) {
      if (typeof scale === "number") {
        if (scale > 0) {
          props[prop] = `${scale}em`;
        }
      } else if (result) {
        props[prop] = result[1];
      }
    }
    return isSet;
  };
  return [check("width", svgWidthRegex), check("height", svgHeightRegex)];
}
async function mergeIconProps(svg, collection, icon, options, propsProvider, afterCustomizations) {
  const { scale, addXmlNs = false } = options ?? {};
  const { additionalProps = {}, iconCustomizer } = options?.customizations ?? {};
  const props = await propsProvider?.() ?? {};
  await iconCustomizer?.(collection, icon, props);
  Object.keys(additionalProps).forEach((p) => {
    const v = additionalProps[p];
    if (v !== void 0 && v !== null)
      props[p] = v;
  });
  afterCustomizations?.(props);
  const [widthOnSvg, heightOnSvg] = configureSvgSize(svg, props, scale);
  if (addXmlNs) {
    if (!svg.includes("xmlns=") && !props["xmlns"]) {
      props["xmlns"] = "http://www.w3.org/2000/svg";
    }
    if (!svg.includes("xmlns:xlink=") && svg.includes("xlink:") && !props["xmlns:xlink"]) {
      props["xmlns:xlink"] = "http://www.w3.org/1999/xlink";
    }
  }
  const propsToAdd = Object.keys(props).map(
    (p) => p === "width" && widthOnSvg || p === "height" && heightOnSvg ? null : `${p}="${props[p]}"`
  ).filter((p) => p != null);
  if (propsToAdd.length) {
    svg = svg.replace(svgTagRegex, `<svg ${propsToAdd.join(" ")} `);
  }
  if (options) {
    const { defaultStyle, defaultClass } = options;
    if (defaultClass && !svg.includes("class=")) {
      svg = svg.replace(svgTagRegex, `<svg class="${defaultClass}" `);
    }
    if (defaultStyle && !svg.includes("style=")) {
      svg = svg.replace(svgTagRegex, `<svg style="${defaultStyle}" `);
    }
  }
  const usedProps = options?.usedProps;
  if (usedProps) {
    Object.keys(additionalProps).forEach((p) => {
      const v = props[p];
      if (v !== void 0 && v !== null)
        usedProps[p] = v;
    });
    if (typeof props.width !== "undefined" && props.width !== null) {
      usedProps.width = props.width;
    }
    if (typeof props.height !== "undefined" && props.height !== null) {
      usedProps.height = props.height;
    }
  }
  return svg;
}

async function getCustomIcon(custom, collection, icon, options) {
  let result;
  try {
    if (typeof custom === "function") {
      result = await custom(icon);
    } else {
      const inline = custom[icon];
      result = typeof inline === "function" ? await inline() : inline;
    }
  } catch (err) {
    console.warn(
      `Failed to load custom icon "${icon}" in "${collection}":`,
      err
    );
    return;
  }
  if (result) {
    const cleanupIdx = result.indexOf("<svg");
    if (cleanupIdx > 0)
      result = result.slice(cleanupIdx);
    const { transform } = options?.customizations ?? {};
    result = typeof transform === "function" ? await transform(result, collection, icon) : result;
    if (!result.startsWith("<svg")) {
      console.warn(
        `Custom icon "${icon}" in "${collection}" is not a valid SVG`
      );
      return result;
    }
    return await mergeIconProps(
      options?.customizations?.trimCustomSvg === true ? trimSVG(result) : result,
      collection,
      icon,
      options,
      void 0
    );
  }
}

async function searchForIcon(iconSet, collection, ids, options) {
  let iconData;
  const { customize } = options?.customizations ?? {};
  for (const id of ids) {
    iconData = getIconData(iconSet, id);
    if (iconData) {
      let defaultCustomizations = { ...defaultIconCustomisations };
      if (typeof customize === "function")
        defaultCustomizations = customize(defaultCustomizations);
      const {
        attributes: { width, height, ...restAttributes },
        body
      } = iconToSVG(iconData, defaultCustomizations);
      const scale = options?.scale;
      return await mergeIconProps(
        // DON'T remove space on <svg >
        `<svg >${body}</svg>`,
        collection,
        id,
        options,
        () => {
          return { ...restAttributes };
        },
        (props) => {
          const check = (prop, defaultValue) => {
            const propValue = props[prop];
            let value;
            if (!isUnsetKeyword(propValue)) {
              if (propValue) {
                return;
              }
              if (typeof scale === "number") {
                if (scale) {
                  value = `${scale}em`;
                }
              } else {
                value = defaultValue;
              }
            }
            if (!value) {
              delete props[prop];
            } else {
              props[prop] = value;
            }
          };
          check("width", width);
          check("height", height);
        }
      );
    }
  }
}

const loadIcon = async (collection, icon, options) => {
  const custom = options?.customCollections?.[collection];
  if (custom) {
    if (typeof custom === "function") {
      let result;
      try {
        result = await custom(icon);
      } catch (err) {
        console.warn(
          `Failed to load custom icon "${icon}" in "${collection}":`,
          err
        );
        return;
      }
      if (result) {
        if (typeof result === "string") {
          return await getCustomIcon(
            () => result,
            collection,
            icon,
            options
          );
        }
        if ("icons" in result) {
          const ids = [
            icon,
            icon.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
            icon.replace(/([a-z])(\d+)/g, "$1-$2")
          ];
          return await searchForIcon(
            result,
            collection,
            ids,
            options
          );
        }
      }
    } else {
      return await getCustomIcon(custom, collection, icon, options);
    }
  }
};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var collections = [
	"academicons",
	"akar-icons",
	"ant-design",
	"arcticons",
	"basil",
	"bi",
	"bitcoin-icons",
	"bpmn",
	"brandico",
	"bx",
	"bxl",
	"bxs",
	"bytesize",
	"carbon",
	"cbi",
	"charm",
	"ci",
	"cib",
	"cif",
	"cil",
	"circle-flags",
	"circum",
	"clarity",
	"codicon",
	"covid",
	"cryptocurrency-color",
	"cryptocurrency",
	"dashicons",
	"devicon-line",
	"devicon-original",
	"devicon-plain",
	"devicon",
	"ei",
	"el",
	"emblemicons",
	"emojione-monotone",
	"emojione-v1",
	"emojione",
	"entypo-social",
	"entypo",
	"eos-icons",
	"ep",
	"et",
	"eva",
	"f7",
	"fa-brands",
	"fa-regular",
	"fa-solid",
	"fa",
	"fa6-brands",
	"fa6-regular",
	"fa6-solid",
	"fad",
	"fe",
	"feather",
	"file-icons",
	"flag",
	"flagpack",
	"flat-color-icons",
	"flat-ui",
	"flowbite",
	"fluent-emoji-flat",
	"fluent-emoji-high-contrast",
	"fluent-emoji",
	"fluent-mdl2",
	"fluent",
	"fontelico",
	"fontisto",
	"formkit",
	"foundation",
	"fxemoji",
	"gala",
	"game-icons",
	"geo",
	"gg",
	"gis",
	"gravity-ui",
	"gridicons",
	"grommet-icons",
	"guidance",
	"healthicons",
	"heroicons-outline",
	"heroicons-solid",
	"heroicons",
	"humbleicons",
	"ic",
	"icomoon-free",
	"icon-park-outline",
	"icon-park-solid",
	"icon-park-twotone",
	"icon-park",
	"iconamoon",
	"iconoir",
	"icons8",
	"il",
	"ion",
	"iwwa",
	"jam",
	"la",
	"lets-icons",
	"line-md",
	"logos",
	"ls",
	"lucide",
	"mage",
	"majesticons",
	"maki",
	"map",
	"material-symbols-light",
	"material-symbols",
	"mdi-light",
	"mdi",
	"medical-icon",
	"memory",
	"meteocons",
	"mi",
	"mingcute",
	"mono-icons",
	"mynaui",
	"nimbus",
	"nonicons",
	"noto-v1",
	"noto",
	"octicon",
	"oi",
	"ooui",
	"openmoji",
	"oui",
	"pajamas",
	"pepicons-pencil",
	"pepicons-pop",
	"pepicons-print",
	"pepicons",
	"ph",
	"pixelarticons",
	"prime",
	"ps",
	"quill",
	"radix-icons",
	"raphael",
	"ri",
	"si-glyph",
	"simple-icons",
	"simple-line-icons",
	"skill-icons",
	"solar",
	"streamline-emojis",
	"streamline",
	"subway",
	"svg-spinners",
	"system-uicons",
	"tabler",
	"tdesign",
	"teenyicons",
	"topcoat",
	"twemoji",
	"typcn",
	"uil",
	"uim",
	"uis",
	"uit",
	"uiw",
	"unjs",
	"vaadin",
	"vs",
	"vscode-icons",
	"websymbol",
	"whh",
	"wi",
	"wpf",
	"zmdi",
	"zondicons"
];

const icons = /*@__PURE__*/getDefaultExportFromCjs(collections);

const COLLECTION_NAME_PARTS_MAX = 3;
function createPresetIcons(lookupIconLoader) {
  return core$9.definePreset((options = {}) => {
    const {
      scale = 1,
      mode = "auto",
      prefix = "i-",
      warn = false,
      collections: customCollections,
      extraProperties = {},
      customizations = {},
      autoInstall = false,
      collectionsNodeResolvePath,
      layer = "icons",
      unit
    } = options;
    const flags = getEnvFlags();
    const loaderOptions = {
      addXmlNs: true,
      scale,
      customCollections,
      autoInstall,
      cwd: collectionsNodeResolvePath,
      // avoid warn from @iconify/loader: we'll warn below if not found
      warn: void 0,
      customizations: {
        ...customizations,
        additionalProps: { ...extraProperties },
        trimCustomSvg: true,
        async iconCustomizer(collection, icon, props) {
          await customizations.iconCustomizer?.(collection, icon, props);
          if (unit) {
            if (!props.width)
              props.width = `${scale}${unit}`;
            if (!props.height)
              props.height = `${scale}${unit}`;
          }
        }
      }
    };
    let iconLoader;
    return {
      name: "@unocss/preset-icons",
      enforce: "pre",
      options,
      layers: { icons: -30 },
      rules: [[
        /^([a-z0-9:_-]+)(?:\?(mask|bg|auto))?$/,
        async ([full, body, _mode = mode]) => {
          let collection = "";
          let name = "";
          let svg;
          iconLoader = iconLoader || await lookupIconLoader(options);
          const usedProps = {};
          if (body.includes(":")) {
            [collection, name] = body.split(":");
            svg = await iconLoader(collection, name, { ...loaderOptions, usedProps });
          } else {
            const parts = body.split(/-/g);
            for (let i = COLLECTION_NAME_PARTS_MAX; i >= 1; i--) {
              collection = parts.slice(0, i).join("-");
              name = parts.slice(i).join("-");
              svg = await iconLoader(collection, name, { ...loaderOptions, usedProps });
              if (svg)
                break;
            }
          }
          if (!svg) {
            if (warn && !flags.isESLint)
              core$9.warnOnce(`failed to load icon "${full}"`);
            return;
          }
          const url = `url("data:image/svg+xml;utf8,${encodeSvgForCss(svg)}")`;
          if (_mode === "auto")
            _mode = svg.includes("currentColor") ? "mask" : "bg";
          if (_mode === "mask") {
            return {
              "--un-icon": url,
              "-webkit-mask": "var(--un-icon) no-repeat",
              "mask": "var(--un-icon) no-repeat",
              "-webkit-mask-size": "100% 100%",
              "mask-size": "100% 100%",
              "background-color": "currentColor",
              // for Safari https://github.com/elk-zone/elk/pull/264
              "color": "inherit",
              ...usedProps
            };
          } else {
            return {
              "background": `${url} no-repeat`,
              "background-size": "100% 100%",
              "background-color": "transparent",
              ...usedProps
            };
          }
        },
        { layer, prefix }
      ]]
    };
  });
}
function combineLoaders(loaders) {
  return async (...args) => {
    for (const loader of loaders) {
      if (!loader)
        continue;
      const result = await loader(...args);
      if (result)
        return result;
    }
  };
}
function createCDNFetchLoader(fetcher, cdnBase) {
  const cache = /* @__PURE__ */ new Map();
  function fetchCollection(name) {
    if (!icons.includes(name))
      return void 0;
    if (!cache.has(name))
      cache.set(name, fetcher(`${cdnBase}@iconify-json/${name}/icons.json`));
    return cache.get(name);
  }
  return async (collection, icon, options) => {
    let result = await loadIcon(collection, icon, options);
    if (result)
      return result;
    const iconSet = await fetchCollection(collection);
    if (iconSet) {
      const ids = [
        icon,
        icon.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
        icon.replace(/([a-z])(\d+)/g, "$1-$2")
      ];
      result = await searchForIcon(iconSet, collection, ids, options);
    }
    return result;
  };
}
function getEnvFlags() {
  const isNode = typeof process !== "undefined" && process.stdout && !process.versions.deno;
  const isVSCode = isNode && !!process.env.VSCODE_CWD;
  const isESLint = isNode && !!process.env.ESLINT;
  return {
    isNode,
    isVSCode,
    isESLint
  };
}

presetIcons_De8FRNb6.combineLoaders = combineLoaders;
presetIcons_De8FRNb6.createCDNFetchLoader = createCDNFetchLoader;
presetIcons_De8FRNb6.createPresetIcons = createPresetIcons;
presetIcons_De8FRNb6.getEnvFlags = getEnvFlags;
presetIcons_De8FRNb6.icons = icons;
presetIcons_De8FRNb6.loadIcon = loadIcon;

const ofetch = node$2;
const core$8 = presetIcons_De8FRNb6;

function createCDNLoader(cdnBase) {
  return core$8.createCDNFetchLoader(ofetch.$fetch, cdnBase);
}

presetIcons_DDHG4xNZ.createCDNLoader = createCDNLoader;

var nodeLoader = {};

var modern = {};

var build = {};

var defaults$1 = {};

var hasRequiredDefaults$1;

function requireDefaults$1 () {
	if (hasRequiredDefaults$1) return defaults$1;
	hasRequiredDefaults$1 = 1;

	const defaultIconDimensions = Object.freeze(
	  {
	    left: 0,
	    top: 0,
	    width: 16,
	    height: 16
	  }
	);
	const defaultIconTransformations = Object.freeze({
	  rotate: 0,
	  vFlip: false,
	  hFlip: false
	});
	const defaultIconProps = Object.freeze({
	  ...defaultIconDimensions,
	  ...defaultIconTransformations
	});
	const defaultExtendedIconProps = Object.freeze({
	  ...defaultIconProps,
	  body: "",
	  hidden: false
	});

	defaults$1.defaultExtendedIconProps = defaultExtendedIconProps;
	defaults$1.defaultIconDimensions = defaultIconDimensions;
	defaults$1.defaultIconProps = defaultIconProps;
	defaults$1.defaultIconTransformations = defaultIconTransformations;
	return defaults$1;
}

var defaults = {};

var hasRequiredDefaults;

function requireDefaults () {
	if (hasRequiredDefaults) return defaults;
	hasRequiredDefaults = 1;

	const icon_defaults = requireDefaults$1();

	const defaultIconSizeCustomisations = Object.freeze({
	  width: null,
	  height: null
	});
	const defaultIconCustomisations = Object.freeze({
	  // Dimensions
	  ...defaultIconSizeCustomisations,
	  // Transformations
	  ...icon_defaults.defaultIconTransformations
	});

	defaults.defaultIconCustomisations = defaultIconCustomisations;
	defaults.defaultIconSizeCustomisations = defaultIconSizeCustomisations;
	return defaults;
}

var size$1 = {};

var hasRequiredSize;

function requireSize () {
	if (hasRequiredSize) return size$1;
	hasRequiredSize = 1;

	const unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
	const unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
	function calculateSize(size, ratio, precision) {
	  if (ratio === 1) {
	    return size;
	  }
	  precision = precision || 100;
	  if (typeof size === "number") {
	    return Math.ceil(size * ratio * precision) / precision;
	  }
	  if (typeof size !== "string") {
	    return size;
	  }
	  const oldParts = size.split(unitsSplit);
	  if (oldParts === null || !oldParts.length) {
	    return size;
	  }
	  const newParts = [];
	  let code = oldParts.shift();
	  let isNumber = unitsTest.test(code);
	  while (true) {
	    if (isNumber) {
	      const num = parseFloat(code);
	      if (isNaN(num)) {
	        newParts.push(code);
	      } else {
	        newParts.push(Math.ceil(num * ratio * precision) / precision);
	      }
	    } else {
	      newParts.push(code);
	    }
	    code = oldParts.shift();
	    if (code === void 0) {
	      return newParts.join("");
	    }
	    isNumber = !isNumber;
	  }
	}

	size$1.calculateSize = calculateSize;
	return size$1;
}

var defs = {};

var hasRequiredDefs;

function requireDefs () {
	if (hasRequiredDefs) return defs;
	hasRequiredDefs = 1;

	function splitSVGDefs(content, tag = "defs") {
	  let defs = "";
	  const index = content.indexOf("<" + tag);
	  while (index >= 0) {
	    const start = content.indexOf(">", index);
	    const end = content.indexOf("</" + tag);
	    if (start === -1 || end === -1) {
	      break;
	    }
	    const endEnd = content.indexOf(">", end);
	    if (endEnd === -1) {
	      break;
	    }
	    defs += content.slice(start + 1, end).trim();
	    content = content.slice(0, index).trim() + content.slice(endEnd + 1);
	  }
	  return {
	    defs,
	    content
	  };
	}
	function mergeDefsAndContent(defs, content) {
	  return defs ? "<defs>" + defs + "</defs>" + content : content;
	}
	function wrapSVGContent(body, start, end) {
	  const split = splitSVGDefs(body);
	  return mergeDefsAndContent(split.defs, start + split.content + end);
	}

	defs.mergeDefsAndContent = mergeDefsAndContent;
	defs.splitSVGDefs = splitSVGDefs;
	defs.wrapSVGContent = wrapSVGContent;
	return defs;
}

var hasRequiredBuild;

function requireBuild () {
	if (hasRequiredBuild) return build;
	hasRequiredBuild = 1;

	const icon_defaults = requireDefaults$1();
	const customisations_defaults = requireDefaults();
	const svg_size = requireSize();
	const svg_defs = requireDefs();

	const isUnsetKeyword = (value) => value === "unset" || value === "undefined" || value === "none";
	function iconToSVG(icon, customisations) {
	  const fullIcon = {
	    ...icon_defaults.defaultIconProps,
	    ...icon
	  };
	  const fullCustomisations = {
	    ...customisations_defaults.defaultIconCustomisations,
	    ...customisations
	  };
	  const box = {
	    left: fullIcon.left,
	    top: fullIcon.top,
	    width: fullIcon.width,
	    height: fullIcon.height
	  };
	  let body = fullIcon.body;
	  [fullIcon, fullCustomisations].forEach((props) => {
	    const transformations = [];
	    const hFlip = props.hFlip;
	    const vFlip = props.vFlip;
	    let rotation = props.rotate;
	    if (hFlip) {
	      if (vFlip) {
	        rotation += 2;
	      } else {
	        transformations.push(
	          "translate(" + (box.width + box.left).toString() + " " + (0 - box.top).toString() + ")"
	        );
	        transformations.push("scale(-1 1)");
	        box.top = box.left = 0;
	      }
	    } else if (vFlip) {
	      transformations.push(
	        "translate(" + (0 - box.left).toString() + " " + (box.height + box.top).toString() + ")"
	      );
	      transformations.push("scale(1 -1)");
	      box.top = box.left = 0;
	    }
	    let tempValue;
	    if (rotation < 0) {
	      rotation -= Math.floor(rotation / 4) * 4;
	    }
	    rotation = rotation % 4;
	    switch (rotation) {
	      case 1:
	        tempValue = box.height / 2 + box.top;
	        transformations.unshift(
	          "rotate(90 " + tempValue.toString() + " " + tempValue.toString() + ")"
	        );
	        break;
	      case 2:
	        transformations.unshift(
	          "rotate(180 " + (box.width / 2 + box.left).toString() + " " + (box.height / 2 + box.top).toString() + ")"
	        );
	        break;
	      case 3:
	        tempValue = box.width / 2 + box.left;
	        transformations.unshift(
	          "rotate(-90 " + tempValue.toString() + " " + tempValue.toString() + ")"
	        );
	        break;
	    }
	    if (rotation % 2 === 1) {
	      if (box.left !== box.top) {
	        tempValue = box.left;
	        box.left = box.top;
	        box.top = tempValue;
	      }
	      if (box.width !== box.height) {
	        tempValue = box.width;
	        box.width = box.height;
	        box.height = tempValue;
	      }
	    }
	    if (transformations.length) {
	      body = svg_defs.wrapSVGContent(
	        body,
	        '<g transform="' + transformations.join(" ") + '">',
	        "</g>"
	      );
	    }
	  });
	  const customisationsWidth = fullCustomisations.width;
	  const customisationsHeight = fullCustomisations.height;
	  const boxWidth = box.width;
	  const boxHeight = box.height;
	  let width;
	  let height;
	  if (customisationsWidth === null) {
	    height = customisationsHeight === null ? "1em" : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
	    width = svg_size.calculateSize(height, boxWidth / boxHeight);
	  } else {
	    width = customisationsWidth === "auto" ? boxWidth : customisationsWidth;
	    height = customisationsHeight === null ? svg_size.calculateSize(width, boxHeight / boxWidth) : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
	  }
	  const attributes = {};
	  const setAttr = (prop, value) => {
	    if (!isUnsetKeyword(value)) {
	      attributes[prop] = value.toString();
	    }
	  };
	  setAttr("width", width);
	  setAttr("height", height);
	  const viewBox = [box.left, box.top, boxWidth, boxHeight];
	  attributes.viewBox = viewBox.join(" ");
	  return {
	    attributes,
	    viewBox,
	    body
	  };
	}

	build.iconToSVG = iconToSVG;
	build.isUnsetKeyword = isUnsetKeyword;
	return build;
}

var getIcon = {};

var merge = {};

var transformations = {};

var hasRequiredTransformations;

function requireTransformations () {
	if (hasRequiredTransformations) return transformations;
	hasRequiredTransformations = 1;

	function mergeIconTransformations(obj1, obj2) {
	  const result = {};
	  if (!obj1.hFlip !== !obj2.hFlip) {
	    result.hFlip = true;
	  }
	  if (!obj1.vFlip !== !obj2.vFlip) {
	    result.vFlip = true;
	  }
	  const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;
	  if (rotate) {
	    result.rotate = rotate;
	  }
	  return result;
	}

	transformations.mergeIconTransformations = mergeIconTransformations;
	return transformations;
}

var hasRequiredMerge;

function requireMerge () {
	if (hasRequiredMerge) return merge;
	hasRequiredMerge = 1;

	const icon_defaults = requireDefaults$1();
	const icon_transformations = requireTransformations();

	function mergeIconData(parent, child) {
	  const result = icon_transformations.mergeIconTransformations(parent, child);
	  for (const key in icon_defaults.defaultExtendedIconProps) {
	    if (key in icon_defaults.defaultIconTransformations) {
	      if (key in parent && !(key in result)) {
	        result[key] = icon_defaults.defaultIconTransformations[key];
	      }
	    } else if (key in child) {
	      result[key] = child[key];
	    } else if (key in parent) {
	      result[key] = parent[key];
	    }
	  }
	  return result;
	}

	merge.mergeIconData = mergeIconData;
	return merge;
}

var tree = {};

var hasRequiredTree;

function requireTree () {
	if (hasRequiredTree) return tree;
	hasRequiredTree = 1;

	function getIconsTree(data, names) {
	  const icons = data.icons;
	  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
	  const resolved = /* @__PURE__ */ Object.create(null);
	  function resolve(name) {
	    if (icons[name]) {
	      return resolved[name] = [];
	    }
	    if (!(name in resolved)) {
	      resolved[name] = null;
	      const parent = aliases[name] && aliases[name].parent;
	      const value = parent && resolve(parent);
	      if (value) {
	        resolved[name] = [parent].concat(value);
	      }
	    }
	    return resolved[name];
	  }
	  (names || Object.keys(icons).concat(Object.keys(aliases))).forEach(resolve);
	  return resolved;
	}

	tree.getIconsTree = getIconsTree;
	return tree;
}

var hasRequiredGetIcon;

function requireGetIcon () {
	if (hasRequiredGetIcon) return getIcon;
	hasRequiredGetIcon = 1;

	const icon_merge = requireMerge();
	const iconSet_tree = requireTree();
	requireDefaults$1();
	requireTransformations();

	function internalGetIconData(data, name, tree) {
	  const icons = data.icons;
	  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
	  let currentProps = {};
	  function parse(name2) {
	    currentProps = icon_merge.mergeIconData(
	      icons[name2] || aliases[name2],
	      currentProps
	    );
	  }
	  parse(name);
	  tree.forEach(parse);
	  return icon_merge.mergeIconData(data, currentProps);
	}
	function getIconData(data, name) {
	  if (data.icons[name]) {
	    return internalGetIconData(data, name, []);
	  }
	  const tree = iconSet_tree.getIconsTree(data, [name])[name];
	  return tree ? internalGetIconData(data, name, tree) : null;
	}

	getIcon.getIconData = getIconData;
	getIcon.internalGetIconData = internalGetIconData;
	return getIcon;
}

var utils$a = {};

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils$a;
	hasRequiredUtils = 1;

	const svg_build = requireBuild();
	requireDefaults$1();
	requireDefaults();
	requireSize();
	requireDefs();

	const svgWidthRegex = /\swidth\s*=\s*["']([\w.]+)["']/;
	const svgHeightRegex = /\sheight\s*=\s*["']([\w.]+)["']/;
	const svgTagRegex = /<svg\s+/;
	function configureSvgSize(svg, props, scale) {
	  const svgNode = svg.slice(0, svg.indexOf(">"));
	  const check = (prop, regex) => {
	    const result = regex.exec(svgNode);
	    const isSet = result != null;
	    const propValue = props[prop];
	    if (!propValue && !svg_build.isUnsetKeyword(propValue)) {
	      if (typeof scale === "number") {
	        if (scale > 0) {
	          props[prop] = `${scale}em`;
	        }
	      } else if (result) {
	        props[prop] = result[1];
	      }
	    }
	    return isSet;
	  };
	  return [check("width", svgWidthRegex), check("height", svgHeightRegex)];
	}
	async function mergeIconProps(svg, collection, icon, options, propsProvider, afterCustomizations) {
	  const { scale, addXmlNs = false } = options ?? {};
	  const { additionalProps = {}, iconCustomizer } = options?.customizations ?? {};
	  const props = await propsProvider?.() ?? {};
	  await iconCustomizer?.(collection, icon, props);
	  Object.keys(additionalProps).forEach((p) => {
	    const v = additionalProps[p];
	    if (v !== void 0 && v !== null)
	      props[p] = v;
	  });
	  afterCustomizations?.(props);
	  const [widthOnSvg, heightOnSvg] = configureSvgSize(svg, props, scale);
	  if (addXmlNs) {
	    if (!svg.includes("xmlns=") && !props["xmlns"]) {
	      props["xmlns"] = "http://www.w3.org/2000/svg";
	    }
	    if (!svg.includes("xmlns:xlink=") && svg.includes("xlink:") && !props["xmlns:xlink"]) {
	      props["xmlns:xlink"] = "http://www.w3.org/1999/xlink";
	    }
	  }
	  const propsToAdd = Object.keys(props).map(
	    (p) => p === "width" && widthOnSvg || p === "height" && heightOnSvg ? null : `${p}="${props[p]}"`
	  ).filter((p) => p != null);
	  if (propsToAdd.length) {
	    svg = svg.replace(svgTagRegex, `<svg ${propsToAdd.join(" ")} `);
	  }
	  if (options) {
	    const { defaultStyle, defaultClass } = options;
	    if (defaultClass && !svg.includes("class=")) {
	      svg = svg.replace(svgTagRegex, `<svg class="${defaultClass}" `);
	    }
	    if (defaultStyle && !svg.includes("style=")) {
	      svg = svg.replace(svgTagRegex, `<svg style="${defaultStyle}" `);
	    }
	  }
	  const usedProps = options?.usedProps;
	  if (usedProps) {
	    Object.keys(additionalProps).forEach((p) => {
	      const v = props[p];
	      if (v !== void 0 && v !== null)
	        usedProps[p] = v;
	    });
	    if (typeof props.width !== "undefined" && props.width !== null) {
	      usedProps.width = props.width;
	    }
	    if (typeof props.height !== "undefined" && props.height !== null) {
	      usedProps.height = props.height;
	    }
	  }
	  return svg;
	}
	function getPossibleIconNames(icon) {
	  return [
	    icon,
	    icon.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
	    icon.replace(/([a-z])(\d+)/g, "$1-$2")
	  ];
	}

	utils$a.getPossibleIconNames = getPossibleIconNames;
	utils$a.mergeIconProps = mergeIconProps;
	return utils$a;
}

var src = {exports: {}};

var browser$1 = {exports: {}};

/**
 * Helpers.
 */

var ms;
var hasRequiredMs;

function requireMs () {
	if (hasRequiredMs) return ms;
	hasRequiredMs = 1;
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	ms = function(val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isFinite(val)) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'weeks':
	    case 'week':
	    case 'w':
	      return n * w;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (msAbs >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (msAbs >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (msAbs >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return plural(ms, msAbs, d, 'day');
	  }
	  if (msAbs >= h) {
	    return plural(ms, msAbs, h, 'hour');
	  }
	  if (msAbs >= m) {
	    return plural(ms, msAbs, m, 'minute');
	  }
	  if (msAbs >= s) {
	    return plural(ms, msAbs, s, 'second');
	  }
	  return ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, msAbs, n, name) {
	  var isPlural = msAbs >= n * 1.5;
	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
	}
	return ms;
}

var common;
var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 */

	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = requireMs();
		createDebug.destroy = destroy;

		Object.keys(env).forEach(key => {
			createDebug[key] = env[key];
		});

		/**
		* The currently active debug mode names, and names to skip.
		*/

		createDebug.names = [];
		createDebug.skips = [];

		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};

		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;

			for (let i = 0; i < namespace.length; i++) {
				hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
				hash |= 0; // Convert to 32bit integer
			}

			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;

		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;

			function debug(...args) {
				// Disabled?
				if (!debug.enabled) {
					return;
				}

				const self = debug;

				// Set `diff` timestamp
				const curr = Number(new Date());
				const ms = curr - (prevTime || curr);
				self.diff = ms;
				self.prev = prevTime;
				self.curr = curr;
				prevTime = curr;

				args[0] = createDebug.coerce(args[0]);

				if (typeof args[0] !== 'string') {
					// Anything else let's inspect with %O
					args.unshift('%O');
				}

				// Apply any `formatters` transformations
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					// If we encounter an escaped % then don't increase the array index
					if (match === '%%') {
						return '%';
					}
					index++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === 'function') {
						const val = args[index];
						match = formatter.call(self, val);

						// Now we need to remove `args[index]` since it's inlined in the `format`
						args.splice(index, 1);
						index--;
					}
					return match;
				});

				// Apply env-specific formatting (colors, etc.)
				createDebug.formatArgs.call(self, args);

				const logFn = self.log || createDebug.log;
				logFn.apply(self, args);
			}

			debug.namespace = namespace;
			debug.useColors = createDebug.useColors();
			debug.color = createDebug.selectColor(namespace);
			debug.extend = extend;
			debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

			Object.defineProperty(debug, 'enabled', {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) {
						return enableOverride;
					}
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}

					return enabledCache;
				},
				set: v => {
					enableOverride = v;
				}
			});

			// Env-specific initialization logic for debug instances
			if (typeof createDebug.init === 'function') {
				createDebug.init(debug);
			}

			return debug;
		}

		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}

		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;

			createDebug.names = [];
			createDebug.skips = [];

			let i;
			const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
			const len = split.length;

			for (i = 0; i < len; i++) {
				if (!split[i]) {
					// ignore empty strings
					continue;
				}

				namespaces = split[i].replace(/\*/g, '.*?');

				if (namespaces[0] === '-') {
					createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
				} else {
					createDebug.names.push(new RegExp('^' + namespaces + '$'));
				}
			}
		}

		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [
				...createDebug.names.map(toNamespace),
				...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
			].join(',');
			createDebug.enable('');
			return namespaces;
		}

		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			if (name[name.length - 1] === '*') {
				return true;
			}

			let i;
			let len;

			for (i = 0, len = createDebug.skips.length; i < len; i++) {
				if (createDebug.skips[i].test(name)) {
					return false;
				}
			}

			for (i = 0, len = createDebug.names.length; i < len; i++) {
				if (createDebug.names[i].test(name)) {
					return true;
				}
			}

			return false;
		}

		/**
		* Convert regexp to namespace
		*
		* @param {RegExp} regxep
		* @return {String} namespace
		* @api private
		*/
		function toNamespace(regexp) {
			return regexp.toString()
				.substring(2, regexp.toString().length - 2)
				.replace(/\.\*\?$/, '*');
		}

		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) {
				return val.stack || val.message;
			}
			return val;
		}

		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy() {
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}

		createDebug.enable(createDebug.load());

		return createDebug;
	}

	common = setup;
	return common;
}

/* eslint-env browser */

var hasRequiredBrowser;

function requireBrowser () {
	if (hasRequiredBrowser) return browser$1.exports;
	hasRequiredBrowser = 1;
	(function (module, exports) {
		/**
		 * This is the web browser implementation of `debug()`.
		 */

		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;
		exports.storage = localstorage();
		exports.destroy = (() => {
			let warned = false;

			return () => {
				if (!warned) {
					warned = true;
					console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
				}
			};
		})();

		/**
		 * Colors.
		 */

		exports.colors = [
			'#0000CC',
			'#0000FF',
			'#0033CC',
			'#0033FF',
			'#0066CC',
			'#0066FF',
			'#0099CC',
			'#0099FF',
			'#00CC00',
			'#00CC33',
			'#00CC66',
			'#00CC99',
			'#00CCCC',
			'#00CCFF',
			'#3300CC',
			'#3300FF',
			'#3333CC',
			'#3333FF',
			'#3366CC',
			'#3366FF',
			'#3399CC',
			'#3399FF',
			'#33CC00',
			'#33CC33',
			'#33CC66',
			'#33CC99',
			'#33CCCC',
			'#33CCFF',
			'#6600CC',
			'#6600FF',
			'#6633CC',
			'#6633FF',
			'#66CC00',
			'#66CC33',
			'#9900CC',
			'#9900FF',
			'#9933CC',
			'#9933FF',
			'#99CC00',
			'#99CC33',
			'#CC0000',
			'#CC0033',
			'#CC0066',
			'#CC0099',
			'#CC00CC',
			'#CC00FF',
			'#CC3300',
			'#CC3333',
			'#CC3366',
			'#CC3399',
			'#CC33CC',
			'#CC33FF',
			'#CC6600',
			'#CC6633',
			'#CC9900',
			'#CC9933',
			'#CCCC00',
			'#CCCC33',
			'#FF0000',
			'#FF0033',
			'#FF0066',
			'#FF0099',
			'#FF00CC',
			'#FF00FF',
			'#FF3300',
			'#FF3333',
			'#FF3366',
			'#FF3399',
			'#FF33CC',
			'#FF33FF',
			'#FF6600',
			'#FF6633',
			'#FF9900',
			'#FF9933',
			'#FFCC00',
			'#FFCC33'
		];

		/**
		 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
		 * and the Firebug extension (any Firefox version) are known
		 * to support "%c" CSS customizations.
		 *
		 * TODO: add a `localStorage` variable to explicitly enable/disable colors
		 */

		// eslint-disable-next-line complexity
		function useColors() {
			// NB: In an Electron preload script, document will be defined but not fully
			// initialized. Since we know we're in Chrome, we'll just detect this case
			// explicitly
			if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
				return true;
			}

			// Internet Explorer and Edge do not support colors.
			if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
				return false;
			}

			// Is webkit? http://stackoverflow.com/a/16459606/376773
			// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
			return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
				// Is firebug? http://stackoverflow.com/a/398120/376773
				(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
				// Is firefox >= v31?
				// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
				(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
				// Double check webkit in userAgent just in case we are in a worker
				(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
		}

		/**
		 * Colorize log arguments if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			args[0] = (this.useColors ? '%c' : '') +
				this.namespace +
				(this.useColors ? ' %c' : ' ') +
				args[0] +
				(this.useColors ? '%c ' : ' ') +
				'+' + module.exports.humanize(this.diff);

			if (!this.useColors) {
				return;
			}

			const c = 'color: ' + this.color;
			args.splice(1, 0, c, 'color: inherit');

			// The final "%c" is somewhat tricky, because there could be other
			// arguments passed either before or after the %c, so we need to
			// figure out the correct index to insert the CSS into
			let index = 0;
			let lastC = 0;
			args[0].replace(/%[a-zA-Z%]/g, match => {
				if (match === '%%') {
					return;
				}
				index++;
				if (match === '%c') {
					// We only are interested in the *last* %c
					// (the user may have provided their own)
					lastC = index;
				}
			});

			args.splice(lastC, 0, c);
		}

		/**
		 * Invokes `console.debug()` when available.
		 * No-op when `console.debug` is not a "function".
		 * If `console.debug` is not available, falls back
		 * to `console.log`.
		 *
		 * @api public
		 */
		exports.log = console.debug || console.log || (() => {});

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			try {
				if (namespaces) {
					exports.storage.setItem('debug', namespaces);
				} else {
					exports.storage.removeItem('debug');
				}
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */
		function load() {
			let r;
			try {
				r = exports.storage.getItem('debug');
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}

			// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
			if (!r && typeof process !== 'undefined' && 'env' in process) {
				r = process.env.DEBUG;
			}

			return r;
		}

		/**
		 * Localstorage attempts to return the localstorage.
		 *
		 * This is necessary because safari throws
		 * when a user disables cookies/localstorage
		 * and you attempt to access it.
		 *
		 * @return {LocalStorage}
		 * @api private
		 */

		function localstorage() {
			try {
				// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
				// The Browser also has localStorage in the global context.
				return localStorage;
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		module.exports = requireCommon()(exports);

		const {formatters} = module.exports;

		/**
		 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
		 */

		formatters.j = function (v) {
			try {
				return JSON.stringify(v);
			} catch (error) {
				return '[UnexpectedJSONParseError]: ' + error.message;
			}
		}; 
	} (browser$1, browser$1.exports));
	return browser$1.exports;
}

var node$1 = {exports: {}};

var hasFlag;
var hasRequiredHasFlag;

function requireHasFlag () {
	if (hasRequiredHasFlag) return hasFlag;
	hasRequiredHasFlag = 1;

	hasFlag = (flag, argv = process.argv) => {
		const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
		const position = argv.indexOf(prefix + flag);
		const terminatorPosition = argv.indexOf('--');
		return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
	};
	return hasFlag;
}

var supportsColor_1;
var hasRequiredSupportsColor;

function requireSupportsColor () {
	if (hasRequiredSupportsColor) return supportsColor_1;
	hasRequiredSupportsColor = 1;
	const os = require$$0$3;
	const tty = require$$1$1;
	const hasFlag = requireHasFlag();

	const {env} = process;

	let forceColor;
	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false') ||
		hasFlag('color=never')) {
		forceColor = 0;
	} else if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		forceColor = 1;
	}

	if ('FORCE_COLOR' in env) {
		if (env.FORCE_COLOR === 'true') {
			forceColor = 1;
		} else if (env.FORCE_COLOR === 'false') {
			forceColor = 0;
		} else {
			forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
		}
	}

	function translateLevel(level) {
		if (level === 0) {
			return false;
		}

		return {
			level,
			hasBasic: true,
			has256: level >= 2,
			has16m: level >= 3
		};
	}

	function supportsColor(haveStream, streamIsTTY) {
		if (forceColor === 0) {
			return 0;
		}

		if (hasFlag('color=16m') ||
			hasFlag('color=full') ||
			hasFlag('color=truecolor')) {
			return 3;
		}

		if (hasFlag('color=256')) {
			return 2;
		}

		if (haveStream && !streamIsTTY && forceColor === undefined) {
			return 0;
		}

		const min = forceColor || 0;

		if (env.TERM === 'dumb') {
			return min;
		}

		if (process.platform === 'win32') {
			// Windows 10 build 10586 is the first Windows release that supports 256 colors.
			// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
			const osRelease = os.release().split('.');
			if (
				Number(osRelease[0]) >= 10 &&
				Number(osRelease[2]) >= 10586
			) {
				return Number(osRelease[2]) >= 14931 ? 3 : 2;
			}

			return 1;
		}

		if ('CI' in env) {
			if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
				return 1;
			}

			return min;
		}

		if ('TEAMCITY_VERSION' in env) {
			return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
		}

		if (env.COLORTERM === 'truecolor') {
			return 3;
		}

		if ('TERM_PROGRAM' in env) {
			const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

			switch (env.TERM_PROGRAM) {
				case 'iTerm.app':
					return version >= 3 ? 3 : 2;
				case 'Apple_Terminal':
					return 2;
				// No default
			}
		}

		if (/-256(color)?$/i.test(env.TERM)) {
			return 2;
		}

		if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
			return 1;
		}

		if ('COLORTERM' in env) {
			return 1;
		}

		return min;
	}

	function getSupportLevel(stream) {
		const level = supportsColor(stream, stream && stream.isTTY);
		return translateLevel(level);
	}

	supportsColor_1 = {
		supportsColor: getSupportLevel,
		stdout: translateLevel(supportsColor(true, tty.isatty(1))),
		stderr: translateLevel(supportsColor(true, tty.isatty(2)))
	};
	return supportsColor_1;
}

/**
 * Module dependencies.
 */

var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node$1.exports;
	hasRequiredNode = 1;
	(function (module, exports) {
		const tty = require$$1$1;
		const util = require$$1$2;

		/**
		 * This is the Node.js implementation of `debug()`.
		 */

		exports.init = init;
		exports.log = log;
		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;
		exports.destroy = util.deprecate(
			() => {},
			'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
		);

		/**
		 * Colors.
		 */

		exports.colors = [6, 2, 3, 4, 5, 1];

		try {
			// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
			// eslint-disable-next-line import/no-extraneous-dependencies
			const supportsColor = requireSupportsColor();

			if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
				exports.colors = [
					20,
					21,
					26,
					27,
					32,
					33,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					56,
					57,
					62,
					63,
					68,
					69,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					92,
					93,
					98,
					99,
					112,
					113,
					128,
					129,
					134,
					135,
					148,
					149,
					160,
					161,
					162,
					163,
					164,
					165,
					166,
					167,
					168,
					169,
					170,
					171,
					172,
					173,
					178,
					179,
					184,
					185,
					196,
					197,
					198,
					199,
					200,
					201,
					202,
					203,
					204,
					205,
					206,
					207,
					208,
					209,
					214,
					215,
					220,
					221
				];
			}
		} catch (error) {
			// Swallow - we only care if `supports-color` is available; it doesn't have to be.
		}

		/**
		 * Build up the default `inspectOpts` object from the environment variables.
		 *
		 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
		 */

		exports.inspectOpts = Object.keys(process.env).filter(key => {
			return /^debug_/i.test(key);
		}).reduce((obj, key) => {
			// Camel-case
			const prop = key
				.substring(6)
				.toLowerCase()
				.replace(/_([a-z])/g, (_, k) => {
					return k.toUpperCase();
				});

			// Coerce string value into JS value
			let val = process.env[key];
			if (/^(yes|on|true|enabled)$/i.test(val)) {
				val = true;
			} else if (/^(no|off|false|disabled)$/i.test(val)) {
				val = false;
			} else if (val === 'null') {
				val = null;
			} else {
				val = Number(val);
			}

			obj[prop] = val;
			return obj;
		}, {});

		/**
		 * Is stdout a TTY? Colored output is enabled when `true`.
		 */

		function useColors() {
			return 'colors' in exports.inspectOpts ?
				Boolean(exports.inspectOpts.colors) :
				tty.isatty(process.stderr.fd);
		}

		/**
		 * Adds ANSI color escape codes if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			const {namespace: name, useColors} = this;

			if (useColors) {
				const c = this.color;
				const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
				const prefix = `  ${colorCode};1m${name} \u001B[0m`;

				args[0] = prefix + args[0].split('\n').join('\n' + prefix);
				args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
			} else {
				args[0] = getDate() + name + ' ' + args[0];
			}
		}

		function getDate() {
			if (exports.inspectOpts.hideDate) {
				return '';
			}
			return new Date().toISOString() + ' ';
		}

		/**
		 * Invokes `util.format()` with the specified arguments and writes to stderr.
		 */

		function log(...args) {
			return process.stderr.write(util.format(...args) + '\n');
		}

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			if (namespaces) {
				process.env.DEBUG = namespaces;
			} else {
				// If you set a process.env field to null or undefined, it gets cast to the
				// string 'null' or 'undefined'. Just delete instead.
				delete process.env.DEBUG;
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */

		function load() {
			return process.env.DEBUG;
		}

		/**
		 * Init logic for `debug` instances.
		 *
		 * Create a new `inspectOpts` object in case `useColors` is set
		 * differently for a particular `debug` instance.
		 */

		function init(debug) {
			debug.inspectOpts = {};

			const keys = Object.keys(exports.inspectOpts);
			for (let i = 0; i < keys.length; i++) {
				debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
			}
		}

		module.exports = requireCommon()(exports);

		const {formatters} = module.exports;

		/**
		 * Map %o to `util.inspect()`, all on a single line.
		 */

		formatters.o = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts)
				.split('\n')
				.map(str => str.trim())
				.join(' ');
		};

		/**
		 * Map %O to `util.inspect()`, allowing multiple lines if needed.
		 */

		formatters.O = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts);
		}; 
	} (node$1, node$1.exports));
	return node$1.exports;
}

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src.exports;
	hasRequiredSrc = 1;
	if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
		src.exports = requireBrowser();
	} else {
		src.exports = requireNode();
	}
	return src.exports;
}

var hasRequiredModern;

function requireModern () {
	if (hasRequiredModern) return modern;
	hasRequiredModern = 1;

	const svg_build = requireBuild();
	const iconSet_getIcon = requireGetIcon();
	const loader_utils = requireUtils();
	const createDebugger = requireSrc();
	const customisations_defaults = requireDefaults();
	requireDefaults$1();
	requireSize();
	requireDefs();
	requireMerge();
	requireTransformations();
	requireTree();

	function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

	const createDebugger__default = /*#__PURE__*/_interopDefaultCompat(createDebugger);

	const debug = createDebugger__default("@iconify-loader:icon");
	async function searchForIcon(iconSet, collection, ids, options) {
	  let iconData;
	  const { customize } = options?.customizations ?? {};
	  for (const id of ids) {
	    iconData = iconSet_getIcon.getIconData(iconSet, id);
	    if (iconData) {
	      debug(`${collection}:${id}`);
	      let defaultCustomizations = { ...customisations_defaults.defaultIconCustomisations };
	      if (typeof customize === "function")
	        defaultCustomizations = customize(defaultCustomizations);
	      const {
	        attributes: { width, height, ...restAttributes },
	        body
	      } = svg_build.iconToSVG(iconData, defaultCustomizations);
	      const scale = options?.scale;
	      return await loader_utils.mergeIconProps(
	        // DON'T remove space on <svg >
	        `<svg >${body}</svg>`,
	        collection,
	        id,
	        options,
	        () => {
	          return { ...restAttributes };
	        },
	        (props) => {
	          const check = (prop, defaultValue) => {
	            const propValue = props[prop];
	            let value;
	            if (!svg_build.isUnsetKeyword(propValue)) {
	              if (propValue) {
	                return;
	              }
	              if (typeof scale === "number") {
	                if (scale) {
	                  value = `${scale}em`;
	                }
	              } else {
	                value = defaultValue;
	              }
	            }
	            if (!value) {
	              delete props[prop];
	            } else {
	              props[prop] = value;
	            }
	          };
	          check("width", width);
	          check("height", height);
	        }
	      );
	    }
	  }
	}

	modern.searchForIcon = searchForIcon;
	return modern;
}

var fs = {};

var dist$e = {};

var dist$d = {};

var acorn$1 = {exports: {}};

var hasRequiredAcorn$1;

function requireAcorn$1 () {
	if (hasRequiredAcorn$1) return acorn$1.exports;
	hasRequiredAcorn$1 = 1;
	(function (module, exports) {
		(function (global, factory) {
		  factory(exports) ;
		})(commonjsGlobal, (function (exports) {
		  // This file was generated. Do not modify manually!
		  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

		  // This file was generated. Do not modify manually!
		  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];

		  // This file was generated. Do not modify manually!
		  var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65";

		  // This file was generated. Do not modify manually!
		  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";

		  // These are a run-length and offset encoded representation of the
		  // >0xffff code points that are a valid part of identifiers. The
		  // offset starts at 0x10000, and each pair of numbers represents an
		  // offset to the next range, and then a size of the range.

		  // Reserved word lists for various dialects of the language

		  var reservedWords = {
		    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
		    5: "class enum extends super const export import",
		    6: "enum",
		    strict: "implements interface let package private protected public static yield",
		    strictBind: "eval arguments"
		  };

		  // And the keywords

		  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

		  var keywords$1 = {
		    5: ecma5AndLessKeywords,
		    "5module": ecma5AndLessKeywords + " export import",
		    6: ecma5AndLessKeywords + " const class extends export import super"
		  };

		  var keywordRelationalOperator = /^in(stanceof)?$/;

		  // ## Character categories

		  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
		  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

		  // This has a complexity linear to the value of the code. The
		  // assumption is that looking up astral identifier characters is
		  // rare.
		  function isInAstralSet(code, set) {
		    var pos = 0x10000;
		    for (var i = 0; i < set.length; i += 2) {
		      pos += set[i];
		      if (pos > code) { return false }
		      pos += set[i + 1];
		      if (pos >= code) { return true }
		    }
		    return false
		  }

		  // Test whether a given character code starts an identifier.

		  function isIdentifierStart(code, astral) {
		    if (code < 65) { return code === 36 }
		    if (code < 91) { return true }
		    if (code < 97) { return code === 95 }
		    if (code < 123) { return true }
		    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
		    if (astral === false) { return false }
		    return isInAstralSet(code, astralIdentifierStartCodes)
		  }

		  // Test whether a given character is part of an identifier.

		  function isIdentifierChar(code, astral) {
		    if (code < 48) { return code === 36 }
		    if (code < 58) { return true }
		    if (code < 65) { return false }
		    if (code < 91) { return true }
		    if (code < 97) { return code === 95 }
		    if (code < 123) { return true }
		    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
		    if (astral === false) { return false }
		    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
		  }

		  // ## Token types

		  // The assignment of fine-grained, information-carrying type objects
		  // allows the tokenizer to store the information it has about a
		  // token in a way that is very cheap for the parser to look up.

		  // All token type variables start with an underscore, to make them
		  // easy to recognize.

		  // The `beforeExpr` property is used to disambiguate between regular
		  // expressions and divisions. It is set on all token types that can
		  // be followed by an expression (thus, a slash after them would be a
		  // regular expression).
		  //
		  // The `startsExpr` property is used to check if the token ends a
		  // `yield` expression. It is set on all token types that either can
		  // directly start an expression (like a quotation mark) or can
		  // continue an expression (like the body of a string).
		  //
		  // `isLoop` marks a keyword as starting a loop, which is important
		  // to know when parsing a label, in order to allow or disallow
		  // continue jumps to that label.

		  var TokenType = function TokenType(label, conf) {
		    if ( conf === void 0 ) conf = {};

		    this.label = label;
		    this.keyword = conf.keyword;
		    this.beforeExpr = !!conf.beforeExpr;
		    this.startsExpr = !!conf.startsExpr;
		    this.isLoop = !!conf.isLoop;
		    this.isAssign = !!conf.isAssign;
		    this.prefix = !!conf.prefix;
		    this.postfix = !!conf.postfix;
		    this.binop = conf.binop || null;
		    this.updateContext = null;
		  };

		  function binop(name, prec) {
		    return new TokenType(name, {beforeExpr: true, binop: prec})
		  }
		  var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

		  // Map keyword names to token types.

		  var keywords = {};

		  // Succinct definitions of keyword token types
		  function kw(name, options) {
		    if ( options === void 0 ) options = {};

		    options.keyword = name;
		    return keywords[name] = new TokenType(name, options)
		  }

		  var types$1 = {
		    num: new TokenType("num", startsExpr),
		    regexp: new TokenType("regexp", startsExpr),
		    string: new TokenType("string", startsExpr),
		    name: new TokenType("name", startsExpr),
		    privateId: new TokenType("privateId", startsExpr),
		    eof: new TokenType("eof"),

		    // Punctuation token types.
		    bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
		    bracketR: new TokenType("]"),
		    braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
		    braceR: new TokenType("}"),
		    parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
		    parenR: new TokenType(")"),
		    comma: new TokenType(",", beforeExpr),
		    semi: new TokenType(";", beforeExpr),
		    colon: new TokenType(":", beforeExpr),
		    dot: new TokenType("."),
		    question: new TokenType("?", beforeExpr),
		    questionDot: new TokenType("?."),
		    arrow: new TokenType("=>", beforeExpr),
		    template: new TokenType("template"),
		    invalidTemplate: new TokenType("invalidTemplate"),
		    ellipsis: new TokenType("...", beforeExpr),
		    backQuote: new TokenType("`", startsExpr),
		    dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

		    // Operators. These carry several kinds of properties to help the
		    // parser use them properly (the presence of these properties is
		    // what categorizes them as operators).
		    //
		    // `binop`, when present, specifies that this operator is a binary
		    // operator, and will refer to its precedence.
		    //
		    // `prefix` and `postfix` mark the operator as a prefix or postfix
		    // unary operator.
		    //
		    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
		    // binary operators with a very low precedence, that should result
		    // in AssignmentExpression nodes.

		    eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
		    assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
		    incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
		    prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
		    logicalOR: binop("||", 1),
		    logicalAND: binop("&&", 2),
		    bitwiseOR: binop("|", 3),
		    bitwiseXOR: binop("^", 4),
		    bitwiseAND: binop("&", 5),
		    equality: binop("==/!=/===/!==", 6),
		    relational: binop("</>/<=/>=", 7),
		    bitShift: binop("<</>>/>>>", 8),
		    plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
		    modulo: binop("%", 10),
		    star: binop("*", 10),
		    slash: binop("/", 10),
		    starstar: new TokenType("**", {beforeExpr: true}),
		    coalesce: binop("??", 1),

		    // Keyword token types.
		    _break: kw("break"),
		    _case: kw("case", beforeExpr),
		    _catch: kw("catch"),
		    _continue: kw("continue"),
		    _debugger: kw("debugger"),
		    _default: kw("default", beforeExpr),
		    _do: kw("do", {isLoop: true, beforeExpr: true}),
		    _else: kw("else", beforeExpr),
		    _finally: kw("finally"),
		    _for: kw("for", {isLoop: true}),
		    _function: kw("function", startsExpr),
		    _if: kw("if"),
		    _return: kw("return", beforeExpr),
		    _switch: kw("switch"),
		    _throw: kw("throw", beforeExpr),
		    _try: kw("try"),
		    _var: kw("var"),
		    _const: kw("const"),
		    _while: kw("while", {isLoop: true}),
		    _with: kw("with"),
		    _new: kw("new", {beforeExpr: true, startsExpr: true}),
		    _this: kw("this", startsExpr),
		    _super: kw("super", startsExpr),
		    _class: kw("class", startsExpr),
		    _extends: kw("extends", beforeExpr),
		    _export: kw("export"),
		    _import: kw("import", startsExpr),
		    _null: kw("null", startsExpr),
		    _true: kw("true", startsExpr),
		    _false: kw("false", startsExpr),
		    _in: kw("in", {beforeExpr: true, binop: 7}),
		    _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
		    _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
		    _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
		    _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
		  };

		  // Matches a whole line break (where CRLF is considered a single
		  // line break). Used to count lines.

		  var lineBreak = /\r\n?|\n|\u2028|\u2029/;
		  var lineBreakG = new RegExp(lineBreak.source, "g");

		  function isNewLine(code) {
		    return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
		  }

		  function nextLineBreak(code, from, end) {
		    if ( end === void 0 ) end = code.length;

		    for (var i = from; i < end; i++) {
		      var next = code.charCodeAt(i);
		      if (isNewLine(next))
		        { return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 }
		    }
		    return -1
		  }

		  var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

		  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

		  var ref = Object.prototype;
		  var hasOwnProperty = ref.hasOwnProperty;
		  var toString = ref.toString;

		  var hasOwn = Object.hasOwn || (function (obj, propName) { return (
		    hasOwnProperty.call(obj, propName)
		  ); });

		  var isArray = Array.isArray || (function (obj) { return (
		    toString.call(obj) === "[object Array]"
		  ); });

		  var regexpCache = Object.create(null);

		  function wordsRegexp(words) {
		    return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"))
		  }

		  function codePointToString(code) {
		    // UTF-16 Decoding
		    if (code <= 0xFFFF) { return String.fromCharCode(code) }
		    code -= 0x10000;
		    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
		  }

		  var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;

		  // These are used when `options.locations` is on, for the
		  // `startLoc` and `endLoc` properties.

		  var Position = function Position(line, col) {
		    this.line = line;
		    this.column = col;
		  };

		  Position.prototype.offset = function offset (n) {
		    return new Position(this.line, this.column + n)
		  };

		  var SourceLocation = function SourceLocation(p, start, end) {
		    this.start = start;
		    this.end = end;
		    if (p.sourceFile !== null) { this.source = p.sourceFile; }
		  };

		  // The `getLineInfo` function is mostly useful when the
		  // `locations` option is off (for performance reasons) and you
		  // want to find the line/column position for a given character
		  // offset. `input` should be the code string that the offset refers
		  // into.

		  function getLineInfo(input, offset) {
		    for (var line = 1, cur = 0;;) {
		      var nextBreak = nextLineBreak(input, cur, offset);
		      if (nextBreak < 0) { return new Position(line, offset - cur) }
		      ++line;
		      cur = nextBreak;
		    }
		  }

		  // A second argument must be given to configure the parser process.
		  // These options are recognized (only `ecmaVersion` is required):

		  var defaultOptions = {
		    // `ecmaVersion` indicates the ECMAScript version to parse. Must be
		    // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
		    // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
		    // (the latest version the library supports). This influences
		    // support for strict mode, the set of reserved words, and support
		    // for new syntax features.
		    ecmaVersion: null,
		    // `sourceType` indicates the mode the code should be parsed in.
		    // Can be either `"script"` or `"module"`. This influences global
		    // strict mode and parsing of `import` and `export` declarations.
		    sourceType: "script",
		    // `onInsertedSemicolon` can be a callback that will be called when
		    // a semicolon is automatically inserted. It will be passed the
		    // position of the inserted semicolon as an offset, and if
		    // `locations` is enabled, it is given the location as a `{line,
		    // column}` object as second argument.
		    onInsertedSemicolon: null,
		    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
		    // trailing commas.
		    onTrailingComma: null,
		    // By default, reserved words are only enforced if ecmaVersion >= 5.
		    // Set `allowReserved` to a boolean value to explicitly turn this on
		    // an off. When this option has the value "never", reserved words
		    // and keywords can also not be used as property names.
		    allowReserved: null,
		    // When enabled, a return at the top level is not considered an
		    // error.
		    allowReturnOutsideFunction: false,
		    // When enabled, import/export statements are not constrained to
		    // appearing at the top of the program, and an import.meta expression
		    // in a script isn't considered an error.
		    allowImportExportEverywhere: false,
		    // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
		    // When enabled, await identifiers are allowed to appear at the top-level scope,
		    // but they are still not allowed in non-async functions.
		    allowAwaitOutsideFunction: null,
		    // When enabled, super identifiers are not constrained to
		    // appearing in methods and do not raise an error when they appear elsewhere.
		    allowSuperOutsideMethod: null,
		    // When enabled, hashbang directive in the beginning of file is
		    // allowed and treated as a line comment. Enabled by default when
		    // `ecmaVersion` >= 2023.
		    allowHashBang: false,
		    // By default, the parser will verify that private properties are
		    // only used in places where they are valid and have been declared.
		    // Set this to false to turn such checks off.
		    checkPrivateFields: true,
		    // When `locations` is on, `loc` properties holding objects with
		    // `start` and `end` properties in `{line, column}` form (with
		    // line being 1-based and column 0-based) will be attached to the
		    // nodes.
		    locations: false,
		    // A function can be passed as `onToken` option, which will
		    // cause Acorn to call that function with object in the same
		    // format as tokens returned from `tokenizer().getToken()`. Note
		    // that you are not allowed to call the parser from the
		    // callback—that will corrupt its internal state.
		    onToken: null,
		    // A function can be passed as `onComment` option, which will
		    // cause Acorn to call that function with `(block, text, start,
		    // end)` parameters whenever a comment is skipped. `block` is a
		    // boolean indicating whether this is a block (`/* */`) comment,
		    // `text` is the content of the comment, and `start` and `end` are
		    // character offsets that denote the start and end of the comment.
		    // When the `locations` option is on, two more parameters are
		    // passed, the full `{line, column}` locations of the start and
		    // end of the comments. Note that you are not allowed to call the
		    // parser from the callback—that will corrupt its internal state.
		    // When this option has an array as value, objects representing the
		    // comments are pushed to it.
		    onComment: null,
		    // Nodes have their start and end characters offsets recorded in
		    // `start` and `end` properties (directly on the node, rather than
		    // the `loc` object, which holds line/column data. To also add a
		    // [semi-standardized][range] `range` property holding a `[start,
		    // end]` array with the same numbers, set the `ranges` option to
		    // `true`.
		    //
		    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
		    ranges: false,
		    // It is possible to parse multiple files into a single AST by
		    // passing the tree produced by parsing the first file as
		    // `program` option in subsequent parses. This will add the
		    // toplevel forms of the parsed file to the `Program` (top) node
		    // of an existing parse tree.
		    program: null,
		    // When `locations` is on, you can pass this to record the source
		    // file in every node's `loc` object.
		    sourceFile: null,
		    // This value, if given, is stored in every node, whether
		    // `locations` is on or off.
		    directSourceFile: null,
		    // When enabled, parenthesized expressions are represented by
		    // (non-standard) ParenthesizedExpression nodes
		    preserveParens: false
		  };

		  // Interpret and default an options object

		  var warnedAboutEcmaVersion = false;

		  function getOptions(opts) {
		    var options = {};

		    for (var opt in defaultOptions)
		      { options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt]; }

		    if (options.ecmaVersion === "latest") {
		      options.ecmaVersion = 1e8;
		    } else if (options.ecmaVersion == null) {
		      if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
		        warnedAboutEcmaVersion = true;
		        console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
		      }
		      options.ecmaVersion = 11;
		    } else if (options.ecmaVersion >= 2015) {
		      options.ecmaVersion -= 2009;
		    }

		    if (options.allowReserved == null)
		      { options.allowReserved = options.ecmaVersion < 5; }

		    if (!opts || opts.allowHashBang == null)
		      { options.allowHashBang = options.ecmaVersion >= 14; }

		    if (isArray(options.onToken)) {
		      var tokens = options.onToken;
		      options.onToken = function (token) { return tokens.push(token); };
		    }
		    if (isArray(options.onComment))
		      { options.onComment = pushComment(options, options.onComment); }

		    return options
		  }

		  function pushComment(options, array) {
		    return function(block, text, start, end, startLoc, endLoc) {
		      var comment = {
		        type: block ? "Block" : "Line",
		        value: text,
		        start: start,
		        end: end
		      };
		      if (options.locations)
		        { comment.loc = new SourceLocation(this, startLoc, endLoc); }
		      if (options.ranges)
		        { comment.range = [start, end]; }
		      array.push(comment);
		    }
		  }

		  // Each scope gets a bitset that may contain these flags
		  var
		      SCOPE_TOP = 1,
		      SCOPE_FUNCTION = 2,
		      SCOPE_ASYNC = 4,
		      SCOPE_GENERATOR = 8,
		      SCOPE_ARROW = 16,
		      SCOPE_SIMPLE_CATCH = 32,
		      SCOPE_SUPER = 64,
		      SCOPE_DIRECT_SUPER = 128,
		      SCOPE_CLASS_STATIC_BLOCK = 256,
		      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;

		  function functionFlags(async, generator) {
		    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
		  }

		  // Used in checkLVal* and declareName to determine the type of a binding
		  var
		      BIND_NONE = 0, // Not a binding
		      BIND_VAR = 1, // Var-style binding
		      BIND_LEXICAL = 2, // Let- or const-style binding
		      BIND_FUNCTION = 3, // Function declaration
		      BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
		      BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

		  var Parser = function Parser(options, input, startPos) {
		    this.options = options = getOptions(options);
		    this.sourceFile = options.sourceFile;
		    this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
		    var reserved = "";
		    if (options.allowReserved !== true) {
		      reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
		      if (options.sourceType === "module") { reserved += " await"; }
		    }
		    this.reservedWords = wordsRegexp(reserved);
		    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
		    this.reservedWordsStrict = wordsRegexp(reservedStrict);
		    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
		    this.input = String(input);

		    // Used to signal to callers of `readWord1` whether the word
		    // contained any escape sequences. This is needed because words with
		    // escape sequences must not be interpreted as keywords.
		    this.containsEsc = false;

		    // Set up token state

		    // The current position of the tokenizer in the input.
		    if (startPos) {
		      this.pos = startPos;
		      this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
		      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
		    } else {
		      this.pos = this.lineStart = 0;
		      this.curLine = 1;
		    }

		    // Properties of the current token:
		    // Its type
		    this.type = types$1.eof;
		    // For tokens that include more information than their type, the value
		    this.value = null;
		    // Its start and end offset
		    this.start = this.end = this.pos;
		    // And, if locations are used, the {line, column} object
		    // corresponding to those offsets
		    this.startLoc = this.endLoc = this.curPosition();

		    // Position information for the previous token
		    this.lastTokEndLoc = this.lastTokStartLoc = null;
		    this.lastTokStart = this.lastTokEnd = this.pos;

		    // The context stack is used to superficially track syntactic
		    // context to predict whether a regular expression is allowed in a
		    // given position.
		    this.context = this.initialContext();
		    this.exprAllowed = true;

		    // Figure out if it's a module code.
		    this.inModule = options.sourceType === "module";
		    this.strict = this.inModule || this.strictDirective(this.pos);

		    // Used to signify the start of a potential arrow function
		    this.potentialArrowAt = -1;
		    this.potentialArrowInForAwait = false;

		    // Positions to delayed-check that yield/await does not exist in default parameters.
		    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
		    // Labels in scope.
		    this.labels = [];
		    // Thus-far undefined exports.
		    this.undefinedExports = Object.create(null);

		    // If enabled, skip leading hashbang line.
		    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
		      { this.skipLineComment(2); }

		    // Scope tracking for duplicate variable names (see scope.js)
		    this.scopeStack = [];
		    this.enterScope(SCOPE_TOP);

		    // For RegExp validation
		    this.regexpState = null;

		    // The stack of private names.
		    // Each element has two properties: 'declared' and 'used'.
		    // When it exited from the outermost class definition, all used private names must be declared.
		    this.privateNameStack = [];
		  };

		  var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },canAwait: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true },allowNewDotTarget: { configurable: true },inClassStaticBlock: { configurable: true } };

		  Parser.prototype.parse = function parse () {
		    var node = this.options.program || this.startNode();
		    this.nextToken();
		    return this.parseTopLevel(node)
		  };

		  prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };

		  prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit };

		  prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit };

		  prototypeAccessors.canAwait.get = function () {
		    for (var i = this.scopeStack.length - 1; i >= 0; i--) {
		      var scope = this.scopeStack[i];
		      if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) { return false }
		      if (scope.flags & SCOPE_FUNCTION) { return (scope.flags & SCOPE_ASYNC) > 0 }
		    }
		    return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction
		  };

		  prototypeAccessors.allowSuper.get = function () {
		    var ref = this.currentThisScope();
		      var flags = ref.flags;
		      var inClassFieldInit = ref.inClassFieldInit;
		    return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod
		  };

		  prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };

		  prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

		  prototypeAccessors.allowNewDotTarget.get = function () {
		    var ref = this.currentThisScope();
		      var flags = ref.flags;
		      var inClassFieldInit = ref.inClassFieldInit;
		    return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit
		  };

		  prototypeAccessors.inClassStaticBlock.get = function () {
		    return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0
		  };

		  Parser.extend = function extend () {
		      var plugins = [], len = arguments.length;
		      while ( len-- ) plugins[ len ] = arguments[ len ];

		    var cls = this;
		    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
		    return cls
		  };

		  Parser.parse = function parse (input, options) {
		    return new this(options, input).parse()
		  };

		  Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
		    var parser = new this(options, input, pos);
		    parser.nextToken();
		    return parser.parseExpression()
		  };

		  Parser.tokenizer = function tokenizer (input, options) {
		    return new this(options, input)
		  };

		  Object.defineProperties( Parser.prototype, prototypeAccessors );

		  var pp$9 = Parser.prototype;

		  // ## Parser utilities

		  var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
		  pp$9.strictDirective = function(start) {
		    if (this.options.ecmaVersion < 5) { return false }
		    for (;;) {
		      // Try to find string literal.
		      skipWhiteSpace.lastIndex = start;
		      start += skipWhiteSpace.exec(this.input)[0].length;
		      var match = literal.exec(this.input.slice(start));
		      if (!match) { return false }
		      if ((match[1] || match[2]) === "use strict") {
		        skipWhiteSpace.lastIndex = start + match[0].length;
		        var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
		        var next = this.input.charAt(end);
		        return next === ";" || next === "}" ||
		          (lineBreak.test(spaceAfter[0]) &&
		           !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "="))
		      }
		      start += match[0].length;

		      // Skip semicolon, if any.
		      skipWhiteSpace.lastIndex = start;
		      start += skipWhiteSpace.exec(this.input)[0].length;
		      if (this.input[start] === ";")
		        { start++; }
		    }
		  };

		  // Predicate that tests whether the next token is of the given
		  // type, and if yes, consumes it as a side effect.

		  pp$9.eat = function(type) {
		    if (this.type === type) {
		      this.next();
		      return true
		    } else {
		      return false
		    }
		  };

		  // Tests whether parsed token is a contextual keyword.

		  pp$9.isContextual = function(name) {
		    return this.type === types$1.name && this.value === name && !this.containsEsc
		  };

		  // Consumes contextual keyword if possible.

		  pp$9.eatContextual = function(name) {
		    if (!this.isContextual(name)) { return false }
		    this.next();
		    return true
		  };

		  // Asserts that following token is given contextual keyword.

		  pp$9.expectContextual = function(name) {
		    if (!this.eatContextual(name)) { this.unexpected(); }
		  };

		  // Test whether a semicolon can be inserted at the current position.

		  pp$9.canInsertSemicolon = function() {
		    return this.type === types$1.eof ||
		      this.type === types$1.braceR ||
		      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
		  };

		  pp$9.insertSemicolon = function() {
		    if (this.canInsertSemicolon()) {
		      if (this.options.onInsertedSemicolon)
		        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
		      return true
		    }
		  };

		  // Consume a semicolon, or, failing that, see if we are allowed to
		  // pretend that there is a semicolon at this position.

		  pp$9.semicolon = function() {
		    if (!this.eat(types$1.semi) && !this.insertSemicolon()) { this.unexpected(); }
		  };

		  pp$9.afterTrailingComma = function(tokType, notNext) {
		    if (this.type === tokType) {
		      if (this.options.onTrailingComma)
		        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
		      if (!notNext)
		        { this.next(); }
		      return true
		    }
		  };

		  // Expect a token of a given type. If found, consume it, otherwise,
		  // raise an unexpected token error.

		  pp$9.expect = function(type) {
		    this.eat(type) || this.unexpected();
		  };

		  // Raise an unexpected token error.

		  pp$9.unexpected = function(pos) {
		    this.raise(pos != null ? pos : this.start, "Unexpected token");
		  };

		  var DestructuringErrors = function DestructuringErrors() {
		    this.shorthandAssign =
		    this.trailingComma =
		    this.parenthesizedAssign =
		    this.parenthesizedBind =
		    this.doubleProto =
		      -1;
		  };

		  pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
		    if (!refDestructuringErrors) { return }
		    if (refDestructuringErrors.trailingComma > -1)
		      { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
		    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
		    if (parens > -1) { this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern"); }
		  };

		  pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
		    if (!refDestructuringErrors) { return false }
		    var shorthandAssign = refDestructuringErrors.shorthandAssign;
		    var doubleProto = refDestructuringErrors.doubleProto;
		    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
		    if (shorthandAssign >= 0)
		      { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
		    if (doubleProto >= 0)
		      { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
		  };

		  pp$9.checkYieldAwaitInDefaultParams = function() {
		    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
		      { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
		    if (this.awaitPos)
		      { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
		  };

		  pp$9.isSimpleAssignTarget = function(expr) {
		    if (expr.type === "ParenthesizedExpression")
		      { return this.isSimpleAssignTarget(expr.expression) }
		    return expr.type === "Identifier" || expr.type === "MemberExpression"
		  };

		  var pp$8 = Parser.prototype;

		  // ### Statement parsing

		  // Parse a program. Initializes the parser, reads any number of
		  // statements, and wraps them in a Program node.  Optionally takes a
		  // `program` argument.  If present, the statements will be appended
		  // to its body instead of creating a new node.

		  pp$8.parseTopLevel = function(node) {
		    var exports = Object.create(null);
		    if (!node.body) { node.body = []; }
		    while (this.type !== types$1.eof) {
		      var stmt = this.parseStatement(null, true, exports);
		      node.body.push(stmt);
		    }
		    if (this.inModule)
		      { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
		        {
		          var name = list[i];

		          this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
		        } }
		    this.adaptDirectivePrologue(node.body);
		    this.next();
		    node.sourceType = this.options.sourceType;
		    return this.finishNode(node, "Program")
		  };

		  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

		  pp$8.isLet = function(context) {
		    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
		    skipWhiteSpace.lastIndex = this.pos;
		    var skip = skipWhiteSpace.exec(this.input);
		    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
		    // For ambiguous cases, determine if a LexicalDeclaration (or only a
		    // Statement) is allowed here. If context is not empty then only a Statement
		    // is allowed. However, `let [` is an explicit negative lookahead for
		    // ExpressionStatement, so special-case it first.
		    if (nextCh === 91 || nextCh === 92) { return true } // '[', '/'
		    if (context) { return false }

		    if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true } // '{', astral
		    if (isIdentifierStart(nextCh, true)) {
		      var pos = next + 1;
		      while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) { ++pos; }
		      if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true }
		      var ident = this.input.slice(next, pos);
		      if (!keywordRelationalOperator.test(ident)) { return true }
		    }
		    return false
		  };

		  // check 'async [no LineTerminator here] function'
		  // - 'async /*foo*/ function' is OK.
		  // - 'async /*\n*/ function' is invalid.
		  pp$8.isAsyncFunction = function() {
		    if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
		      { return false }

		    skipWhiteSpace.lastIndex = this.pos;
		    var skip = skipWhiteSpace.exec(this.input);
		    var next = this.pos + skip[0].length, after;
		    return !lineBreak.test(this.input.slice(this.pos, next)) &&
		      this.input.slice(next, next + 8) === "function" &&
		      (next + 8 === this.input.length ||
		       !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00))
		  };

		  // Parse a single statement.
		  //
		  // If expecting a statement and finding a slash operator, parse a
		  // regular expression literal. This is to handle cases like
		  // `if (foo) /blah/.exec(foo)`, where looking at the previous token
		  // does not help.

		  pp$8.parseStatement = function(context, topLevel, exports) {
		    var starttype = this.type, node = this.startNode(), kind;

		    if (this.isLet(context)) {
		      starttype = types$1._var;
		      kind = "let";
		    }

		    // Most types of statements are recognized by the keyword they
		    // start with. Many are trivial to parse, some require a bit of
		    // complexity.

		    switch (starttype) {
		    case types$1._break: case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
		    case types$1._debugger: return this.parseDebuggerStatement(node)
		    case types$1._do: return this.parseDoStatement(node)
		    case types$1._for: return this.parseForStatement(node)
		    case types$1._function:
		      // Function as sole body of either an if statement or a labeled statement
		      // works, but not when it is part of a labeled statement that is the sole
		      // body of an if statement.
		      if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
		      return this.parseFunctionStatement(node, false, !context)
		    case types$1._class:
		      if (context) { this.unexpected(); }
		      return this.parseClass(node, true)
		    case types$1._if: return this.parseIfStatement(node)
		    case types$1._return: return this.parseReturnStatement(node)
		    case types$1._switch: return this.parseSwitchStatement(node)
		    case types$1._throw: return this.parseThrowStatement(node)
		    case types$1._try: return this.parseTryStatement(node)
		    case types$1._const: case types$1._var:
		      kind = kind || this.value;
		      if (context && kind !== "var") { this.unexpected(); }
		      return this.parseVarStatement(node, kind)
		    case types$1._while: return this.parseWhileStatement(node)
		    case types$1._with: return this.parseWithStatement(node)
		    case types$1.braceL: return this.parseBlock(true, node)
		    case types$1.semi: return this.parseEmptyStatement(node)
		    case types$1._export:
		    case types$1._import:
		      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
		        skipWhiteSpace.lastIndex = this.pos;
		        var skip = skipWhiteSpace.exec(this.input);
		        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
		        if (nextCh === 40 || nextCh === 46) // '(' or '.'
		          { return this.parseExpressionStatement(node, this.parseExpression()) }
		      }

		      if (!this.options.allowImportExportEverywhere) {
		        if (!topLevel)
		          { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
		        if (!this.inModule)
		          { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
		      }
		      return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports)

		      // If the statement does not start with a statement keyword or a
		      // brace, it's an ExpressionStatement or LabeledStatement. We
		      // simply start parsing an expression, and afterwards, if the
		      // next token is a colon and the expression was a simple
		      // Identifier node, we switch to interpreting it as a label.
		    default:
		      if (this.isAsyncFunction()) {
		        if (context) { this.unexpected(); }
		        this.next();
		        return this.parseFunctionStatement(node, true, !context)
		      }

		      var maybeName = this.value, expr = this.parseExpression();
		      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon))
		        { return this.parseLabeledStatement(node, maybeName, expr, context) }
		      else { return this.parseExpressionStatement(node, expr) }
		    }
		  };

		  pp$8.parseBreakContinueStatement = function(node, keyword) {
		    var isBreak = keyword === "break";
		    this.next();
		    if (this.eat(types$1.semi) || this.insertSemicolon()) { node.label = null; }
		    else if (this.type !== types$1.name) { this.unexpected(); }
		    else {
		      node.label = this.parseIdent();
		      this.semicolon();
		    }

		    // Verify that there is an actual destination to break or
		    // continue to.
		    var i = 0;
		    for (; i < this.labels.length; ++i) {
		      var lab = this.labels[i];
		      if (node.label == null || lab.name === node.label.name) {
		        if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
		        if (node.label && isBreak) { break }
		      }
		    }
		    if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
		    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
		  };

		  pp$8.parseDebuggerStatement = function(node) {
		    this.next();
		    this.semicolon();
		    return this.finishNode(node, "DebuggerStatement")
		  };

		  pp$8.parseDoStatement = function(node) {
		    this.next();
		    this.labels.push(loopLabel);
		    node.body = this.parseStatement("do");
		    this.labels.pop();
		    this.expect(types$1._while);
		    node.test = this.parseParenExpression();
		    if (this.options.ecmaVersion >= 6)
		      { this.eat(types$1.semi); }
		    else
		      { this.semicolon(); }
		    return this.finishNode(node, "DoWhileStatement")
		  };

		  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
		  // loop is non-trivial. Basically, we have to parse the init `var`
		  // statement or expression, disallowing the `in` operator (see
		  // the second parameter to `parseExpression`), and then check
		  // whether the next token is `in` or `of`. When there is no init
		  // part (semicolon immediately after the opening parenthesis), it
		  // is a regular `for` loop.

		  pp$8.parseForStatement = function(node) {
		    this.next();
		    var awaitAt = (this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await")) ? this.lastTokStart : -1;
		    this.labels.push(loopLabel);
		    this.enterScope(0);
		    this.expect(types$1.parenL);
		    if (this.type === types$1.semi) {
		      if (awaitAt > -1) { this.unexpected(awaitAt); }
		      return this.parseFor(node, null)
		    }
		    var isLet = this.isLet();
		    if (this.type === types$1._var || this.type === types$1._const || isLet) {
		      var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
		      this.next();
		      this.parseVar(init$1, true, kind);
		      this.finishNode(init$1, "VariableDeclaration");
		      if ((this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
		        if (this.options.ecmaVersion >= 9) {
		          if (this.type === types$1._in) {
		            if (awaitAt > -1) { this.unexpected(awaitAt); }
		          } else { node.await = awaitAt > -1; }
		        }
		        return this.parseForIn(node, init$1)
		      }
		      if (awaitAt > -1) { this.unexpected(awaitAt); }
		      return this.parseFor(node, init$1)
		    }
		    var startsWithLet = this.isContextual("let"), isForOf = false;
		    var refDestructuringErrors = new DestructuringErrors;
		    var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
		    if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
		      if (this.options.ecmaVersion >= 9) {
		        if (this.type === types$1._in) {
		          if (awaitAt > -1) { this.unexpected(awaitAt); }
		        } else { node.await = awaitAt > -1; }
		      }
		      if (startsWithLet && isForOf) { this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'."); }
		      this.toAssignable(init, false, refDestructuringErrors);
		      this.checkLValPattern(init);
		      return this.parseForIn(node, init)
		    } else {
		      this.checkExpressionErrors(refDestructuringErrors, true);
		    }
		    if (awaitAt > -1) { this.unexpected(awaitAt); }
		    return this.parseFor(node, init)
		  };

		  pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
		    this.next();
		    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
		  };

		  pp$8.parseIfStatement = function(node) {
		    this.next();
		    node.test = this.parseParenExpression();
		    // allow function declarations in branches, but only in non-strict mode
		    node.consequent = this.parseStatement("if");
		    node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
		    return this.finishNode(node, "IfStatement")
		  };

		  pp$8.parseReturnStatement = function(node) {
		    if (!this.inFunction && !this.options.allowReturnOutsideFunction)
		      { this.raise(this.start, "'return' outside of function"); }
		    this.next();

		    // In `return` (and `break`/`continue`), the keywords with
		    // optional arguments, we eagerly look for a semicolon or the
		    // possibility to insert one.

		    if (this.eat(types$1.semi) || this.insertSemicolon()) { node.argument = null; }
		    else { node.argument = this.parseExpression(); this.semicolon(); }
		    return this.finishNode(node, "ReturnStatement")
		  };

		  pp$8.parseSwitchStatement = function(node) {
		    this.next();
		    node.discriminant = this.parseParenExpression();
		    node.cases = [];
		    this.expect(types$1.braceL);
		    this.labels.push(switchLabel);
		    this.enterScope(0);

		    // Statements under must be grouped (by label) in SwitchCase
		    // nodes. `cur` is used to keep the node that we are currently
		    // adding statements to.

		    var cur;
		    for (var sawDefault = false; this.type !== types$1.braceR;) {
		      if (this.type === types$1._case || this.type === types$1._default) {
		        var isCase = this.type === types$1._case;
		        if (cur) { this.finishNode(cur, "SwitchCase"); }
		        node.cases.push(cur = this.startNode());
		        cur.consequent = [];
		        this.next();
		        if (isCase) {
		          cur.test = this.parseExpression();
		        } else {
		          if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
		          sawDefault = true;
		          cur.test = null;
		        }
		        this.expect(types$1.colon);
		      } else {
		        if (!cur) { this.unexpected(); }
		        cur.consequent.push(this.parseStatement(null));
		      }
		    }
		    this.exitScope();
		    if (cur) { this.finishNode(cur, "SwitchCase"); }
		    this.next(); // Closing brace
		    this.labels.pop();
		    return this.finishNode(node, "SwitchStatement")
		  };

		  pp$8.parseThrowStatement = function(node) {
		    this.next();
		    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
		      { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
		    node.argument = this.parseExpression();
		    this.semicolon();
		    return this.finishNode(node, "ThrowStatement")
		  };

		  // Reused empty array added for node fields that are always empty.

		  var empty$1 = [];

		  pp$8.parseCatchClauseParam = function() {
		    var param = this.parseBindingAtom();
		    var simple = param.type === "Identifier";
		    this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
		    this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
		    this.expect(types$1.parenR);

		    return param
		  };

		  pp$8.parseTryStatement = function(node) {
		    this.next();
		    node.block = this.parseBlock();
		    node.handler = null;
		    if (this.type === types$1._catch) {
		      var clause = this.startNode();
		      this.next();
		      if (this.eat(types$1.parenL)) {
		        clause.param = this.parseCatchClauseParam();
		      } else {
		        if (this.options.ecmaVersion < 10) { this.unexpected(); }
		        clause.param = null;
		        this.enterScope(0);
		      }
		      clause.body = this.parseBlock(false);
		      this.exitScope();
		      node.handler = this.finishNode(clause, "CatchClause");
		    }
		    node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
		    if (!node.handler && !node.finalizer)
		      { this.raise(node.start, "Missing catch or finally clause"); }
		    return this.finishNode(node, "TryStatement")
		  };

		  pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
		    this.next();
		    this.parseVar(node, false, kind, allowMissingInitializer);
		    this.semicolon();
		    return this.finishNode(node, "VariableDeclaration")
		  };

		  pp$8.parseWhileStatement = function(node) {
		    this.next();
		    node.test = this.parseParenExpression();
		    this.labels.push(loopLabel);
		    node.body = this.parseStatement("while");
		    this.labels.pop();
		    return this.finishNode(node, "WhileStatement")
		  };

		  pp$8.parseWithStatement = function(node) {
		    if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
		    this.next();
		    node.object = this.parseParenExpression();
		    node.body = this.parseStatement("with");
		    return this.finishNode(node, "WithStatement")
		  };

		  pp$8.parseEmptyStatement = function(node) {
		    this.next();
		    return this.finishNode(node, "EmptyStatement")
		  };

		  pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
		    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
		      {
		      var label = list[i$1];

		      if (label.name === maybeName)
		        { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
		    } }
		    var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
		    for (var i = this.labels.length - 1; i >= 0; i--) {
		      var label$1 = this.labels[i];
		      if (label$1.statementStart === node.start) {
		        // Update information about previous labels on this node
		        label$1.statementStart = this.start;
		        label$1.kind = kind;
		      } else { break }
		    }
		    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
		    node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
		    this.labels.pop();
		    node.label = expr;
		    return this.finishNode(node, "LabeledStatement")
		  };

		  pp$8.parseExpressionStatement = function(node, expr) {
		    node.expression = expr;
		    this.semicolon();
		    return this.finishNode(node, "ExpressionStatement")
		  };

		  // Parse a semicolon-enclosed block of statements, handling `"use
		  // strict"` declarations when `allowStrict` is true (used for
		  // function bodies).

		  pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
		    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
		    if ( node === void 0 ) node = this.startNode();

		    node.body = [];
		    this.expect(types$1.braceL);
		    if (createNewLexicalScope) { this.enterScope(0); }
		    while (this.type !== types$1.braceR) {
		      var stmt = this.parseStatement(null);
		      node.body.push(stmt);
		    }
		    if (exitStrict) { this.strict = false; }
		    this.next();
		    if (createNewLexicalScope) { this.exitScope(); }
		    return this.finishNode(node, "BlockStatement")
		  };

		  // Parse a regular `for` loop. The disambiguation code in
		  // `parseStatement` will already have parsed the init statement or
		  // expression.

		  pp$8.parseFor = function(node, init) {
		    node.init = init;
		    this.expect(types$1.semi);
		    node.test = this.type === types$1.semi ? null : this.parseExpression();
		    this.expect(types$1.semi);
		    node.update = this.type === types$1.parenR ? null : this.parseExpression();
		    this.expect(types$1.parenR);
		    node.body = this.parseStatement("for");
		    this.exitScope();
		    this.labels.pop();
		    return this.finishNode(node, "ForStatement")
		  };

		  // Parse a `for`/`in` and `for`/`of` loop, which are almost
		  // same from parser's perspective.

		  pp$8.parseForIn = function(node, init) {
		    var isForIn = this.type === types$1._in;
		    this.next();

		    if (
		      init.type === "VariableDeclaration" &&
		      init.declarations[0].init != null &&
		      (
		        !isForIn ||
		        this.options.ecmaVersion < 8 ||
		        this.strict ||
		        init.kind !== "var" ||
		        init.declarations[0].id.type !== "Identifier"
		      )
		    ) {
		      this.raise(
		        init.start,
		        ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
		      );
		    }
		    node.left = init;
		    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
		    this.expect(types$1.parenR);
		    node.body = this.parseStatement("for");
		    this.exitScope();
		    this.labels.pop();
		    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
		  };

		  // Parse a list of variable declarations.

		  pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
		    node.declarations = [];
		    node.kind = kind;
		    for (;;) {
		      var decl = this.startNode();
		      this.parseVarId(decl, kind);
		      if (this.eat(types$1.eq)) {
		        decl.init = this.parseMaybeAssign(isFor);
		      } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
		        this.unexpected();
		      } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
		        this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
		      } else {
		        decl.init = null;
		      }
		      node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
		      if (!this.eat(types$1.comma)) { break }
		    }
		    return node
		  };

		  pp$8.parseVarId = function(decl, kind) {
		    decl.id = this.parseBindingAtom();
		    this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
		  };

		  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

		  // Parse a function declaration or literal (depending on the
		  // `statement & FUNC_STATEMENT`).

		  // Remove `allowExpressionBody` for 7.0.0, as it is only called with false
		  pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
		    this.initFunction(node);
		    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
		      if (this.type === types$1.star && (statement & FUNC_HANGING_STATEMENT))
		        { this.unexpected(); }
		      node.generator = this.eat(types$1.star);
		    }
		    if (this.options.ecmaVersion >= 8)
		      { node.async = !!isAsync; }

		    if (statement & FUNC_STATEMENT) {
		      node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types$1.name ? null : this.parseIdent();
		      if (node.id && !(statement & FUNC_HANGING_STATEMENT))
		        // If it is a regular function declaration in sloppy mode, then it is
		        // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
		        // mode depends on properties of the current scope (see
		        // treatFunctionsAsVar).
		        { this.checkLValSimple(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
		    }

		    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
		    this.yieldPos = 0;
		    this.awaitPos = 0;
		    this.awaitIdentPos = 0;
		    this.enterScope(functionFlags(node.async, node.generator));

		    if (!(statement & FUNC_STATEMENT))
		      { node.id = this.type === types$1.name ? this.parseIdent() : null; }

		    this.parseFunctionParams(node);
		    this.parseFunctionBody(node, allowExpressionBody, false, forInit);

		    this.yieldPos = oldYieldPos;
		    this.awaitPos = oldAwaitPos;
		    this.awaitIdentPos = oldAwaitIdentPos;
		    return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
		  };

		  pp$8.parseFunctionParams = function(node) {
		    this.expect(types$1.parenL);
		    node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
		    this.checkYieldAwaitInDefaultParams();
		  };

		  // Parse a class declaration or literal (depending on the
		  // `isStatement` parameter).

		  pp$8.parseClass = function(node, isStatement) {
		    this.next();

		    // ecma-262 14.6 Class Definitions
		    // A class definition is always strict mode code.
		    var oldStrict = this.strict;
		    this.strict = true;

		    this.parseClassId(node, isStatement);
		    this.parseClassSuper(node);
		    var privateNameMap = this.enterClassBody();
		    var classBody = this.startNode();
		    var hadConstructor = false;
		    classBody.body = [];
		    this.expect(types$1.braceL);
		    while (this.type !== types$1.braceR) {
		      var element = this.parseClassElement(node.superClass !== null);
		      if (element) {
		        classBody.body.push(element);
		        if (element.type === "MethodDefinition" && element.kind === "constructor") {
		          if (hadConstructor) { this.raiseRecoverable(element.start, "Duplicate constructor in the same class"); }
		          hadConstructor = true;
		        } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
		          this.raiseRecoverable(element.key.start, ("Identifier '#" + (element.key.name) + "' has already been declared"));
		        }
		      }
		    }
		    this.strict = oldStrict;
		    this.next();
		    node.body = this.finishNode(classBody, "ClassBody");
		    this.exitClassBody();
		    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
		  };

		  pp$8.parseClassElement = function(constructorAllowsSuper) {
		    if (this.eat(types$1.semi)) { return null }

		    var ecmaVersion = this.options.ecmaVersion;
		    var node = this.startNode();
		    var keyName = "";
		    var isGenerator = false;
		    var isAsync = false;
		    var kind = "method";
		    var isStatic = false;

		    if (this.eatContextual("static")) {
		      // Parse static init block
		      if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
		        this.parseClassStaticBlock(node);
		        return node
		      }
		      if (this.isClassElementNameStart() || this.type === types$1.star) {
		        isStatic = true;
		      } else {
		        keyName = "static";
		      }
		    }
		    node.static = isStatic;
		    if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
		      if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
		        isAsync = true;
		      } else {
		        keyName = "async";
		      }
		    }
		    if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
		      isGenerator = true;
		    }
		    if (!keyName && !isAsync && !isGenerator) {
		      var lastValue = this.value;
		      if (this.eatContextual("get") || this.eatContextual("set")) {
		        if (this.isClassElementNameStart()) {
		          kind = lastValue;
		        } else {
		          keyName = lastValue;
		        }
		      }
		    }

		    // Parse element name
		    if (keyName) {
		      // 'async', 'get', 'set', or 'static' were not a keyword contextually.
		      // The last token is any of those. Make it the element name.
		      node.computed = false;
		      node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
		      node.key.name = keyName;
		      this.finishNode(node.key, "Identifier");
		    } else {
		      this.parseClassElementName(node);
		    }

		    // Parse element value
		    if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
		      var isConstructor = !node.static && checkKeyName(node, "constructor");
		      var allowsDirectSuper = isConstructor && constructorAllowsSuper;
		      // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.
		      if (isConstructor && kind !== "method") { this.raise(node.key.start, "Constructor can't have get/set modifier"); }
		      node.kind = isConstructor ? "constructor" : kind;
		      this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
		    } else {
		      this.parseClassField(node);
		    }

		    return node
		  };

		  pp$8.isClassElementNameStart = function() {
		    return (
		      this.type === types$1.name ||
		      this.type === types$1.privateId ||
		      this.type === types$1.num ||
		      this.type === types$1.string ||
		      this.type === types$1.bracketL ||
		      this.type.keyword
		    )
		  };

		  pp$8.parseClassElementName = function(element) {
		    if (this.type === types$1.privateId) {
		      if (this.value === "constructor") {
		        this.raise(this.start, "Classes can't have an element named '#constructor'");
		      }
		      element.computed = false;
		      element.key = this.parsePrivateIdent();
		    } else {
		      this.parsePropertyName(element);
		    }
		  };

		  pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
		    // Check key and flags
		    var key = method.key;
		    if (method.kind === "constructor") {
		      if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
		      if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
		    } else if (method.static && checkKeyName(method, "prototype")) {
		      this.raise(key.start, "Classes may not have a static property named prototype");
		    }

		    // Parse value
		    var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);

		    // Check value
		    if (method.kind === "get" && value.params.length !== 0)
		      { this.raiseRecoverable(value.start, "getter should have no params"); }
		    if (method.kind === "set" && value.params.length !== 1)
		      { this.raiseRecoverable(value.start, "setter should have exactly one param"); }
		    if (method.kind === "set" && value.params[0].type === "RestElement")
		      { this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params"); }

		    return this.finishNode(method, "MethodDefinition")
		  };

		  pp$8.parseClassField = function(field) {
		    if (checkKeyName(field, "constructor")) {
		      this.raise(field.key.start, "Classes can't have a field named 'constructor'");
		    } else if (field.static && checkKeyName(field, "prototype")) {
		      this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
		    }

		    if (this.eat(types$1.eq)) {
		      // To raise SyntaxError if 'arguments' exists in the initializer.
		      var scope = this.currentThisScope();
		      var inClassFieldInit = scope.inClassFieldInit;
		      scope.inClassFieldInit = true;
		      field.value = this.parseMaybeAssign();
		      scope.inClassFieldInit = inClassFieldInit;
		    } else {
		      field.value = null;
		    }
		    this.semicolon();

		    return this.finishNode(field, "PropertyDefinition")
		  };

		  pp$8.parseClassStaticBlock = function(node) {
		    node.body = [];

		    var oldLabels = this.labels;
		    this.labels = [];
		    this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
		    while (this.type !== types$1.braceR) {
		      var stmt = this.parseStatement(null);
		      node.body.push(stmt);
		    }
		    this.next();
		    this.exitScope();
		    this.labels = oldLabels;

		    return this.finishNode(node, "StaticBlock")
		  };

		  pp$8.parseClassId = function(node, isStatement) {
		    if (this.type === types$1.name) {
		      node.id = this.parseIdent();
		      if (isStatement)
		        { this.checkLValSimple(node.id, BIND_LEXICAL, false); }
		    } else {
		      if (isStatement === true)
		        { this.unexpected(); }
		      node.id = null;
		    }
		  };

		  pp$8.parseClassSuper = function(node) {
		    node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
		  };

		  pp$8.enterClassBody = function() {
		    var element = {declared: Object.create(null), used: []};
		    this.privateNameStack.push(element);
		    return element.declared
		  };

		  pp$8.exitClassBody = function() {
		    var ref = this.privateNameStack.pop();
		    var declared = ref.declared;
		    var used = ref.used;
		    if (!this.options.checkPrivateFields) { return }
		    var len = this.privateNameStack.length;
		    var parent = len === 0 ? null : this.privateNameStack[len - 1];
		    for (var i = 0; i < used.length; ++i) {
		      var id = used[i];
		      if (!hasOwn(declared, id.name)) {
		        if (parent) {
		          parent.used.push(id);
		        } else {
		          this.raiseRecoverable(id.start, ("Private field '#" + (id.name) + "' must be declared in an enclosing class"));
		        }
		      }
		    }
		  };

		  function isPrivateNameConflicted(privateNameMap, element) {
		    var name = element.key.name;
		    var curr = privateNameMap[name];

		    var next = "true";
		    if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
		      next = (element.static ? "s" : "i") + element.kind;
		    }

		    // `class { get #a(){}; static set #a(_){} }` is also conflict.
		    if (
		      curr === "iget" && next === "iset" ||
		      curr === "iset" && next === "iget" ||
		      curr === "sget" && next === "sset" ||
		      curr === "sset" && next === "sget"
		    ) {
		      privateNameMap[name] = "true";
		      return false
		    } else if (!curr) {
		      privateNameMap[name] = next;
		      return false
		    } else {
		      return true
		    }
		  }

		  function checkKeyName(node, name) {
		    var computed = node.computed;
		    var key = node.key;
		    return !computed && (
		      key.type === "Identifier" && key.name === name ||
		      key.type === "Literal" && key.value === name
		    )
		  }

		  // Parses module export declaration.

		  pp$8.parseExportAllDeclaration = function(node, exports) {
		    if (this.options.ecmaVersion >= 11) {
		      if (this.eatContextual("as")) {
		        node.exported = this.parseModuleExportName();
		        this.checkExport(exports, node.exported, this.lastTokStart);
		      } else {
		        node.exported = null;
		      }
		    }
		    this.expectContextual("from");
		    if (this.type !== types$1.string) { this.unexpected(); }
		    node.source = this.parseExprAtom();
		    this.semicolon();
		    return this.finishNode(node, "ExportAllDeclaration")
		  };

		  pp$8.parseExport = function(node, exports) {
		    this.next();
		    // export * from '...'
		    if (this.eat(types$1.star)) {
		      return this.parseExportAllDeclaration(node, exports)
		    }
		    if (this.eat(types$1._default)) { // export default ...
		      this.checkExport(exports, "default", this.lastTokStart);
		      node.declaration = this.parseExportDefaultDeclaration();
		      return this.finishNode(node, "ExportDefaultDeclaration")
		    }
		    // export var|const|let|function|class ...
		    if (this.shouldParseExportStatement()) {
		      node.declaration = this.parseExportDeclaration(node);
		      if (node.declaration.type === "VariableDeclaration")
		        { this.checkVariableExport(exports, node.declaration.declarations); }
		      else
		        { this.checkExport(exports, node.declaration.id, node.declaration.id.start); }
		      node.specifiers = [];
		      node.source = null;
		    } else { // export { x, y as z } [from '...']
		      node.declaration = null;
		      node.specifiers = this.parseExportSpecifiers(exports);
		      if (this.eatContextual("from")) {
		        if (this.type !== types$1.string) { this.unexpected(); }
		        node.source = this.parseExprAtom();
		      } else {
		        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
		          // check for keywords used as local names
		          var spec = list[i];

		          this.checkUnreserved(spec.local);
		          // check if export is defined
		          this.checkLocalExport(spec.local);

		          if (spec.local.type === "Literal") {
		            this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
		          }
		        }

		        node.source = null;
		      }
		      this.semicolon();
		    }
		    return this.finishNode(node, "ExportNamedDeclaration")
		  };

		  pp$8.parseExportDeclaration = function(node) {
		    return this.parseStatement(null)
		  };

		  pp$8.parseExportDefaultDeclaration = function() {
		    var isAsync;
		    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
		      var fNode = this.startNode();
		      this.next();
		      if (isAsync) { this.next(); }
		      return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync)
		    } else if (this.type === types$1._class) {
		      var cNode = this.startNode();
		      return this.parseClass(cNode, "nullableID")
		    } else {
		      var declaration = this.parseMaybeAssign();
		      this.semicolon();
		      return declaration
		    }
		  };

		  pp$8.checkExport = function(exports, name, pos) {
		    if (!exports) { return }
		    if (typeof name !== "string")
		      { name = name.type === "Identifier" ? name.name : name.value; }
		    if (hasOwn(exports, name))
		      { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
		    exports[name] = true;
		  };

		  pp$8.checkPatternExport = function(exports, pat) {
		    var type = pat.type;
		    if (type === "Identifier")
		      { this.checkExport(exports, pat, pat.start); }
		    else if (type === "ObjectPattern")
		      { for (var i = 0, list = pat.properties; i < list.length; i += 1)
		        {
		          var prop = list[i];

		          this.checkPatternExport(exports, prop);
		        } }
		    else if (type === "ArrayPattern")
		      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
		        var elt = list$1[i$1];

		          if (elt) { this.checkPatternExport(exports, elt); }
		      } }
		    else if (type === "Property")
		      { this.checkPatternExport(exports, pat.value); }
		    else if (type === "AssignmentPattern")
		      { this.checkPatternExport(exports, pat.left); }
		    else if (type === "RestElement")
		      { this.checkPatternExport(exports, pat.argument); }
		  };

		  pp$8.checkVariableExport = function(exports, decls) {
		    if (!exports) { return }
		    for (var i = 0, list = decls; i < list.length; i += 1)
		      {
		      var decl = list[i];

		      this.checkPatternExport(exports, decl.id);
		    }
		  };

		  pp$8.shouldParseExportStatement = function() {
		    return this.type.keyword === "var" ||
		      this.type.keyword === "const" ||
		      this.type.keyword === "class" ||
		      this.type.keyword === "function" ||
		      this.isLet() ||
		      this.isAsyncFunction()
		  };

		  // Parses a comma-separated list of module exports.

		  pp$8.parseExportSpecifier = function(exports) {
		    var node = this.startNode();
		    node.local = this.parseModuleExportName();

		    node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
		    this.checkExport(
		      exports,
		      node.exported,
		      node.exported.start
		    );

		    return this.finishNode(node, "ExportSpecifier")
		  };

		  pp$8.parseExportSpecifiers = function(exports) {
		    var nodes = [], first = true;
		    // export { x, y as z } [from '...']
		    this.expect(types$1.braceL);
		    while (!this.eat(types$1.braceR)) {
		      if (!first) {
		        this.expect(types$1.comma);
		        if (this.afterTrailingComma(types$1.braceR)) { break }
		      } else { first = false; }

		      nodes.push(this.parseExportSpecifier(exports));
		    }
		    return nodes
		  };

		  // Parses import declaration.

		  pp$8.parseImport = function(node) {
		    this.next();

		    // import '...'
		    if (this.type === types$1.string) {
		      node.specifiers = empty$1;
		      node.source = this.parseExprAtom();
		    } else {
		      node.specifiers = this.parseImportSpecifiers();
		      this.expectContextual("from");
		      node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
		    }
		    this.semicolon();
		    return this.finishNode(node, "ImportDeclaration")
		  };

		  // Parses a comma-separated list of module imports.

		  pp$8.parseImportSpecifier = function() {
		    var node = this.startNode();
		    node.imported = this.parseModuleExportName();

		    if (this.eatContextual("as")) {
		      node.local = this.parseIdent();
		    } else {
		      this.checkUnreserved(node.imported);
		      node.local = node.imported;
		    }
		    this.checkLValSimple(node.local, BIND_LEXICAL);

		    return this.finishNode(node, "ImportSpecifier")
		  };

		  pp$8.parseImportDefaultSpecifier = function() {
		    // import defaultObj, { x, y as z } from '...'
		    var node = this.startNode();
		    node.local = this.parseIdent();
		    this.checkLValSimple(node.local, BIND_LEXICAL);
		    return this.finishNode(node, "ImportDefaultSpecifier")
		  };

		  pp$8.parseImportNamespaceSpecifier = function() {
		    var node = this.startNode();
		    this.next();
		    this.expectContextual("as");
		    node.local = this.parseIdent();
		    this.checkLValSimple(node.local, BIND_LEXICAL);
		    return this.finishNode(node, "ImportNamespaceSpecifier")
		  };

		  pp$8.parseImportSpecifiers = function() {
		    var nodes = [], first = true;
		    if (this.type === types$1.name) {
		      nodes.push(this.parseImportDefaultSpecifier());
		      if (!this.eat(types$1.comma)) { return nodes }
		    }
		    if (this.type === types$1.star) {
		      nodes.push(this.parseImportNamespaceSpecifier());
		      return nodes
		    }
		    this.expect(types$1.braceL);
		    while (!this.eat(types$1.braceR)) {
		      if (!first) {
		        this.expect(types$1.comma);
		        if (this.afterTrailingComma(types$1.braceR)) { break }
		      } else { first = false; }

		      nodes.push(this.parseImportSpecifier());
		    }
		    return nodes
		  };

		  pp$8.parseModuleExportName = function() {
		    if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
		      var stringLiteral = this.parseLiteral(this.value);
		      if (loneSurrogate.test(stringLiteral.value)) {
		        this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
		      }
		      return stringLiteral
		    }
		    return this.parseIdent(true)
		  };

		  // Set `ExpressionStatement#directive` property for directive prologues.
		  pp$8.adaptDirectivePrologue = function(statements) {
		    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
		      statements[i].directive = statements[i].expression.raw.slice(1, -1);
		    }
		  };
		  pp$8.isDirectiveCandidate = function(statement) {
		    return (
		      this.options.ecmaVersion >= 5 &&
		      statement.type === "ExpressionStatement" &&
		      statement.expression.type === "Literal" &&
		      typeof statement.expression.value === "string" &&
		      // Reject parenthesized strings.
		      (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
		    )
		  };

		  var pp$7 = Parser.prototype;

		  // Convert existing expression atom to assignable pattern
		  // if possible.

		  pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
		    if (this.options.ecmaVersion >= 6 && node) {
		      switch (node.type) {
		      case "Identifier":
		        if (this.inAsync && node.name === "await")
		          { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
		        break

		      case "ObjectPattern":
		      case "ArrayPattern":
		      case "AssignmentPattern":
		      case "RestElement":
		        break

		      case "ObjectExpression":
		        node.type = "ObjectPattern";
		        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
		        for (var i = 0, list = node.properties; i < list.length; i += 1) {
		          var prop = list[i];

		        this.toAssignable(prop, isBinding);
		          // Early error:
		          //   AssignmentRestProperty[Yield, Await] :
		          //     `...` DestructuringAssignmentTarget[Yield, Await]
		          //
		          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
		          if (
		            prop.type === "RestElement" &&
		            (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
		          ) {
		            this.raise(prop.argument.start, "Unexpected token");
		          }
		        }
		        break

		      case "Property":
		        // AssignmentProperty has type === "Property"
		        if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
		        this.toAssignable(node.value, isBinding);
		        break

		      case "ArrayExpression":
		        node.type = "ArrayPattern";
		        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
		        this.toAssignableList(node.elements, isBinding);
		        break

		      case "SpreadElement":
		        node.type = "RestElement";
		        this.toAssignable(node.argument, isBinding);
		        if (node.argument.type === "AssignmentPattern")
		          { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
		        break

		      case "AssignmentExpression":
		        if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
		        node.type = "AssignmentPattern";
		        delete node.operator;
		        this.toAssignable(node.left, isBinding);
		        break

		      case "ParenthesizedExpression":
		        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
		        break

		      case "ChainExpression":
		        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
		        break

		      case "MemberExpression":
		        if (!isBinding) { break }

		      default:
		        this.raise(node.start, "Assigning to rvalue");
		      }
		    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
		    return node
		  };

		  // Convert list of expression atoms to binding list.

		  pp$7.toAssignableList = function(exprList, isBinding) {
		    var end = exprList.length;
		    for (var i = 0; i < end; i++) {
		      var elt = exprList[i];
		      if (elt) { this.toAssignable(elt, isBinding); }
		    }
		    if (end) {
		      var last = exprList[end - 1];
		      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
		        { this.unexpected(last.argument.start); }
		    }
		    return exprList
		  };

		  // Parses spread element.

		  pp$7.parseSpread = function(refDestructuringErrors) {
		    var node = this.startNode();
		    this.next();
		    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
		    return this.finishNode(node, "SpreadElement")
		  };

		  pp$7.parseRestBinding = function() {
		    var node = this.startNode();
		    this.next();

		    // RestElement inside of a function parameter must be an identifier
		    if (this.options.ecmaVersion === 6 && this.type !== types$1.name)
		      { this.unexpected(); }

		    node.argument = this.parseBindingAtom();

		    return this.finishNode(node, "RestElement")
		  };

		  // Parses lvalue (assignable) atom.

		  pp$7.parseBindingAtom = function() {
		    if (this.options.ecmaVersion >= 6) {
		      switch (this.type) {
		      case types$1.bracketL:
		        var node = this.startNode();
		        this.next();
		        node.elements = this.parseBindingList(types$1.bracketR, true, true);
		        return this.finishNode(node, "ArrayPattern")

		      case types$1.braceL:
		        return this.parseObj(true)
		      }
		    }
		    return this.parseIdent()
		  };

		  pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
		    var elts = [], first = true;
		    while (!this.eat(close)) {
		      if (first) { first = false; }
		      else { this.expect(types$1.comma); }
		      if (allowEmpty && this.type === types$1.comma) {
		        elts.push(null);
		      } else if (allowTrailingComma && this.afterTrailingComma(close)) {
		        break
		      } else if (this.type === types$1.ellipsis) {
		        var rest = this.parseRestBinding();
		        this.parseBindingListItem(rest);
		        elts.push(rest);
		        if (this.type === types$1.comma) { this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"); }
		        this.expect(close);
		        break
		      } else {
		        elts.push(this.parseAssignableListItem(allowModifiers));
		      }
		    }
		    return elts
		  };

		  pp$7.parseAssignableListItem = function(allowModifiers) {
		    var elem = this.parseMaybeDefault(this.start, this.startLoc);
		    this.parseBindingListItem(elem);
		    return elem
		  };

		  pp$7.parseBindingListItem = function(param) {
		    return param
		  };

		  // Parses assignment pattern around given atom if possible.

		  pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
		    left = left || this.parseBindingAtom();
		    if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) { return left }
		    var node = this.startNodeAt(startPos, startLoc);
		    node.left = left;
		    node.right = this.parseMaybeAssign();
		    return this.finishNode(node, "AssignmentPattern")
		  };

		  // The following three functions all verify that a node is an lvalue —
		  // something that can be bound, or assigned to. In order to do so, they perform
		  // a variety of checks:
		  //
		  // - Check that none of the bound/assigned-to identifiers are reserved words.
		  // - Record name declarations for bindings in the appropriate scope.
		  // - Check duplicate argument names, if checkClashes is set.
		  //
		  // If a complex binding pattern is encountered (e.g., object and array
		  // destructuring), the entire pattern is recursively checked.
		  //
		  // There are three versions of checkLVal*() appropriate for different
		  // circumstances:
		  //
		  // - checkLValSimple() shall be used if the syntactic construct supports
		  //   nothing other than identifiers and member expressions. Parenthesized
		  //   expressions are also correctly handled. This is generally appropriate for
		  //   constructs for which the spec says
		  //
		  //   > It is a Syntax Error if AssignmentTargetType of [the production] is not
		  //   > simple.
		  //
		  //   It is also appropriate for checking if an identifier is valid and not
		  //   defined elsewhere, like import declarations or function/class identifiers.
		  //
		  //   Examples where this is used include:
		  //     a += …;
		  //     import a from '…';
		  //   where a is the node to be checked.
		  //
		  // - checkLValPattern() shall be used if the syntactic construct supports
		  //   anything checkLValSimple() supports, as well as object and array
		  //   destructuring patterns. This is generally appropriate for constructs for
		  //   which the spec says
		  //
		  //   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor
		  //   > an ArrayLiteral and AssignmentTargetType of [the production] is not
		  //   > simple.
		  //
		  //   Examples where this is used include:
		  //     (a = …);
		  //     const a = …;
		  //     try { … } catch (a) { … }
		  //   where a is the node to be checked.
		  //
		  // - checkLValInnerPattern() shall be used if the syntactic construct supports
		  //   anything checkLValPattern() supports, as well as default assignment
		  //   patterns, rest elements, and other constructs that may appear within an
		  //   object or array destructuring pattern.
		  //
		  //   As a special case, function parameters also use checkLValInnerPattern(),
		  //   as they also support defaults and rest constructs.
		  //
		  // These functions deliberately support both assignment and binding constructs,
		  // as the logic for both is exceedingly similar. If the node is the target of
		  // an assignment, then bindingType should be set to BIND_NONE. Otherwise, it
		  // should be set to the appropriate BIND_* constant, like BIND_VAR or
		  // BIND_LEXICAL.
		  //
		  // If the function is called with a non-BIND_NONE bindingType, then
		  // additionally a checkClashes object may be specified to allow checking for
		  // duplicate argument names. checkClashes is ignored if the provided construct
		  // is an assignment (i.e., bindingType is BIND_NONE).

		  pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
		    if ( bindingType === void 0 ) bindingType = BIND_NONE;

		    var isBind = bindingType !== BIND_NONE;

		    switch (expr.type) {
		    case "Identifier":
		      if (this.strict && this.reservedWordsStrictBind.test(expr.name))
		        { this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
		      if (isBind) {
		        if (bindingType === BIND_LEXICAL && expr.name === "let")
		          { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
		        if (checkClashes) {
		          if (hasOwn(checkClashes, expr.name))
		            { this.raiseRecoverable(expr.start, "Argument name clash"); }
		          checkClashes[expr.name] = true;
		        }
		        if (bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
		      }
		      break

		    case "ChainExpression":
		      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
		      break

		    case "MemberExpression":
		      if (isBind) { this.raiseRecoverable(expr.start, "Binding member expression"); }
		      break

		    case "ParenthesizedExpression":
		      if (isBind) { this.raiseRecoverable(expr.start, "Binding parenthesized expression"); }
		      return this.checkLValSimple(expr.expression, bindingType, checkClashes)

		    default:
		      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
		    }
		  };

		  pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
		    if ( bindingType === void 0 ) bindingType = BIND_NONE;

		    switch (expr.type) {
		    case "ObjectPattern":
		      for (var i = 0, list = expr.properties; i < list.length; i += 1) {
		        var prop = list[i];

		      this.checkLValInnerPattern(prop, bindingType, checkClashes);
		      }
		      break

		    case "ArrayPattern":
		      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
		        var elem = list$1[i$1];

		      if (elem) { this.checkLValInnerPattern(elem, bindingType, checkClashes); }
		      }
		      break

		    default:
		      this.checkLValSimple(expr, bindingType, checkClashes);
		    }
		  };

		  pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
		    if ( bindingType === void 0 ) bindingType = BIND_NONE;

		    switch (expr.type) {
		    case "Property":
		      // AssignmentProperty has type === "Property"
		      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
		      break

		    case "AssignmentPattern":
		      this.checkLValPattern(expr.left, bindingType, checkClashes);
		      break

		    case "RestElement":
		      this.checkLValPattern(expr.argument, bindingType, checkClashes);
		      break

		    default:
		      this.checkLValPattern(expr, bindingType, checkClashes);
		    }
		  };

		  // The algorithm used to determine whether a regexp can appear at a
		  // given point in the program is loosely based on sweet.js' approach.
		  // See https://github.com/mozilla/sweet.js/wiki/design


		  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
		    this.token = token;
		    this.isExpr = !!isExpr;
		    this.preserveSpace = !!preserveSpace;
		    this.override = override;
		    this.generator = !!generator;
		  };

		  var types = {
		    b_stat: new TokContext("{", false),
		    b_expr: new TokContext("{", true),
		    b_tmpl: new TokContext("${", false),
		    p_stat: new TokContext("(", false),
		    p_expr: new TokContext("(", true),
		    q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
		    f_stat: new TokContext("function", false),
		    f_expr: new TokContext("function", true),
		    f_expr_gen: new TokContext("function", true, false, null, true),
		    f_gen: new TokContext("function", false, false, null, true)
		  };

		  var pp$6 = Parser.prototype;

		  pp$6.initialContext = function() {
		    return [types.b_stat]
		  };

		  pp$6.curContext = function() {
		    return this.context[this.context.length - 1]
		  };

		  pp$6.braceIsBlock = function(prevType) {
		    var parent = this.curContext();
		    if (parent === types.f_expr || parent === types.f_stat)
		      { return true }
		    if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr))
		      { return !parent.isExpr }

		    // The check for `tt.name && exprAllowed` detects whether we are
		    // after a `yield` or `of` construct. See the `updateContext` for
		    // `tt.name`.
		    if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed)
		      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
		    if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)
		      { return true }
		    if (prevType === types$1.braceL)
		      { return parent === types.b_stat }
		    if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)
		      { return false }
		    return !this.exprAllowed
		  };

		  pp$6.inGeneratorContext = function() {
		    for (var i = this.context.length - 1; i >= 1; i--) {
		      var context = this.context[i];
		      if (context.token === "function")
		        { return context.generator }
		    }
		    return false
		  };

		  pp$6.updateContext = function(prevType) {
		    var update, type = this.type;
		    if (type.keyword && prevType === types$1.dot)
		      { this.exprAllowed = false; }
		    else if (update = type.updateContext)
		      { update.call(this, prevType); }
		    else
		      { this.exprAllowed = type.beforeExpr; }
		  };

		  // Used to handle edge cases when token context could not be inferred correctly during tokenization phase

		  pp$6.overrideContext = function(tokenCtx) {
		    if (this.curContext() !== tokenCtx) {
		      this.context[this.context.length - 1] = tokenCtx;
		    }
		  };

		  // Token-specific context update code

		  types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
		    if (this.context.length === 1) {
		      this.exprAllowed = true;
		      return
		    }
		    var out = this.context.pop();
		    if (out === types.b_stat && this.curContext().token === "function") {
		      out = this.context.pop();
		    }
		    this.exprAllowed = !out.isExpr;
		  };

		  types$1.braceL.updateContext = function(prevType) {
		    this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
		    this.exprAllowed = true;
		  };

		  types$1.dollarBraceL.updateContext = function() {
		    this.context.push(types.b_tmpl);
		    this.exprAllowed = true;
		  };

		  types$1.parenL.updateContext = function(prevType) {
		    var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
		    this.context.push(statementParens ? types.p_stat : types.p_expr);
		    this.exprAllowed = true;
		  };

		  types$1.incDec.updateContext = function() {
		    // tokExprAllowed stays unchanged
		  };

		  types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
		    if (prevType.beforeExpr && prevType !== types$1._else &&
		        !(prevType === types$1.semi && this.curContext() !== types.p_stat) &&
		        !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
		        !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat))
		      { this.context.push(types.f_expr); }
		    else
		      { this.context.push(types.f_stat); }
		    this.exprAllowed = false;
		  };

		  types$1.colon.updateContext = function() {
		    if (this.curContext().token === "function") { this.context.pop(); }
		    this.exprAllowed = true;
		  };

		  types$1.backQuote.updateContext = function() {
		    if (this.curContext() === types.q_tmpl)
		      { this.context.pop(); }
		    else
		      { this.context.push(types.q_tmpl); }
		    this.exprAllowed = false;
		  };

		  types$1.star.updateContext = function(prevType) {
		    if (prevType === types$1._function) {
		      var index = this.context.length - 1;
		      if (this.context[index] === types.f_expr)
		        { this.context[index] = types.f_expr_gen; }
		      else
		        { this.context[index] = types.f_gen; }
		    }
		    this.exprAllowed = true;
		  };

		  types$1.name.updateContext = function(prevType) {
		    var allowed = false;
		    if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
		      if (this.value === "of" && !this.exprAllowed ||
		          this.value === "yield" && this.inGeneratorContext())
		        { allowed = true; }
		    }
		    this.exprAllowed = allowed;
		  };

		  // A recursive descent parser operates by defining functions for all
		  // syntactic elements, and recursively calling those, each function
		  // advancing the input stream and returning an AST node. Precedence
		  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
		  // instead of `(!x)[1]` is handled by the fact that the parser
		  // function that parses unary prefix operators is called first, and
		  // in turn calls the function that parses `[]` subscripts — that
		  // way, it'll receive the node for `x[1]` already parsed, and wraps
		  // *that* in the unary operator node.
		  //
		  // Acorn uses an [operator precedence parser][opp] to handle binary
		  // operator precedence, because it is much more compact than using
		  // the technique outlined above, which uses different, nesting
		  // functions to specify precedence, for all of the ten binary
		  // precedence levels that JavaScript defines.
		  //
		  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser


		  var pp$5 = Parser.prototype;

		  // Check if property name clashes with already added.
		  // Object/class getters and setters are not allowed to clash —
		  // either with each other or with an init property — and in
		  // strict mode, init properties are also not allowed to be repeated.

		  pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
		    if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
		      { return }
		    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
		      { return }
		    var key = prop.key;
		    var name;
		    switch (key.type) {
		    case "Identifier": name = key.name; break
		    case "Literal": name = String(key.value); break
		    default: return
		    }
		    var kind = prop.kind;
		    if (this.options.ecmaVersion >= 6) {
		      if (name === "__proto__" && kind === "init") {
		        if (propHash.proto) {
		          if (refDestructuringErrors) {
		            if (refDestructuringErrors.doubleProto < 0) {
		              refDestructuringErrors.doubleProto = key.start;
		            }
		          } else {
		            this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
		          }
		        }
		        propHash.proto = true;
		      }
		      return
		    }
		    name = "$" + name;
		    var other = propHash[name];
		    if (other) {
		      var redefinition;
		      if (kind === "init") {
		        redefinition = this.strict && other.init || other.get || other.set;
		      } else {
		        redefinition = other.init || other[kind];
		      }
		      if (redefinition)
		        { this.raiseRecoverable(key.start, "Redefinition of property"); }
		    } else {
		      other = propHash[name] = {
		        init: false,
		        get: false,
		        set: false
		      };
		    }
		    other[kind] = true;
		  };

		  // ### Expression parsing

		  // These nest, from the most general expression type at the top to
		  // 'atomic', nondivisible expression types at the bottom. Most of
		  // the functions will simply let the function(s) below them parse,
		  // and, *if* the syntactic construct they handle is present, wrap
		  // the AST node that the inner parser gave them in another node.

		  // Parse a full expression. The optional arguments are used to
		  // forbid the `in` operator (in for loops initalization expressions)
		  // and provide reference for storing '=' operator inside shorthand
		  // property assignment in contexts where both object expression
		  // and object pattern might appear (so it's possible to raise
		  // delayed syntax error at correct position).

		  pp$5.parseExpression = function(forInit, refDestructuringErrors) {
		    var startPos = this.start, startLoc = this.startLoc;
		    var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
		    if (this.type === types$1.comma) {
		      var node = this.startNodeAt(startPos, startLoc);
		      node.expressions = [expr];
		      while (this.eat(types$1.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }
		      return this.finishNode(node, "SequenceExpression")
		    }
		    return expr
		  };

		  // Parse an assignment expression. This includes applications of
		  // operators like `+=`.

		  pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
		    if (this.isContextual("yield")) {
		      if (this.inGenerator) { return this.parseYield(forInit) }
		      // The tokenizer will assume an expression is allowed after
		      // `yield`, but this isn't that kind of yield
		      else { this.exprAllowed = false; }
		    }

		    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
		    if (refDestructuringErrors) {
		      oldParenAssign = refDestructuringErrors.parenthesizedAssign;
		      oldTrailingComma = refDestructuringErrors.trailingComma;
		      oldDoubleProto = refDestructuringErrors.doubleProto;
		      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
		    } else {
		      refDestructuringErrors = new DestructuringErrors;
		      ownDestructuringErrors = true;
		    }

		    var startPos = this.start, startLoc = this.startLoc;
		    if (this.type === types$1.parenL || this.type === types$1.name) {
		      this.potentialArrowAt = this.start;
		      this.potentialArrowInForAwait = forInit === "await";
		    }
		    var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
		    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
		    if (this.type.isAssign) {
		      var node = this.startNodeAt(startPos, startLoc);
		      node.operator = this.value;
		      if (this.type === types$1.eq)
		        { left = this.toAssignable(left, false, refDestructuringErrors); }
		      if (!ownDestructuringErrors) {
		        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
		      }
		      if (refDestructuringErrors.shorthandAssign >= left.start)
		        { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly
		      if (this.type === types$1.eq)
		        { this.checkLValPattern(left); }
		      else
		        { this.checkLValSimple(left); }
		      node.left = left;
		      this.next();
		      node.right = this.parseMaybeAssign(forInit);
		      if (oldDoubleProto > -1) { refDestructuringErrors.doubleProto = oldDoubleProto; }
		      return this.finishNode(node, "AssignmentExpression")
		    } else {
		      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
		    }
		    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
		    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
		    return left
		  };

		  // Parse a ternary conditional (`?:`) operator.

		  pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
		    var startPos = this.start, startLoc = this.startLoc;
		    var expr = this.parseExprOps(forInit, refDestructuringErrors);
		    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
		    if (this.eat(types$1.question)) {
		      var node = this.startNodeAt(startPos, startLoc);
		      node.test = expr;
		      node.consequent = this.parseMaybeAssign();
		      this.expect(types$1.colon);
		      node.alternate = this.parseMaybeAssign(forInit);
		      return this.finishNode(node, "ConditionalExpression")
		    }
		    return expr
		  };

		  // Start the precedence parser.

		  pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
		    var startPos = this.start, startLoc = this.startLoc;
		    var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
		    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
		    return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit)
		  };

		  // Parse binary operators with the operator precedence parsing
		  // algorithm. `left` is the left-hand side of the operator.
		  // `minPrec` provides context that allows the function to stop and
		  // defer further parser to one of its callers when it encounters an
		  // operator that has a lower precedence than the set it is parsing.

		  pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
		    var prec = this.type.binop;
		    if (prec != null && (!forInit || this.type !== types$1._in)) {
		      if (prec > minPrec) {
		        var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
		        var coalesce = this.type === types$1.coalesce;
		        if (coalesce) {
		          // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
		          // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
		          prec = types$1.logicalAND.binop;
		        }
		        var op = this.value;
		        this.next();
		        var startPos = this.start, startLoc = this.startLoc;
		        var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
		        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
		        if ((logical && this.type === types$1.coalesce) || (coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND))) {
		          this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
		        }
		        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit)
		      }
		    }
		    return left
		  };

		  pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
		    if (right.type === "PrivateIdentifier") { this.raise(right.start, "Private identifier can only be left side of binary expression"); }
		    var node = this.startNodeAt(startPos, startLoc);
		    node.left = left;
		    node.operator = op;
		    node.right = right;
		    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
		  };

		  // Parse unary operators, both prefix and postfix.

		  pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
		    var startPos = this.start, startLoc = this.startLoc, expr;
		    if (this.isContextual("await") && this.canAwait) {
		      expr = this.parseAwait(forInit);
		      sawUnary = true;
		    } else if (this.type.prefix) {
		      var node = this.startNode(), update = this.type === types$1.incDec;
		      node.operator = this.value;
		      node.prefix = true;
		      this.next();
		      node.argument = this.parseMaybeUnary(null, true, update, forInit);
		      this.checkExpressionErrors(refDestructuringErrors, true);
		      if (update) { this.checkLValSimple(node.argument); }
		      else if (this.strict && node.operator === "delete" &&
		               node.argument.type === "Identifier")
		        { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
		      else if (node.operator === "delete" && isPrivateFieldAccess(node.argument))
		        { this.raiseRecoverable(node.start, "Private fields can not be deleted"); }
		      else { sawUnary = true; }
		      expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
		    } else if (!sawUnary && this.type === types$1.privateId) {
		      if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) { this.unexpected(); }
		      expr = this.parsePrivateIdent();
		      // only could be private fields in 'in', such as #x in obj
		      if (this.type !== types$1._in) { this.unexpected(); }
		    } else {
		      expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
		      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
		      while (this.type.postfix && !this.canInsertSemicolon()) {
		        var node$1 = this.startNodeAt(startPos, startLoc);
		        node$1.operator = this.value;
		        node$1.prefix = false;
		        node$1.argument = expr;
		        this.checkLValSimple(expr);
		        this.next();
		        expr = this.finishNode(node$1, "UpdateExpression");
		      }
		    }

		    if (!incDec && this.eat(types$1.starstar)) {
		      if (sawUnary)
		        { this.unexpected(this.lastTokStart); }
		      else
		        { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false) }
		    } else {
		      return expr
		    }
		  };

		  function isPrivateFieldAccess(node) {
		    return (
		      node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" ||
		      node.type === "ChainExpression" && isPrivateFieldAccess(node.expression)
		    )
		  }

		  // Parse call, dot, and `[]`-subscript expressions.

		  pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
		    var startPos = this.start, startLoc = this.startLoc;
		    var expr = this.parseExprAtom(refDestructuringErrors, forInit);
		    if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
		      { return expr }
		    var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
		    if (refDestructuringErrors && result.type === "MemberExpression") {
		      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
		      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
		      if (refDestructuringErrors.trailingComma >= result.start) { refDestructuringErrors.trailingComma = -1; }
		    }
		    return result
		  };

		  pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
		    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
		        this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
		        this.potentialArrowAt === base.start;
		    var optionalChained = false;

		    while (true) {
		      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);

		      if (element.optional) { optionalChained = true; }
		      if (element === base || element.type === "ArrowFunctionExpression") {
		        if (optionalChained) {
		          var chainNode = this.startNodeAt(startPos, startLoc);
		          chainNode.expression = element;
		          element = this.finishNode(chainNode, "ChainExpression");
		        }
		        return element
		      }

		      base = element;
		    }
		  };

		  pp$5.shouldParseAsyncArrow = function() {
		    return !this.canInsertSemicolon() && this.eat(types$1.arrow)
		  };

		  pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
		    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit)
		  };

		  pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
		    var optionalSupported = this.options.ecmaVersion >= 11;
		    var optional = optionalSupported && this.eat(types$1.questionDot);
		    if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }

		    var computed = this.eat(types$1.bracketL);
		    if (computed || (optional && this.type !== types$1.parenL && this.type !== types$1.backQuote) || this.eat(types$1.dot)) {
		      var node = this.startNodeAt(startPos, startLoc);
		      node.object = base;
		      if (computed) {
		        node.property = this.parseExpression();
		        this.expect(types$1.bracketR);
		      } else if (this.type === types$1.privateId && base.type !== "Super") {
		        node.property = this.parsePrivateIdent();
		      } else {
		        node.property = this.parseIdent(this.options.allowReserved !== "never");
		      }
		      node.computed = !!computed;
		      if (optionalSupported) {
		        node.optional = optional;
		      }
		      base = this.finishNode(node, "MemberExpression");
		    } else if (!noCalls && this.eat(types$1.parenL)) {
		      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
		      this.yieldPos = 0;
		      this.awaitPos = 0;
		      this.awaitIdentPos = 0;
		      var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
		      if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
		        this.checkPatternErrors(refDestructuringErrors, false);
		        this.checkYieldAwaitInDefaultParams();
		        if (this.awaitIdentPos > 0)
		          { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
		        this.yieldPos = oldYieldPos;
		        this.awaitPos = oldAwaitPos;
		        this.awaitIdentPos = oldAwaitIdentPos;
		        return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit)
		      }
		      this.checkExpressionErrors(refDestructuringErrors, true);
		      this.yieldPos = oldYieldPos || this.yieldPos;
		      this.awaitPos = oldAwaitPos || this.awaitPos;
		      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
		      var node$1 = this.startNodeAt(startPos, startLoc);
		      node$1.callee = base;
		      node$1.arguments = exprList;
		      if (optionalSupported) {
		        node$1.optional = optional;
		      }
		      base = this.finishNode(node$1, "CallExpression");
		    } else if (this.type === types$1.backQuote) {
		      if (optional || optionalChained) {
		        this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
		      }
		      var node$2 = this.startNodeAt(startPos, startLoc);
		      node$2.tag = base;
		      node$2.quasi = this.parseTemplate({isTagged: true});
		      base = this.finishNode(node$2, "TaggedTemplateExpression");
		    }
		    return base
		  };

		  // Parse an atomic expression — either a single token that is an
		  // expression, an expression started by a keyword like `function` or
		  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
		  // or `{}`.

		  pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
		    // If a division operator appears in an expression position, the
		    // tokenizer got confused, and we force it to read a regexp instead.
		    if (this.type === types$1.slash) { this.readRegexp(); }

		    var node, canBeArrow = this.potentialArrowAt === this.start;
		    switch (this.type) {
		    case types$1._super:
		      if (!this.allowSuper)
		        { this.raise(this.start, "'super' keyword outside a method"); }
		      node = this.startNode();
		      this.next();
		      if (this.type === types$1.parenL && !this.allowDirectSuper)
		        { this.raise(node.start, "super() call outside constructor of a subclass"); }
		      // The `super` keyword can appear at below:
		      // SuperProperty:
		      //     super [ Expression ]
		      //     super . IdentifierName
		      // SuperCall:
		      //     super ( Arguments )
		      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL)
		        { this.unexpected(); }
		      return this.finishNode(node, "Super")

		    case types$1._this:
		      node = this.startNode();
		      this.next();
		      return this.finishNode(node, "ThisExpression")

		    case types$1.name:
		      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
		      var id = this.parseIdent(false);
		      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
		        this.overrideContext(types.f_expr);
		        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)
		      }
		      if (canBeArrow && !this.canInsertSemicolon()) {
		        if (this.eat(types$1.arrow))
		          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }
		        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc &&
		            (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
		          id = this.parseIdent(false);
		          if (this.canInsertSemicolon() || !this.eat(types$1.arrow))
		            { this.unexpected(); }
		          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)
		        }
		      }
		      return id

		    case types$1.regexp:
		      var value = this.value;
		      node = this.parseLiteral(value.value);
		      node.regex = {pattern: value.pattern, flags: value.flags};
		      return node

		    case types$1.num: case types$1.string:
		      return this.parseLiteral(this.value)

		    case types$1._null: case types$1._true: case types$1._false:
		      node = this.startNode();
		      node.value = this.type === types$1._null ? null : this.type === types$1._true;
		      node.raw = this.type.keyword;
		      this.next();
		      return this.finishNode(node, "Literal")

		    case types$1.parenL:
		      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
		      if (refDestructuringErrors) {
		        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
		          { refDestructuringErrors.parenthesizedAssign = start; }
		        if (refDestructuringErrors.parenthesizedBind < 0)
		          { refDestructuringErrors.parenthesizedBind = start; }
		      }
		      return expr

		    case types$1.bracketL:
		      node = this.startNode();
		      this.next();
		      node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
		      return this.finishNode(node, "ArrayExpression")

		    case types$1.braceL:
		      this.overrideContext(types.b_expr);
		      return this.parseObj(false, refDestructuringErrors)

		    case types$1._function:
		      node = this.startNode();
		      this.next();
		      return this.parseFunction(node, 0)

		    case types$1._class:
		      return this.parseClass(this.startNode(), false)

		    case types$1._new:
		      return this.parseNew()

		    case types$1.backQuote:
		      return this.parseTemplate()

		    case types$1._import:
		      if (this.options.ecmaVersion >= 11) {
		        return this.parseExprImport(forNew)
		      } else {
		        return this.unexpected()
		      }

		    default:
		      return this.parseExprAtomDefault()
		    }
		  };

		  pp$5.parseExprAtomDefault = function() {
		    this.unexpected();
		  };

		  pp$5.parseExprImport = function(forNew) {
		    var node = this.startNode();

		    // Consume `import` as an identifier for `import.meta`.
		    // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
		    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword import"); }
		    this.next();

		    if (this.type === types$1.parenL && !forNew) {
		      return this.parseDynamicImport(node)
		    } else if (this.type === types$1.dot) {
		      var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
		      meta.name = "import";
		      node.meta = this.finishNode(meta, "Identifier");
		      return this.parseImportMeta(node)
		    } else {
		      this.unexpected();
		    }
		  };

		  pp$5.parseDynamicImport = function(node) {
		    this.next(); // skip `(`

		    // Parse node.source.
		    node.source = this.parseMaybeAssign();

		    // Verify ending.
		    if (!this.eat(types$1.parenR)) {
		      var errorPos = this.start;
		      if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
		        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
		      } else {
		        this.unexpected(errorPos);
		      }
		    }

		    return this.finishNode(node, "ImportExpression")
		  };

		  pp$5.parseImportMeta = function(node) {
		    this.next(); // skip `.`

		    var containsEsc = this.containsEsc;
		    node.property = this.parseIdent(true);

		    if (node.property.name !== "meta")
		      { this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"); }
		    if (containsEsc)
		      { this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"); }
		    if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere)
		      { this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"); }

		    return this.finishNode(node, "MetaProperty")
		  };

		  pp$5.parseLiteral = function(value) {
		    var node = this.startNode();
		    node.value = value;
		    node.raw = this.input.slice(this.start, this.end);
		    if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, ""); }
		    this.next();
		    return this.finishNode(node, "Literal")
		  };

		  pp$5.parseParenExpression = function() {
		    this.expect(types$1.parenL);
		    var val = this.parseExpression();
		    this.expect(types$1.parenR);
		    return val
		  };

		  pp$5.shouldParseArrow = function(exprList) {
		    return !this.canInsertSemicolon()
		  };

		  pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
		    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
		    if (this.options.ecmaVersion >= 6) {
		      this.next();

		      var innerStartPos = this.start, innerStartLoc = this.startLoc;
		      var exprList = [], first = true, lastIsComma = false;
		      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
		      this.yieldPos = 0;
		      this.awaitPos = 0;
		      // Do not save awaitIdentPos to allow checking awaits nested in parameters
		      while (this.type !== types$1.parenR) {
		        first ? first = false : this.expect(types$1.comma);
		        if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
		          lastIsComma = true;
		          break
		        } else if (this.type === types$1.ellipsis) {
		          spreadStart = this.start;
		          exprList.push(this.parseParenItem(this.parseRestBinding()));
		          if (this.type === types$1.comma) {
		            this.raiseRecoverable(
		              this.start,
		              "Comma is not permitted after the rest element"
		            );
		          }
		          break
		        } else {
		          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
		        }
		      }
		      var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
		      this.expect(types$1.parenR);

		      if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
		        this.checkPatternErrors(refDestructuringErrors, false);
		        this.checkYieldAwaitInDefaultParams();
		        this.yieldPos = oldYieldPos;
		        this.awaitPos = oldAwaitPos;
		        return this.parseParenArrowList(startPos, startLoc, exprList, forInit)
		      }

		      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
		      if (spreadStart) { this.unexpected(spreadStart); }
		      this.checkExpressionErrors(refDestructuringErrors, true);
		      this.yieldPos = oldYieldPos || this.yieldPos;
		      this.awaitPos = oldAwaitPos || this.awaitPos;

		      if (exprList.length > 1) {
		        val = this.startNodeAt(innerStartPos, innerStartLoc);
		        val.expressions = exprList;
		        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
		      } else {
		        val = exprList[0];
		      }
		    } else {
		      val = this.parseParenExpression();
		    }

		    if (this.options.preserveParens) {
		      var par = this.startNodeAt(startPos, startLoc);
		      par.expression = val;
		      return this.finishNode(par, "ParenthesizedExpression")
		    } else {
		      return val
		    }
		  };

		  pp$5.parseParenItem = function(item) {
		    return item
		  };

		  pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
		    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit)
		  };

		  // New's precedence is slightly tricky. It must allow its argument to
		  // be a `[]` or dot subscript expression, but not a call — at least,
		  // not without wrapping it in parentheses. Thus, it uses the noCalls
		  // argument to parseSubscripts to prevent it from consuming the
		  // argument list.

		  var empty = [];

		  pp$5.parseNew = function() {
		    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
		    var node = this.startNode();
		    this.next();
		    if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
		      var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
		      meta.name = "new";
		      node.meta = this.finishNode(meta, "Identifier");
		      this.next();
		      var containsEsc = this.containsEsc;
		      node.property = this.parseIdent(true);
		      if (node.property.name !== "target")
		        { this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"); }
		      if (containsEsc)
		        { this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"); }
		      if (!this.allowNewDotTarget)
		        { this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block"); }
		      return this.finishNode(node, "MetaProperty")
		    }
		    var startPos = this.start, startLoc = this.startLoc;
		    node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
		    if (this.eat(types$1.parenL)) { node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false); }
		    else { node.arguments = empty; }
		    return this.finishNode(node, "NewExpression")
		  };

		  // Parse template expression.

		  pp$5.parseTemplateElement = function(ref) {
		    var isTagged = ref.isTagged;

		    var elem = this.startNode();
		    if (this.type === types$1.invalidTemplate) {
		      if (!isTagged) {
		        this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
		      }
		      elem.value = {
		        raw: this.value,
		        cooked: null
		      };
		    } else {
		      elem.value = {
		        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
		        cooked: this.value
		      };
		    }
		    this.next();
		    elem.tail = this.type === types$1.backQuote;
		    return this.finishNode(elem, "TemplateElement")
		  };

		  pp$5.parseTemplate = function(ref) {
		    if ( ref === void 0 ) ref = {};
		    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

		    var node = this.startNode();
		    this.next();
		    node.expressions = [];
		    var curElt = this.parseTemplateElement({isTagged: isTagged});
		    node.quasis = [curElt];
		    while (!curElt.tail) {
		      if (this.type === types$1.eof) { this.raise(this.pos, "Unterminated template literal"); }
		      this.expect(types$1.dollarBraceL);
		      node.expressions.push(this.parseExpression());
		      this.expect(types$1.braceR);
		      node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
		    }
		    this.next();
		    return this.finishNode(node, "TemplateLiteral")
		  };

		  pp$5.isAsyncProp = function(prop) {
		    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
		      (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types$1.star)) &&
		      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
		  };

		  // Parse an object literal or binding pattern.

		  pp$5.parseObj = function(isPattern, refDestructuringErrors) {
		    var node = this.startNode(), first = true, propHash = {};
		    node.properties = [];
		    this.next();
		    while (!this.eat(types$1.braceR)) {
		      if (!first) {
		        this.expect(types$1.comma);
		        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) { break }
		      } else { first = false; }

		      var prop = this.parseProperty(isPattern, refDestructuringErrors);
		      if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
		      node.properties.push(prop);
		    }
		    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
		  };

		  pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
		    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
		    if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
		      if (isPattern) {
		        prop.argument = this.parseIdent(false);
		        if (this.type === types$1.comma) {
		          this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
		        }
		        return this.finishNode(prop, "RestElement")
		      }
		      // Parse argument.
		      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
		      // To disallow trailing comma via `this.toAssignable()`.
		      if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
		        refDestructuringErrors.trailingComma = this.start;
		      }
		      // Finish
		      return this.finishNode(prop, "SpreadElement")
		    }
		    if (this.options.ecmaVersion >= 6) {
		      prop.method = false;
		      prop.shorthand = false;
		      if (isPattern || refDestructuringErrors) {
		        startPos = this.start;
		        startLoc = this.startLoc;
		      }
		      if (!isPattern)
		        { isGenerator = this.eat(types$1.star); }
		    }
		    var containsEsc = this.containsEsc;
		    this.parsePropertyName(prop);
		    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
		      isAsync = true;
		      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
		      this.parsePropertyName(prop);
		    } else {
		      isAsync = false;
		    }
		    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
		    return this.finishNode(prop, "Property")
		  };

		  pp$5.parseGetterSetter = function(prop) {
		    prop.kind = prop.key.name;
		    this.parsePropertyName(prop);
		    prop.value = this.parseMethod(false);
		    var paramCount = prop.kind === "get" ? 0 : 1;
		    if (prop.value.params.length !== paramCount) {
		      var start = prop.value.start;
		      if (prop.kind === "get")
		        { this.raiseRecoverable(start, "getter should have no params"); }
		      else
		        { this.raiseRecoverable(start, "setter should have exactly one param"); }
		    } else {
		      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
		        { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
		    }
		  };

		  pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
		    if ((isGenerator || isAsync) && this.type === types$1.colon)
		      { this.unexpected(); }

		    if (this.eat(types$1.colon)) {
		      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
		      prop.kind = "init";
		    } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
		      if (isPattern) { this.unexpected(); }
		      prop.kind = "init";
		      prop.method = true;
		      prop.value = this.parseMethod(isGenerator, isAsync);
		    } else if (!isPattern && !containsEsc &&
		               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
		               (prop.key.name === "get" || prop.key.name === "set") &&
		               (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
		      if (isGenerator || isAsync) { this.unexpected(); }
		      this.parseGetterSetter(prop);
		    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
		      if (isGenerator || isAsync) { this.unexpected(); }
		      this.checkUnreserved(prop.key);
		      if (prop.key.name === "await" && !this.awaitIdentPos)
		        { this.awaitIdentPos = startPos; }
		      prop.kind = "init";
		      if (isPattern) {
		        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
		      } else if (this.type === types$1.eq && refDestructuringErrors) {
		        if (refDestructuringErrors.shorthandAssign < 0)
		          { refDestructuringErrors.shorthandAssign = this.start; }
		        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
		      } else {
		        prop.value = this.copyNode(prop.key);
		      }
		      prop.shorthand = true;
		    } else { this.unexpected(); }
		  };

		  pp$5.parsePropertyName = function(prop) {
		    if (this.options.ecmaVersion >= 6) {
		      if (this.eat(types$1.bracketL)) {
		        prop.computed = true;
		        prop.key = this.parseMaybeAssign();
		        this.expect(types$1.bracketR);
		        return prop.key
		      } else {
		        prop.computed = false;
		      }
		    }
		    return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
		  };

		  // Initialize empty function node.

		  pp$5.initFunction = function(node) {
		    node.id = null;
		    if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
		    if (this.options.ecmaVersion >= 8) { node.async = false; }
		  };

		  // Parse object or class method.

		  pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
		    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

		    this.initFunction(node);
		    if (this.options.ecmaVersion >= 6)
		      { node.generator = isGenerator; }
		    if (this.options.ecmaVersion >= 8)
		      { node.async = !!isAsync; }

		    this.yieldPos = 0;
		    this.awaitPos = 0;
		    this.awaitIdentPos = 0;
		    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

		    this.expect(types$1.parenL);
		    node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
		    this.checkYieldAwaitInDefaultParams();
		    this.parseFunctionBody(node, false, true, false);

		    this.yieldPos = oldYieldPos;
		    this.awaitPos = oldAwaitPos;
		    this.awaitIdentPos = oldAwaitIdentPos;
		    return this.finishNode(node, "FunctionExpression")
		  };

		  // Parse arrow function expression with given parameters.

		  pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
		    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

		    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
		    this.initFunction(node);
		    if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

		    this.yieldPos = 0;
		    this.awaitPos = 0;
		    this.awaitIdentPos = 0;

		    node.params = this.toAssignableList(params, true);
		    this.parseFunctionBody(node, true, false, forInit);

		    this.yieldPos = oldYieldPos;
		    this.awaitPos = oldAwaitPos;
		    this.awaitIdentPos = oldAwaitIdentPos;
		    return this.finishNode(node, "ArrowFunctionExpression")
		  };

		  // Parse function body and check parameters.

		  pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
		    var isExpression = isArrowFunction && this.type !== types$1.braceL;
		    var oldStrict = this.strict, useStrict = false;

		    if (isExpression) {
		      node.body = this.parseMaybeAssign(forInit);
		      node.expression = true;
		      this.checkParams(node, false);
		    } else {
		      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
		      if (!oldStrict || nonSimple) {
		        useStrict = this.strictDirective(this.end);
		        // If this is a strict mode function, verify that argument names
		        // are not repeated, and it does not try to bind the words `eval`
		        // or `arguments`.
		        if (useStrict && nonSimple)
		          { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
		      }
		      // Start a new scope with regard to labels and the `inFunction`
		      // flag (restore them to their old value afterwards).
		      var oldLabels = this.labels;
		      this.labels = [];
		      if (useStrict) { this.strict = true; }

		      // Add the params to varDeclaredNames to ensure that an error is thrown
		      // if a let/const declaration in the function clashes with one of the params.
		      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
		      // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
		      if (this.strict && node.id) { this.checkLValSimple(node.id, BIND_OUTSIDE); }
		      node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
		      node.expression = false;
		      this.adaptDirectivePrologue(node.body.body);
		      this.labels = oldLabels;
		    }
		    this.exitScope();
		  };

		  pp$5.isSimpleParamList = function(params) {
		    for (var i = 0, list = params; i < list.length; i += 1)
		      {
		      var param = list[i];

		      if (param.type !== "Identifier") { return false
		    } }
		    return true
		  };

		  // Checks function params for various disallowed patterns such as using "eval"
		  // or "arguments" and duplicate parameters.

		  pp$5.checkParams = function(node, allowDuplicates) {
		    var nameHash = Object.create(null);
		    for (var i = 0, list = node.params; i < list.length; i += 1)
		      {
		      var param = list[i];

		      this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
		    }
		  };

		  // Parses a comma-separated list of expressions, and returns them as
		  // an array. `close` is the token type that ends the list, and
		  // `allowEmpty` can be turned on to allow subsequent commas with
		  // nothing in between them to be parsed as `null` (which is needed
		  // for array literals).

		  pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
		    var elts = [], first = true;
		    while (!this.eat(close)) {
		      if (!first) {
		        this.expect(types$1.comma);
		        if (allowTrailingComma && this.afterTrailingComma(close)) { break }
		      } else { first = false; }

		      var elt = (void 0);
		      if (allowEmpty && this.type === types$1.comma)
		        { elt = null; }
		      else if (this.type === types$1.ellipsis) {
		        elt = this.parseSpread(refDestructuringErrors);
		        if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0)
		          { refDestructuringErrors.trailingComma = this.start; }
		      } else {
		        elt = this.parseMaybeAssign(false, refDestructuringErrors);
		      }
		      elts.push(elt);
		    }
		    return elts
		  };

		  pp$5.checkUnreserved = function(ref) {
		    var start = ref.start;
		    var end = ref.end;
		    var name = ref.name;

		    if (this.inGenerator && name === "yield")
		      { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
		    if (this.inAsync && name === "await")
		      { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
		    if (this.currentThisScope().inClassFieldInit && name === "arguments")
		      { this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer"); }
		    if (this.inClassStaticBlock && (name === "arguments" || name === "await"))
		      { this.raise(start, ("Cannot use " + name + " in class static initialization block")); }
		    if (this.keywords.test(name))
		      { this.raise(start, ("Unexpected keyword '" + name + "'")); }
		    if (this.options.ecmaVersion < 6 &&
		      this.input.slice(start, end).indexOf("\\") !== -1) { return }
		    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
		    if (re.test(name)) {
		      if (!this.inAsync && name === "await")
		        { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
		      this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
		    }
		  };

		  // Parse the next token as an identifier. If `liberal` is true (used
		  // when parsing properties), it will also convert keywords into
		  // identifiers.

		  pp$5.parseIdent = function(liberal) {
		    var node = this.parseIdentNode();
		    this.next(!!liberal);
		    this.finishNode(node, "Identifier");
		    if (!liberal) {
		      this.checkUnreserved(node);
		      if (node.name === "await" && !this.awaitIdentPos)
		        { this.awaitIdentPos = node.start; }
		    }
		    return node
		  };

		  pp$5.parseIdentNode = function() {
		    var node = this.startNode();
		    if (this.type === types$1.name) {
		      node.name = this.value;
		    } else if (this.type.keyword) {
		      node.name = this.type.keyword;

		      // To fix https://github.com/acornjs/acorn/issues/575
		      // `class` and `function` keywords push new context into this.context.
		      // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
		      // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
		      if ((node.name === "class" || node.name === "function") &&
		        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
		        this.context.pop();
		      }
		      this.type = types$1.name;
		    } else {
		      this.unexpected();
		    }
		    return node
		  };

		  pp$5.parsePrivateIdent = function() {
		    var node = this.startNode();
		    if (this.type === types$1.privateId) {
		      node.name = this.value;
		    } else {
		      this.unexpected();
		    }
		    this.next();
		    this.finishNode(node, "PrivateIdentifier");

		    // For validating existence
		    if (this.options.checkPrivateFields) {
		      if (this.privateNameStack.length === 0) {
		        this.raise(node.start, ("Private field '#" + (node.name) + "' must be declared in an enclosing class"));
		      } else {
		        this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
		      }
		    }

		    return node
		  };

		  // Parses yield expression inside generator.

		  pp$5.parseYield = function(forInit) {
		    if (!this.yieldPos) { this.yieldPos = this.start; }

		    var node = this.startNode();
		    this.next();
		    if (this.type === types$1.semi || this.canInsertSemicolon() || (this.type !== types$1.star && !this.type.startsExpr)) {
		      node.delegate = false;
		      node.argument = null;
		    } else {
		      node.delegate = this.eat(types$1.star);
		      node.argument = this.parseMaybeAssign(forInit);
		    }
		    return this.finishNode(node, "YieldExpression")
		  };

		  pp$5.parseAwait = function(forInit) {
		    if (!this.awaitPos) { this.awaitPos = this.start; }

		    var node = this.startNode();
		    this.next();
		    node.argument = this.parseMaybeUnary(null, true, false, forInit);
		    return this.finishNode(node, "AwaitExpression")
		  };

		  var pp$4 = Parser.prototype;

		  // This function is used to raise exceptions on parse errors. It
		  // takes an offset integer (into the current `input`) to indicate
		  // the location of the error, attaches the position to the end
		  // of the error message, and then raises a `SyntaxError` with that
		  // message.

		  pp$4.raise = function(pos, message) {
		    var loc = getLineInfo(this.input, pos);
		    message += " (" + loc.line + ":" + loc.column + ")";
		    var err = new SyntaxError(message);
		    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
		    throw err
		  };

		  pp$4.raiseRecoverable = pp$4.raise;

		  pp$4.curPosition = function() {
		    if (this.options.locations) {
		      return new Position(this.curLine, this.pos - this.lineStart)
		    }
		  };

		  var pp$3 = Parser.prototype;

		  var Scope = function Scope(flags) {
		    this.flags = flags;
		    // A list of var-declared names in the current lexical scope
		    this.var = [];
		    // A list of lexically-declared names in the current lexical scope
		    this.lexical = [];
		    // A list of lexically-declared FunctionDeclaration names in the current lexical scope
		    this.functions = [];
		    // A switch to disallow the identifier reference 'arguments'
		    this.inClassFieldInit = false;
		  };

		  // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

		  pp$3.enterScope = function(flags) {
		    this.scopeStack.push(new Scope(flags));
		  };

		  pp$3.exitScope = function() {
		    this.scopeStack.pop();
		  };

		  // The spec says:
		  // > At the top level of a function, or script, function declarations are
		  // > treated like var declarations rather than like lexical declarations.
		  pp$3.treatFunctionsAsVarInScope = function(scope) {
		    return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
		  };

		  pp$3.declareName = function(name, bindingType, pos) {
		    var redeclared = false;
		    if (bindingType === BIND_LEXICAL) {
		      var scope = this.currentScope();
		      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
		      scope.lexical.push(name);
		      if (this.inModule && (scope.flags & SCOPE_TOP))
		        { delete this.undefinedExports[name]; }
		    } else if (bindingType === BIND_SIMPLE_CATCH) {
		      var scope$1 = this.currentScope();
		      scope$1.lexical.push(name);
		    } else if (bindingType === BIND_FUNCTION) {
		      var scope$2 = this.currentScope();
		      if (this.treatFunctionsAsVar)
		        { redeclared = scope$2.lexical.indexOf(name) > -1; }
		      else
		        { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
		      scope$2.functions.push(name);
		    } else {
		      for (var i = this.scopeStack.length - 1; i >= 0; --i) {
		        var scope$3 = this.scopeStack[i];
		        if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
		            !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
		          redeclared = true;
		          break
		        }
		        scope$3.var.push(name);
		        if (this.inModule && (scope$3.flags & SCOPE_TOP))
		          { delete this.undefinedExports[name]; }
		        if (scope$3.flags & SCOPE_VAR) { break }
		      }
		    }
		    if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
		  };

		  pp$3.checkLocalExport = function(id) {
		    // scope.functions must be empty as Module code is always strict.
		    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
		        this.scopeStack[0].var.indexOf(id.name) === -1) {
		      this.undefinedExports[id.name] = id;
		    }
		  };

		  pp$3.currentScope = function() {
		    return this.scopeStack[this.scopeStack.length - 1]
		  };

		  pp$3.currentVarScope = function() {
		    for (var i = this.scopeStack.length - 1;; i--) {
		      var scope = this.scopeStack[i];
		      if (scope.flags & SCOPE_VAR) { return scope }
		    }
		  };

		  // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
		  pp$3.currentThisScope = function() {
		    for (var i = this.scopeStack.length - 1;; i--) {
		      var scope = this.scopeStack[i];
		      if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
		    }
		  };

		  var Node = function Node(parser, pos, loc) {
		    this.type = "";
		    this.start = pos;
		    this.end = 0;
		    if (parser.options.locations)
		      { this.loc = new SourceLocation(parser, loc); }
		    if (parser.options.directSourceFile)
		      { this.sourceFile = parser.options.directSourceFile; }
		    if (parser.options.ranges)
		      { this.range = [pos, 0]; }
		  };

		  // Start an AST node, attaching a start offset.

		  var pp$2 = Parser.prototype;

		  pp$2.startNode = function() {
		    return new Node(this, this.start, this.startLoc)
		  };

		  pp$2.startNodeAt = function(pos, loc) {
		    return new Node(this, pos, loc)
		  };

		  // Finish an AST node, adding `type` and `end` properties.

		  function finishNodeAt(node, type, pos, loc) {
		    node.type = type;
		    node.end = pos;
		    if (this.options.locations)
		      { node.loc.end = loc; }
		    if (this.options.ranges)
		      { node.range[1] = pos; }
		    return node
		  }

		  pp$2.finishNode = function(node, type) {
		    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
		  };

		  // Finish node at given position

		  pp$2.finishNodeAt = function(node, type, pos, loc) {
		    return finishNodeAt.call(this, node, type, pos, loc)
		  };

		  pp$2.copyNode = function(node) {
		    var newNode = new Node(this, node.start, this.startLoc);
		    for (var prop in node) { newNode[prop] = node[prop]; }
		    return newNode
		  };

		  // This file contains Unicode properties extracted from the ECMAScript specification.
		  // The lists are extracted like so:
		  // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

		  // #table-binary-unicode-properties
		  var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
		  var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
		  var ecma11BinaryProperties = ecma10BinaryProperties;
		  var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
		  var ecma13BinaryProperties = ecma12BinaryProperties;
		  var ecma14BinaryProperties = ecma13BinaryProperties;

		  var unicodeBinaryProperties = {
		    9: ecma9BinaryProperties,
		    10: ecma10BinaryProperties,
		    11: ecma11BinaryProperties,
		    12: ecma12BinaryProperties,
		    13: ecma13BinaryProperties,
		    14: ecma14BinaryProperties
		  };

		  // #table-binary-unicode-properties-of-strings
		  var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";

		  var unicodeBinaryPropertiesOfStrings = {
		    9: "",
		    10: "",
		    11: "",
		    12: "",
		    13: "",
		    14: ecma14BinaryPropertiesOfStrings
		  };

		  // #table-unicode-general-category-values
		  var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

		  // #table-unicode-script-values
		  var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
		  var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
		  var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
		  var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
		  var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
		  var ecma14ScriptValues = ecma13ScriptValues + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";

		  var unicodeScriptValues = {
		    9: ecma9ScriptValues,
		    10: ecma10ScriptValues,
		    11: ecma11ScriptValues,
		    12: ecma12ScriptValues,
		    13: ecma13ScriptValues,
		    14: ecma14ScriptValues
		  };

		  var data = {};
		  function buildUnicodeData(ecmaVersion) {
		    var d = data[ecmaVersion] = {
		      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
		      binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
		      nonBinary: {
		        General_Category: wordsRegexp(unicodeGeneralCategoryValues),
		        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
		      }
		    };
		    d.nonBinary.Script_Extensions = d.nonBinary.Script;

		    d.nonBinary.gc = d.nonBinary.General_Category;
		    d.nonBinary.sc = d.nonBinary.Script;
		    d.nonBinary.scx = d.nonBinary.Script_Extensions;
		  }

		  for (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
		    var ecmaVersion = list[i];

		    buildUnicodeData(ecmaVersion);
		  }

		  var pp$1 = Parser.prototype;

		  var RegExpValidationState = function RegExpValidationState(parser) {
		    this.parser = parser;
		    this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
		    this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
		    this.source = "";
		    this.flags = "";
		    this.start = 0;
		    this.switchU = false;
		    this.switchV = false;
		    this.switchN = false;
		    this.pos = 0;
		    this.lastIntValue = 0;
		    this.lastStringValue = "";
		    this.lastAssertionIsQuantifiable = false;
		    this.numCapturingParens = 0;
		    this.maxBackReference = 0;
		    this.groupNames = [];
		    this.backReferenceNames = [];
		  };

		  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
		    var unicodeSets = flags.indexOf("v") !== -1;
		    var unicode = flags.indexOf("u") !== -1;
		    this.start = start | 0;
		    this.source = pattern + "";
		    this.flags = flags;
		    if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
		      this.switchU = true;
		      this.switchV = true;
		      this.switchN = true;
		    } else {
		      this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
		      this.switchV = false;
		      this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
		    }
		  };

		  RegExpValidationState.prototype.raise = function raise (message) {
		    this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
		  };

		  // If u flag is given, this returns the code point at the index (it combines a surrogate pair).
		  // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
		  RegExpValidationState.prototype.at = function at (i, forceU) {
		      if ( forceU === void 0 ) forceU = false;

		    var s = this.source;
		    var l = s.length;
		    if (i >= l) {
		      return -1
		    }
		    var c = s.charCodeAt(i);
		    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
		      return c
		    }
		    var next = s.charCodeAt(i + 1);
		    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
		  };

		  RegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {
		      if ( forceU === void 0 ) forceU = false;

		    var s = this.source;
		    var l = s.length;
		    if (i >= l) {
		      return l
		    }
		    var c = s.charCodeAt(i), next;
		    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
		        (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
		      return i + 1
		    }
		    return i + 2
		  };

		  RegExpValidationState.prototype.current = function current (forceU) {
		      if ( forceU === void 0 ) forceU = false;

		    return this.at(this.pos, forceU)
		  };

		  RegExpValidationState.prototype.lookahead = function lookahead (forceU) {
		      if ( forceU === void 0 ) forceU = false;

		    return this.at(this.nextIndex(this.pos, forceU), forceU)
		  };

		  RegExpValidationState.prototype.advance = function advance (forceU) {
		      if ( forceU === void 0 ) forceU = false;

		    this.pos = this.nextIndex(this.pos, forceU);
		  };

		  RegExpValidationState.prototype.eat = function eat (ch, forceU) {
		      if ( forceU === void 0 ) forceU = false;

		    if (this.current(forceU) === ch) {
		      this.advance(forceU);
		      return true
		    }
		    return false
		  };

		  RegExpValidationState.prototype.eatChars = function eatChars (chs, forceU) {
		      if ( forceU === void 0 ) forceU = false;

		    var pos = this.pos;
		    for (var i = 0, list = chs; i < list.length; i += 1) {
		      var ch = list[i];

		        var current = this.at(pos, forceU);
		      if (current === -1 || current !== ch) {
		        return false
		      }
		      pos = this.nextIndex(pos, forceU);
		    }
		    this.pos = pos;
		    return true
		  };

		  /**
		   * Validate the flags part of a given RegExpLiteral.
		   *
		   * @param {RegExpValidationState} state The state to validate RegExp.
		   * @returns {void}
		   */
		  pp$1.validateRegExpFlags = function(state) {
		    var validFlags = state.validFlags;
		    var flags = state.flags;

		    var u = false;
		    var v = false;

		    for (var i = 0; i < flags.length; i++) {
		      var flag = flags.charAt(i);
		      if (validFlags.indexOf(flag) === -1) {
		        this.raise(state.start, "Invalid regular expression flag");
		      }
		      if (flags.indexOf(flag, i + 1) > -1) {
		        this.raise(state.start, "Duplicate regular expression flag");
		      }
		      if (flag === "u") { u = true; }
		      if (flag === "v") { v = true; }
		    }
		    if (this.options.ecmaVersion >= 15 && u && v) {
		      this.raise(state.start, "Invalid regular expression flag");
		    }
		  };

		  /**
		   * Validate the pattern part of a given RegExpLiteral.
		   *
		   * @param {RegExpValidationState} state The state to validate RegExp.
		   * @returns {void}
		   */
		  pp$1.validateRegExpPattern = function(state) {
		    this.regexp_pattern(state);

		    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
		    // parsing contains a |GroupName|, reparse with the goal symbol
		    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
		    // exception if _P_ did not conform to the grammar, if any elements of _P_
		    // were not matched by the parse, or if any Early Error conditions exist.
		    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
		      state.switchN = true;
		      this.regexp_pattern(state);
		    }
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
		  pp$1.regexp_pattern = function(state) {
		    state.pos = 0;
		    state.lastIntValue = 0;
		    state.lastStringValue = "";
		    state.lastAssertionIsQuantifiable = false;
		    state.numCapturingParens = 0;
		    state.maxBackReference = 0;
		    state.groupNames.length = 0;
		    state.backReferenceNames.length = 0;

		    this.regexp_disjunction(state);

		    if (state.pos !== state.source.length) {
		      // Make the same messages as V8.
		      if (state.eat(0x29 /* ) */)) {
		        state.raise("Unmatched ')'");
		      }
		      if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {
		        state.raise("Lone quantifier brackets");
		      }
		    }
		    if (state.maxBackReference > state.numCapturingParens) {
		      state.raise("Invalid escape");
		    }
		    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
		      var name = list[i];

		      if (state.groupNames.indexOf(name) === -1) {
		        state.raise("Invalid named capture referenced");
		      }
		    }
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
		  pp$1.regexp_disjunction = function(state) {
		    this.regexp_alternative(state);
		    while (state.eat(0x7C /* | */)) {
		      this.regexp_alternative(state);
		    }

		    // Make the same message as V8.
		    if (this.regexp_eatQuantifier(state, true)) {
		      state.raise("Nothing to repeat");
		    }
		    if (state.eat(0x7B /* { */)) {
		      state.raise("Lone quantifier brackets");
		    }
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
		  pp$1.regexp_alternative = function(state) {
		    while (state.pos < state.source.length && this.regexp_eatTerm(state))
		      { }
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
		  pp$1.regexp_eatTerm = function(state) {
		    if (this.regexp_eatAssertion(state)) {
		      // Handle `QuantifiableAssertion Quantifier` alternative.
		      // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
		      // is a QuantifiableAssertion.
		      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
		        // Make the same message as V8.
		        if (state.switchU) {
		          state.raise("Invalid quantifier");
		        }
		      }
		      return true
		    }

		    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
		      this.regexp_eatQuantifier(state);
		      return true
		    }

		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
		  pp$1.regexp_eatAssertion = function(state) {
		    var start = state.pos;
		    state.lastAssertionIsQuantifiable = false;

		    // ^, $
		    if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
		      return true
		    }

		    // \b \B
		    if (state.eat(0x5C /* \ */)) {
		      if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
		        return true
		      }
		      state.pos = start;
		    }

		    // Lookahead / Lookbehind
		    if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
		      var lookbehind = false;
		      if (this.options.ecmaVersion >= 9) {
		        lookbehind = state.eat(0x3C /* < */);
		      }
		      if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
		        this.regexp_disjunction(state);
		        if (!state.eat(0x29 /* ) */)) {
		          state.raise("Unterminated group");
		        }
		        state.lastAssertionIsQuantifiable = !lookbehind;
		        return true
		      }
		    }

		    state.pos = start;
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
		  pp$1.regexp_eatQuantifier = function(state, noError) {
		    if ( noError === void 0 ) noError = false;

		    if (this.regexp_eatQuantifierPrefix(state, noError)) {
		      state.eat(0x3F /* ? */);
		      return true
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
		  pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
		    return (
		      state.eat(0x2A /* * */) ||
		      state.eat(0x2B /* + */) ||
		      state.eat(0x3F /* ? */) ||
		      this.regexp_eatBracedQuantifier(state, noError)
		    )
		  };
		  pp$1.regexp_eatBracedQuantifier = function(state, noError) {
		    var start = state.pos;
		    if (state.eat(0x7B /* { */)) {
		      var min = 0, max = -1;
		      if (this.regexp_eatDecimalDigits(state)) {
		        min = state.lastIntValue;
		        if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
		          max = state.lastIntValue;
		        }
		        if (state.eat(0x7D /* } */)) {
		          // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
		          if (max !== -1 && max < min && !noError) {
		            state.raise("numbers out of order in {} quantifier");
		          }
		          return true
		        }
		      }
		      if (state.switchU && !noError) {
		        state.raise("Incomplete quantifier");
		      }
		      state.pos = start;
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
		  pp$1.regexp_eatAtom = function(state) {
		    return (
		      this.regexp_eatPatternCharacters(state) ||
		      state.eat(0x2E /* . */) ||
		      this.regexp_eatReverseSolidusAtomEscape(state) ||
		      this.regexp_eatCharacterClass(state) ||
		      this.regexp_eatUncapturingGroup(state) ||
		      this.regexp_eatCapturingGroup(state)
		    )
		  };
		  pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
		    var start = state.pos;
		    if (state.eat(0x5C /* \ */)) {
		      if (this.regexp_eatAtomEscape(state)) {
		        return true
		      }
		      state.pos = start;
		    }
		    return false
		  };
		  pp$1.regexp_eatUncapturingGroup = function(state) {
		    var start = state.pos;
		    if (state.eat(0x28 /* ( */)) {
		      if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
		        this.regexp_disjunction(state);
		        if (state.eat(0x29 /* ) */)) {
		          return true
		        }
		        state.raise("Unterminated group");
		      }
		      state.pos = start;
		    }
		    return false
		  };
		  pp$1.regexp_eatCapturingGroup = function(state) {
		    if (state.eat(0x28 /* ( */)) {
		      if (this.options.ecmaVersion >= 9) {
		        this.regexp_groupSpecifier(state);
		      } else if (state.current() === 0x3F /* ? */) {
		        state.raise("Invalid group");
		      }
		      this.regexp_disjunction(state);
		      if (state.eat(0x29 /* ) */)) {
		        state.numCapturingParens += 1;
		        return true
		      }
		      state.raise("Unterminated group");
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
		  pp$1.regexp_eatExtendedAtom = function(state) {
		    return (
		      state.eat(0x2E /* . */) ||
		      this.regexp_eatReverseSolidusAtomEscape(state) ||
		      this.regexp_eatCharacterClass(state) ||
		      this.regexp_eatUncapturingGroup(state) ||
		      this.regexp_eatCapturingGroup(state) ||
		      this.regexp_eatInvalidBracedQuantifier(state) ||
		      this.regexp_eatExtendedPatternCharacter(state)
		    )
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
		  pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
		    if (this.regexp_eatBracedQuantifier(state, true)) {
		      state.raise("Nothing to repeat");
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
		  pp$1.regexp_eatSyntaxCharacter = function(state) {
		    var ch = state.current();
		    if (isSyntaxCharacter(ch)) {
		      state.lastIntValue = ch;
		      state.advance();
		      return true
		    }
		    return false
		  };
		  function isSyntaxCharacter(ch) {
		    return (
		      ch === 0x24 /* $ */ ||
		      ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
		      ch === 0x2E /* . */ ||
		      ch === 0x3F /* ? */ ||
		      ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
		      ch >= 0x7B /* { */ && ch <= 0x7D /* } */
		    )
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
		  // But eat eager.
		  pp$1.regexp_eatPatternCharacters = function(state) {
		    var start = state.pos;
		    var ch = 0;
		    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
		      state.advance();
		    }
		    return state.pos !== start
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
		  pp$1.regexp_eatExtendedPatternCharacter = function(state) {
		    var ch = state.current();
		    if (
		      ch !== -1 &&
		      ch !== 0x24 /* $ */ &&
		      !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
		      ch !== 0x2E /* . */ &&
		      ch !== 0x3F /* ? */ &&
		      ch !== 0x5B /* [ */ &&
		      ch !== 0x5E /* ^ */ &&
		      ch !== 0x7C /* | */
		    ) {
		      state.advance();
		      return true
		    }
		    return false
		  };

		  // GroupSpecifier ::
		  //   [empty]
		  //   `?` GroupName
		  pp$1.regexp_groupSpecifier = function(state) {
		    if (state.eat(0x3F /* ? */)) {
		      if (this.regexp_eatGroupName(state)) {
		        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
		          state.raise("Duplicate capture group name");
		        }
		        state.groupNames.push(state.lastStringValue);
		        return
		      }
		      state.raise("Invalid group");
		    }
		  };

		  // GroupName ::
		  //   `<` RegExpIdentifierName `>`
		  // Note: this updates `state.lastStringValue` property with the eaten name.
		  pp$1.regexp_eatGroupName = function(state) {
		    state.lastStringValue = "";
		    if (state.eat(0x3C /* < */)) {
		      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
		        return true
		      }
		      state.raise("Invalid capture group name");
		    }
		    return false
		  };

		  // RegExpIdentifierName ::
		  //   RegExpIdentifierStart
		  //   RegExpIdentifierName RegExpIdentifierPart
		  // Note: this updates `state.lastStringValue` property with the eaten name.
		  pp$1.regexp_eatRegExpIdentifierName = function(state) {
		    state.lastStringValue = "";
		    if (this.regexp_eatRegExpIdentifierStart(state)) {
		      state.lastStringValue += codePointToString(state.lastIntValue);
		      while (this.regexp_eatRegExpIdentifierPart(state)) {
		        state.lastStringValue += codePointToString(state.lastIntValue);
		      }
		      return true
		    }
		    return false
		  };

		  // RegExpIdentifierStart ::
		  //   UnicodeIDStart
		  //   `$`
		  //   `_`
		  //   `\` RegExpUnicodeEscapeSequence[+U]
		  pp$1.regexp_eatRegExpIdentifierStart = function(state) {
		    var start = state.pos;
		    var forceU = this.options.ecmaVersion >= 11;
		    var ch = state.current(forceU);
		    state.advance(forceU);

		    if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
		      ch = state.lastIntValue;
		    }
		    if (isRegExpIdentifierStart(ch)) {
		      state.lastIntValue = ch;
		      return true
		    }

		    state.pos = start;
		    return false
		  };
		  function isRegExpIdentifierStart(ch) {
		    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
		  }

		  // RegExpIdentifierPart ::
		  //   UnicodeIDContinue
		  //   `$`
		  //   `_`
		  //   `\` RegExpUnicodeEscapeSequence[+U]
		  //   <ZWNJ>
		  //   <ZWJ>
		  pp$1.regexp_eatRegExpIdentifierPart = function(state) {
		    var start = state.pos;
		    var forceU = this.options.ecmaVersion >= 11;
		    var ch = state.current(forceU);
		    state.advance(forceU);

		    if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
		      ch = state.lastIntValue;
		    }
		    if (isRegExpIdentifierPart(ch)) {
		      state.lastIntValue = ch;
		      return true
		    }

		    state.pos = start;
		    return false
		  };
		  function isRegExpIdentifierPart(ch) {
		    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
		  pp$1.regexp_eatAtomEscape = function(state) {
		    if (
		      this.regexp_eatBackReference(state) ||
		      this.regexp_eatCharacterClassEscape(state) ||
		      this.regexp_eatCharacterEscape(state) ||
		      (state.switchN && this.regexp_eatKGroupName(state))
		    ) {
		      return true
		    }
		    if (state.switchU) {
		      // Make the same message as V8.
		      if (state.current() === 0x63 /* c */) {
		        state.raise("Invalid unicode escape");
		      }
		      state.raise("Invalid escape");
		    }
		    return false
		  };
		  pp$1.regexp_eatBackReference = function(state) {
		    var start = state.pos;
		    if (this.regexp_eatDecimalEscape(state)) {
		      var n = state.lastIntValue;
		      if (state.switchU) {
		        // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
		        if (n > state.maxBackReference) {
		          state.maxBackReference = n;
		        }
		        return true
		      }
		      if (n <= state.numCapturingParens) {
		        return true
		      }
		      state.pos = start;
		    }
		    return false
		  };
		  pp$1.regexp_eatKGroupName = function(state) {
		    if (state.eat(0x6B /* k */)) {
		      if (this.regexp_eatGroupName(state)) {
		        state.backReferenceNames.push(state.lastStringValue);
		        return true
		      }
		      state.raise("Invalid named reference");
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
		  pp$1.regexp_eatCharacterEscape = function(state) {
		    return (
		      this.regexp_eatControlEscape(state) ||
		      this.regexp_eatCControlLetter(state) ||
		      this.regexp_eatZero(state) ||
		      this.regexp_eatHexEscapeSequence(state) ||
		      this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||
		      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
		      this.regexp_eatIdentityEscape(state)
		    )
		  };
		  pp$1.regexp_eatCControlLetter = function(state) {
		    var start = state.pos;
		    if (state.eat(0x63 /* c */)) {
		      if (this.regexp_eatControlLetter(state)) {
		        return true
		      }
		      state.pos = start;
		    }
		    return false
		  };
		  pp$1.regexp_eatZero = function(state) {
		    if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
		      state.lastIntValue = 0;
		      state.advance();
		      return true
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
		  pp$1.regexp_eatControlEscape = function(state) {
		    var ch = state.current();
		    if (ch === 0x74 /* t */) {
		      state.lastIntValue = 0x09; /* \t */
		      state.advance();
		      return true
		    }
		    if (ch === 0x6E /* n */) {
		      state.lastIntValue = 0x0A; /* \n */
		      state.advance();
		      return true
		    }
		    if (ch === 0x76 /* v */) {
		      state.lastIntValue = 0x0B; /* \v */
		      state.advance();
		      return true
		    }
		    if (ch === 0x66 /* f */) {
		      state.lastIntValue = 0x0C; /* \f */
		      state.advance();
		      return true
		    }
		    if (ch === 0x72 /* r */) {
		      state.lastIntValue = 0x0D; /* \r */
		      state.advance();
		      return true
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
		  pp$1.regexp_eatControlLetter = function(state) {
		    var ch = state.current();
		    if (isControlLetter(ch)) {
		      state.lastIntValue = ch % 0x20;
		      state.advance();
		      return true
		    }
		    return false
		  };
		  function isControlLetter(ch) {
		    return (
		      (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
		      (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
		    )
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
		  pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
		    if ( forceU === void 0 ) forceU = false;

		    var start = state.pos;
		    var switchU = forceU || state.switchU;

		    if (state.eat(0x75 /* u */)) {
		      if (this.regexp_eatFixedHexDigits(state, 4)) {
		        var lead = state.lastIntValue;
		        if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
		          var leadSurrogateEnd = state.pos;
		          if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
		            var trail = state.lastIntValue;
		            if (trail >= 0xDC00 && trail <= 0xDFFF) {
		              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
		              return true
		            }
		          }
		          state.pos = leadSurrogateEnd;
		          state.lastIntValue = lead;
		        }
		        return true
		      }
		      if (
		        switchU &&
		        state.eat(0x7B /* { */) &&
		        this.regexp_eatHexDigits(state) &&
		        state.eat(0x7D /* } */) &&
		        isValidUnicode(state.lastIntValue)
		      ) {
		        return true
		      }
		      if (switchU) {
		        state.raise("Invalid unicode escape");
		      }
		      state.pos = start;
		    }

		    return false
		  };
		  function isValidUnicode(ch) {
		    return ch >= 0 && ch <= 0x10FFFF
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
		  pp$1.regexp_eatIdentityEscape = function(state) {
		    if (state.switchU) {
		      if (this.regexp_eatSyntaxCharacter(state)) {
		        return true
		      }
		      if (state.eat(0x2F /* / */)) {
		        state.lastIntValue = 0x2F; /* / */
		        return true
		      }
		      return false
		    }

		    var ch = state.current();
		    if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
		      state.lastIntValue = ch;
		      state.advance();
		      return true
		    }

		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
		  pp$1.regexp_eatDecimalEscape = function(state) {
		    state.lastIntValue = 0;
		    var ch = state.current();
		    if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
		      do {
		        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
		        state.advance();
		      } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
		      return true
		    }
		    return false
		  };

		  // Return values used by character set parsing methods, needed to
		  // forbid negation of sets that can match strings.
		  var CharSetNone = 0; // Nothing parsed
		  var CharSetOk = 1; // Construct parsed, cannot contain strings
		  var CharSetString = 2; // Construct parsed, can contain strings

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
		  pp$1.regexp_eatCharacterClassEscape = function(state) {
		    var ch = state.current();

		    if (isCharacterClassEscape(ch)) {
		      state.lastIntValue = -1;
		      state.advance();
		      return CharSetOk
		    }

		    var negate = false;
		    if (
		      state.switchU &&
		      this.options.ecmaVersion >= 9 &&
		      ((negate = ch === 0x50 /* P */) || ch === 0x70 /* p */)
		    ) {
		      state.lastIntValue = -1;
		      state.advance();
		      var result;
		      if (
		        state.eat(0x7B /* { */) &&
		        (result = this.regexp_eatUnicodePropertyValueExpression(state)) &&
		        state.eat(0x7D /* } */)
		      ) {
		        if (negate && result === CharSetString) { state.raise("Invalid property name"); }
		        return result
		      }
		      state.raise("Invalid property name");
		    }

		    return CharSetNone
		  };

		  function isCharacterClassEscape(ch) {
		    return (
		      ch === 0x64 /* d */ ||
		      ch === 0x44 /* D */ ||
		      ch === 0x73 /* s */ ||
		      ch === 0x53 /* S */ ||
		      ch === 0x77 /* w */ ||
		      ch === 0x57 /* W */
		    )
		  }

		  // UnicodePropertyValueExpression ::
		  //   UnicodePropertyName `=` UnicodePropertyValue
		  //   LoneUnicodePropertyNameOrValue
		  pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
		    var start = state.pos;

		    // UnicodePropertyName `=` UnicodePropertyValue
		    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
		      var name = state.lastStringValue;
		      if (this.regexp_eatUnicodePropertyValue(state)) {
		        var value = state.lastStringValue;
		        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
		        return CharSetOk
		      }
		    }
		    state.pos = start;

		    // LoneUnicodePropertyNameOrValue
		    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
		      var nameOrValue = state.lastStringValue;
		      return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue)
		    }
		    return CharSetNone
		  };

		  pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
		    if (!hasOwn(state.unicodeProperties.nonBinary, name))
		      { state.raise("Invalid property name"); }
		    if (!state.unicodeProperties.nonBinary[name].test(value))
		      { state.raise("Invalid property value"); }
		  };

		  pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
		    if (state.unicodeProperties.binary.test(nameOrValue)) { return CharSetOk }
		    if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) { return CharSetString }
		    state.raise("Invalid property name");
		  };

		  // UnicodePropertyName ::
		  //   UnicodePropertyNameCharacters
		  pp$1.regexp_eatUnicodePropertyName = function(state) {
		    var ch = 0;
		    state.lastStringValue = "";
		    while (isUnicodePropertyNameCharacter(ch = state.current())) {
		      state.lastStringValue += codePointToString(ch);
		      state.advance();
		    }
		    return state.lastStringValue !== ""
		  };

		  function isUnicodePropertyNameCharacter(ch) {
		    return isControlLetter(ch) || ch === 0x5F /* _ */
		  }

		  // UnicodePropertyValue ::
		  //   UnicodePropertyValueCharacters
		  pp$1.regexp_eatUnicodePropertyValue = function(state) {
		    var ch = 0;
		    state.lastStringValue = "";
		    while (isUnicodePropertyValueCharacter(ch = state.current())) {
		      state.lastStringValue += codePointToString(ch);
		      state.advance();
		    }
		    return state.lastStringValue !== ""
		  };
		  function isUnicodePropertyValueCharacter(ch) {
		    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
		  }

		  // LoneUnicodePropertyNameOrValue ::
		  //   UnicodePropertyValueCharacters
		  pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
		    return this.regexp_eatUnicodePropertyValue(state)
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
		  pp$1.regexp_eatCharacterClass = function(state) {
		    if (state.eat(0x5B /* [ */)) {
		      var negate = state.eat(0x5E /* ^ */);
		      var result = this.regexp_classContents(state);
		      if (!state.eat(0x5D /* ] */))
		        { state.raise("Unterminated character class"); }
		      if (negate && result === CharSetString)
		        { state.raise("Negated character class may contain strings"); }
		      return true
		    }
		    return false
		  };

		  // https://tc39.es/ecma262/#prod-ClassContents
		  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
		  pp$1.regexp_classContents = function(state) {
		    if (state.current() === 0x5D /* ] */) { return CharSetOk }
		    if (state.switchV) { return this.regexp_classSetExpression(state) }
		    this.regexp_nonEmptyClassRanges(state);
		    return CharSetOk
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
		  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
		  pp$1.regexp_nonEmptyClassRanges = function(state) {
		    while (this.regexp_eatClassAtom(state)) {
		      var left = state.lastIntValue;
		      if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
		        var right = state.lastIntValue;
		        if (state.switchU && (left === -1 || right === -1)) {
		          state.raise("Invalid character class");
		        }
		        if (left !== -1 && right !== -1 && left > right) {
		          state.raise("Range out of order in character class");
		        }
		      }
		    }
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
		  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
		  pp$1.regexp_eatClassAtom = function(state) {
		    var start = state.pos;

		    if (state.eat(0x5C /* \ */)) {
		      if (this.regexp_eatClassEscape(state)) {
		        return true
		      }
		      if (state.switchU) {
		        // Make the same message as V8.
		        var ch$1 = state.current();
		        if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
		          state.raise("Invalid class escape");
		        }
		        state.raise("Invalid escape");
		      }
		      state.pos = start;
		    }

		    var ch = state.current();
		    if (ch !== 0x5D /* ] */) {
		      state.lastIntValue = ch;
		      state.advance();
		      return true
		    }

		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
		  pp$1.regexp_eatClassEscape = function(state) {
		    var start = state.pos;

		    if (state.eat(0x62 /* b */)) {
		      state.lastIntValue = 0x08; /* <BS> */
		      return true
		    }

		    if (state.switchU && state.eat(0x2D /* - */)) {
		      state.lastIntValue = 0x2D; /* - */
		      return true
		    }

		    if (!state.switchU && state.eat(0x63 /* c */)) {
		      if (this.regexp_eatClassControlLetter(state)) {
		        return true
		      }
		      state.pos = start;
		    }

		    return (
		      this.regexp_eatCharacterClassEscape(state) ||
		      this.regexp_eatCharacterEscape(state)
		    )
		  };

		  // https://tc39.es/ecma262/#prod-ClassSetExpression
		  // https://tc39.es/ecma262/#prod-ClassUnion
		  // https://tc39.es/ecma262/#prod-ClassIntersection
		  // https://tc39.es/ecma262/#prod-ClassSubtraction
		  pp$1.regexp_classSetExpression = function(state) {
		    var result = CharSetOk, subResult;
		    if (this.regexp_eatClassSetRange(state)) ; else if (subResult = this.regexp_eatClassSetOperand(state)) {
		      if (subResult === CharSetString) { result = CharSetString; }
		      // https://tc39.es/ecma262/#prod-ClassIntersection
		      var start = state.pos;
		      while (state.eatChars([0x26, 0x26] /* && */)) {
		        if (
		          state.current() !== 0x26 /* & */ &&
		          (subResult = this.regexp_eatClassSetOperand(state))
		        ) {
		          if (subResult !== CharSetString) { result = CharSetOk; }
		          continue
		        }
		        state.raise("Invalid character in character class");
		      }
		      if (start !== state.pos) { return result }
		      // https://tc39.es/ecma262/#prod-ClassSubtraction
		      while (state.eatChars([0x2D, 0x2D] /* -- */)) {
		        if (this.regexp_eatClassSetOperand(state)) { continue }
		        state.raise("Invalid character in character class");
		      }
		      if (start !== state.pos) { return result }
		    } else {
		      state.raise("Invalid character in character class");
		    }
		    // https://tc39.es/ecma262/#prod-ClassUnion
		    for (;;) {
		      if (this.regexp_eatClassSetRange(state)) { continue }
		      subResult = this.regexp_eatClassSetOperand(state);
		      if (!subResult) { return result }
		      if (subResult === CharSetString) { result = CharSetString; }
		    }
		  };

		  // https://tc39.es/ecma262/#prod-ClassSetRange
		  pp$1.regexp_eatClassSetRange = function(state) {
		    var start = state.pos;
		    if (this.regexp_eatClassSetCharacter(state)) {
		      var left = state.lastIntValue;
		      if (state.eat(0x2D /* - */) && this.regexp_eatClassSetCharacter(state)) {
		        var right = state.lastIntValue;
		        if (left !== -1 && right !== -1 && left > right) {
		          state.raise("Range out of order in character class");
		        }
		        return true
		      }
		      state.pos = start;
		    }
		    return false
		  };

		  // https://tc39.es/ecma262/#prod-ClassSetOperand
		  pp$1.regexp_eatClassSetOperand = function(state) {
		    if (this.regexp_eatClassSetCharacter(state)) { return CharSetOk }
		    return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state)
		  };

		  // https://tc39.es/ecma262/#prod-NestedClass
		  pp$1.regexp_eatNestedClass = function(state) {
		    var start = state.pos;
		    if (state.eat(0x5B /* [ */)) {
		      var negate = state.eat(0x5E /* ^ */);
		      var result = this.regexp_classContents(state);
		      if (state.eat(0x5D /* ] */)) {
		        if (negate && result === CharSetString) {
		          state.raise("Negated character class may contain strings");
		        }
		        return result
		      }
		      state.pos = start;
		    }
		    if (state.eat(0x5C /* \ */)) {
		      var result$1 = this.regexp_eatCharacterClassEscape(state);
		      if (result$1) {
		        return result$1
		      }
		      state.pos = start;
		    }
		    return null
		  };

		  // https://tc39.es/ecma262/#prod-ClassStringDisjunction
		  pp$1.regexp_eatClassStringDisjunction = function(state) {
		    var start = state.pos;
		    if (state.eatChars([0x5C, 0x71] /* \q */)) {
		      if (state.eat(0x7B /* { */)) {
		        var result = this.regexp_classStringDisjunctionContents(state);
		        if (state.eat(0x7D /* } */)) {
		          return result
		        }
		      } else {
		        // Make the same message as V8.
		        state.raise("Invalid escape");
		      }
		      state.pos = start;
		    }
		    return null
		  };

		  // https://tc39.es/ecma262/#prod-ClassStringDisjunctionContents
		  pp$1.regexp_classStringDisjunctionContents = function(state) {
		    var result = this.regexp_classString(state);
		    while (state.eat(0x7C /* | */)) {
		      if (this.regexp_classString(state) === CharSetString) { result = CharSetString; }
		    }
		    return result
		  };

		  // https://tc39.es/ecma262/#prod-ClassString
		  // https://tc39.es/ecma262/#prod-NonEmptyClassString
		  pp$1.regexp_classString = function(state) {
		    var count = 0;
		    while (this.regexp_eatClassSetCharacter(state)) { count++; }
		    return count === 1 ? CharSetOk : CharSetString
		  };

		  // https://tc39.es/ecma262/#prod-ClassSetCharacter
		  pp$1.regexp_eatClassSetCharacter = function(state) {
		    var start = state.pos;
		    if (state.eat(0x5C /* \ */)) {
		      if (
		        this.regexp_eatCharacterEscape(state) ||
		        this.regexp_eatClassSetReservedPunctuator(state)
		      ) {
		        return true
		      }
		      if (state.eat(0x62 /* b */)) {
		        state.lastIntValue = 0x08; /* <BS> */
		        return true
		      }
		      state.pos = start;
		      return false
		    }
		    var ch = state.current();
		    if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) { return false }
		    if (isClassSetSyntaxCharacter(ch)) { return false }
		    state.advance();
		    state.lastIntValue = ch;
		    return true
		  };

		  // https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator
		  function isClassSetReservedDoublePunctuatorCharacter(ch) {
		    return (
		      ch === 0x21 /* ! */ ||
		      ch >= 0x23 /* # */ && ch <= 0x26 /* & */ ||
		      ch >= 0x2A /* * */ && ch <= 0x2C /* , */ ||
		      ch === 0x2E /* . */ ||
		      ch >= 0x3A /* : */ && ch <= 0x40 /* @ */ ||
		      ch === 0x5E /* ^ */ ||
		      ch === 0x60 /* ` */ ||
		      ch === 0x7E /* ~ */
		    )
		  }

		  // https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter
		  function isClassSetSyntaxCharacter(ch) {
		    return (
		      ch === 0x28 /* ( */ ||
		      ch === 0x29 /* ) */ ||
		      ch === 0x2D /* - */ ||
		      ch === 0x2F /* / */ ||
		      ch >= 0x5B /* [ */ && ch <= 0x5D /* ] */ ||
		      ch >= 0x7B /* { */ && ch <= 0x7D /* } */
		    )
		  }

		  // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator
		  pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
		    var ch = state.current();
		    if (isClassSetReservedPunctuator(ch)) {
		      state.lastIntValue = ch;
		      state.advance();
		      return true
		    }
		    return false
		  };

		  // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator
		  function isClassSetReservedPunctuator(ch) {
		    return (
		      ch === 0x21 /* ! */ ||
		      ch === 0x23 /* # */ ||
		      ch === 0x25 /* % */ ||
		      ch === 0x26 /* & */ ||
		      ch === 0x2C /* , */ ||
		      ch === 0x2D /* - */ ||
		      ch >= 0x3A /* : */ && ch <= 0x3E /* > */ ||
		      ch === 0x40 /* @ */ ||
		      ch === 0x60 /* ` */ ||
		      ch === 0x7E /* ~ */
		    )
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
		  pp$1.regexp_eatClassControlLetter = function(state) {
		    var ch = state.current();
		    if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
		      state.lastIntValue = ch % 0x20;
		      state.advance();
		      return true
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
		  pp$1.regexp_eatHexEscapeSequence = function(state) {
		    var start = state.pos;
		    if (state.eat(0x78 /* x */)) {
		      if (this.regexp_eatFixedHexDigits(state, 2)) {
		        return true
		      }
		      if (state.switchU) {
		        state.raise("Invalid escape");
		      }
		      state.pos = start;
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
		  pp$1.regexp_eatDecimalDigits = function(state) {
		    var start = state.pos;
		    var ch = 0;
		    state.lastIntValue = 0;
		    while (isDecimalDigit(ch = state.current())) {
		      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
		      state.advance();
		    }
		    return state.pos !== start
		  };
		  function isDecimalDigit(ch) {
		    return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
		  pp$1.regexp_eatHexDigits = function(state) {
		    var start = state.pos;
		    var ch = 0;
		    state.lastIntValue = 0;
		    while (isHexDigit(ch = state.current())) {
		      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
		      state.advance();
		    }
		    return state.pos !== start
		  };
		  function isHexDigit(ch) {
		    return (
		      (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
		      (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
		      (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
		    )
		  }
		  function hexToInt(ch) {
		    if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
		      return 10 + (ch - 0x41 /* A */)
		    }
		    if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
		      return 10 + (ch - 0x61 /* a */)
		    }
		    return ch - 0x30 /* 0 */
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
		  // Allows only 0-377(octal) i.e. 0-255(decimal).
		  pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
		    if (this.regexp_eatOctalDigit(state)) {
		      var n1 = state.lastIntValue;
		      if (this.regexp_eatOctalDigit(state)) {
		        var n2 = state.lastIntValue;
		        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
		          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
		        } else {
		          state.lastIntValue = n1 * 8 + n2;
		        }
		      } else {
		        state.lastIntValue = n1;
		      }
		      return true
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
		  pp$1.regexp_eatOctalDigit = function(state) {
		    var ch = state.current();
		    if (isOctalDigit(ch)) {
		      state.lastIntValue = ch - 0x30; /* 0 */
		      state.advance();
		      return true
		    }
		    state.lastIntValue = 0;
		    return false
		  };
		  function isOctalDigit(ch) {
		    return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
		  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
		  // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
		  pp$1.regexp_eatFixedHexDigits = function(state, length) {
		    var start = state.pos;
		    state.lastIntValue = 0;
		    for (var i = 0; i < length; ++i) {
		      var ch = state.current();
		      if (!isHexDigit(ch)) {
		        state.pos = start;
		        return false
		      }
		      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
		      state.advance();
		    }
		    return true
		  };

		  // Object type used to represent tokens. Note that normally, tokens
		  // simply exist as properties on the parser object. This is only
		  // used for the onToken callback and the external tokenizer.

		  var Token = function Token(p) {
		    this.type = p.type;
		    this.value = p.value;
		    this.start = p.start;
		    this.end = p.end;
		    if (p.options.locations)
		      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
		    if (p.options.ranges)
		      { this.range = [p.start, p.end]; }
		  };

		  // ## Tokenizer

		  var pp = Parser.prototype;

		  // Move to the next token

		  pp.next = function(ignoreEscapeSequenceInKeyword) {
		    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
		      { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
		    if (this.options.onToken)
		      { this.options.onToken(new Token(this)); }

		    this.lastTokEnd = this.end;
		    this.lastTokStart = this.start;
		    this.lastTokEndLoc = this.endLoc;
		    this.lastTokStartLoc = this.startLoc;
		    this.nextToken();
		  };

		  pp.getToken = function() {
		    this.next();
		    return new Token(this)
		  };

		  // If we're in an ES6 environment, make parsers iterable
		  if (typeof Symbol !== "undefined")
		    { pp[Symbol.iterator] = function() {
		      var this$1$1 = this;

		      return {
		        next: function () {
		          var token = this$1$1.getToken();
		          return {
		            done: token.type === types$1.eof,
		            value: token
		          }
		        }
		      }
		    }; }

		  // Toggle strict mode. Re-reads the next number or string to please
		  // pedantic tests (`"use strict"; 010;` should fail).

		  // Read a single token, updating the parser object's token-related
		  // properties.

		  pp.nextToken = function() {
		    var curContext = this.curContext();
		    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

		    this.start = this.pos;
		    if (this.options.locations) { this.startLoc = this.curPosition(); }
		    if (this.pos >= this.input.length) { return this.finishToken(types$1.eof) }

		    if (curContext.override) { return curContext.override(this) }
		    else { this.readToken(this.fullCharCodeAtPos()); }
		  };

		  pp.readToken = function(code) {
		    // Identifier or keyword. '\uXXXX' sequences are allowed in
		    // identifiers, so '\' also dispatches to that.
		    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
		      { return this.readWord() }

		    return this.getTokenFromCode(code)
		  };

		  pp.fullCharCodeAtPos = function() {
		    var code = this.input.charCodeAt(this.pos);
		    if (code <= 0xd7ff || code >= 0xdc00) { return code }
		    var next = this.input.charCodeAt(this.pos + 1);
		    return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00
		  };

		  pp.skipBlockComment = function() {
		    var startLoc = this.options.onComment && this.curPosition();
		    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
		    if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
		    this.pos = end + 2;
		    if (this.options.locations) {
		      for (var nextBreak = (void 0), pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {
		        ++this.curLine;
		        pos = this.lineStart = nextBreak;
		      }
		    }
		    if (this.options.onComment)
		      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
		                             startLoc, this.curPosition()); }
		  };

		  pp.skipLineComment = function(startSkip) {
		    var start = this.pos;
		    var startLoc = this.options.onComment && this.curPosition();
		    var ch = this.input.charCodeAt(this.pos += startSkip);
		    while (this.pos < this.input.length && !isNewLine(ch)) {
		      ch = this.input.charCodeAt(++this.pos);
		    }
		    if (this.options.onComment)
		      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
		                             startLoc, this.curPosition()); }
		  };

		  // Called at the start of the parse and after every token. Skips
		  // whitespace and comments, and.

		  pp.skipSpace = function() {
		    loop: while (this.pos < this.input.length) {
		      var ch = this.input.charCodeAt(this.pos);
		      switch (ch) {
		      case 32: case 160: // ' '
		        ++this.pos;
		        break
		      case 13:
		        if (this.input.charCodeAt(this.pos + 1) === 10) {
		          ++this.pos;
		        }
		      case 10: case 8232: case 8233:
		        ++this.pos;
		        if (this.options.locations) {
		          ++this.curLine;
		          this.lineStart = this.pos;
		        }
		        break
		      case 47: // '/'
		        switch (this.input.charCodeAt(this.pos + 1)) {
		        case 42: // '*'
		          this.skipBlockComment();
		          break
		        case 47:
		          this.skipLineComment(2);
		          break
		        default:
		          break loop
		        }
		        break
		      default:
		        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
		          ++this.pos;
		        } else {
		          break loop
		        }
		      }
		    }
		  };

		  // Called at the end of every token. Sets `end`, `val`, and
		  // maintains `context` and `exprAllowed`, and skips the space after
		  // the token, so that the next one's `start` will point at the
		  // right position.

		  pp.finishToken = function(type, val) {
		    this.end = this.pos;
		    if (this.options.locations) { this.endLoc = this.curPosition(); }
		    var prevType = this.type;
		    this.type = type;
		    this.value = val;

		    this.updateContext(prevType);
		  };

		  // ### Token reading

		  // This is the function that is called to fetch the next token. It
		  // is somewhat obscure, because it works in character codes rather
		  // than characters, and because operator parsing has been inlined
		  // into it.
		  //
		  // All in the name of speed.
		  //
		  pp.readToken_dot = function() {
		    var next = this.input.charCodeAt(this.pos + 1);
		    if (next >= 48 && next <= 57) { return this.readNumber(true) }
		    var next2 = this.input.charCodeAt(this.pos + 2);
		    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
		      this.pos += 3;
		      return this.finishToken(types$1.ellipsis)
		    } else {
		      ++this.pos;
		      return this.finishToken(types$1.dot)
		    }
		  };

		  pp.readToken_slash = function() { // '/'
		    var next = this.input.charCodeAt(this.pos + 1);
		    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
		    if (next === 61) { return this.finishOp(types$1.assign, 2) }
		    return this.finishOp(types$1.slash, 1)
		  };

		  pp.readToken_mult_modulo_exp = function(code) { // '%*'
		    var next = this.input.charCodeAt(this.pos + 1);
		    var size = 1;
		    var tokentype = code === 42 ? types$1.star : types$1.modulo;

		    // exponentiation operator ** and **=
		    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
		      ++size;
		      tokentype = types$1.starstar;
		      next = this.input.charCodeAt(this.pos + 2);
		    }

		    if (next === 61) { return this.finishOp(types$1.assign, size + 1) }
		    return this.finishOp(tokentype, size)
		  };

		  pp.readToken_pipe_amp = function(code) { // '|&'
		    var next = this.input.charCodeAt(this.pos + 1);
		    if (next === code) {
		      if (this.options.ecmaVersion >= 12) {
		        var next2 = this.input.charCodeAt(this.pos + 2);
		        if (next2 === 61) { return this.finishOp(types$1.assign, 3) }
		      }
		      return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2)
		    }
		    if (next === 61) { return this.finishOp(types$1.assign, 2) }
		    return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1)
		  };

		  pp.readToken_caret = function() { // '^'
		    var next = this.input.charCodeAt(this.pos + 1);
		    if (next === 61) { return this.finishOp(types$1.assign, 2) }
		    return this.finishOp(types$1.bitwiseXOR, 1)
		  };

		  pp.readToken_plus_min = function(code) { // '+-'
		    var next = this.input.charCodeAt(this.pos + 1);
		    if (next === code) {
		      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
		          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
		        // A `-->` line comment
		        this.skipLineComment(3);
		        this.skipSpace();
		        return this.nextToken()
		      }
		      return this.finishOp(types$1.incDec, 2)
		    }
		    if (next === 61) { return this.finishOp(types$1.assign, 2) }
		    return this.finishOp(types$1.plusMin, 1)
		  };

		  pp.readToken_lt_gt = function(code) { // '<>'
		    var next = this.input.charCodeAt(this.pos + 1);
		    var size = 1;
		    if (next === code) {
		      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
		      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types$1.assign, size + 1) }
		      return this.finishOp(types$1.bitShift, size)
		    }
		    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
		        this.input.charCodeAt(this.pos + 3) === 45) {
		      // `<!--`, an XML-style comment that should be interpreted as a line comment
		      this.skipLineComment(4);
		      this.skipSpace();
		      return this.nextToken()
		    }
		    if (next === 61) { size = 2; }
		    return this.finishOp(types$1.relational, size)
		  };

		  pp.readToken_eq_excl = function(code) { // '=!'
		    var next = this.input.charCodeAt(this.pos + 1);
		    if (next === 61) { return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
		    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
		      this.pos += 2;
		      return this.finishToken(types$1.arrow)
		    }
		    return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1)
		  };

		  pp.readToken_question = function() { // '?'
		    var ecmaVersion = this.options.ecmaVersion;
		    if (ecmaVersion >= 11) {
		      var next = this.input.charCodeAt(this.pos + 1);
		      if (next === 46) {
		        var next2 = this.input.charCodeAt(this.pos + 2);
		        if (next2 < 48 || next2 > 57) { return this.finishOp(types$1.questionDot, 2) }
		      }
		      if (next === 63) {
		        if (ecmaVersion >= 12) {
		          var next2$1 = this.input.charCodeAt(this.pos + 2);
		          if (next2$1 === 61) { return this.finishOp(types$1.assign, 3) }
		        }
		        return this.finishOp(types$1.coalesce, 2)
		      }
		    }
		    return this.finishOp(types$1.question, 1)
		  };

		  pp.readToken_numberSign = function() { // '#'
		    var ecmaVersion = this.options.ecmaVersion;
		    var code = 35; // '#'
		    if (ecmaVersion >= 13) {
		      ++this.pos;
		      code = this.fullCharCodeAtPos();
		      if (isIdentifierStart(code, true) || code === 92 /* '\' */) {
		        return this.finishToken(types$1.privateId, this.readWord1())
		      }
		    }

		    this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
		  };

		  pp.getTokenFromCode = function(code) {
		    switch (code) {
		    // The interpretation of a dot depends on whether it is followed
		    // by a digit or another two dots.
		    case 46: // '.'
		      return this.readToken_dot()

		    // Punctuation tokens.
		    case 40: ++this.pos; return this.finishToken(types$1.parenL)
		    case 41: ++this.pos; return this.finishToken(types$1.parenR)
		    case 59: ++this.pos; return this.finishToken(types$1.semi)
		    case 44: ++this.pos; return this.finishToken(types$1.comma)
		    case 91: ++this.pos; return this.finishToken(types$1.bracketL)
		    case 93: ++this.pos; return this.finishToken(types$1.bracketR)
		    case 123: ++this.pos; return this.finishToken(types$1.braceL)
		    case 125: ++this.pos; return this.finishToken(types$1.braceR)
		    case 58: ++this.pos; return this.finishToken(types$1.colon)

		    case 96: // '`'
		      if (this.options.ecmaVersion < 6) { break }
		      ++this.pos;
		      return this.finishToken(types$1.backQuote)

		    case 48: // '0'
		      var next = this.input.charCodeAt(this.pos + 1);
		      if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
		      if (this.options.ecmaVersion >= 6) {
		        if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
		        if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
		      }

		    // Anything else beginning with a digit is an integer, octal
		    // number, or float.
		    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
		      return this.readNumber(false)

		    // Quotes produce strings.
		    case 34: case 39: // '"', "'"
		      return this.readString(code)

		    // Operators are parsed inline in tiny state machines. '=' (61) is
		    // often referred to. `finishOp` simply skips the amount of
		    // characters it is given as second argument, and returns a token
		    // of the type given by its first argument.
		    case 47: // '/'
		      return this.readToken_slash()

		    case 37: case 42: // '%*'
		      return this.readToken_mult_modulo_exp(code)

		    case 124: case 38: // '|&'
		      return this.readToken_pipe_amp(code)

		    case 94: // '^'
		      return this.readToken_caret()

		    case 43: case 45: // '+-'
		      return this.readToken_plus_min(code)

		    case 60: case 62: // '<>'
		      return this.readToken_lt_gt(code)

		    case 61: case 33: // '=!'
		      return this.readToken_eq_excl(code)

		    case 63: // '?'
		      return this.readToken_question()

		    case 126: // '~'
		      return this.finishOp(types$1.prefix, 1)

		    case 35: // '#'
		      return this.readToken_numberSign()
		    }

		    this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
		  };

		  pp.finishOp = function(type, size) {
		    var str = this.input.slice(this.pos, this.pos + size);
		    this.pos += size;
		    return this.finishToken(type, str)
		  };

		  pp.readRegexp = function() {
		    var escaped, inClass, start = this.pos;
		    for (;;) {
		      if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
		      var ch = this.input.charAt(this.pos);
		      if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
		      if (!escaped) {
		        if (ch === "[") { inClass = true; }
		        else if (ch === "]" && inClass) { inClass = false; }
		        else if (ch === "/" && !inClass) { break }
		        escaped = ch === "\\";
		      } else { escaped = false; }
		      ++this.pos;
		    }
		    var pattern = this.input.slice(start, this.pos);
		    ++this.pos;
		    var flagsStart = this.pos;
		    var flags = this.readWord1();
		    if (this.containsEsc) { this.unexpected(flagsStart); }

		    // Validate pattern
		    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
		    state.reset(start, pattern, flags);
		    this.validateRegExpFlags(state);
		    this.validateRegExpPattern(state);

		    // Create Literal#value property value.
		    var value = null;
		    try {
		      value = new RegExp(pattern, flags);
		    } catch (e) {
		      // ESTree requires null if it failed to instantiate RegExp object.
		      // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
		    }

		    return this.finishToken(types$1.regexp, {pattern: pattern, flags: flags, value: value})
		  };

		  // Read an integer in the given radix. Return null if zero digits
		  // were read, the integer value otherwise. When `len` is given, this
		  // will return `null` unless the integer has exactly `len` digits.

		  pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
		    // `len` is used for character escape sequences. In that case, disallow separators.
		    var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;

		    // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)
		    // and isn't fraction part nor exponent part. In that case, if the first digit
		    // is zero then disallow separators.
		    var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;

		    var start = this.pos, total = 0, lastCode = 0;
		    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
		      var code = this.input.charCodeAt(this.pos), val = (void 0);

		      if (allowSeparators && code === 95) {
		        if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"); }
		        if (lastCode === 95) { this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"); }
		        if (i === 0) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"); }
		        lastCode = code;
		        continue
		      }

		      if (code >= 97) { val = code - 97 + 10; } // a
		      else if (code >= 65) { val = code - 65 + 10; } // A
		      else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
		      else { val = Infinity; }
		      if (val >= radix) { break }
		      lastCode = code;
		      total = total * radix + val;
		    }

		    if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"); }
		    if (this.pos === start || len != null && this.pos - start !== len) { return null }

		    return total
		  };

		  function stringToNumber(str, isLegacyOctalNumericLiteral) {
		    if (isLegacyOctalNumericLiteral) {
		      return parseInt(str, 8)
		    }

		    // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.
		    return parseFloat(str.replace(/_/g, ""))
		  }

		  function stringToBigInt(str) {
		    if (typeof BigInt !== "function") {
		      return null
		    }

		    // `BigInt(value)` throws syntax error if the string contains numeric separators.
		    return BigInt(str.replace(/_/g, ""))
		  }

		  pp.readRadixNumber = function(radix) {
		    var start = this.pos;
		    this.pos += 2; // 0x
		    var val = this.readInt(radix);
		    if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
		    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
		      val = stringToBigInt(this.input.slice(start, this.pos));
		      ++this.pos;
		    } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
		    return this.finishToken(types$1.num, val)
		  };

		  // Read an integer, octal integer, or floating-point number.

		  pp.readNumber = function(startsWithDot) {
		    var start = this.pos;
		    if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, "Invalid number"); }
		    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
		    if (octal && this.strict) { this.raise(start, "Invalid number"); }
		    var next = this.input.charCodeAt(this.pos);
		    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
		      var val$1 = stringToBigInt(this.input.slice(start, this.pos));
		      ++this.pos;
		      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
		      return this.finishToken(types$1.num, val$1)
		    }
		    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
		    if (next === 46 && !octal) { // '.'
		      ++this.pos;
		      this.readInt(10);
		      next = this.input.charCodeAt(this.pos);
		    }
		    if ((next === 69 || next === 101) && !octal) { // 'eE'
		      next = this.input.charCodeAt(++this.pos);
		      if (next === 43 || next === 45) { ++this.pos; } // '+-'
		      if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
		    }
		    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

		    var val = stringToNumber(this.input.slice(start, this.pos), octal);
		    return this.finishToken(types$1.num, val)
		  };

		  // Read a string value, interpreting backslash-escapes.

		  pp.readCodePoint = function() {
		    var ch = this.input.charCodeAt(this.pos), code;

		    if (ch === 123) { // '{'
		      if (this.options.ecmaVersion < 6) { this.unexpected(); }
		      var codePos = ++this.pos;
		      code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
		      ++this.pos;
		      if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
		    } else {
		      code = this.readHexChar(4);
		    }
		    return code
		  };

		  pp.readString = function(quote) {
		    var out = "", chunkStart = ++this.pos;
		    for (;;) {
		      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
		      var ch = this.input.charCodeAt(this.pos);
		      if (ch === quote) { break }
		      if (ch === 92) { // '\'
		        out += this.input.slice(chunkStart, this.pos);
		        out += this.readEscapedChar(false);
		        chunkStart = this.pos;
		      } else if (ch === 0x2028 || ch === 0x2029) {
		        if (this.options.ecmaVersion < 10) { this.raise(this.start, "Unterminated string constant"); }
		        ++this.pos;
		        if (this.options.locations) {
		          this.curLine++;
		          this.lineStart = this.pos;
		        }
		      } else {
		        if (isNewLine(ch)) { this.raise(this.start, "Unterminated string constant"); }
		        ++this.pos;
		      }
		    }
		    out += this.input.slice(chunkStart, this.pos++);
		    return this.finishToken(types$1.string, out)
		  };

		  // Reads template string tokens.

		  var INVALID_TEMPLATE_ESCAPE_ERROR = {};

		  pp.tryReadTemplateToken = function() {
		    this.inTemplateElement = true;
		    try {
		      this.readTmplToken();
		    } catch (err) {
		      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
		        this.readInvalidTemplateToken();
		      } else {
		        throw err
		      }
		    }

		    this.inTemplateElement = false;
		  };

		  pp.invalidStringToken = function(position, message) {
		    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
		      throw INVALID_TEMPLATE_ESCAPE_ERROR
		    } else {
		      this.raise(position, message);
		    }
		  };

		  pp.readTmplToken = function() {
		    var out = "", chunkStart = this.pos;
		    for (;;) {
		      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
		      var ch = this.input.charCodeAt(this.pos);
		      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
		        if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
		          if (ch === 36) {
		            this.pos += 2;
		            return this.finishToken(types$1.dollarBraceL)
		          } else {
		            ++this.pos;
		            return this.finishToken(types$1.backQuote)
		          }
		        }
		        out += this.input.slice(chunkStart, this.pos);
		        return this.finishToken(types$1.template, out)
		      }
		      if (ch === 92) { // '\'
		        out += this.input.slice(chunkStart, this.pos);
		        out += this.readEscapedChar(true);
		        chunkStart = this.pos;
		      } else if (isNewLine(ch)) {
		        out += this.input.slice(chunkStart, this.pos);
		        ++this.pos;
		        switch (ch) {
		        case 13:
		          if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
		        case 10:
		          out += "\n";
		          break
		        default:
		          out += String.fromCharCode(ch);
		          break
		        }
		        if (this.options.locations) {
		          ++this.curLine;
		          this.lineStart = this.pos;
		        }
		        chunkStart = this.pos;
		      } else {
		        ++this.pos;
		      }
		    }
		  };

		  // Reads a template token to search for the end, without validating any escape sequences
		  pp.readInvalidTemplateToken = function() {
		    for (; this.pos < this.input.length; this.pos++) {
		      switch (this.input[this.pos]) {
		      case "\\":
		        ++this.pos;
		        break

		      case "$":
		        if (this.input[this.pos + 1] !== "{") {
		          break
		        }

		      // falls through
		      case "`":
		        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos))

		      // no default
		      }
		    }
		    this.raise(this.start, "Unterminated template");
		  };

		  // Used to read escaped characters

		  pp.readEscapedChar = function(inTemplate) {
		    var ch = this.input.charCodeAt(++this.pos);
		    ++this.pos;
		    switch (ch) {
		    case 110: return "\n" // 'n' -> '\n'
		    case 114: return "\r" // 'r' -> '\r'
		    case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
		    case 117: return codePointToString(this.readCodePoint()) // 'u'
		    case 116: return "\t" // 't' -> '\t'
		    case 98: return "\b" // 'b' -> '\b'
		    case 118: return "\u000b" // 'v' -> '\u000b'
		    case 102: return "\f" // 'f' -> '\f'
		    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
		    case 10: // ' \n'
		      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
		      return ""
		    case 56:
		    case 57:
		      if (this.strict) {
		        this.invalidStringToken(
		          this.pos - 1,
		          "Invalid escape sequence"
		        );
		      }
		      if (inTemplate) {
		        var codePos = this.pos - 1;

		        this.invalidStringToken(
		          codePos,
		          "Invalid escape sequence in template string"
		        );
		      }
		    default:
		      if (ch >= 48 && ch <= 55) {
		        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
		        var octal = parseInt(octalStr, 8);
		        if (octal > 255) {
		          octalStr = octalStr.slice(0, -1);
		          octal = parseInt(octalStr, 8);
		        }
		        this.pos += octalStr.length - 1;
		        ch = this.input.charCodeAt(this.pos);
		        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
		          this.invalidStringToken(
		            this.pos - 1 - octalStr.length,
		            inTemplate
		              ? "Octal literal in template string"
		              : "Octal literal in strict mode"
		          );
		        }
		        return String.fromCharCode(octal)
		      }
		      if (isNewLine(ch)) {
		        // Unicode new line characters after \ get removed from output in both
		        // template literals and strings
		        return ""
		      }
		      return String.fromCharCode(ch)
		    }
		  };

		  // Used to read character escape sequences ('\x', '\u', '\U').

		  pp.readHexChar = function(len) {
		    var codePos = this.pos;
		    var n = this.readInt(16, len);
		    if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
		    return n
		  };

		  // Read an identifier, and return it as a string. Sets `this.containsEsc`
		  // to whether the word contained a '\u' escape.
		  //
		  // Incrementally adds only escaped chars, adding other chunks as-is
		  // as a micro-optimization.

		  pp.readWord1 = function() {
		    this.containsEsc = false;
		    var word = "", first = true, chunkStart = this.pos;
		    var astral = this.options.ecmaVersion >= 6;
		    while (this.pos < this.input.length) {
		      var ch = this.fullCharCodeAtPos();
		      if (isIdentifierChar(ch, astral)) {
		        this.pos += ch <= 0xffff ? 1 : 2;
		      } else if (ch === 92) { // "\"
		        this.containsEsc = true;
		        word += this.input.slice(chunkStart, this.pos);
		        var escStart = this.pos;
		        if (this.input.charCodeAt(++this.pos) !== 117) // "u"
		          { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
		        ++this.pos;
		        var esc = this.readCodePoint();
		        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
		          { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
		        word += codePointToString(esc);
		        chunkStart = this.pos;
		      } else {
		        break
		      }
		      first = false;
		    }
		    return word + this.input.slice(chunkStart, this.pos)
		  };

		  // Read an identifier or keyword token. Will check for reserved
		  // words when necessary.

		  pp.readWord = function() {
		    var word = this.readWord1();
		    var type = types$1.name;
		    if (this.keywords.test(word)) {
		      type = keywords[word];
		    }
		    return this.finishToken(type, word)
		  };

		  // Acorn is a tiny, fast JavaScript parser written in JavaScript.
		  //
		  // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
		  // various contributors and released under an MIT license.
		  //
		  // Git repositories for Acorn are available at
		  //
		  //     http://marijnhaverbeke.nl/git/acorn
		  //     https://github.com/acornjs/acorn.git
		  //
		  // Please use the [github bug tracker][ghbt] to report issues.
		  //
		  // [ghbt]: https://github.com/acornjs/acorn/issues
		  //
		  // [walk]: util/walk.js


		  var version = "8.11.3";

		  Parser.acorn = {
		    Parser: Parser,
		    version: version,
		    defaultOptions: defaultOptions,
		    Position: Position,
		    SourceLocation: SourceLocation,
		    getLineInfo: getLineInfo,
		    Node: Node,
		    TokenType: TokenType,
		    tokTypes: types$1,
		    keywordTypes: keywords,
		    TokContext: TokContext,
		    tokContexts: types,
		    isIdentifierChar: isIdentifierChar,
		    isIdentifierStart: isIdentifierStart,
		    Token: Token,
		    isNewLine: isNewLine,
		    lineBreak: lineBreak,
		    lineBreakG: lineBreakG,
		    nonASCIIwhitespace: nonASCIIwhitespace
		  };

		  // The main exported interface (under `self.acorn` when in the
		  // browser) is a `parse` function that takes a code string and returns
		  // an abstract syntax tree as specified by the [ESTree spec][estree].
		  //
		  // [estree]: https://github.com/estree/estree

		  function parse(input, options) {
		    return Parser.parse(input, options)
		  }

		  // This function tries to parse a single expression at a given
		  // offset in a string. Useful for parsing mixed-language formats
		  // that embed JavaScript expressions.

		  function parseExpressionAt(input, pos, options) {
		    return Parser.parseExpressionAt(input, pos, options)
		  }

		  // Acorn is organized as a tokenizer and a recursive-descent parser.
		  // The `tokenizer` export provides an interface to the tokenizer.

		  function tokenizer(input, options) {
		    return Parser.tokenizer(input, options)
		  }

		  exports.Node = Node;
		  exports.Parser = Parser;
		  exports.Position = Position;
		  exports.SourceLocation = SourceLocation;
		  exports.TokContext = TokContext;
		  exports.Token = Token;
		  exports.TokenType = TokenType;
		  exports.defaultOptions = defaultOptions;
		  exports.getLineInfo = getLineInfo;
		  exports.isIdentifierChar = isIdentifierChar;
		  exports.isIdentifierStart = isIdentifierStart;
		  exports.isNewLine = isNewLine;
		  exports.keywordTypes = keywords;
		  exports.lineBreak = lineBreak;
		  exports.lineBreakG = lineBreakG;
		  exports.nonASCIIwhitespace = nonASCIIwhitespace;
		  exports.parse = parse;
		  exports.parseExpressionAt = parseExpressionAt;
		  exports.tokContexts = types;
		  exports.tokTypes = types$1;
		  exports.tokenizer = tokenizer;
		  exports.version = version;

		})); 
	} (acorn$1, acorn$1.exports));
	return acorn$1.exports;
}

var dist$c = {};

var hasRequiredDist$8;

function requireDist$8 () {
	if (hasRequiredDist$8) return dist$c;
	hasRequiredDist$8 = 1;

	const n = /[^\0-\x7E]/;
	const t = /[\x2E\u3002\uFF0E\uFF61]/g;
	const o = {
	  overflow: "Overflow Error",
	  "not-basic": "Illegal Input",
	  "invalid-input": "Invalid Input"
	};
	const e = Math.floor;
	const r = String.fromCharCode;
	function s(n2) {
	  throw new RangeError(o[n2]);
	}
	const c = function(n2, t2) {
	  return n2 + 22 + 75 * (n2 < 26) - ((t2 != 0) << 5);
	};
	const u = function(n2, t2, o2) {
	  let r2 = 0;
	  for (n2 = o2 ? e(n2 / 700) : n2 >> 1, n2 += e(n2 / t2); n2 > 455; r2 += 36) {
	    n2 = e(n2 / 35);
	  }
	  return e(r2 + 36 * n2 / (n2 + 38));
	};
	function toASCII(o2) {
	  return function(n2, o3) {
	    const e2 = n2.split("@");
	    let r2 = "";
	    e2.length > 1 && (r2 = e2[0] + "@", n2 = e2[1]);
	    const s2 = function(n3, t2) {
	      const o4 = [];
	      let e3 = n3.length;
	      for (; e3--; ) {
	        o4[e3] = t2(n3[e3]);
	      }
	      return o4;
	    }((n2 = n2.replace(t, ".")).split("."), o3).join(".");
	    return r2 + s2;
	  }(o2, function(t2) {
	    return n.test(t2) ? "xn--" + function(n2) {
	      const t3 = [];
	      const o3 = (n2 = function(n3) {
	        const t4 = [];
	        let o4 = 0;
	        const e2 = n3.length;
	        for (; o4 < e2; ) {
	          const r2 = n3.charCodeAt(o4++);
	          if (r2 >= 55296 && r2 <= 56319 && o4 < e2) {
	            const e3 = n3.charCodeAt(o4++);
	            (64512 & e3) == 56320 ? t4.push(((1023 & r2) << 10) + (1023 & e3) + 65536) : (t4.push(r2), o4--);
	          } else {
	            t4.push(r2);
	          }
	        }
	        return t4;
	      }(n2)).length;
	      let f = 128;
	      let i = 0;
	      let l = 72;
	      for (const o4 of n2) {
	        o4 < 128 && t3.push(r(o4));
	      }
	      const h = t3.length;
	      let p = h;
	      for (h && t3.push("-"); p < o3; ) {
	        let o4 = 2147483647;
	        for (const t4 of n2) {
	          t4 >= f && t4 < o4 && (o4 = t4);
	        }
	        const a = p + 1;
	        o4 - f > e((2147483647 - i) / a) && s("overflow"), i += (o4 - f) * a, f = o4;
	        for (const o5 of n2) {
	          if (o5 < f && ++i > 2147483647 && s("overflow"), o5 == f) {
	            let n3 = i;
	            for (let o6 = 36; ; o6 += 36) {
	              const s2 = o6 <= l ? 1 : o6 >= l + 26 ? 26 : o6 - l;
	              if (n3 < s2) {
	                break;
	              }
	              const u2 = n3 - s2;
	              const f2 = 36 - s2;
	              t3.push(r(c(s2 + u2 % f2, 0))), n3 = e(u2 / f2);
	            }
	            t3.push(r(c(n3, 0))), l = u(i, a, p == h), i = 0, ++p;
	          }
	        }
	        ++i, ++f;
	      }
	      return t3.join("");
	    }(t2) : t2;
	  });
	}

	const HASH_RE = /#/g;
	const AMPERSAND_RE = /&/g;
	const SLASH_RE = /\//g;
	const EQUAL_RE = /=/g;
	const IM_RE = /\?/g;
	const PLUS_RE = /\+/g;
	const ENC_CARET_RE = /%5e/gi;
	const ENC_BACKTICK_RE = /%60/gi;
	const ENC_CURLY_OPEN_RE = /%7b/gi;
	const ENC_PIPE_RE = /%7c/gi;
	const ENC_CURLY_CLOSE_RE = /%7d/gi;
	const ENC_SPACE_RE = /%20/gi;
	const ENC_SLASH_RE = /%2f/gi;
	const ENC_ENC_SLASH_RE = /%252f/gi;
	function encode(text) {
	  return encodeURI("" + text).replace(ENC_PIPE_RE, "|");
	}
	function encodeHash(text) {
	  return encode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
	}
	function encodeQueryValue(input) {
	  return encode(typeof input === "string" ? input : JSON.stringify(input)).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CARET_RE, "^");
	}
	function encodeQueryKey(text) {
	  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
	}
	function encodePath(text) {
	  return encode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F").replace(ENC_ENC_SLASH_RE, "%2F").replace(AMPERSAND_RE, "%26").replace(PLUS_RE, "%2B");
	}
	function encodeParam(text) {
	  return encodePath(text).replace(SLASH_RE, "%2F");
	}
	function decode(text = "") {
	  try {
	    return decodeURIComponent("" + text);
	  } catch {
	    return "" + text;
	  }
	}
	function decodePath(text) {
	  return decode(text.replace(ENC_SLASH_RE, "%252F"));
	}
	function decodeQueryKey(text) {
	  return decode(text.replace(PLUS_RE, " "));
	}
	function decodeQueryValue(text) {
	  return decode(text.replace(PLUS_RE, " "));
	}
	function encodeHost(name = "") {
	  return toASCII(name);
	}

	function parseQuery(parametersString = "") {
	  const object = {};
	  if (parametersString[0] === "?") {
	    parametersString = parametersString.slice(1);
	  }
	  for (const parameter of parametersString.split("&")) {
	    const s = parameter.match(/([^=]+)=?(.*)/) || [];
	    if (s.length < 2) {
	      continue;
	    }
	    const key = decodeQueryKey(s[1]);
	    if (key === "__proto__" || key === "constructor") {
	      continue;
	    }
	    const value = decodeQueryValue(s[2] || "");
	    if (object[key] === void 0) {
	      object[key] = value;
	    } else if (Array.isArray(object[key])) {
	      object[key].push(value);
	    } else {
	      object[key] = [object[key], value];
	    }
	  }
	  return object;
	}
	function encodeQueryItem(key, value) {
	  if (typeof value === "number" || typeof value === "boolean") {
	    value = String(value);
	  }
	  if (!value) {
	    return encodeQueryKey(key);
	  }
	  if (Array.isArray(value)) {
	    return value.map((_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`).join("&");
	  }
	  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;
	}
	function stringifyQuery(query) {
	  return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).filter(Boolean).join("&");
	}

	var __defProp = Object.defineProperty;
	var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __publicField = (obj, key, value) => {
	  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
	  return value;
	};
	class $URL {
	  constructor(input = "") {
	    __publicField(this, "protocol");
	    __publicField(this, "host");
	    __publicField(this, "auth");
	    __publicField(this, "pathname");
	    __publicField(this, "query", {});
	    __publicField(this, "hash");
	    if (typeof input !== "string") {
	      throw new TypeError(
	        `URL input should be string received ${typeof input} (${input})`
	      );
	    }
	    const parsed = parseURL(input);
	    this.protocol = decode(parsed.protocol);
	    this.host = decode(parsed.host);
	    this.auth = decode(parsed.auth);
	    this.pathname = decodePath(parsed.pathname);
	    this.query = parseQuery(parsed.search);
	    this.hash = decode(parsed.hash);
	  }
	  get hostname() {
	    return parseHost(this.host).hostname;
	  }
	  get port() {
	    return parseHost(this.host).port || "";
	  }
	  get username() {
	    return parseAuth(this.auth).username;
	  }
	  get password() {
	    return parseAuth(this.auth).password || "";
	  }
	  get hasProtocol() {
	    return this.protocol.length;
	  }
	  get isAbsolute() {
	    return this.hasProtocol || this.pathname[0] === "/";
	  }
	  get search() {
	    const q = stringifyQuery(this.query);
	    return q.length > 0 ? "?" + q : "";
	  }
	  get searchParams() {
	    const p = new URLSearchParams();
	    for (const name in this.query) {
	      const value = this.query[name];
	      if (Array.isArray(value)) {
	        for (const v of value) {
	          p.append(name, v);
	        }
	      } else {
	        p.append(
	          name,
	          typeof value === "string" ? value : JSON.stringify(value)
	        );
	      }
	    }
	    return p;
	  }
	  get origin() {
	    return (this.protocol ? this.protocol + "//" : "") + encodeHost(this.host);
	  }
	  get fullpath() {
	    return encodePath(this.pathname) + this.search + encodeHash(this.hash);
	  }
	  get encodedAuth() {
	    if (!this.auth) {
	      return "";
	    }
	    const { username, password } = parseAuth(this.auth);
	    return encodeURIComponent(username) + (password ? ":" + encodeURIComponent(password) : "");
	  }
	  get href() {
	    const auth = this.encodedAuth;
	    const originWithAuth = (this.protocol ? this.protocol + "//" : "") + (auth ? auth + "@" : "") + encodeHost(this.host);
	    return this.hasProtocol && this.isAbsolute ? originWithAuth + this.fullpath : this.fullpath;
	  }
	  append(url) {
	    if (url.hasProtocol) {
	      throw new Error("Cannot append a URL with protocol");
	    }
	    Object.assign(this.query, url.query);
	    if (url.pathname) {
	      this.pathname = withTrailingSlash(this.pathname) + withoutLeadingSlash(url.pathname);
	    }
	    if (url.hash) {
	      this.hash = url.hash;
	    }
	  }
	  toJSON() {
	    return this.href;
	  }
	  toString() {
	    return this.href;
	  }
	}

	function isRelative(inputString) {
	  return ["./", "../"].some((string_) => inputString.startsWith(string_));
	}
	const PROTOCOL_STRICT_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/;
	const PROTOCOL_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{2})?/;
	const PROTOCOL_RELATIVE_REGEX = /^([/\\]\s*){2,}[^/\\]/;
	function hasProtocol(inputString, opts = {}) {
	  if (typeof opts === "boolean") {
	    opts = { acceptRelative: opts };
	  }
	  if (opts.strict) {
	    return PROTOCOL_STRICT_REGEX.test(inputString);
	  }
	  return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);
	}
	const PROTOCOL_SCRIPT_RE = /^[\s\0]*(blob|data|javascript|vbscript):$/i;
	function isScriptProtocol(protocol) {
	  return !!protocol && PROTOCOL_SCRIPT_RE.test(protocol);
	}
	const TRAILING_SLASH_RE = /\/$|\/\?|\/#/;
	function hasTrailingSlash(input = "", respectQueryAndFragment) {
	  if (!respectQueryAndFragment) {
	    return input.endsWith("/");
	  }
	  return TRAILING_SLASH_RE.test(input);
	}
	function withoutTrailingSlash(input = "", respectQueryAndFragment) {
	  if (!respectQueryAndFragment) {
	    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || "/";
	  }
	  if (!hasTrailingSlash(input, true)) {
	    return input || "/";
	  }
	  let path = input;
	  let fragment = "";
	  const fragmentIndex = input.indexOf("#");
	  if (fragmentIndex >= 0) {
	    path = input.slice(0, fragmentIndex);
	    fragment = input.slice(fragmentIndex);
	  }
	  const [s0, ...s] = path.split("?");
	  return (s0.slice(0, -1) || "/") + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
	}
	function withTrailingSlash(input = "", respectQueryAndFragment) {
	  if (!respectQueryAndFragment) {
	    return input.endsWith("/") ? input : input + "/";
	  }
	  if (hasTrailingSlash(input, true)) {
	    return input || "/";
	  }
	  let path = input;
	  let fragment = "";
	  const fragmentIndex = input.indexOf("#");
	  if (fragmentIndex >= 0) {
	    path = input.slice(0, fragmentIndex);
	    fragment = input.slice(fragmentIndex);
	    if (!path) {
	      return fragment;
	    }
	  }
	  const [s0, ...s] = path.split("?");
	  return s0 + "/" + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
	}
	function hasLeadingSlash(input = "") {
	  return input.startsWith("/");
	}
	function withoutLeadingSlash(input = "") {
	  return (hasLeadingSlash(input) ? input.slice(1) : input) || "/";
	}
	function withLeadingSlash(input = "") {
	  return hasLeadingSlash(input) ? input : "/" + input;
	}
	function cleanDoubleSlashes(input = "") {
	  return input.split("://").map((string_) => string_.replace(/\/{2,}/g, "/")).join("://");
	}
	function withBase(input, base) {
	  if (isEmptyURL(base) || hasProtocol(input)) {
	    return input;
	  }
	  const _base = withoutTrailingSlash(base);
	  if (input.startsWith(_base)) {
	    return input;
	  }
	  return joinURL(_base, input);
	}
	function withoutBase(input, base) {
	  if (isEmptyURL(base)) {
	    return input;
	  }
	  const _base = withoutTrailingSlash(base);
	  if (!input.startsWith(_base)) {
	    return input;
	  }
	  const trimmed = input.slice(_base.length);
	  return trimmed[0] === "/" ? trimmed : "/" + trimmed;
	}
	function withQuery(input, query) {
	  const parsed = parseURL(input);
	  const mergedQuery = { ...parseQuery(parsed.search), ...query };
	  parsed.search = stringifyQuery(mergedQuery);
	  return stringifyParsedURL(parsed);
	}
	function getQuery(input) {
	  return parseQuery(parseURL(input).search);
	}
	function isEmptyURL(url) {
	  return !url || url === "/";
	}
	function isNonEmptyURL(url) {
	  return url && url !== "/";
	}
	const JOIN_LEADING_SLASH_RE = /^\.?\//;
	function joinURL(base, ...input) {
	  let url = base || "";
	  for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {
	    if (url) {
	      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, "");
	      url = withTrailingSlash(url) + _segment;
	    } else {
	      url = segment;
	    }
	  }
	  return url;
	}
	function withHttp(input) {
	  return withProtocol(input, "http://");
	}
	function withHttps(input) {
	  return withProtocol(input, "https://");
	}
	function withoutProtocol(input) {
	  return withProtocol(input, "");
	}
	function withProtocol(input, protocol) {
	  const match = input.match(PROTOCOL_REGEX);
	  if (!match) {
	    return protocol + input;
	  }
	  return protocol + input.slice(match[0].length);
	}
	function createURL(input) {
	  return new $URL(input);
	}
	function normalizeURL(input) {
	  return createURL(input).toString();
	}
	function resolveURL(base, ...input) {
	  const url = createURL(base);
	  for (const index of input.filter((url2) => isNonEmptyURL(url2))) {
	    url.append(createURL(index));
	  }
	  return url.toString();
	}
	function isSamePath(p1, p2) {
	  return decode(withoutTrailingSlash(p1)) === decode(withoutTrailingSlash(p2));
	}
	function isEqual(a, b, options = {}) {
	  if (!options.trailingSlash) {
	    a = withTrailingSlash(a);
	    b = withTrailingSlash(b);
	  }
	  if (!options.leadingSlash) {
	    a = withLeadingSlash(a);
	    b = withLeadingSlash(b);
	  }
	  if (!options.encoding) {
	    a = decode(a);
	    b = decode(b);
	  }
	  return a === b;
	}

	function parseURL(input = "", defaultProto) {
	  const _specialProtoMatch = input.match(
	    /^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i
	  );
	  if (_specialProtoMatch) {
	    const [, _proto, _pathname = ""] = _specialProtoMatch;
	    return {
	      protocol: _proto.toLowerCase(),
	      pathname: _pathname,
	      href: _proto + _pathname,
	      auth: "",
	      host: "",
	      search: "",
	      hash: ""
	    };
	  }
	  if (!hasProtocol(input, { acceptRelative: true })) {
	    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);
	  }
	  const [, protocol = "", auth, hostAndPath = ""] = input.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [];
	  const [, host = "", path = ""] = hostAndPath.match(/([^#/?]*)(.*)?/) || [];
	  const { pathname, search, hash } = parsePath(
	    path.replace(/\/(?=[A-Za-z]:)/, "")
	  );
	  return {
	    protocol: protocol.toLowerCase(),
	    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : "",
	    host,
	    pathname,
	    search,
	    hash
	  };
	}
	function parsePath(input = "") {
	  const [pathname = "", search = "", hash = ""] = (input.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
	  return {
	    pathname,
	    search,
	    hash
	  };
	}
	function parseAuth(input = "") {
	  const [username, password] = input.split(":");
	  return {
	    username: decode(username),
	    password: decode(password)
	  };
	}
	function parseHost(input = "") {
	  const [hostname, port] = (input.match(/([^/:]*):?(\d+)?/) || []).splice(1);
	  return {
	    hostname: decode(hostname),
	    port
	  };
	}
	function stringifyParsedURL(parsed) {
	  const pathname = parsed.pathname || "";
	  const search = parsed.search ? (parsed.search.startsWith("?") ? "" : "?") + parsed.search : "";
	  const hash = parsed.hash || "";
	  const auth = parsed.auth ? parsed.auth + "@" : "";
	  const host = parsed.host || "";
	  const proto = parsed.protocol ? parsed.protocol + "//" : "";
	  return proto + auth + host + pathname + search + hash;
	}
	const FILENAME_STRICT_REGEX = /\/([^/]+\.[^/]+)$/;
	const FILENAME_REGEX = /\/([^/]+)$/;
	function parseFilename(input = "", { strict }) {
	  const { pathname } = parseURL(input);
	  const matches = strict ? pathname.match(FILENAME_STRICT_REGEX) : pathname.match(FILENAME_REGEX);
	  return matches ? matches[1] : void 0;
	}

	dist$c.$URL = $URL;
	dist$c.cleanDoubleSlashes = cleanDoubleSlashes;
	dist$c.createURL = createURL;
	dist$c.decode = decode;
	dist$c.decodePath = decodePath;
	dist$c.decodeQueryKey = decodeQueryKey;
	dist$c.decodeQueryValue = decodeQueryValue;
	dist$c.encode = encode;
	dist$c.encodeHash = encodeHash;
	dist$c.encodeHost = encodeHost;
	dist$c.encodeParam = encodeParam;
	dist$c.encodePath = encodePath;
	dist$c.encodeQueryItem = encodeQueryItem;
	dist$c.encodeQueryKey = encodeQueryKey;
	dist$c.encodeQueryValue = encodeQueryValue;
	dist$c.getQuery = getQuery;
	dist$c.hasLeadingSlash = hasLeadingSlash;
	dist$c.hasProtocol = hasProtocol;
	dist$c.hasTrailingSlash = hasTrailingSlash;
	dist$c.isEmptyURL = isEmptyURL;
	dist$c.isEqual = isEqual;
	dist$c.isNonEmptyURL = isNonEmptyURL;
	dist$c.isRelative = isRelative;
	dist$c.isSamePath = isSamePath;
	dist$c.isScriptProtocol = isScriptProtocol;
	dist$c.joinURL = joinURL;
	dist$c.normalizeURL = normalizeURL;
	dist$c.parseAuth = parseAuth;
	dist$c.parseFilename = parseFilename;
	dist$c.parseHost = parseHost;
	dist$c.parsePath = parsePath;
	dist$c.parseQuery = parseQuery;
	dist$c.parseURL = parseURL;
	dist$c.resolveURL = resolveURL;
	dist$c.stringifyParsedURL = stringifyParsedURL;
	dist$c.stringifyQuery = stringifyQuery;
	dist$c.withBase = withBase;
	dist$c.withHttp = withHttp;
	dist$c.withHttps = withHttps;
	dist$c.withLeadingSlash = withLeadingSlash;
	dist$c.withProtocol = withProtocol;
	dist$c.withQuery = withQuery;
	dist$c.withTrailingSlash = withTrailingSlash;
	dist$c.withoutBase = withoutBase;
	dist$c.withoutLeadingSlash = withoutLeadingSlash;
	dist$c.withoutProtocol = withoutProtocol;
	dist$c.withoutTrailingSlash = withoutTrailingSlash;
	return dist$c;
}

var dist$b = {};

var pathe_1f0a373c = {};

var hasRequiredPathe_1f0a373c;

function requirePathe_1f0a373c () {
	if (hasRequiredPathe_1f0a373c) return pathe_1f0a373c;
	hasRequiredPathe_1f0a373c = 1;

	const _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
	function normalizeWindowsPath(input = "") {
	  if (!input) {
	    return input;
	  }
	  return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());
	}

	const _UNC_REGEX = /^[/\\]{2}/;
	const _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
	const _DRIVE_LETTER_RE = /^[A-Za-z]:$/;
	const _ROOT_FOLDER_RE = /^\/([A-Za-z]:)?$/;
	const sep = "/";
	const delimiter = ":";
	const normalize = function(path) {
	  if (path.length === 0) {
	    return ".";
	  }
	  path = normalizeWindowsPath(path);
	  const isUNCPath = path.match(_UNC_REGEX);
	  const isPathAbsolute = isAbsolute(path);
	  const trailingSeparator = path[path.length - 1] === "/";
	  path = normalizeString(path, !isPathAbsolute);
	  if (path.length === 0) {
	    if (isPathAbsolute) {
	      return "/";
	    }
	    return trailingSeparator ? "./" : ".";
	  }
	  if (trailingSeparator) {
	    path += "/";
	  }
	  if (_DRIVE_LETTER_RE.test(path)) {
	    path += "/";
	  }
	  if (isUNCPath) {
	    if (!isPathAbsolute) {
	      return `//./${path}`;
	    }
	    return `//${path}`;
	  }
	  return isPathAbsolute && !isAbsolute(path) ? `/${path}` : path;
	};
	const join = function(...arguments_) {
	  if (arguments_.length === 0) {
	    return ".";
	  }
	  let joined;
	  for (const argument of arguments_) {
	    if (argument && argument.length > 0) {
	      if (joined === void 0) {
	        joined = argument;
	      } else {
	        joined += `/${argument}`;
	      }
	    }
	  }
	  if (joined === void 0) {
	    return ".";
	  }
	  return normalize(joined.replace(/\/\/+/g, "/"));
	};
	function cwd() {
	  if (typeof process !== "undefined" && typeof process.cwd === "function") {
	    return process.cwd().replace(/\\/g, "/");
	  }
	  return "/";
	}
	const resolve = function(...arguments_) {
	  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
	  let resolvedPath = "";
	  let resolvedAbsolute = false;
	  for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
	    const path = index >= 0 ? arguments_[index] : cwd();
	    if (!path || path.length === 0) {
	      continue;
	    }
	    resolvedPath = `${path}/${resolvedPath}`;
	    resolvedAbsolute = isAbsolute(path);
	  }
	  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
	  if (resolvedAbsolute && !isAbsolute(resolvedPath)) {
	    return `/${resolvedPath}`;
	  }
	  return resolvedPath.length > 0 ? resolvedPath : ".";
	};
	function normalizeString(path, allowAboveRoot) {
	  let res = "";
	  let lastSegmentLength = 0;
	  let lastSlash = -1;
	  let dots = 0;
	  let char = null;
	  for (let index = 0; index <= path.length; ++index) {
	    if (index < path.length) {
	      char = path[index];
	    } else if (char === "/") {
	      break;
	    } else {
	      char = "/";
	    }
	    if (char === "/") {
	      if (lastSlash === index - 1 || dots === 1) ; else if (dots === 2) {
	        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
	          if (res.length > 2) {
	            const lastSlashIndex = res.lastIndexOf("/");
	            if (lastSlashIndex === -1) {
	              res = "";
	              lastSegmentLength = 0;
	            } else {
	              res = res.slice(0, lastSlashIndex);
	              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
	            }
	            lastSlash = index;
	            dots = 0;
	            continue;
	          } else if (res.length > 0) {
	            res = "";
	            lastSegmentLength = 0;
	            lastSlash = index;
	            dots = 0;
	            continue;
	          }
	        }
	        if (allowAboveRoot) {
	          res += res.length > 0 ? "/.." : "..";
	          lastSegmentLength = 2;
	        }
	      } else {
	        if (res.length > 0) {
	          res += `/${path.slice(lastSlash + 1, index)}`;
	        } else {
	          res = path.slice(lastSlash + 1, index);
	        }
	        lastSegmentLength = index - lastSlash - 1;
	      }
	      lastSlash = index;
	      dots = 0;
	    } else if (char === "." && dots !== -1) {
	      ++dots;
	    } else {
	      dots = -1;
	    }
	  }
	  return res;
	}
	const isAbsolute = function(p) {
	  return _IS_ABSOLUTE_RE.test(p);
	};
	const toNamespacedPath = function(p) {
	  return normalizeWindowsPath(p);
	};
	const _EXTNAME_RE = /.(\.[^./]+)$/;
	const extname = function(p) {
	  const match = _EXTNAME_RE.exec(normalizeWindowsPath(p));
	  return match && match[1] || "";
	};
	const relative = function(from, to) {
	  const _from = resolve(from).replace(_ROOT_FOLDER_RE, "$1").split("/");
	  const _to = resolve(to).replace(_ROOT_FOLDER_RE, "$1").split("/");
	  if (_to[0][1] === ":" && _from[0][1] === ":" && _from[0] !== _to[0]) {
	    return _to.join("/");
	  }
	  const _fromCopy = [..._from];
	  for (const segment of _fromCopy) {
	    if (_to[0] !== segment) {
	      break;
	    }
	    _from.shift();
	    _to.shift();
	  }
	  return [..._from.map(() => ".."), ..._to].join("/");
	};
	const dirname = function(p) {
	  const segments = normalizeWindowsPath(p).replace(/\/$/, "").split("/").slice(0, -1);
	  if (segments.length === 1 && _DRIVE_LETTER_RE.test(segments[0])) {
	    segments[0] += "/";
	  }
	  return segments.join("/") || (isAbsolute(p) ? "/" : ".");
	};
	const format = function(p) {
	  const segments = [p.root, p.dir, p.base ?? p.name + p.ext].filter(Boolean);
	  return normalizeWindowsPath(
	    p.root ? resolve(...segments) : segments.join("/")
	  );
	};
	const basename = function(p, extension) {
	  const lastSegment = normalizeWindowsPath(p).split("/").pop();
	  return extension && lastSegment.endsWith(extension) ? lastSegment.slice(0, -extension.length) : lastSegment;
	};
	const parse = function(p) {
	  const root = normalizeWindowsPath(p).split("/").shift() || "/";
	  const base = basename(p);
	  const extension = extname(base);
	  return {
	    root,
	    dir: dirname(p),
	    base,
	    ext: extension,
	    name: base.slice(0, base.length - extension.length)
	  };
	};

	const path = {
	  __proto__: null,
	  basename: basename,
	  delimiter: delimiter,
	  dirname: dirname,
	  extname: extname,
	  format: format,
	  isAbsolute: isAbsolute,
	  join: join,
	  normalize: normalize,
	  normalizeString: normalizeString,
	  parse: parse,
	  relative: relative,
	  resolve: resolve,
	  sep: sep,
	  toNamespacedPath: toNamespacedPath
	};

	pathe_1f0a373c.basename = basename;
	pathe_1f0a373c.delimiter = delimiter;
	pathe_1f0a373c.dirname = dirname;
	pathe_1f0a373c.extname = extname;
	pathe_1f0a373c.format = format;
	pathe_1f0a373c.isAbsolute = isAbsolute;
	pathe_1f0a373c.join = join;
	pathe_1f0a373c.normalize = normalize;
	pathe_1f0a373c.normalizeString = normalizeString;
	pathe_1f0a373c.normalizeWindowsPath = normalizeWindowsPath;
	pathe_1f0a373c.parse = parse;
	pathe_1f0a373c.path = path;
	pathe_1f0a373c.relative = relative;
	pathe_1f0a373c.resolve = resolve;
	pathe_1f0a373c.sep = sep;
	pathe_1f0a373c.toNamespacedPath = toNamespacedPath;
	return pathe_1f0a373c;
}

var hasRequiredDist$7;

function requireDist$7 () {
	if (hasRequiredDist$7) return dist$b;
	hasRequiredDist$7 = 1;

	Object.defineProperty(dist$b, '__esModule', { value: true });

	const index = requirePathe_1f0a373c();



	dist$b.basename = index.basename;
	dist$b.default = index.path;
	dist$b.delimiter = index.delimiter;
	dist$b.dirname = index.dirname;
	dist$b.extname = index.extname;
	dist$b.format = index.format;
	dist$b.isAbsolute = index.isAbsolute;
	dist$b.join = index.join;
	dist$b.normalize = index.normalize;
	dist$b.normalizeString = index.normalizeString;
	dist$b.parse = index.parse;
	dist$b.relative = index.relative;
	dist$b.resolve = index.resolve;
	dist$b.sep = index.sep;
	dist$b.toNamespacedPath = index.toNamespacedPath;
	return dist$b;
}

var dist$a = {};

var dist$9 = {};

var pathe_adaa73b5 = {};

var hasRequiredPathe_adaa73b5;

function requirePathe_adaa73b5 () {
	if (hasRequiredPathe_adaa73b5) return pathe_adaa73b5;
	hasRequiredPathe_adaa73b5 = 1;

	function normalizeWindowsPath(input = "") {
	  if (!input || !input.includes("\\")) {
	    return input;
	  }
	  return input.replace(/\\/g, "/");
	}

	const _UNC_REGEX = /^[/\\]{2}/;
	const _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
	const _DRIVE_LETTER_RE = /^[A-Za-z]:$/;
	const sep = "/";
	const delimiter = ":";
	const normalize = function(path) {
	  if (path.length === 0) {
	    return ".";
	  }
	  path = normalizeWindowsPath(path);
	  const isUNCPath = path.match(_UNC_REGEX);
	  const isPathAbsolute = isAbsolute(path);
	  const trailingSeparator = path[path.length - 1] === "/";
	  path = normalizeString(path, !isPathAbsolute);
	  if (path.length === 0) {
	    if (isPathAbsolute) {
	      return "/";
	    }
	    return trailingSeparator ? "./" : ".";
	  }
	  if (trailingSeparator) {
	    path += "/";
	  }
	  if (_DRIVE_LETTER_RE.test(path)) {
	    path += "/";
	  }
	  if (isUNCPath) {
	    if (!isPathAbsolute) {
	      return `//./${path}`;
	    }
	    return `//${path}`;
	  }
	  return isPathAbsolute && !isAbsolute(path) ? `/${path}` : path;
	};
	const join = function(...arguments_) {
	  if (arguments_.length === 0) {
	    return ".";
	  }
	  let joined;
	  for (const argument of arguments_) {
	    if (argument && argument.length > 0) {
	      if (joined === void 0) {
	        joined = argument;
	      } else {
	        joined += `/${argument}`;
	      }
	    }
	  }
	  if (joined === void 0) {
	    return ".";
	  }
	  return normalize(joined.replace(/\/\/+/g, "/"));
	};
	function cwd() {
	  if (typeof process !== "undefined") {
	    return process.cwd().replace(/\\/g, "/");
	  }
	  return "/";
	}
	const resolve = function(...arguments_) {
	  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
	  let resolvedPath = "";
	  let resolvedAbsolute = false;
	  for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
	    const path = index >= 0 ? arguments_[index] : cwd();
	    if (!path || path.length === 0) {
	      continue;
	    }
	    resolvedPath = `${path}/${resolvedPath}`;
	    resolvedAbsolute = isAbsolute(path);
	  }
	  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
	  if (resolvedAbsolute && !isAbsolute(resolvedPath)) {
	    return `/${resolvedPath}`;
	  }
	  return resolvedPath.length > 0 ? resolvedPath : ".";
	};
	function normalizeString(path, allowAboveRoot) {
	  let res = "";
	  let lastSegmentLength = 0;
	  let lastSlash = -1;
	  let dots = 0;
	  let char = null;
	  for (let index = 0; index <= path.length; ++index) {
	    if (index < path.length) {
	      char = path[index];
	    } else if (char === "/") {
	      break;
	    } else {
	      char = "/";
	    }
	    if (char === "/") {
	      if (lastSlash === index - 1 || dots === 1) ; else if (dots === 2) {
	        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
	          if (res.length > 2) {
	            const lastSlashIndex = res.lastIndexOf("/");
	            if (lastSlashIndex === -1) {
	              res = "";
	              lastSegmentLength = 0;
	            } else {
	              res = res.slice(0, lastSlashIndex);
	              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
	            }
	            lastSlash = index;
	            dots = 0;
	            continue;
	          } else if (res.length > 0) {
	            res = "";
	            lastSegmentLength = 0;
	            lastSlash = index;
	            dots = 0;
	            continue;
	          }
	        }
	        if (allowAboveRoot) {
	          res += res.length > 0 ? "/.." : "..";
	          lastSegmentLength = 2;
	        }
	      } else {
	        if (res.length > 0) {
	          res += `/${path.slice(lastSlash + 1, index)}`;
	        } else {
	          res = path.slice(lastSlash + 1, index);
	        }
	        lastSegmentLength = index - lastSlash - 1;
	      }
	      lastSlash = index;
	      dots = 0;
	    } else if (char === "." && dots !== -1) {
	      ++dots;
	    } else {
	      dots = -1;
	    }
	  }
	  return res;
	}
	const isAbsolute = function(p) {
	  return _IS_ABSOLUTE_RE.test(p);
	};
	const toNamespacedPath = function(p) {
	  return normalizeWindowsPath(p);
	};
	const _EXTNAME_RE = /.(\.[^./]+)$/;
	const extname = function(p) {
	  const match = _EXTNAME_RE.exec(normalizeWindowsPath(p));
	  return match && match[1] || "";
	};
	const relative = function(from, to) {
	  const _from = resolve(from).split("/");
	  const _to = resolve(to).split("/");
	  const _fromCopy = [..._from];
	  for (const segment of _fromCopy) {
	    if (_to[0] !== segment) {
	      break;
	    }
	    _from.shift();
	    _to.shift();
	  }
	  return [..._from.map(() => ".."), ..._to].join("/");
	};
	const dirname = function(p) {
	  const segments = normalizeWindowsPath(p).replace(/\/$/, "").split("/").slice(0, -1);
	  if (segments.length === 1 && _DRIVE_LETTER_RE.test(segments[0])) {
	    segments[0] += "/";
	  }
	  return segments.join("/") || (isAbsolute(p) ? "/" : ".");
	};
	const format = function(p) {
	  const segments = [p.root, p.dir, p.base ?? p.name + p.ext].filter(Boolean);
	  return normalizeWindowsPath(
	    p.root ? resolve(...segments) : segments.join("/")
	  );
	};
	const basename = function(p, extension) {
	  const lastSegment = normalizeWindowsPath(p).split("/").pop();
	  return extension && lastSegment.endsWith(extension) ? lastSegment.slice(0, -extension.length) : lastSegment;
	};
	const parse = function(p) {
	  const root = normalizeWindowsPath(p).split("/").shift() || "/";
	  const base = basename(p);
	  const extension = extname(base);
	  return {
	    root,
	    dir: dirname(p),
	    base,
	    ext: extension,
	    name: base.slice(0, base.length - extension.length)
	  };
	};

	const path = {
	  __proto__: null,
	  basename: basename,
	  delimiter: delimiter,
	  dirname: dirname,
	  extname: extname,
	  format: format,
	  isAbsolute: isAbsolute,
	  join: join,
	  normalize: normalize,
	  normalizeString: normalizeString,
	  parse: parse,
	  relative: relative,
	  resolve: resolve,
	  sep: sep,
	  toNamespacedPath: toNamespacedPath
	};

	pathe_adaa73b5.basename = basename;
	pathe_adaa73b5.delimiter = delimiter;
	pathe_adaa73b5.dirname = dirname;
	pathe_adaa73b5.extname = extname;
	pathe_adaa73b5.format = format;
	pathe_adaa73b5.isAbsolute = isAbsolute;
	pathe_adaa73b5.join = join;
	pathe_adaa73b5.normalize = normalize;
	pathe_adaa73b5.normalizeString = normalizeString;
	pathe_adaa73b5.normalizeWindowsPath = normalizeWindowsPath;
	pathe_adaa73b5.parse = parse;
	pathe_adaa73b5.path = path;
	pathe_adaa73b5.relative = relative;
	pathe_adaa73b5.resolve = resolve;
	pathe_adaa73b5.sep = sep;
	pathe_adaa73b5.toNamespacedPath = toNamespacedPath;
	return pathe_adaa73b5;
}

var hasRequiredDist$6;

function requireDist$6 () {
	if (hasRequiredDist$6) return dist$9;
	hasRequiredDist$6 = 1;

	Object.defineProperty(dist$9, '__esModule', { value: true });

	const path = requirePathe_adaa73b5();



	dist$9.basename = path.basename;
	dist$9.default = path.path;
	dist$9.delimiter = path.delimiter;
	dist$9.dirname = path.dirname;
	dist$9.extname = path.extname;
	dist$9.format = path.format;
	dist$9.isAbsolute = path.isAbsolute;
	dist$9.join = path.join;
	dist$9.normalize = path.normalize;
	dist$9.normalizeString = path.normalizeString;
	dist$9.parse = path.parse;
	dist$9.relative = path.relative;
	dist$9.resolve = path.resolve;
	dist$9.sep = path.sep;
	dist$9.toNamespacedPath = path.toNamespacedPath;
	return dist$9;
}

var dist$8 = {};

var acorn = {exports: {}};

var hasRequiredAcorn;

function requireAcorn () {
	if (hasRequiredAcorn) return acorn.exports;
	hasRequiredAcorn = 1;
	(function (module, exports) {
		(function (global, factory) {
		  factory(exports) ;
		})(commonjsGlobal, (function (exports) {
		  // This file was generated. Do not modify manually!
		  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

		  // This file was generated. Do not modify manually!
		  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];

		  // This file was generated. Do not modify manually!
		  var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65";

		  // This file was generated. Do not modify manually!
		  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";

		  // These are a run-length and offset encoded representation of the
		  // >0xffff code points that are a valid part of identifiers. The
		  // offset starts at 0x10000, and each pair of numbers represents an
		  // offset to the next range, and then a size of the range.

		  // Reserved word lists for various dialects of the language

		  var reservedWords = {
		    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
		    5: "class enum extends super const export import",
		    6: "enum",
		    strict: "implements interface let package private protected public static yield",
		    strictBind: "eval arguments"
		  };

		  // And the keywords

		  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

		  var keywords$1 = {
		    5: ecma5AndLessKeywords,
		    "5module": ecma5AndLessKeywords + " export import",
		    6: ecma5AndLessKeywords + " const class extends export import super"
		  };

		  var keywordRelationalOperator = /^in(stanceof)?$/;

		  // ## Character categories

		  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
		  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

		  // This has a complexity linear to the value of the code. The
		  // assumption is that looking up astral identifier characters is
		  // rare.
		  function isInAstralSet(code, set) {
		    var pos = 0x10000;
		    for (var i = 0; i < set.length; i += 2) {
		      pos += set[i];
		      if (pos > code) { return false }
		      pos += set[i + 1];
		      if (pos >= code) { return true }
		    }
		    return false
		  }

		  // Test whether a given character code starts an identifier.

		  function isIdentifierStart(code, astral) {
		    if (code < 65) { return code === 36 }
		    if (code < 91) { return true }
		    if (code < 97) { return code === 95 }
		    if (code < 123) { return true }
		    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
		    if (astral === false) { return false }
		    return isInAstralSet(code, astralIdentifierStartCodes)
		  }

		  // Test whether a given character is part of an identifier.

		  function isIdentifierChar(code, astral) {
		    if (code < 48) { return code === 36 }
		    if (code < 58) { return true }
		    if (code < 65) { return false }
		    if (code < 91) { return true }
		    if (code < 97) { return code === 95 }
		    if (code < 123) { return true }
		    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
		    if (astral === false) { return false }
		    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
		  }

		  // ## Token types

		  // The assignment of fine-grained, information-carrying type objects
		  // allows the tokenizer to store the information it has about a
		  // token in a way that is very cheap for the parser to look up.

		  // All token type variables start with an underscore, to make them
		  // easy to recognize.

		  // The `beforeExpr` property is used to disambiguate between regular
		  // expressions and divisions. It is set on all token types that can
		  // be followed by an expression (thus, a slash after them would be a
		  // regular expression).
		  //
		  // The `startsExpr` property is used to check if the token ends a
		  // `yield` expression. It is set on all token types that either can
		  // directly start an expression (like a quotation mark) or can
		  // continue an expression (like the body of a string).
		  //
		  // `isLoop` marks a keyword as starting a loop, which is important
		  // to know when parsing a label, in order to allow or disallow
		  // continue jumps to that label.

		  var TokenType = function TokenType(label, conf) {
		    if ( conf === void 0 ) conf = {};

		    this.label = label;
		    this.keyword = conf.keyword;
		    this.beforeExpr = !!conf.beforeExpr;
		    this.startsExpr = !!conf.startsExpr;
		    this.isLoop = !!conf.isLoop;
		    this.isAssign = !!conf.isAssign;
		    this.prefix = !!conf.prefix;
		    this.postfix = !!conf.postfix;
		    this.binop = conf.binop || null;
		    this.updateContext = null;
		  };

		  function binop(name, prec) {
		    return new TokenType(name, {beforeExpr: true, binop: prec})
		  }
		  var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

		  // Map keyword names to token types.

		  var keywords = {};

		  // Succinct definitions of keyword token types
		  function kw(name, options) {
		    if ( options === void 0 ) options = {};

		    options.keyword = name;
		    return keywords[name] = new TokenType(name, options)
		  }

		  var types$1 = {
		    num: new TokenType("num", startsExpr),
		    regexp: new TokenType("regexp", startsExpr),
		    string: new TokenType("string", startsExpr),
		    name: new TokenType("name", startsExpr),
		    privateId: new TokenType("privateId", startsExpr),
		    eof: new TokenType("eof"),

		    // Punctuation token types.
		    bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
		    bracketR: new TokenType("]"),
		    braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
		    braceR: new TokenType("}"),
		    parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
		    parenR: new TokenType(")"),
		    comma: new TokenType(",", beforeExpr),
		    semi: new TokenType(";", beforeExpr),
		    colon: new TokenType(":", beforeExpr),
		    dot: new TokenType("."),
		    question: new TokenType("?", beforeExpr),
		    questionDot: new TokenType("?."),
		    arrow: new TokenType("=>", beforeExpr),
		    template: new TokenType("template"),
		    invalidTemplate: new TokenType("invalidTemplate"),
		    ellipsis: new TokenType("...", beforeExpr),
		    backQuote: new TokenType("`", startsExpr),
		    dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

		    // Operators. These carry several kinds of properties to help the
		    // parser use them properly (the presence of these properties is
		    // what categorizes them as operators).
		    //
		    // `binop`, when present, specifies that this operator is a binary
		    // operator, and will refer to its precedence.
		    //
		    // `prefix` and `postfix` mark the operator as a prefix or postfix
		    // unary operator.
		    //
		    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
		    // binary operators with a very low precedence, that should result
		    // in AssignmentExpression nodes.

		    eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
		    assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
		    incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
		    prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
		    logicalOR: binop("||", 1),
		    logicalAND: binop("&&", 2),
		    bitwiseOR: binop("|", 3),
		    bitwiseXOR: binop("^", 4),
		    bitwiseAND: binop("&", 5),
		    equality: binop("==/!=/===/!==", 6),
		    relational: binop("</>/<=/>=", 7),
		    bitShift: binop("<</>>/>>>", 8),
		    plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
		    modulo: binop("%", 10),
		    star: binop("*", 10),
		    slash: binop("/", 10),
		    starstar: new TokenType("**", {beforeExpr: true}),
		    coalesce: binop("??", 1),

		    // Keyword token types.
		    _break: kw("break"),
		    _case: kw("case", beforeExpr),
		    _catch: kw("catch"),
		    _continue: kw("continue"),
		    _debugger: kw("debugger"),
		    _default: kw("default", beforeExpr),
		    _do: kw("do", {isLoop: true, beforeExpr: true}),
		    _else: kw("else", beforeExpr),
		    _finally: kw("finally"),
		    _for: kw("for", {isLoop: true}),
		    _function: kw("function", startsExpr),
		    _if: kw("if"),
		    _return: kw("return", beforeExpr),
		    _switch: kw("switch"),
		    _throw: kw("throw", beforeExpr),
		    _try: kw("try"),
		    _var: kw("var"),
		    _const: kw("const"),
		    _while: kw("while", {isLoop: true}),
		    _with: kw("with"),
		    _new: kw("new", {beforeExpr: true, startsExpr: true}),
		    _this: kw("this", startsExpr),
		    _super: kw("super", startsExpr),
		    _class: kw("class", startsExpr),
		    _extends: kw("extends", beforeExpr),
		    _export: kw("export"),
		    _import: kw("import", startsExpr),
		    _null: kw("null", startsExpr),
		    _true: kw("true", startsExpr),
		    _false: kw("false", startsExpr),
		    _in: kw("in", {beforeExpr: true, binop: 7}),
		    _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
		    _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
		    _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
		    _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
		  };

		  // Matches a whole line break (where CRLF is considered a single
		  // line break). Used to count lines.

		  var lineBreak = /\r\n?|\n|\u2028|\u2029/;
		  var lineBreakG = new RegExp(lineBreak.source, "g");

		  function isNewLine(code) {
		    return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
		  }

		  function nextLineBreak(code, from, end) {
		    if ( end === void 0 ) end = code.length;

		    for (var i = from; i < end; i++) {
		      var next = code.charCodeAt(i);
		      if (isNewLine(next))
		        { return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 }
		    }
		    return -1
		  }

		  var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

		  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

		  var ref = Object.prototype;
		  var hasOwnProperty = ref.hasOwnProperty;
		  var toString = ref.toString;

		  var hasOwn = Object.hasOwn || (function (obj, propName) { return (
		    hasOwnProperty.call(obj, propName)
		  ); });

		  var isArray = Array.isArray || (function (obj) { return (
		    toString.call(obj) === "[object Array]"
		  ); });

		  var regexpCache = Object.create(null);

		  function wordsRegexp(words) {
		    return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"))
		  }

		  function codePointToString(code) {
		    // UTF-16 Decoding
		    if (code <= 0xFFFF) { return String.fromCharCode(code) }
		    code -= 0x10000;
		    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
		  }

		  var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;

		  // These are used when `options.locations` is on, for the
		  // `startLoc` and `endLoc` properties.

		  var Position = function Position(line, col) {
		    this.line = line;
		    this.column = col;
		  };

		  Position.prototype.offset = function offset (n) {
		    return new Position(this.line, this.column + n)
		  };

		  var SourceLocation = function SourceLocation(p, start, end) {
		    this.start = start;
		    this.end = end;
		    if (p.sourceFile !== null) { this.source = p.sourceFile; }
		  };

		  // The `getLineInfo` function is mostly useful when the
		  // `locations` option is off (for performance reasons) and you
		  // want to find the line/column position for a given character
		  // offset. `input` should be the code string that the offset refers
		  // into.

		  function getLineInfo(input, offset) {
		    for (var line = 1, cur = 0;;) {
		      var nextBreak = nextLineBreak(input, cur, offset);
		      if (nextBreak < 0) { return new Position(line, offset - cur) }
		      ++line;
		      cur = nextBreak;
		    }
		  }

		  // A second argument must be given to configure the parser process.
		  // These options are recognized (only `ecmaVersion` is required):

		  var defaultOptions = {
		    // `ecmaVersion` indicates the ECMAScript version to parse. Must be
		    // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
		    // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
		    // (the latest version the library supports). This influences
		    // support for strict mode, the set of reserved words, and support
		    // for new syntax features.
		    ecmaVersion: null,
		    // `sourceType` indicates the mode the code should be parsed in.
		    // Can be either `"script"` or `"module"`. This influences global
		    // strict mode and parsing of `import` and `export` declarations.
		    sourceType: "script",
		    // `onInsertedSemicolon` can be a callback that will be called when
		    // a semicolon is automatically inserted. It will be passed the
		    // position of the inserted semicolon as an offset, and if
		    // `locations` is enabled, it is given the location as a `{line,
		    // column}` object as second argument.
		    onInsertedSemicolon: null,
		    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
		    // trailing commas.
		    onTrailingComma: null,
		    // By default, reserved words are only enforced if ecmaVersion >= 5.
		    // Set `allowReserved` to a boolean value to explicitly turn this on
		    // an off. When this option has the value "never", reserved words
		    // and keywords can also not be used as property names.
		    allowReserved: null,
		    // When enabled, a return at the top level is not considered an
		    // error.
		    allowReturnOutsideFunction: false,
		    // When enabled, import/export statements are not constrained to
		    // appearing at the top of the program, and an import.meta expression
		    // in a script isn't considered an error.
		    allowImportExportEverywhere: false,
		    // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
		    // When enabled, await identifiers are allowed to appear at the top-level scope,
		    // but they are still not allowed in non-async functions.
		    allowAwaitOutsideFunction: null,
		    // When enabled, super identifiers are not constrained to
		    // appearing in methods and do not raise an error when they appear elsewhere.
		    allowSuperOutsideMethod: null,
		    // When enabled, hashbang directive in the beginning of file is
		    // allowed and treated as a line comment. Enabled by default when
		    // `ecmaVersion` >= 2023.
		    allowHashBang: false,
		    // By default, the parser will verify that private properties are
		    // only used in places where they are valid and have been declared.
		    // Set this to false to turn such checks off.
		    checkPrivateFields: true,
		    // When `locations` is on, `loc` properties holding objects with
		    // `start` and `end` properties in `{line, column}` form (with
		    // line being 1-based and column 0-based) will be attached to the
		    // nodes.
		    locations: false,
		    // A function can be passed as `onToken` option, which will
		    // cause Acorn to call that function with object in the same
		    // format as tokens returned from `tokenizer().getToken()`. Note
		    // that you are not allowed to call the parser from the
		    // callback—that will corrupt its internal state.
		    onToken: null,
		    // A function can be passed as `onComment` option, which will
		    // cause Acorn to call that function with `(block, text, start,
		    // end)` parameters whenever a comment is skipped. `block` is a
		    // boolean indicating whether this is a block (`/* */`) comment,
		    // `text` is the content of the comment, and `start` and `end` are
		    // character offsets that denote the start and end of the comment.
		    // When the `locations` option is on, two more parameters are
		    // passed, the full `{line, column}` locations of the start and
		    // end of the comments. Note that you are not allowed to call the
		    // parser from the callback—that will corrupt its internal state.
		    // When this option has an array as value, objects representing the
		    // comments are pushed to it.
		    onComment: null,
		    // Nodes have their start and end characters offsets recorded in
		    // `start` and `end` properties (directly on the node, rather than
		    // the `loc` object, which holds line/column data. To also add a
		    // [semi-standardized][range] `range` property holding a `[start,
		    // end]` array with the same numbers, set the `ranges` option to
		    // `true`.
		    //
		    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
		    ranges: false,
		    // It is possible to parse multiple files into a single AST by
		    // passing the tree produced by parsing the first file as
		    // `program` option in subsequent parses. This will add the
		    // toplevel forms of the parsed file to the `Program` (top) node
		    // of an existing parse tree.
		    program: null,
		    // When `locations` is on, you can pass this to record the source
		    // file in every node's `loc` object.
		    sourceFile: null,
		    // This value, if given, is stored in every node, whether
		    // `locations` is on or off.
		    directSourceFile: null,
		    // When enabled, parenthesized expressions are represented by
		    // (non-standard) ParenthesizedExpression nodes
		    preserveParens: false
		  };

		  // Interpret and default an options object

		  var warnedAboutEcmaVersion = false;

		  function getOptions(opts) {
		    var options = {};

		    for (var opt in defaultOptions)
		      { options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt]; }

		    if (options.ecmaVersion === "latest") {
		      options.ecmaVersion = 1e8;
		    } else if (options.ecmaVersion == null) {
		      if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
		        warnedAboutEcmaVersion = true;
		        console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
		      }
		      options.ecmaVersion = 11;
		    } else if (options.ecmaVersion >= 2015) {
		      options.ecmaVersion -= 2009;
		    }

		    if (options.allowReserved == null)
		      { options.allowReserved = options.ecmaVersion < 5; }

		    if (!opts || opts.allowHashBang == null)
		      { options.allowHashBang = options.ecmaVersion >= 14; }

		    if (isArray(options.onToken)) {
		      var tokens = options.onToken;
		      options.onToken = function (token) { return tokens.push(token); };
		    }
		    if (isArray(options.onComment))
		      { options.onComment = pushComment(options, options.onComment); }

		    return options
		  }

		  function pushComment(options, array) {
		    return function(block, text, start, end, startLoc, endLoc) {
		      var comment = {
		        type: block ? "Block" : "Line",
		        value: text,
		        start: start,
		        end: end
		      };
		      if (options.locations)
		        { comment.loc = new SourceLocation(this, startLoc, endLoc); }
		      if (options.ranges)
		        { comment.range = [start, end]; }
		      array.push(comment);
		    }
		  }

		  // Each scope gets a bitset that may contain these flags
		  var
		      SCOPE_TOP = 1,
		      SCOPE_FUNCTION = 2,
		      SCOPE_ASYNC = 4,
		      SCOPE_GENERATOR = 8,
		      SCOPE_ARROW = 16,
		      SCOPE_SIMPLE_CATCH = 32,
		      SCOPE_SUPER = 64,
		      SCOPE_DIRECT_SUPER = 128,
		      SCOPE_CLASS_STATIC_BLOCK = 256,
		      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;

		  function functionFlags(async, generator) {
		    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
		  }

		  // Used in checkLVal* and declareName to determine the type of a binding
		  var
		      BIND_NONE = 0, // Not a binding
		      BIND_VAR = 1, // Var-style binding
		      BIND_LEXICAL = 2, // Let- or const-style binding
		      BIND_FUNCTION = 3, // Function declaration
		      BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
		      BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

		  var Parser = function Parser(options, input, startPos) {
		    this.options = options = getOptions(options);
		    this.sourceFile = options.sourceFile;
		    this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
		    var reserved = "";
		    if (options.allowReserved !== true) {
		      reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
		      if (options.sourceType === "module") { reserved += " await"; }
		    }
		    this.reservedWords = wordsRegexp(reserved);
		    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
		    this.reservedWordsStrict = wordsRegexp(reservedStrict);
		    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
		    this.input = String(input);

		    // Used to signal to callers of `readWord1` whether the word
		    // contained any escape sequences. This is needed because words with
		    // escape sequences must not be interpreted as keywords.
		    this.containsEsc = false;

		    // Set up token state

		    // The current position of the tokenizer in the input.
		    if (startPos) {
		      this.pos = startPos;
		      this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
		      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
		    } else {
		      this.pos = this.lineStart = 0;
		      this.curLine = 1;
		    }

		    // Properties of the current token:
		    // Its type
		    this.type = types$1.eof;
		    // For tokens that include more information than their type, the value
		    this.value = null;
		    // Its start and end offset
		    this.start = this.end = this.pos;
		    // And, if locations are used, the {line, column} object
		    // corresponding to those offsets
		    this.startLoc = this.endLoc = this.curPosition();

		    // Position information for the previous token
		    this.lastTokEndLoc = this.lastTokStartLoc = null;
		    this.lastTokStart = this.lastTokEnd = this.pos;

		    // The context stack is used to superficially track syntactic
		    // context to predict whether a regular expression is allowed in a
		    // given position.
		    this.context = this.initialContext();
		    this.exprAllowed = true;

		    // Figure out if it's a module code.
		    this.inModule = options.sourceType === "module";
		    this.strict = this.inModule || this.strictDirective(this.pos);

		    // Used to signify the start of a potential arrow function
		    this.potentialArrowAt = -1;
		    this.potentialArrowInForAwait = false;

		    // Positions to delayed-check that yield/await does not exist in default parameters.
		    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
		    // Labels in scope.
		    this.labels = [];
		    // Thus-far undefined exports.
		    this.undefinedExports = Object.create(null);

		    // If enabled, skip leading hashbang line.
		    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
		      { this.skipLineComment(2); }

		    // Scope tracking for duplicate variable names (see scope.js)
		    this.scopeStack = [];
		    this.enterScope(SCOPE_TOP);

		    // For RegExp validation
		    this.regexpState = null;

		    // The stack of private names.
		    // Each element has two properties: 'declared' and 'used'.
		    // When it exited from the outermost class definition, all used private names must be declared.
		    this.privateNameStack = [];
		  };

		  var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },canAwait: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true },allowNewDotTarget: { configurable: true },inClassStaticBlock: { configurable: true } };

		  Parser.prototype.parse = function parse () {
		    var node = this.options.program || this.startNode();
		    this.nextToken();
		    return this.parseTopLevel(node)
		  };

		  prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };

		  prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit };

		  prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit };

		  prototypeAccessors.canAwait.get = function () {
		    for (var i = this.scopeStack.length - 1; i >= 0; i--) {
		      var scope = this.scopeStack[i];
		      if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) { return false }
		      if (scope.flags & SCOPE_FUNCTION) { return (scope.flags & SCOPE_ASYNC) > 0 }
		    }
		    return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction
		  };

		  prototypeAccessors.allowSuper.get = function () {
		    var ref = this.currentThisScope();
		      var flags = ref.flags;
		      var inClassFieldInit = ref.inClassFieldInit;
		    return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod
		  };

		  prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };

		  prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

		  prototypeAccessors.allowNewDotTarget.get = function () {
		    var ref = this.currentThisScope();
		      var flags = ref.flags;
		      var inClassFieldInit = ref.inClassFieldInit;
		    return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit
		  };

		  prototypeAccessors.inClassStaticBlock.get = function () {
		    return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0
		  };

		  Parser.extend = function extend () {
		      var plugins = [], len = arguments.length;
		      while ( len-- ) plugins[ len ] = arguments[ len ];

		    var cls = this;
		    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
		    return cls
		  };

		  Parser.parse = function parse (input, options) {
		    return new this(options, input).parse()
		  };

		  Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
		    var parser = new this(options, input, pos);
		    parser.nextToken();
		    return parser.parseExpression()
		  };

		  Parser.tokenizer = function tokenizer (input, options) {
		    return new this(options, input)
		  };

		  Object.defineProperties( Parser.prototype, prototypeAccessors );

		  var pp$9 = Parser.prototype;

		  // ## Parser utilities

		  var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
		  pp$9.strictDirective = function(start) {
		    if (this.options.ecmaVersion < 5) { return false }
		    for (;;) {
		      // Try to find string literal.
		      skipWhiteSpace.lastIndex = start;
		      start += skipWhiteSpace.exec(this.input)[0].length;
		      var match = literal.exec(this.input.slice(start));
		      if (!match) { return false }
		      if ((match[1] || match[2]) === "use strict") {
		        skipWhiteSpace.lastIndex = start + match[0].length;
		        var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
		        var next = this.input.charAt(end);
		        return next === ";" || next === "}" ||
		          (lineBreak.test(spaceAfter[0]) &&
		           !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "="))
		      }
		      start += match[0].length;

		      // Skip semicolon, if any.
		      skipWhiteSpace.lastIndex = start;
		      start += skipWhiteSpace.exec(this.input)[0].length;
		      if (this.input[start] === ";")
		        { start++; }
		    }
		  };

		  // Predicate that tests whether the next token is of the given
		  // type, and if yes, consumes it as a side effect.

		  pp$9.eat = function(type) {
		    if (this.type === type) {
		      this.next();
		      return true
		    } else {
		      return false
		    }
		  };

		  // Tests whether parsed token is a contextual keyword.

		  pp$9.isContextual = function(name) {
		    return this.type === types$1.name && this.value === name && !this.containsEsc
		  };

		  // Consumes contextual keyword if possible.

		  pp$9.eatContextual = function(name) {
		    if (!this.isContextual(name)) { return false }
		    this.next();
		    return true
		  };

		  // Asserts that following token is given contextual keyword.

		  pp$9.expectContextual = function(name) {
		    if (!this.eatContextual(name)) { this.unexpected(); }
		  };

		  // Test whether a semicolon can be inserted at the current position.

		  pp$9.canInsertSemicolon = function() {
		    return this.type === types$1.eof ||
		      this.type === types$1.braceR ||
		      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
		  };

		  pp$9.insertSemicolon = function() {
		    if (this.canInsertSemicolon()) {
		      if (this.options.onInsertedSemicolon)
		        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
		      return true
		    }
		  };

		  // Consume a semicolon, or, failing that, see if we are allowed to
		  // pretend that there is a semicolon at this position.

		  pp$9.semicolon = function() {
		    if (!this.eat(types$1.semi) && !this.insertSemicolon()) { this.unexpected(); }
		  };

		  pp$9.afterTrailingComma = function(tokType, notNext) {
		    if (this.type === tokType) {
		      if (this.options.onTrailingComma)
		        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
		      if (!notNext)
		        { this.next(); }
		      return true
		    }
		  };

		  // Expect a token of a given type. If found, consume it, otherwise,
		  // raise an unexpected token error.

		  pp$9.expect = function(type) {
		    this.eat(type) || this.unexpected();
		  };

		  // Raise an unexpected token error.

		  pp$9.unexpected = function(pos) {
		    this.raise(pos != null ? pos : this.start, "Unexpected token");
		  };

		  var DestructuringErrors = function DestructuringErrors() {
		    this.shorthandAssign =
		    this.trailingComma =
		    this.parenthesizedAssign =
		    this.parenthesizedBind =
		    this.doubleProto =
		      -1;
		  };

		  pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
		    if (!refDestructuringErrors) { return }
		    if (refDestructuringErrors.trailingComma > -1)
		      { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
		    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
		    if (parens > -1) { this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern"); }
		  };

		  pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
		    if (!refDestructuringErrors) { return false }
		    var shorthandAssign = refDestructuringErrors.shorthandAssign;
		    var doubleProto = refDestructuringErrors.doubleProto;
		    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
		    if (shorthandAssign >= 0)
		      { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
		    if (doubleProto >= 0)
		      { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
		  };

		  pp$9.checkYieldAwaitInDefaultParams = function() {
		    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
		      { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
		    if (this.awaitPos)
		      { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
		  };

		  pp$9.isSimpleAssignTarget = function(expr) {
		    if (expr.type === "ParenthesizedExpression")
		      { return this.isSimpleAssignTarget(expr.expression) }
		    return expr.type === "Identifier" || expr.type === "MemberExpression"
		  };

		  var pp$8 = Parser.prototype;

		  // ### Statement parsing

		  // Parse a program. Initializes the parser, reads any number of
		  // statements, and wraps them in a Program node.  Optionally takes a
		  // `program` argument.  If present, the statements will be appended
		  // to its body instead of creating a new node.

		  pp$8.parseTopLevel = function(node) {
		    var exports = Object.create(null);
		    if (!node.body) { node.body = []; }
		    while (this.type !== types$1.eof) {
		      var stmt = this.parseStatement(null, true, exports);
		      node.body.push(stmt);
		    }
		    if (this.inModule)
		      { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
		        {
		          var name = list[i];

		          this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
		        } }
		    this.adaptDirectivePrologue(node.body);
		    this.next();
		    node.sourceType = this.options.sourceType;
		    return this.finishNode(node, "Program")
		  };

		  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

		  pp$8.isLet = function(context) {
		    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
		    skipWhiteSpace.lastIndex = this.pos;
		    var skip = skipWhiteSpace.exec(this.input);
		    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
		    // For ambiguous cases, determine if a LexicalDeclaration (or only a
		    // Statement) is allowed here. If context is not empty then only a Statement
		    // is allowed. However, `let [` is an explicit negative lookahead for
		    // ExpressionStatement, so special-case it first.
		    if (nextCh === 91 || nextCh === 92) { return true } // '[', '/'
		    if (context) { return false }

		    if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true } // '{', astral
		    if (isIdentifierStart(nextCh, true)) {
		      var pos = next + 1;
		      while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) { ++pos; }
		      if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true }
		      var ident = this.input.slice(next, pos);
		      if (!keywordRelationalOperator.test(ident)) { return true }
		    }
		    return false
		  };

		  // check 'async [no LineTerminator here] function'
		  // - 'async /*foo*/ function' is OK.
		  // - 'async /*\n*/ function' is invalid.
		  pp$8.isAsyncFunction = function() {
		    if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
		      { return false }

		    skipWhiteSpace.lastIndex = this.pos;
		    var skip = skipWhiteSpace.exec(this.input);
		    var next = this.pos + skip[0].length, after;
		    return !lineBreak.test(this.input.slice(this.pos, next)) &&
		      this.input.slice(next, next + 8) === "function" &&
		      (next + 8 === this.input.length ||
		       !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00))
		  };

		  // Parse a single statement.
		  //
		  // If expecting a statement and finding a slash operator, parse a
		  // regular expression literal. This is to handle cases like
		  // `if (foo) /blah/.exec(foo)`, where looking at the previous token
		  // does not help.

		  pp$8.parseStatement = function(context, topLevel, exports) {
		    var starttype = this.type, node = this.startNode(), kind;

		    if (this.isLet(context)) {
		      starttype = types$1._var;
		      kind = "let";
		    }

		    // Most types of statements are recognized by the keyword they
		    // start with. Many are trivial to parse, some require a bit of
		    // complexity.

		    switch (starttype) {
		    case types$1._break: case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
		    case types$1._debugger: return this.parseDebuggerStatement(node)
		    case types$1._do: return this.parseDoStatement(node)
		    case types$1._for: return this.parseForStatement(node)
		    case types$1._function:
		      // Function as sole body of either an if statement or a labeled statement
		      // works, but not when it is part of a labeled statement that is the sole
		      // body of an if statement.
		      if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
		      return this.parseFunctionStatement(node, false, !context)
		    case types$1._class:
		      if (context) { this.unexpected(); }
		      return this.parseClass(node, true)
		    case types$1._if: return this.parseIfStatement(node)
		    case types$1._return: return this.parseReturnStatement(node)
		    case types$1._switch: return this.parseSwitchStatement(node)
		    case types$1._throw: return this.parseThrowStatement(node)
		    case types$1._try: return this.parseTryStatement(node)
		    case types$1._const: case types$1._var:
		      kind = kind || this.value;
		      if (context && kind !== "var") { this.unexpected(); }
		      return this.parseVarStatement(node, kind)
		    case types$1._while: return this.parseWhileStatement(node)
		    case types$1._with: return this.parseWithStatement(node)
		    case types$1.braceL: return this.parseBlock(true, node)
		    case types$1.semi: return this.parseEmptyStatement(node)
		    case types$1._export:
		    case types$1._import:
		      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
		        skipWhiteSpace.lastIndex = this.pos;
		        var skip = skipWhiteSpace.exec(this.input);
		        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
		        if (nextCh === 40 || nextCh === 46) // '(' or '.'
		          { return this.parseExpressionStatement(node, this.parseExpression()) }
		      }

		      if (!this.options.allowImportExportEverywhere) {
		        if (!topLevel)
		          { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
		        if (!this.inModule)
		          { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
		      }
		      return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports)

		      // If the statement does not start with a statement keyword or a
		      // brace, it's an ExpressionStatement or LabeledStatement. We
		      // simply start parsing an expression, and afterwards, if the
		      // next token is a colon and the expression was a simple
		      // Identifier node, we switch to interpreting it as a label.
		    default:
		      if (this.isAsyncFunction()) {
		        if (context) { this.unexpected(); }
		        this.next();
		        return this.parseFunctionStatement(node, true, !context)
		      }

		      var maybeName = this.value, expr = this.parseExpression();
		      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon))
		        { return this.parseLabeledStatement(node, maybeName, expr, context) }
		      else { return this.parseExpressionStatement(node, expr) }
		    }
		  };

		  pp$8.parseBreakContinueStatement = function(node, keyword) {
		    var isBreak = keyword === "break";
		    this.next();
		    if (this.eat(types$1.semi) || this.insertSemicolon()) { node.label = null; }
		    else if (this.type !== types$1.name) { this.unexpected(); }
		    else {
		      node.label = this.parseIdent();
		      this.semicolon();
		    }

		    // Verify that there is an actual destination to break or
		    // continue to.
		    var i = 0;
		    for (; i < this.labels.length; ++i) {
		      var lab = this.labels[i];
		      if (node.label == null || lab.name === node.label.name) {
		        if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
		        if (node.label && isBreak) { break }
		      }
		    }
		    if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
		    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
		  };

		  pp$8.parseDebuggerStatement = function(node) {
		    this.next();
		    this.semicolon();
		    return this.finishNode(node, "DebuggerStatement")
		  };

		  pp$8.parseDoStatement = function(node) {
		    this.next();
		    this.labels.push(loopLabel);
		    node.body = this.parseStatement("do");
		    this.labels.pop();
		    this.expect(types$1._while);
		    node.test = this.parseParenExpression();
		    if (this.options.ecmaVersion >= 6)
		      { this.eat(types$1.semi); }
		    else
		      { this.semicolon(); }
		    return this.finishNode(node, "DoWhileStatement")
		  };

		  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
		  // loop is non-trivial. Basically, we have to parse the init `var`
		  // statement or expression, disallowing the `in` operator (see
		  // the second parameter to `parseExpression`), and then check
		  // whether the next token is `in` or `of`. When there is no init
		  // part (semicolon immediately after the opening parenthesis), it
		  // is a regular `for` loop.

		  pp$8.parseForStatement = function(node) {
		    this.next();
		    var awaitAt = (this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await")) ? this.lastTokStart : -1;
		    this.labels.push(loopLabel);
		    this.enterScope(0);
		    this.expect(types$1.parenL);
		    if (this.type === types$1.semi) {
		      if (awaitAt > -1) { this.unexpected(awaitAt); }
		      return this.parseFor(node, null)
		    }
		    var isLet = this.isLet();
		    if (this.type === types$1._var || this.type === types$1._const || isLet) {
		      var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
		      this.next();
		      this.parseVar(init$1, true, kind);
		      this.finishNode(init$1, "VariableDeclaration");
		      if ((this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
		        if (this.options.ecmaVersion >= 9) {
		          if (this.type === types$1._in) {
		            if (awaitAt > -1) { this.unexpected(awaitAt); }
		          } else { node.await = awaitAt > -1; }
		        }
		        return this.parseForIn(node, init$1)
		      }
		      if (awaitAt > -1) { this.unexpected(awaitAt); }
		      return this.parseFor(node, init$1)
		    }
		    var startsWithLet = this.isContextual("let"), isForOf = false;
		    var refDestructuringErrors = new DestructuringErrors;
		    var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
		    if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
		      if (this.options.ecmaVersion >= 9) {
		        if (this.type === types$1._in) {
		          if (awaitAt > -1) { this.unexpected(awaitAt); }
		        } else { node.await = awaitAt > -1; }
		      }
		      if (startsWithLet && isForOf) { this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'."); }
		      this.toAssignable(init, false, refDestructuringErrors);
		      this.checkLValPattern(init);
		      return this.parseForIn(node, init)
		    } else {
		      this.checkExpressionErrors(refDestructuringErrors, true);
		    }
		    if (awaitAt > -1) { this.unexpected(awaitAt); }
		    return this.parseFor(node, init)
		  };

		  pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
		    this.next();
		    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
		  };

		  pp$8.parseIfStatement = function(node) {
		    this.next();
		    node.test = this.parseParenExpression();
		    // allow function declarations in branches, but only in non-strict mode
		    node.consequent = this.parseStatement("if");
		    node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
		    return this.finishNode(node, "IfStatement")
		  };

		  pp$8.parseReturnStatement = function(node) {
		    if (!this.inFunction && !this.options.allowReturnOutsideFunction)
		      { this.raise(this.start, "'return' outside of function"); }
		    this.next();

		    // In `return` (and `break`/`continue`), the keywords with
		    // optional arguments, we eagerly look for a semicolon or the
		    // possibility to insert one.

		    if (this.eat(types$1.semi) || this.insertSemicolon()) { node.argument = null; }
		    else { node.argument = this.parseExpression(); this.semicolon(); }
		    return this.finishNode(node, "ReturnStatement")
		  };

		  pp$8.parseSwitchStatement = function(node) {
		    this.next();
		    node.discriminant = this.parseParenExpression();
		    node.cases = [];
		    this.expect(types$1.braceL);
		    this.labels.push(switchLabel);
		    this.enterScope(0);

		    // Statements under must be grouped (by label) in SwitchCase
		    // nodes. `cur` is used to keep the node that we are currently
		    // adding statements to.

		    var cur;
		    for (var sawDefault = false; this.type !== types$1.braceR;) {
		      if (this.type === types$1._case || this.type === types$1._default) {
		        var isCase = this.type === types$1._case;
		        if (cur) { this.finishNode(cur, "SwitchCase"); }
		        node.cases.push(cur = this.startNode());
		        cur.consequent = [];
		        this.next();
		        if (isCase) {
		          cur.test = this.parseExpression();
		        } else {
		          if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
		          sawDefault = true;
		          cur.test = null;
		        }
		        this.expect(types$1.colon);
		      } else {
		        if (!cur) { this.unexpected(); }
		        cur.consequent.push(this.parseStatement(null));
		      }
		    }
		    this.exitScope();
		    if (cur) { this.finishNode(cur, "SwitchCase"); }
		    this.next(); // Closing brace
		    this.labels.pop();
		    return this.finishNode(node, "SwitchStatement")
		  };

		  pp$8.parseThrowStatement = function(node) {
		    this.next();
		    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
		      { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
		    node.argument = this.parseExpression();
		    this.semicolon();
		    return this.finishNode(node, "ThrowStatement")
		  };

		  // Reused empty array added for node fields that are always empty.

		  var empty$1 = [];

		  pp$8.parseCatchClauseParam = function() {
		    var param = this.parseBindingAtom();
		    var simple = param.type === "Identifier";
		    this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
		    this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
		    this.expect(types$1.parenR);

		    return param
		  };

		  pp$8.parseTryStatement = function(node) {
		    this.next();
		    node.block = this.parseBlock();
		    node.handler = null;
		    if (this.type === types$1._catch) {
		      var clause = this.startNode();
		      this.next();
		      if (this.eat(types$1.parenL)) {
		        clause.param = this.parseCatchClauseParam();
		      } else {
		        if (this.options.ecmaVersion < 10) { this.unexpected(); }
		        clause.param = null;
		        this.enterScope(0);
		      }
		      clause.body = this.parseBlock(false);
		      this.exitScope();
		      node.handler = this.finishNode(clause, "CatchClause");
		    }
		    node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
		    if (!node.handler && !node.finalizer)
		      { this.raise(node.start, "Missing catch or finally clause"); }
		    return this.finishNode(node, "TryStatement")
		  };

		  pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
		    this.next();
		    this.parseVar(node, false, kind, allowMissingInitializer);
		    this.semicolon();
		    return this.finishNode(node, "VariableDeclaration")
		  };

		  pp$8.parseWhileStatement = function(node) {
		    this.next();
		    node.test = this.parseParenExpression();
		    this.labels.push(loopLabel);
		    node.body = this.parseStatement("while");
		    this.labels.pop();
		    return this.finishNode(node, "WhileStatement")
		  };

		  pp$8.parseWithStatement = function(node) {
		    if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
		    this.next();
		    node.object = this.parseParenExpression();
		    node.body = this.parseStatement("with");
		    return this.finishNode(node, "WithStatement")
		  };

		  pp$8.parseEmptyStatement = function(node) {
		    this.next();
		    return this.finishNode(node, "EmptyStatement")
		  };

		  pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
		    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
		      {
		      var label = list[i$1];

		      if (label.name === maybeName)
		        { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
		    } }
		    var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
		    for (var i = this.labels.length - 1; i >= 0; i--) {
		      var label$1 = this.labels[i];
		      if (label$1.statementStart === node.start) {
		        // Update information about previous labels on this node
		        label$1.statementStart = this.start;
		        label$1.kind = kind;
		      } else { break }
		    }
		    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
		    node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
		    this.labels.pop();
		    node.label = expr;
		    return this.finishNode(node, "LabeledStatement")
		  };

		  pp$8.parseExpressionStatement = function(node, expr) {
		    node.expression = expr;
		    this.semicolon();
		    return this.finishNode(node, "ExpressionStatement")
		  };

		  // Parse a semicolon-enclosed block of statements, handling `"use
		  // strict"` declarations when `allowStrict` is true (used for
		  // function bodies).

		  pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
		    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
		    if ( node === void 0 ) node = this.startNode();

		    node.body = [];
		    this.expect(types$1.braceL);
		    if (createNewLexicalScope) { this.enterScope(0); }
		    while (this.type !== types$1.braceR) {
		      var stmt = this.parseStatement(null);
		      node.body.push(stmt);
		    }
		    if (exitStrict) { this.strict = false; }
		    this.next();
		    if (createNewLexicalScope) { this.exitScope(); }
		    return this.finishNode(node, "BlockStatement")
		  };

		  // Parse a regular `for` loop. The disambiguation code in
		  // `parseStatement` will already have parsed the init statement or
		  // expression.

		  pp$8.parseFor = function(node, init) {
		    node.init = init;
		    this.expect(types$1.semi);
		    node.test = this.type === types$1.semi ? null : this.parseExpression();
		    this.expect(types$1.semi);
		    node.update = this.type === types$1.parenR ? null : this.parseExpression();
		    this.expect(types$1.parenR);
		    node.body = this.parseStatement("for");
		    this.exitScope();
		    this.labels.pop();
		    return this.finishNode(node, "ForStatement")
		  };

		  // Parse a `for`/`in` and `for`/`of` loop, which are almost
		  // same from parser's perspective.

		  pp$8.parseForIn = function(node, init) {
		    var isForIn = this.type === types$1._in;
		    this.next();

		    if (
		      init.type === "VariableDeclaration" &&
		      init.declarations[0].init != null &&
		      (
		        !isForIn ||
		        this.options.ecmaVersion < 8 ||
		        this.strict ||
		        init.kind !== "var" ||
		        init.declarations[0].id.type !== "Identifier"
		      )
		    ) {
		      this.raise(
		        init.start,
		        ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
		      );
		    }
		    node.left = init;
		    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
		    this.expect(types$1.parenR);
		    node.body = this.parseStatement("for");
		    this.exitScope();
		    this.labels.pop();
		    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
		  };

		  // Parse a list of variable declarations.

		  pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
		    node.declarations = [];
		    node.kind = kind;
		    for (;;) {
		      var decl = this.startNode();
		      this.parseVarId(decl, kind);
		      if (this.eat(types$1.eq)) {
		        decl.init = this.parseMaybeAssign(isFor);
		      } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
		        this.unexpected();
		      } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
		        this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
		      } else {
		        decl.init = null;
		      }
		      node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
		      if (!this.eat(types$1.comma)) { break }
		    }
		    return node
		  };

		  pp$8.parseVarId = function(decl, kind) {
		    decl.id = this.parseBindingAtom();
		    this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
		  };

		  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

		  // Parse a function declaration or literal (depending on the
		  // `statement & FUNC_STATEMENT`).

		  // Remove `allowExpressionBody` for 7.0.0, as it is only called with false
		  pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
		    this.initFunction(node);
		    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
		      if (this.type === types$1.star && (statement & FUNC_HANGING_STATEMENT))
		        { this.unexpected(); }
		      node.generator = this.eat(types$1.star);
		    }
		    if (this.options.ecmaVersion >= 8)
		      { node.async = !!isAsync; }

		    if (statement & FUNC_STATEMENT) {
		      node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types$1.name ? null : this.parseIdent();
		      if (node.id && !(statement & FUNC_HANGING_STATEMENT))
		        // If it is a regular function declaration in sloppy mode, then it is
		        // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
		        // mode depends on properties of the current scope (see
		        // treatFunctionsAsVar).
		        { this.checkLValSimple(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
		    }

		    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
		    this.yieldPos = 0;
		    this.awaitPos = 0;
		    this.awaitIdentPos = 0;
		    this.enterScope(functionFlags(node.async, node.generator));

		    if (!(statement & FUNC_STATEMENT))
		      { node.id = this.type === types$1.name ? this.parseIdent() : null; }

		    this.parseFunctionParams(node);
		    this.parseFunctionBody(node, allowExpressionBody, false, forInit);

		    this.yieldPos = oldYieldPos;
		    this.awaitPos = oldAwaitPos;
		    this.awaitIdentPos = oldAwaitIdentPos;
		    return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
		  };

		  pp$8.parseFunctionParams = function(node) {
		    this.expect(types$1.parenL);
		    node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
		    this.checkYieldAwaitInDefaultParams();
		  };

		  // Parse a class declaration or literal (depending on the
		  // `isStatement` parameter).

		  pp$8.parseClass = function(node, isStatement) {
		    this.next();

		    // ecma-262 14.6 Class Definitions
		    // A class definition is always strict mode code.
		    var oldStrict = this.strict;
		    this.strict = true;

		    this.parseClassId(node, isStatement);
		    this.parseClassSuper(node);
		    var privateNameMap = this.enterClassBody();
		    var classBody = this.startNode();
		    var hadConstructor = false;
		    classBody.body = [];
		    this.expect(types$1.braceL);
		    while (this.type !== types$1.braceR) {
		      var element = this.parseClassElement(node.superClass !== null);
		      if (element) {
		        classBody.body.push(element);
		        if (element.type === "MethodDefinition" && element.kind === "constructor") {
		          if (hadConstructor) { this.raiseRecoverable(element.start, "Duplicate constructor in the same class"); }
		          hadConstructor = true;
		        } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
		          this.raiseRecoverable(element.key.start, ("Identifier '#" + (element.key.name) + "' has already been declared"));
		        }
		      }
		    }
		    this.strict = oldStrict;
		    this.next();
		    node.body = this.finishNode(classBody, "ClassBody");
		    this.exitClassBody();
		    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
		  };

		  pp$8.parseClassElement = function(constructorAllowsSuper) {
		    if (this.eat(types$1.semi)) { return null }

		    var ecmaVersion = this.options.ecmaVersion;
		    var node = this.startNode();
		    var keyName = "";
		    var isGenerator = false;
		    var isAsync = false;
		    var kind = "method";
		    var isStatic = false;

		    if (this.eatContextual("static")) {
		      // Parse static init block
		      if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
		        this.parseClassStaticBlock(node);
		        return node
		      }
		      if (this.isClassElementNameStart() || this.type === types$1.star) {
		        isStatic = true;
		      } else {
		        keyName = "static";
		      }
		    }
		    node.static = isStatic;
		    if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
		      if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
		        isAsync = true;
		      } else {
		        keyName = "async";
		      }
		    }
		    if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
		      isGenerator = true;
		    }
		    if (!keyName && !isAsync && !isGenerator) {
		      var lastValue = this.value;
		      if (this.eatContextual("get") || this.eatContextual("set")) {
		        if (this.isClassElementNameStart()) {
		          kind = lastValue;
		        } else {
		          keyName = lastValue;
		        }
		      }
		    }

		    // Parse element name
		    if (keyName) {
		      // 'async', 'get', 'set', or 'static' were not a keyword contextually.
		      // The last token is any of those. Make it the element name.
		      node.computed = false;
		      node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
		      node.key.name = keyName;
		      this.finishNode(node.key, "Identifier");
		    } else {
		      this.parseClassElementName(node);
		    }

		    // Parse element value
		    if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
		      var isConstructor = !node.static && checkKeyName(node, "constructor");
		      var allowsDirectSuper = isConstructor && constructorAllowsSuper;
		      // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.
		      if (isConstructor && kind !== "method") { this.raise(node.key.start, "Constructor can't have get/set modifier"); }
		      node.kind = isConstructor ? "constructor" : kind;
		      this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
		    } else {
		      this.parseClassField(node);
		    }

		    return node
		  };

		  pp$8.isClassElementNameStart = function() {
		    return (
		      this.type === types$1.name ||
		      this.type === types$1.privateId ||
		      this.type === types$1.num ||
		      this.type === types$1.string ||
		      this.type === types$1.bracketL ||
		      this.type.keyword
		    )
		  };

		  pp$8.parseClassElementName = function(element) {
		    if (this.type === types$1.privateId) {
		      if (this.value === "constructor") {
		        this.raise(this.start, "Classes can't have an element named '#constructor'");
		      }
		      element.computed = false;
		      element.key = this.parsePrivateIdent();
		    } else {
		      this.parsePropertyName(element);
		    }
		  };

		  pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
		    // Check key and flags
		    var key = method.key;
		    if (method.kind === "constructor") {
		      if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
		      if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
		    } else if (method.static && checkKeyName(method, "prototype")) {
		      this.raise(key.start, "Classes may not have a static property named prototype");
		    }

		    // Parse value
		    var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);

		    // Check value
		    if (method.kind === "get" && value.params.length !== 0)
		      { this.raiseRecoverable(value.start, "getter should have no params"); }
		    if (method.kind === "set" && value.params.length !== 1)
		      { this.raiseRecoverable(value.start, "setter should have exactly one param"); }
		    if (method.kind === "set" && value.params[0].type === "RestElement")
		      { this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params"); }

		    return this.finishNode(method, "MethodDefinition")
		  };

		  pp$8.parseClassField = function(field) {
		    if (checkKeyName(field, "constructor")) {
		      this.raise(field.key.start, "Classes can't have a field named 'constructor'");
		    } else if (field.static && checkKeyName(field, "prototype")) {
		      this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
		    }

		    if (this.eat(types$1.eq)) {
		      // To raise SyntaxError if 'arguments' exists in the initializer.
		      var scope = this.currentThisScope();
		      var inClassFieldInit = scope.inClassFieldInit;
		      scope.inClassFieldInit = true;
		      field.value = this.parseMaybeAssign();
		      scope.inClassFieldInit = inClassFieldInit;
		    } else {
		      field.value = null;
		    }
		    this.semicolon();

		    return this.finishNode(field, "PropertyDefinition")
		  };

		  pp$8.parseClassStaticBlock = function(node) {
		    node.body = [];

		    var oldLabels = this.labels;
		    this.labels = [];
		    this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
		    while (this.type !== types$1.braceR) {
		      var stmt = this.parseStatement(null);
		      node.body.push(stmt);
		    }
		    this.next();
		    this.exitScope();
		    this.labels = oldLabels;

		    return this.finishNode(node, "StaticBlock")
		  };

		  pp$8.parseClassId = function(node, isStatement) {
		    if (this.type === types$1.name) {
		      node.id = this.parseIdent();
		      if (isStatement)
		        { this.checkLValSimple(node.id, BIND_LEXICAL, false); }
		    } else {
		      if (isStatement === true)
		        { this.unexpected(); }
		      node.id = null;
		    }
		  };

		  pp$8.parseClassSuper = function(node) {
		    node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
		  };

		  pp$8.enterClassBody = function() {
		    var element = {declared: Object.create(null), used: []};
		    this.privateNameStack.push(element);
		    return element.declared
		  };

		  pp$8.exitClassBody = function() {
		    var ref = this.privateNameStack.pop();
		    var declared = ref.declared;
		    var used = ref.used;
		    if (!this.options.checkPrivateFields) { return }
		    var len = this.privateNameStack.length;
		    var parent = len === 0 ? null : this.privateNameStack[len - 1];
		    for (var i = 0; i < used.length; ++i) {
		      var id = used[i];
		      if (!hasOwn(declared, id.name)) {
		        if (parent) {
		          parent.used.push(id);
		        } else {
		          this.raiseRecoverable(id.start, ("Private field '#" + (id.name) + "' must be declared in an enclosing class"));
		        }
		      }
		    }
		  };

		  function isPrivateNameConflicted(privateNameMap, element) {
		    var name = element.key.name;
		    var curr = privateNameMap[name];

		    var next = "true";
		    if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
		      next = (element.static ? "s" : "i") + element.kind;
		    }

		    // `class { get #a(){}; static set #a(_){} }` is also conflict.
		    if (
		      curr === "iget" && next === "iset" ||
		      curr === "iset" && next === "iget" ||
		      curr === "sget" && next === "sset" ||
		      curr === "sset" && next === "sget"
		    ) {
		      privateNameMap[name] = "true";
		      return false
		    } else if (!curr) {
		      privateNameMap[name] = next;
		      return false
		    } else {
		      return true
		    }
		  }

		  function checkKeyName(node, name) {
		    var computed = node.computed;
		    var key = node.key;
		    return !computed && (
		      key.type === "Identifier" && key.name === name ||
		      key.type === "Literal" && key.value === name
		    )
		  }

		  // Parses module export declaration.

		  pp$8.parseExportAllDeclaration = function(node, exports) {
		    if (this.options.ecmaVersion >= 11) {
		      if (this.eatContextual("as")) {
		        node.exported = this.parseModuleExportName();
		        this.checkExport(exports, node.exported, this.lastTokStart);
		      } else {
		        node.exported = null;
		      }
		    }
		    this.expectContextual("from");
		    if (this.type !== types$1.string) { this.unexpected(); }
		    node.source = this.parseExprAtom();
		    this.semicolon();
		    return this.finishNode(node, "ExportAllDeclaration")
		  };

		  pp$8.parseExport = function(node, exports) {
		    this.next();
		    // export * from '...'
		    if (this.eat(types$1.star)) {
		      return this.parseExportAllDeclaration(node, exports)
		    }
		    if (this.eat(types$1._default)) { // export default ...
		      this.checkExport(exports, "default", this.lastTokStart);
		      node.declaration = this.parseExportDefaultDeclaration();
		      return this.finishNode(node, "ExportDefaultDeclaration")
		    }
		    // export var|const|let|function|class ...
		    if (this.shouldParseExportStatement()) {
		      node.declaration = this.parseExportDeclaration(node);
		      if (node.declaration.type === "VariableDeclaration")
		        { this.checkVariableExport(exports, node.declaration.declarations); }
		      else
		        { this.checkExport(exports, node.declaration.id, node.declaration.id.start); }
		      node.specifiers = [];
		      node.source = null;
		    } else { // export { x, y as z } [from '...']
		      node.declaration = null;
		      node.specifiers = this.parseExportSpecifiers(exports);
		      if (this.eatContextual("from")) {
		        if (this.type !== types$1.string) { this.unexpected(); }
		        node.source = this.parseExprAtom();
		      } else {
		        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
		          // check for keywords used as local names
		          var spec = list[i];

		          this.checkUnreserved(spec.local);
		          // check if export is defined
		          this.checkLocalExport(spec.local);

		          if (spec.local.type === "Literal") {
		            this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
		          }
		        }

		        node.source = null;
		      }
		      this.semicolon();
		    }
		    return this.finishNode(node, "ExportNamedDeclaration")
		  };

		  pp$8.parseExportDeclaration = function(node) {
		    return this.parseStatement(null)
		  };

		  pp$8.parseExportDefaultDeclaration = function() {
		    var isAsync;
		    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
		      var fNode = this.startNode();
		      this.next();
		      if (isAsync) { this.next(); }
		      return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync)
		    } else if (this.type === types$1._class) {
		      var cNode = this.startNode();
		      return this.parseClass(cNode, "nullableID")
		    } else {
		      var declaration = this.parseMaybeAssign();
		      this.semicolon();
		      return declaration
		    }
		  };

		  pp$8.checkExport = function(exports, name, pos) {
		    if (!exports) { return }
		    if (typeof name !== "string")
		      { name = name.type === "Identifier" ? name.name : name.value; }
		    if (hasOwn(exports, name))
		      { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
		    exports[name] = true;
		  };

		  pp$8.checkPatternExport = function(exports, pat) {
		    var type = pat.type;
		    if (type === "Identifier")
		      { this.checkExport(exports, pat, pat.start); }
		    else if (type === "ObjectPattern")
		      { for (var i = 0, list = pat.properties; i < list.length; i += 1)
		        {
		          var prop = list[i];

		          this.checkPatternExport(exports, prop);
		        } }
		    else if (type === "ArrayPattern")
		      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
		        var elt = list$1[i$1];

		          if (elt) { this.checkPatternExport(exports, elt); }
		      } }
		    else if (type === "Property")
		      { this.checkPatternExport(exports, pat.value); }
		    else if (type === "AssignmentPattern")
		      { this.checkPatternExport(exports, pat.left); }
		    else if (type === "RestElement")
		      { this.checkPatternExport(exports, pat.argument); }
		  };

		  pp$8.checkVariableExport = function(exports, decls) {
		    if (!exports) { return }
		    for (var i = 0, list = decls; i < list.length; i += 1)
		      {
		      var decl = list[i];

		      this.checkPatternExport(exports, decl.id);
		    }
		  };

		  pp$8.shouldParseExportStatement = function() {
		    return this.type.keyword === "var" ||
		      this.type.keyword === "const" ||
		      this.type.keyword === "class" ||
		      this.type.keyword === "function" ||
		      this.isLet() ||
		      this.isAsyncFunction()
		  };

		  // Parses a comma-separated list of module exports.

		  pp$8.parseExportSpecifier = function(exports) {
		    var node = this.startNode();
		    node.local = this.parseModuleExportName();

		    node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
		    this.checkExport(
		      exports,
		      node.exported,
		      node.exported.start
		    );

		    return this.finishNode(node, "ExportSpecifier")
		  };

		  pp$8.parseExportSpecifiers = function(exports) {
		    var nodes = [], first = true;
		    // export { x, y as z } [from '...']
		    this.expect(types$1.braceL);
		    while (!this.eat(types$1.braceR)) {
		      if (!first) {
		        this.expect(types$1.comma);
		        if (this.afterTrailingComma(types$1.braceR)) { break }
		      } else { first = false; }

		      nodes.push(this.parseExportSpecifier(exports));
		    }
		    return nodes
		  };

		  // Parses import declaration.

		  pp$8.parseImport = function(node) {
		    this.next();

		    // import '...'
		    if (this.type === types$1.string) {
		      node.specifiers = empty$1;
		      node.source = this.parseExprAtom();
		    } else {
		      node.specifiers = this.parseImportSpecifiers();
		      this.expectContextual("from");
		      node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
		    }
		    this.semicolon();
		    return this.finishNode(node, "ImportDeclaration")
		  };

		  // Parses a comma-separated list of module imports.

		  pp$8.parseImportSpecifier = function() {
		    var node = this.startNode();
		    node.imported = this.parseModuleExportName();

		    if (this.eatContextual("as")) {
		      node.local = this.parseIdent();
		    } else {
		      this.checkUnreserved(node.imported);
		      node.local = node.imported;
		    }
		    this.checkLValSimple(node.local, BIND_LEXICAL);

		    return this.finishNode(node, "ImportSpecifier")
		  };

		  pp$8.parseImportDefaultSpecifier = function() {
		    // import defaultObj, { x, y as z } from '...'
		    var node = this.startNode();
		    node.local = this.parseIdent();
		    this.checkLValSimple(node.local, BIND_LEXICAL);
		    return this.finishNode(node, "ImportDefaultSpecifier")
		  };

		  pp$8.parseImportNamespaceSpecifier = function() {
		    var node = this.startNode();
		    this.next();
		    this.expectContextual("as");
		    node.local = this.parseIdent();
		    this.checkLValSimple(node.local, BIND_LEXICAL);
		    return this.finishNode(node, "ImportNamespaceSpecifier")
		  };

		  pp$8.parseImportSpecifiers = function() {
		    var nodes = [], first = true;
		    if (this.type === types$1.name) {
		      nodes.push(this.parseImportDefaultSpecifier());
		      if (!this.eat(types$1.comma)) { return nodes }
		    }
		    if (this.type === types$1.star) {
		      nodes.push(this.parseImportNamespaceSpecifier());
		      return nodes
		    }
		    this.expect(types$1.braceL);
		    while (!this.eat(types$1.braceR)) {
		      if (!first) {
		        this.expect(types$1.comma);
		        if (this.afterTrailingComma(types$1.braceR)) { break }
		      } else { first = false; }

		      nodes.push(this.parseImportSpecifier());
		    }
		    return nodes
		  };

		  pp$8.parseModuleExportName = function() {
		    if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
		      var stringLiteral = this.parseLiteral(this.value);
		      if (loneSurrogate.test(stringLiteral.value)) {
		        this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
		      }
		      return stringLiteral
		    }
		    return this.parseIdent(true)
		  };

		  // Set `ExpressionStatement#directive` property for directive prologues.
		  pp$8.adaptDirectivePrologue = function(statements) {
		    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
		      statements[i].directive = statements[i].expression.raw.slice(1, -1);
		    }
		  };
		  pp$8.isDirectiveCandidate = function(statement) {
		    return (
		      this.options.ecmaVersion >= 5 &&
		      statement.type === "ExpressionStatement" &&
		      statement.expression.type === "Literal" &&
		      typeof statement.expression.value === "string" &&
		      // Reject parenthesized strings.
		      (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
		    )
		  };

		  var pp$7 = Parser.prototype;

		  // Convert existing expression atom to assignable pattern
		  // if possible.

		  pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
		    if (this.options.ecmaVersion >= 6 && node) {
		      switch (node.type) {
		      case "Identifier":
		        if (this.inAsync && node.name === "await")
		          { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
		        break

		      case "ObjectPattern":
		      case "ArrayPattern":
		      case "AssignmentPattern":
		      case "RestElement":
		        break

		      case "ObjectExpression":
		        node.type = "ObjectPattern";
		        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
		        for (var i = 0, list = node.properties; i < list.length; i += 1) {
		          var prop = list[i];

		        this.toAssignable(prop, isBinding);
		          // Early error:
		          //   AssignmentRestProperty[Yield, Await] :
		          //     `...` DestructuringAssignmentTarget[Yield, Await]
		          //
		          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
		          if (
		            prop.type === "RestElement" &&
		            (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
		          ) {
		            this.raise(prop.argument.start, "Unexpected token");
		          }
		        }
		        break

		      case "Property":
		        // AssignmentProperty has type === "Property"
		        if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
		        this.toAssignable(node.value, isBinding);
		        break

		      case "ArrayExpression":
		        node.type = "ArrayPattern";
		        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
		        this.toAssignableList(node.elements, isBinding);
		        break

		      case "SpreadElement":
		        node.type = "RestElement";
		        this.toAssignable(node.argument, isBinding);
		        if (node.argument.type === "AssignmentPattern")
		          { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
		        break

		      case "AssignmentExpression":
		        if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
		        node.type = "AssignmentPattern";
		        delete node.operator;
		        this.toAssignable(node.left, isBinding);
		        break

		      case "ParenthesizedExpression":
		        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
		        break

		      case "ChainExpression":
		        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
		        break

		      case "MemberExpression":
		        if (!isBinding) { break }

		      default:
		        this.raise(node.start, "Assigning to rvalue");
		      }
		    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
		    return node
		  };

		  // Convert list of expression atoms to binding list.

		  pp$7.toAssignableList = function(exprList, isBinding) {
		    var end = exprList.length;
		    for (var i = 0; i < end; i++) {
		      var elt = exprList[i];
		      if (elt) { this.toAssignable(elt, isBinding); }
		    }
		    if (end) {
		      var last = exprList[end - 1];
		      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
		        { this.unexpected(last.argument.start); }
		    }
		    return exprList
		  };

		  // Parses spread element.

		  pp$7.parseSpread = function(refDestructuringErrors) {
		    var node = this.startNode();
		    this.next();
		    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
		    return this.finishNode(node, "SpreadElement")
		  };

		  pp$7.parseRestBinding = function() {
		    var node = this.startNode();
		    this.next();

		    // RestElement inside of a function parameter must be an identifier
		    if (this.options.ecmaVersion === 6 && this.type !== types$1.name)
		      { this.unexpected(); }

		    node.argument = this.parseBindingAtom();

		    return this.finishNode(node, "RestElement")
		  };

		  // Parses lvalue (assignable) atom.

		  pp$7.parseBindingAtom = function() {
		    if (this.options.ecmaVersion >= 6) {
		      switch (this.type) {
		      case types$1.bracketL:
		        var node = this.startNode();
		        this.next();
		        node.elements = this.parseBindingList(types$1.bracketR, true, true);
		        return this.finishNode(node, "ArrayPattern")

		      case types$1.braceL:
		        return this.parseObj(true)
		      }
		    }
		    return this.parseIdent()
		  };

		  pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
		    var elts = [], first = true;
		    while (!this.eat(close)) {
		      if (first) { first = false; }
		      else { this.expect(types$1.comma); }
		      if (allowEmpty && this.type === types$1.comma) {
		        elts.push(null);
		      } else if (allowTrailingComma && this.afterTrailingComma(close)) {
		        break
		      } else if (this.type === types$1.ellipsis) {
		        var rest = this.parseRestBinding();
		        this.parseBindingListItem(rest);
		        elts.push(rest);
		        if (this.type === types$1.comma) { this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"); }
		        this.expect(close);
		        break
		      } else {
		        elts.push(this.parseAssignableListItem(allowModifiers));
		      }
		    }
		    return elts
		  };

		  pp$7.parseAssignableListItem = function(allowModifiers) {
		    var elem = this.parseMaybeDefault(this.start, this.startLoc);
		    this.parseBindingListItem(elem);
		    return elem
		  };

		  pp$7.parseBindingListItem = function(param) {
		    return param
		  };

		  // Parses assignment pattern around given atom if possible.

		  pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
		    left = left || this.parseBindingAtom();
		    if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) { return left }
		    var node = this.startNodeAt(startPos, startLoc);
		    node.left = left;
		    node.right = this.parseMaybeAssign();
		    return this.finishNode(node, "AssignmentPattern")
		  };

		  // The following three functions all verify that a node is an lvalue —
		  // something that can be bound, or assigned to. In order to do so, they perform
		  // a variety of checks:
		  //
		  // - Check that none of the bound/assigned-to identifiers are reserved words.
		  // - Record name declarations for bindings in the appropriate scope.
		  // - Check duplicate argument names, if checkClashes is set.
		  //
		  // If a complex binding pattern is encountered (e.g., object and array
		  // destructuring), the entire pattern is recursively checked.
		  //
		  // There are three versions of checkLVal*() appropriate for different
		  // circumstances:
		  //
		  // - checkLValSimple() shall be used if the syntactic construct supports
		  //   nothing other than identifiers and member expressions. Parenthesized
		  //   expressions are also correctly handled. This is generally appropriate for
		  //   constructs for which the spec says
		  //
		  //   > It is a Syntax Error if AssignmentTargetType of [the production] is not
		  //   > simple.
		  //
		  //   It is also appropriate for checking if an identifier is valid and not
		  //   defined elsewhere, like import declarations or function/class identifiers.
		  //
		  //   Examples where this is used include:
		  //     a += …;
		  //     import a from '…';
		  //   where a is the node to be checked.
		  //
		  // - checkLValPattern() shall be used if the syntactic construct supports
		  //   anything checkLValSimple() supports, as well as object and array
		  //   destructuring patterns. This is generally appropriate for constructs for
		  //   which the spec says
		  //
		  //   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor
		  //   > an ArrayLiteral and AssignmentTargetType of [the production] is not
		  //   > simple.
		  //
		  //   Examples where this is used include:
		  //     (a = …);
		  //     const a = …;
		  //     try { … } catch (a) { … }
		  //   where a is the node to be checked.
		  //
		  // - checkLValInnerPattern() shall be used if the syntactic construct supports
		  //   anything checkLValPattern() supports, as well as default assignment
		  //   patterns, rest elements, and other constructs that may appear within an
		  //   object or array destructuring pattern.
		  //
		  //   As a special case, function parameters also use checkLValInnerPattern(),
		  //   as they also support defaults and rest constructs.
		  //
		  // These functions deliberately support both assignment and binding constructs,
		  // as the logic for both is exceedingly similar. If the node is the target of
		  // an assignment, then bindingType should be set to BIND_NONE. Otherwise, it
		  // should be set to the appropriate BIND_* constant, like BIND_VAR or
		  // BIND_LEXICAL.
		  //
		  // If the function is called with a non-BIND_NONE bindingType, then
		  // additionally a checkClashes object may be specified to allow checking for
		  // duplicate argument names. checkClashes is ignored if the provided construct
		  // is an assignment (i.e., bindingType is BIND_NONE).

		  pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
		    if ( bindingType === void 0 ) bindingType = BIND_NONE;

		    var isBind = bindingType !== BIND_NONE;

		    switch (expr.type) {
		    case "Identifier":
		      if (this.strict && this.reservedWordsStrictBind.test(expr.name))
		        { this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
		      if (isBind) {
		        if (bindingType === BIND_LEXICAL && expr.name === "let")
		          { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
		        if (checkClashes) {
		          if (hasOwn(checkClashes, expr.name))
		            { this.raiseRecoverable(expr.start, "Argument name clash"); }
		          checkClashes[expr.name] = true;
		        }
		        if (bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
		      }
		      break

		    case "ChainExpression":
		      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
		      break

		    case "MemberExpression":
		      if (isBind) { this.raiseRecoverable(expr.start, "Binding member expression"); }
		      break

		    case "ParenthesizedExpression":
		      if (isBind) { this.raiseRecoverable(expr.start, "Binding parenthesized expression"); }
		      return this.checkLValSimple(expr.expression, bindingType, checkClashes)

		    default:
		      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
		    }
		  };

		  pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
		    if ( bindingType === void 0 ) bindingType = BIND_NONE;

		    switch (expr.type) {
		    case "ObjectPattern":
		      for (var i = 0, list = expr.properties; i < list.length; i += 1) {
		        var prop = list[i];

		      this.checkLValInnerPattern(prop, bindingType, checkClashes);
		      }
		      break

		    case "ArrayPattern":
		      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
		        var elem = list$1[i$1];

		      if (elem) { this.checkLValInnerPattern(elem, bindingType, checkClashes); }
		      }
		      break

		    default:
		      this.checkLValSimple(expr, bindingType, checkClashes);
		    }
		  };

		  pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
		    if ( bindingType === void 0 ) bindingType = BIND_NONE;

		    switch (expr.type) {
		    case "Property":
		      // AssignmentProperty has type === "Property"
		      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
		      break

		    case "AssignmentPattern":
		      this.checkLValPattern(expr.left, bindingType, checkClashes);
		      break

		    case "RestElement":
		      this.checkLValPattern(expr.argument, bindingType, checkClashes);
		      break

		    default:
		      this.checkLValPattern(expr, bindingType, checkClashes);
		    }
		  };

		  // The algorithm used to determine whether a regexp can appear at a
		  // given point in the program is loosely based on sweet.js' approach.
		  // See https://github.com/mozilla/sweet.js/wiki/design


		  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
		    this.token = token;
		    this.isExpr = !!isExpr;
		    this.preserveSpace = !!preserveSpace;
		    this.override = override;
		    this.generator = !!generator;
		  };

		  var types = {
		    b_stat: new TokContext("{", false),
		    b_expr: new TokContext("{", true),
		    b_tmpl: new TokContext("${", false),
		    p_stat: new TokContext("(", false),
		    p_expr: new TokContext("(", true),
		    q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
		    f_stat: new TokContext("function", false),
		    f_expr: new TokContext("function", true),
		    f_expr_gen: new TokContext("function", true, false, null, true),
		    f_gen: new TokContext("function", false, false, null, true)
		  };

		  var pp$6 = Parser.prototype;

		  pp$6.initialContext = function() {
		    return [types.b_stat]
		  };

		  pp$6.curContext = function() {
		    return this.context[this.context.length - 1]
		  };

		  pp$6.braceIsBlock = function(prevType) {
		    var parent = this.curContext();
		    if (parent === types.f_expr || parent === types.f_stat)
		      { return true }
		    if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr))
		      { return !parent.isExpr }

		    // The check for `tt.name && exprAllowed` detects whether we are
		    // after a `yield` or `of` construct. See the `updateContext` for
		    // `tt.name`.
		    if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed)
		      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
		    if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)
		      { return true }
		    if (prevType === types$1.braceL)
		      { return parent === types.b_stat }
		    if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)
		      { return false }
		    return !this.exprAllowed
		  };

		  pp$6.inGeneratorContext = function() {
		    for (var i = this.context.length - 1; i >= 1; i--) {
		      var context = this.context[i];
		      if (context.token === "function")
		        { return context.generator }
		    }
		    return false
		  };

		  pp$6.updateContext = function(prevType) {
		    var update, type = this.type;
		    if (type.keyword && prevType === types$1.dot)
		      { this.exprAllowed = false; }
		    else if (update = type.updateContext)
		      { update.call(this, prevType); }
		    else
		      { this.exprAllowed = type.beforeExpr; }
		  };

		  // Used to handle edge cases when token context could not be inferred correctly during tokenization phase

		  pp$6.overrideContext = function(tokenCtx) {
		    if (this.curContext() !== tokenCtx) {
		      this.context[this.context.length - 1] = tokenCtx;
		    }
		  };

		  // Token-specific context update code

		  types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
		    if (this.context.length === 1) {
		      this.exprAllowed = true;
		      return
		    }
		    var out = this.context.pop();
		    if (out === types.b_stat && this.curContext().token === "function") {
		      out = this.context.pop();
		    }
		    this.exprAllowed = !out.isExpr;
		  };

		  types$1.braceL.updateContext = function(prevType) {
		    this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
		    this.exprAllowed = true;
		  };

		  types$1.dollarBraceL.updateContext = function() {
		    this.context.push(types.b_tmpl);
		    this.exprAllowed = true;
		  };

		  types$1.parenL.updateContext = function(prevType) {
		    var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
		    this.context.push(statementParens ? types.p_stat : types.p_expr);
		    this.exprAllowed = true;
		  };

		  types$1.incDec.updateContext = function() {
		    // tokExprAllowed stays unchanged
		  };

		  types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
		    if (prevType.beforeExpr && prevType !== types$1._else &&
		        !(prevType === types$1.semi && this.curContext() !== types.p_stat) &&
		        !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
		        !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat))
		      { this.context.push(types.f_expr); }
		    else
		      { this.context.push(types.f_stat); }
		    this.exprAllowed = false;
		  };

		  types$1.colon.updateContext = function() {
		    if (this.curContext().token === "function") { this.context.pop(); }
		    this.exprAllowed = true;
		  };

		  types$1.backQuote.updateContext = function() {
		    if (this.curContext() === types.q_tmpl)
		      { this.context.pop(); }
		    else
		      { this.context.push(types.q_tmpl); }
		    this.exprAllowed = false;
		  };

		  types$1.star.updateContext = function(prevType) {
		    if (prevType === types$1._function) {
		      var index = this.context.length - 1;
		      if (this.context[index] === types.f_expr)
		        { this.context[index] = types.f_expr_gen; }
		      else
		        { this.context[index] = types.f_gen; }
		    }
		    this.exprAllowed = true;
		  };

		  types$1.name.updateContext = function(prevType) {
		    var allowed = false;
		    if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
		      if (this.value === "of" && !this.exprAllowed ||
		          this.value === "yield" && this.inGeneratorContext())
		        { allowed = true; }
		    }
		    this.exprAllowed = allowed;
		  };

		  // A recursive descent parser operates by defining functions for all
		  // syntactic elements, and recursively calling those, each function
		  // advancing the input stream and returning an AST node. Precedence
		  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
		  // instead of `(!x)[1]` is handled by the fact that the parser
		  // function that parses unary prefix operators is called first, and
		  // in turn calls the function that parses `[]` subscripts — that
		  // way, it'll receive the node for `x[1]` already parsed, and wraps
		  // *that* in the unary operator node.
		  //
		  // Acorn uses an [operator precedence parser][opp] to handle binary
		  // operator precedence, because it is much more compact than using
		  // the technique outlined above, which uses different, nesting
		  // functions to specify precedence, for all of the ten binary
		  // precedence levels that JavaScript defines.
		  //
		  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser


		  var pp$5 = Parser.prototype;

		  // Check if property name clashes with already added.
		  // Object/class getters and setters are not allowed to clash —
		  // either with each other or with an init property — and in
		  // strict mode, init properties are also not allowed to be repeated.

		  pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
		    if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
		      { return }
		    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
		      { return }
		    var key = prop.key;
		    var name;
		    switch (key.type) {
		    case "Identifier": name = key.name; break
		    case "Literal": name = String(key.value); break
		    default: return
		    }
		    var kind = prop.kind;
		    if (this.options.ecmaVersion >= 6) {
		      if (name === "__proto__" && kind === "init") {
		        if (propHash.proto) {
		          if (refDestructuringErrors) {
		            if (refDestructuringErrors.doubleProto < 0) {
		              refDestructuringErrors.doubleProto = key.start;
		            }
		          } else {
		            this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
		          }
		        }
		        propHash.proto = true;
		      }
		      return
		    }
		    name = "$" + name;
		    var other = propHash[name];
		    if (other) {
		      var redefinition;
		      if (kind === "init") {
		        redefinition = this.strict && other.init || other.get || other.set;
		      } else {
		        redefinition = other.init || other[kind];
		      }
		      if (redefinition)
		        { this.raiseRecoverable(key.start, "Redefinition of property"); }
		    } else {
		      other = propHash[name] = {
		        init: false,
		        get: false,
		        set: false
		      };
		    }
		    other[kind] = true;
		  };

		  // ### Expression parsing

		  // These nest, from the most general expression type at the top to
		  // 'atomic', nondivisible expression types at the bottom. Most of
		  // the functions will simply let the function(s) below them parse,
		  // and, *if* the syntactic construct they handle is present, wrap
		  // the AST node that the inner parser gave them in another node.

		  // Parse a full expression. The optional arguments are used to
		  // forbid the `in` operator (in for loops initalization expressions)
		  // and provide reference for storing '=' operator inside shorthand
		  // property assignment in contexts where both object expression
		  // and object pattern might appear (so it's possible to raise
		  // delayed syntax error at correct position).

		  pp$5.parseExpression = function(forInit, refDestructuringErrors) {
		    var startPos = this.start, startLoc = this.startLoc;
		    var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
		    if (this.type === types$1.comma) {
		      var node = this.startNodeAt(startPos, startLoc);
		      node.expressions = [expr];
		      while (this.eat(types$1.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }
		      return this.finishNode(node, "SequenceExpression")
		    }
		    return expr
		  };

		  // Parse an assignment expression. This includes applications of
		  // operators like `+=`.

		  pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
		    if (this.isContextual("yield")) {
		      if (this.inGenerator) { return this.parseYield(forInit) }
		      // The tokenizer will assume an expression is allowed after
		      // `yield`, but this isn't that kind of yield
		      else { this.exprAllowed = false; }
		    }

		    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
		    if (refDestructuringErrors) {
		      oldParenAssign = refDestructuringErrors.parenthesizedAssign;
		      oldTrailingComma = refDestructuringErrors.trailingComma;
		      oldDoubleProto = refDestructuringErrors.doubleProto;
		      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
		    } else {
		      refDestructuringErrors = new DestructuringErrors;
		      ownDestructuringErrors = true;
		    }

		    var startPos = this.start, startLoc = this.startLoc;
		    if (this.type === types$1.parenL || this.type === types$1.name) {
		      this.potentialArrowAt = this.start;
		      this.potentialArrowInForAwait = forInit === "await";
		    }
		    var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
		    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
		    if (this.type.isAssign) {
		      var node = this.startNodeAt(startPos, startLoc);
		      node.operator = this.value;
		      if (this.type === types$1.eq)
		        { left = this.toAssignable(left, false, refDestructuringErrors); }
		      if (!ownDestructuringErrors) {
		        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
		      }
		      if (refDestructuringErrors.shorthandAssign >= left.start)
		        { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly
		      if (this.type === types$1.eq)
		        { this.checkLValPattern(left); }
		      else
		        { this.checkLValSimple(left); }
		      node.left = left;
		      this.next();
		      node.right = this.parseMaybeAssign(forInit);
		      if (oldDoubleProto > -1) { refDestructuringErrors.doubleProto = oldDoubleProto; }
		      return this.finishNode(node, "AssignmentExpression")
		    } else {
		      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
		    }
		    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
		    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
		    return left
		  };

		  // Parse a ternary conditional (`?:`) operator.

		  pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
		    var startPos = this.start, startLoc = this.startLoc;
		    var expr = this.parseExprOps(forInit, refDestructuringErrors);
		    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
		    if (this.eat(types$1.question)) {
		      var node = this.startNodeAt(startPos, startLoc);
		      node.test = expr;
		      node.consequent = this.parseMaybeAssign();
		      this.expect(types$1.colon);
		      node.alternate = this.parseMaybeAssign(forInit);
		      return this.finishNode(node, "ConditionalExpression")
		    }
		    return expr
		  };

		  // Start the precedence parser.

		  pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
		    var startPos = this.start, startLoc = this.startLoc;
		    var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
		    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
		    return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit)
		  };

		  // Parse binary operators with the operator precedence parsing
		  // algorithm. `left` is the left-hand side of the operator.
		  // `minPrec` provides context that allows the function to stop and
		  // defer further parser to one of its callers when it encounters an
		  // operator that has a lower precedence than the set it is parsing.

		  pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
		    var prec = this.type.binop;
		    if (prec != null && (!forInit || this.type !== types$1._in)) {
		      if (prec > minPrec) {
		        var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
		        var coalesce = this.type === types$1.coalesce;
		        if (coalesce) {
		          // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
		          // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
		          prec = types$1.logicalAND.binop;
		        }
		        var op = this.value;
		        this.next();
		        var startPos = this.start, startLoc = this.startLoc;
		        var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
		        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
		        if ((logical && this.type === types$1.coalesce) || (coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND))) {
		          this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
		        }
		        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit)
		      }
		    }
		    return left
		  };

		  pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
		    if (right.type === "PrivateIdentifier") { this.raise(right.start, "Private identifier can only be left side of binary expression"); }
		    var node = this.startNodeAt(startPos, startLoc);
		    node.left = left;
		    node.operator = op;
		    node.right = right;
		    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
		  };

		  // Parse unary operators, both prefix and postfix.

		  pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
		    var startPos = this.start, startLoc = this.startLoc, expr;
		    if (this.isContextual("await") && this.canAwait) {
		      expr = this.parseAwait(forInit);
		      sawUnary = true;
		    } else if (this.type.prefix) {
		      var node = this.startNode(), update = this.type === types$1.incDec;
		      node.operator = this.value;
		      node.prefix = true;
		      this.next();
		      node.argument = this.parseMaybeUnary(null, true, update, forInit);
		      this.checkExpressionErrors(refDestructuringErrors, true);
		      if (update) { this.checkLValSimple(node.argument); }
		      else if (this.strict && node.operator === "delete" &&
		               node.argument.type === "Identifier")
		        { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
		      else if (node.operator === "delete" && isPrivateFieldAccess(node.argument))
		        { this.raiseRecoverable(node.start, "Private fields can not be deleted"); }
		      else { sawUnary = true; }
		      expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
		    } else if (!sawUnary && this.type === types$1.privateId) {
		      if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) { this.unexpected(); }
		      expr = this.parsePrivateIdent();
		      // only could be private fields in 'in', such as #x in obj
		      if (this.type !== types$1._in) { this.unexpected(); }
		    } else {
		      expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
		      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
		      while (this.type.postfix && !this.canInsertSemicolon()) {
		        var node$1 = this.startNodeAt(startPos, startLoc);
		        node$1.operator = this.value;
		        node$1.prefix = false;
		        node$1.argument = expr;
		        this.checkLValSimple(expr);
		        this.next();
		        expr = this.finishNode(node$1, "UpdateExpression");
		      }
		    }

		    if (!incDec && this.eat(types$1.starstar)) {
		      if (sawUnary)
		        { this.unexpected(this.lastTokStart); }
		      else
		        { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false) }
		    } else {
		      return expr
		    }
		  };

		  function isPrivateFieldAccess(node) {
		    return (
		      node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" ||
		      node.type === "ChainExpression" && isPrivateFieldAccess(node.expression)
		    )
		  }

		  // Parse call, dot, and `[]`-subscript expressions.

		  pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
		    var startPos = this.start, startLoc = this.startLoc;
		    var expr = this.parseExprAtom(refDestructuringErrors, forInit);
		    if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
		      { return expr }
		    var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
		    if (refDestructuringErrors && result.type === "MemberExpression") {
		      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
		      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
		      if (refDestructuringErrors.trailingComma >= result.start) { refDestructuringErrors.trailingComma = -1; }
		    }
		    return result
		  };

		  pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
		    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
		        this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
		        this.potentialArrowAt === base.start;
		    var optionalChained = false;

		    while (true) {
		      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);

		      if (element.optional) { optionalChained = true; }
		      if (element === base || element.type === "ArrowFunctionExpression") {
		        if (optionalChained) {
		          var chainNode = this.startNodeAt(startPos, startLoc);
		          chainNode.expression = element;
		          element = this.finishNode(chainNode, "ChainExpression");
		        }
		        return element
		      }

		      base = element;
		    }
		  };

		  pp$5.shouldParseAsyncArrow = function() {
		    return !this.canInsertSemicolon() && this.eat(types$1.arrow)
		  };

		  pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
		    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit)
		  };

		  pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
		    var optionalSupported = this.options.ecmaVersion >= 11;
		    var optional = optionalSupported && this.eat(types$1.questionDot);
		    if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }

		    var computed = this.eat(types$1.bracketL);
		    if (computed || (optional && this.type !== types$1.parenL && this.type !== types$1.backQuote) || this.eat(types$1.dot)) {
		      var node = this.startNodeAt(startPos, startLoc);
		      node.object = base;
		      if (computed) {
		        node.property = this.parseExpression();
		        this.expect(types$1.bracketR);
		      } else if (this.type === types$1.privateId && base.type !== "Super") {
		        node.property = this.parsePrivateIdent();
		      } else {
		        node.property = this.parseIdent(this.options.allowReserved !== "never");
		      }
		      node.computed = !!computed;
		      if (optionalSupported) {
		        node.optional = optional;
		      }
		      base = this.finishNode(node, "MemberExpression");
		    } else if (!noCalls && this.eat(types$1.parenL)) {
		      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
		      this.yieldPos = 0;
		      this.awaitPos = 0;
		      this.awaitIdentPos = 0;
		      var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
		      if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
		        this.checkPatternErrors(refDestructuringErrors, false);
		        this.checkYieldAwaitInDefaultParams();
		        if (this.awaitIdentPos > 0)
		          { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
		        this.yieldPos = oldYieldPos;
		        this.awaitPos = oldAwaitPos;
		        this.awaitIdentPos = oldAwaitIdentPos;
		        return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit)
		      }
		      this.checkExpressionErrors(refDestructuringErrors, true);
		      this.yieldPos = oldYieldPos || this.yieldPos;
		      this.awaitPos = oldAwaitPos || this.awaitPos;
		      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
		      var node$1 = this.startNodeAt(startPos, startLoc);
		      node$1.callee = base;
		      node$1.arguments = exprList;
		      if (optionalSupported) {
		        node$1.optional = optional;
		      }
		      base = this.finishNode(node$1, "CallExpression");
		    } else if (this.type === types$1.backQuote) {
		      if (optional || optionalChained) {
		        this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
		      }
		      var node$2 = this.startNodeAt(startPos, startLoc);
		      node$2.tag = base;
		      node$2.quasi = this.parseTemplate({isTagged: true});
		      base = this.finishNode(node$2, "TaggedTemplateExpression");
		    }
		    return base
		  };

		  // Parse an atomic expression — either a single token that is an
		  // expression, an expression started by a keyword like `function` or
		  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
		  // or `{}`.

		  pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
		    // If a division operator appears in an expression position, the
		    // tokenizer got confused, and we force it to read a regexp instead.
		    if (this.type === types$1.slash) { this.readRegexp(); }

		    var node, canBeArrow = this.potentialArrowAt === this.start;
		    switch (this.type) {
		    case types$1._super:
		      if (!this.allowSuper)
		        { this.raise(this.start, "'super' keyword outside a method"); }
		      node = this.startNode();
		      this.next();
		      if (this.type === types$1.parenL && !this.allowDirectSuper)
		        { this.raise(node.start, "super() call outside constructor of a subclass"); }
		      // The `super` keyword can appear at below:
		      // SuperProperty:
		      //     super [ Expression ]
		      //     super . IdentifierName
		      // SuperCall:
		      //     super ( Arguments )
		      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL)
		        { this.unexpected(); }
		      return this.finishNode(node, "Super")

		    case types$1._this:
		      node = this.startNode();
		      this.next();
		      return this.finishNode(node, "ThisExpression")

		    case types$1.name:
		      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
		      var id = this.parseIdent(false);
		      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
		        this.overrideContext(types.f_expr);
		        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)
		      }
		      if (canBeArrow && !this.canInsertSemicolon()) {
		        if (this.eat(types$1.arrow))
		          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }
		        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc &&
		            (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
		          id = this.parseIdent(false);
		          if (this.canInsertSemicolon() || !this.eat(types$1.arrow))
		            { this.unexpected(); }
		          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)
		        }
		      }
		      return id

		    case types$1.regexp:
		      var value = this.value;
		      node = this.parseLiteral(value.value);
		      node.regex = {pattern: value.pattern, flags: value.flags};
		      return node

		    case types$1.num: case types$1.string:
		      return this.parseLiteral(this.value)

		    case types$1._null: case types$1._true: case types$1._false:
		      node = this.startNode();
		      node.value = this.type === types$1._null ? null : this.type === types$1._true;
		      node.raw = this.type.keyword;
		      this.next();
		      return this.finishNode(node, "Literal")

		    case types$1.parenL:
		      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
		      if (refDestructuringErrors) {
		        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
		          { refDestructuringErrors.parenthesizedAssign = start; }
		        if (refDestructuringErrors.parenthesizedBind < 0)
		          { refDestructuringErrors.parenthesizedBind = start; }
		      }
		      return expr

		    case types$1.bracketL:
		      node = this.startNode();
		      this.next();
		      node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
		      return this.finishNode(node, "ArrayExpression")

		    case types$1.braceL:
		      this.overrideContext(types.b_expr);
		      return this.parseObj(false, refDestructuringErrors)

		    case types$1._function:
		      node = this.startNode();
		      this.next();
		      return this.parseFunction(node, 0)

		    case types$1._class:
		      return this.parseClass(this.startNode(), false)

		    case types$1._new:
		      return this.parseNew()

		    case types$1.backQuote:
		      return this.parseTemplate()

		    case types$1._import:
		      if (this.options.ecmaVersion >= 11) {
		        return this.parseExprImport(forNew)
		      } else {
		        return this.unexpected()
		      }

		    default:
		      return this.parseExprAtomDefault()
		    }
		  };

		  pp$5.parseExprAtomDefault = function() {
		    this.unexpected();
		  };

		  pp$5.parseExprImport = function(forNew) {
		    var node = this.startNode();

		    // Consume `import` as an identifier for `import.meta`.
		    // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
		    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword import"); }
		    var meta = this.parseIdent(true);

		    if (this.type === types$1.parenL && !forNew) {
		      return this.parseDynamicImport(node)
		    } else if (this.type === types$1.dot) {
		      node.meta = meta;
		      return this.parseImportMeta(node)
		    } else {
		      this.unexpected();
		    }
		  };

		  pp$5.parseDynamicImport = function(node) {
		    this.next(); // skip `(`

		    // Parse node.source.
		    node.source = this.parseMaybeAssign();

		    // Verify ending.
		    if (!this.eat(types$1.parenR)) {
		      var errorPos = this.start;
		      if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
		        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
		      } else {
		        this.unexpected(errorPos);
		      }
		    }

		    return this.finishNode(node, "ImportExpression")
		  };

		  pp$5.parseImportMeta = function(node) {
		    this.next(); // skip `.`

		    var containsEsc = this.containsEsc;
		    node.property = this.parseIdent(true);

		    if (node.property.name !== "meta")
		      { this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"); }
		    if (containsEsc)
		      { this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"); }
		    if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere)
		      { this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"); }

		    return this.finishNode(node, "MetaProperty")
		  };

		  pp$5.parseLiteral = function(value) {
		    var node = this.startNode();
		    node.value = value;
		    node.raw = this.input.slice(this.start, this.end);
		    if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, ""); }
		    this.next();
		    return this.finishNode(node, "Literal")
		  };

		  pp$5.parseParenExpression = function() {
		    this.expect(types$1.parenL);
		    var val = this.parseExpression();
		    this.expect(types$1.parenR);
		    return val
		  };

		  pp$5.shouldParseArrow = function(exprList) {
		    return !this.canInsertSemicolon()
		  };

		  pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
		    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
		    if (this.options.ecmaVersion >= 6) {
		      this.next();

		      var innerStartPos = this.start, innerStartLoc = this.startLoc;
		      var exprList = [], first = true, lastIsComma = false;
		      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
		      this.yieldPos = 0;
		      this.awaitPos = 0;
		      // Do not save awaitIdentPos to allow checking awaits nested in parameters
		      while (this.type !== types$1.parenR) {
		        first ? first = false : this.expect(types$1.comma);
		        if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
		          lastIsComma = true;
		          break
		        } else if (this.type === types$1.ellipsis) {
		          spreadStart = this.start;
		          exprList.push(this.parseParenItem(this.parseRestBinding()));
		          if (this.type === types$1.comma) {
		            this.raiseRecoverable(
		              this.start,
		              "Comma is not permitted after the rest element"
		            );
		          }
		          break
		        } else {
		          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
		        }
		      }
		      var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
		      this.expect(types$1.parenR);

		      if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
		        this.checkPatternErrors(refDestructuringErrors, false);
		        this.checkYieldAwaitInDefaultParams();
		        this.yieldPos = oldYieldPos;
		        this.awaitPos = oldAwaitPos;
		        return this.parseParenArrowList(startPos, startLoc, exprList, forInit)
		      }

		      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
		      if (spreadStart) { this.unexpected(spreadStart); }
		      this.checkExpressionErrors(refDestructuringErrors, true);
		      this.yieldPos = oldYieldPos || this.yieldPos;
		      this.awaitPos = oldAwaitPos || this.awaitPos;

		      if (exprList.length > 1) {
		        val = this.startNodeAt(innerStartPos, innerStartLoc);
		        val.expressions = exprList;
		        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
		      } else {
		        val = exprList[0];
		      }
		    } else {
		      val = this.parseParenExpression();
		    }

		    if (this.options.preserveParens) {
		      var par = this.startNodeAt(startPos, startLoc);
		      par.expression = val;
		      return this.finishNode(par, "ParenthesizedExpression")
		    } else {
		      return val
		    }
		  };

		  pp$5.parseParenItem = function(item) {
		    return item
		  };

		  pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
		    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit)
		  };

		  // New's precedence is slightly tricky. It must allow its argument to
		  // be a `[]` or dot subscript expression, but not a call — at least,
		  // not without wrapping it in parentheses. Thus, it uses the noCalls
		  // argument to parseSubscripts to prevent it from consuming the
		  // argument list.

		  var empty = [];

		  pp$5.parseNew = function() {
		    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
		    var node = this.startNode();
		    this.next();
		    if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
		      var meta = this.startNodeAt(node.start, node.startLoc);
		      meta.name = "new";
		      node.meta = this.finishNode(meta, "Identifier");
		      this.next();
		      var containsEsc = this.containsEsc;
		      node.property = this.parseIdent(true);
		      if (node.property.name !== "target")
		        { this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"); }
		      if (containsEsc)
		        { this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"); }
		      if (!this.allowNewDotTarget)
		        { this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block"); }
		      return this.finishNode(node, "MetaProperty")
		    }
		    var startPos = this.start, startLoc = this.startLoc;
		    node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
		    if (this.eat(types$1.parenL)) { node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false); }
		    else { node.arguments = empty; }
		    return this.finishNode(node, "NewExpression")
		  };

		  // Parse template expression.

		  pp$5.parseTemplateElement = function(ref) {
		    var isTagged = ref.isTagged;

		    var elem = this.startNode();
		    if (this.type === types$1.invalidTemplate) {
		      if (!isTagged) {
		        this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
		      }
		      elem.value = {
		        raw: this.value,
		        cooked: null
		      };
		    } else {
		      elem.value = {
		        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
		        cooked: this.value
		      };
		    }
		    this.next();
		    elem.tail = this.type === types$1.backQuote;
		    return this.finishNode(elem, "TemplateElement")
		  };

		  pp$5.parseTemplate = function(ref) {
		    if ( ref === void 0 ) ref = {};
		    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

		    var node = this.startNode();
		    this.next();
		    node.expressions = [];
		    var curElt = this.parseTemplateElement({isTagged: isTagged});
		    node.quasis = [curElt];
		    while (!curElt.tail) {
		      if (this.type === types$1.eof) { this.raise(this.pos, "Unterminated template literal"); }
		      this.expect(types$1.dollarBraceL);
		      node.expressions.push(this.parseExpression());
		      this.expect(types$1.braceR);
		      node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
		    }
		    this.next();
		    return this.finishNode(node, "TemplateLiteral")
		  };

		  pp$5.isAsyncProp = function(prop) {
		    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
		      (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types$1.star)) &&
		      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
		  };

		  // Parse an object literal or binding pattern.

		  pp$5.parseObj = function(isPattern, refDestructuringErrors) {
		    var node = this.startNode(), first = true, propHash = {};
		    node.properties = [];
		    this.next();
		    while (!this.eat(types$1.braceR)) {
		      if (!first) {
		        this.expect(types$1.comma);
		        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) { break }
		      } else { first = false; }

		      var prop = this.parseProperty(isPattern, refDestructuringErrors);
		      if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
		      node.properties.push(prop);
		    }
		    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
		  };

		  pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
		    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
		    if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
		      if (isPattern) {
		        prop.argument = this.parseIdent(false);
		        if (this.type === types$1.comma) {
		          this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
		        }
		        return this.finishNode(prop, "RestElement")
		      }
		      // Parse argument.
		      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
		      // To disallow trailing comma via `this.toAssignable()`.
		      if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
		        refDestructuringErrors.trailingComma = this.start;
		      }
		      // Finish
		      return this.finishNode(prop, "SpreadElement")
		    }
		    if (this.options.ecmaVersion >= 6) {
		      prop.method = false;
		      prop.shorthand = false;
		      if (isPattern || refDestructuringErrors) {
		        startPos = this.start;
		        startLoc = this.startLoc;
		      }
		      if (!isPattern)
		        { isGenerator = this.eat(types$1.star); }
		    }
		    var containsEsc = this.containsEsc;
		    this.parsePropertyName(prop);
		    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
		      isAsync = true;
		      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
		      this.parsePropertyName(prop);
		    } else {
		      isAsync = false;
		    }
		    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
		    return this.finishNode(prop, "Property")
		  };

		  pp$5.parseGetterSetter = function(prop) {
		    prop.kind = prop.key.name;
		    this.parsePropertyName(prop);
		    prop.value = this.parseMethod(false);
		    var paramCount = prop.kind === "get" ? 0 : 1;
		    if (prop.value.params.length !== paramCount) {
		      var start = prop.value.start;
		      if (prop.kind === "get")
		        { this.raiseRecoverable(start, "getter should have no params"); }
		      else
		        { this.raiseRecoverable(start, "setter should have exactly one param"); }
		    } else {
		      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
		        { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
		    }
		  };

		  pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
		    if ((isGenerator || isAsync) && this.type === types$1.colon)
		      { this.unexpected(); }

		    if (this.eat(types$1.colon)) {
		      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
		      prop.kind = "init";
		    } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
		      if (isPattern) { this.unexpected(); }
		      prop.kind = "init";
		      prop.method = true;
		      prop.value = this.parseMethod(isGenerator, isAsync);
		    } else if (!isPattern && !containsEsc &&
		               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
		               (prop.key.name === "get" || prop.key.name === "set") &&
		               (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
		      if (isGenerator || isAsync) { this.unexpected(); }
		      this.parseGetterSetter(prop);
		    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
		      if (isGenerator || isAsync) { this.unexpected(); }
		      this.checkUnreserved(prop.key);
		      if (prop.key.name === "await" && !this.awaitIdentPos)
		        { this.awaitIdentPos = startPos; }
		      prop.kind = "init";
		      if (isPattern) {
		        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
		      } else if (this.type === types$1.eq && refDestructuringErrors) {
		        if (refDestructuringErrors.shorthandAssign < 0)
		          { refDestructuringErrors.shorthandAssign = this.start; }
		        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
		      } else {
		        prop.value = this.copyNode(prop.key);
		      }
		      prop.shorthand = true;
		    } else { this.unexpected(); }
		  };

		  pp$5.parsePropertyName = function(prop) {
		    if (this.options.ecmaVersion >= 6) {
		      if (this.eat(types$1.bracketL)) {
		        prop.computed = true;
		        prop.key = this.parseMaybeAssign();
		        this.expect(types$1.bracketR);
		        return prop.key
		      } else {
		        prop.computed = false;
		      }
		    }
		    return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
		  };

		  // Initialize empty function node.

		  pp$5.initFunction = function(node) {
		    node.id = null;
		    if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
		    if (this.options.ecmaVersion >= 8) { node.async = false; }
		  };

		  // Parse object or class method.

		  pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
		    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

		    this.initFunction(node);
		    if (this.options.ecmaVersion >= 6)
		      { node.generator = isGenerator; }
		    if (this.options.ecmaVersion >= 8)
		      { node.async = !!isAsync; }

		    this.yieldPos = 0;
		    this.awaitPos = 0;
		    this.awaitIdentPos = 0;
		    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

		    this.expect(types$1.parenL);
		    node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
		    this.checkYieldAwaitInDefaultParams();
		    this.parseFunctionBody(node, false, true, false);

		    this.yieldPos = oldYieldPos;
		    this.awaitPos = oldAwaitPos;
		    this.awaitIdentPos = oldAwaitIdentPos;
		    return this.finishNode(node, "FunctionExpression")
		  };

		  // Parse arrow function expression with given parameters.

		  pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
		    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

		    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
		    this.initFunction(node);
		    if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

		    this.yieldPos = 0;
		    this.awaitPos = 0;
		    this.awaitIdentPos = 0;

		    node.params = this.toAssignableList(params, true);
		    this.parseFunctionBody(node, true, false, forInit);

		    this.yieldPos = oldYieldPos;
		    this.awaitPos = oldAwaitPos;
		    this.awaitIdentPos = oldAwaitIdentPos;
		    return this.finishNode(node, "ArrowFunctionExpression")
		  };

		  // Parse function body and check parameters.

		  pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
		    var isExpression = isArrowFunction && this.type !== types$1.braceL;
		    var oldStrict = this.strict, useStrict = false;

		    if (isExpression) {
		      node.body = this.parseMaybeAssign(forInit);
		      node.expression = true;
		      this.checkParams(node, false);
		    } else {
		      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
		      if (!oldStrict || nonSimple) {
		        useStrict = this.strictDirective(this.end);
		        // If this is a strict mode function, verify that argument names
		        // are not repeated, and it does not try to bind the words `eval`
		        // or `arguments`.
		        if (useStrict && nonSimple)
		          { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
		      }
		      // Start a new scope with regard to labels and the `inFunction`
		      // flag (restore them to their old value afterwards).
		      var oldLabels = this.labels;
		      this.labels = [];
		      if (useStrict) { this.strict = true; }

		      // Add the params to varDeclaredNames to ensure that an error is thrown
		      // if a let/const declaration in the function clashes with one of the params.
		      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
		      // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
		      if (this.strict && node.id) { this.checkLValSimple(node.id, BIND_OUTSIDE); }
		      node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
		      node.expression = false;
		      this.adaptDirectivePrologue(node.body.body);
		      this.labels = oldLabels;
		    }
		    this.exitScope();
		  };

		  pp$5.isSimpleParamList = function(params) {
		    for (var i = 0, list = params; i < list.length; i += 1)
		      {
		      var param = list[i];

		      if (param.type !== "Identifier") { return false
		    } }
		    return true
		  };

		  // Checks function params for various disallowed patterns such as using "eval"
		  // or "arguments" and duplicate parameters.

		  pp$5.checkParams = function(node, allowDuplicates) {
		    var nameHash = Object.create(null);
		    for (var i = 0, list = node.params; i < list.length; i += 1)
		      {
		      var param = list[i];

		      this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
		    }
		  };

		  // Parses a comma-separated list of expressions, and returns them as
		  // an array. `close` is the token type that ends the list, and
		  // `allowEmpty` can be turned on to allow subsequent commas with
		  // nothing in between them to be parsed as `null` (which is needed
		  // for array literals).

		  pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
		    var elts = [], first = true;
		    while (!this.eat(close)) {
		      if (!first) {
		        this.expect(types$1.comma);
		        if (allowTrailingComma && this.afterTrailingComma(close)) { break }
		      } else { first = false; }

		      var elt = (void 0);
		      if (allowEmpty && this.type === types$1.comma)
		        { elt = null; }
		      else if (this.type === types$1.ellipsis) {
		        elt = this.parseSpread(refDestructuringErrors);
		        if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0)
		          { refDestructuringErrors.trailingComma = this.start; }
		      } else {
		        elt = this.parseMaybeAssign(false, refDestructuringErrors);
		      }
		      elts.push(elt);
		    }
		    return elts
		  };

		  pp$5.checkUnreserved = function(ref) {
		    var start = ref.start;
		    var end = ref.end;
		    var name = ref.name;

		    if (this.inGenerator && name === "yield")
		      { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
		    if (this.inAsync && name === "await")
		      { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
		    if (this.currentThisScope().inClassFieldInit && name === "arguments")
		      { this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer"); }
		    if (this.inClassStaticBlock && (name === "arguments" || name === "await"))
		      { this.raise(start, ("Cannot use " + name + " in class static initialization block")); }
		    if (this.keywords.test(name))
		      { this.raise(start, ("Unexpected keyword '" + name + "'")); }
		    if (this.options.ecmaVersion < 6 &&
		      this.input.slice(start, end).indexOf("\\") !== -1) { return }
		    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
		    if (re.test(name)) {
		      if (!this.inAsync && name === "await")
		        { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
		      this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
		    }
		  };

		  // Parse the next token as an identifier. If `liberal` is true (used
		  // when parsing properties), it will also convert keywords into
		  // identifiers.

		  pp$5.parseIdent = function(liberal) {
		    var node = this.parseIdentNode();
		    this.next(!!liberal);
		    this.finishNode(node, "Identifier");
		    if (!liberal) {
		      this.checkUnreserved(node);
		      if (node.name === "await" && !this.awaitIdentPos)
		        { this.awaitIdentPos = node.start; }
		    }
		    return node
		  };

		  pp$5.parseIdentNode = function() {
		    var node = this.startNode();
		    if (this.type === types$1.name) {
		      node.name = this.value;
		    } else if (this.type.keyword) {
		      node.name = this.type.keyword;

		      // To fix https://github.com/acornjs/acorn/issues/575
		      // `class` and `function` keywords push new context into this.context.
		      // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
		      // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
		      if ((node.name === "class" || node.name === "function") &&
		        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
		        this.context.pop();
		      }
		      this.type = types$1.name;
		    } else {
		      this.unexpected();
		    }
		    return node
		  };

		  pp$5.parsePrivateIdent = function() {
		    var node = this.startNode();
		    if (this.type === types$1.privateId) {
		      node.name = this.value;
		    } else {
		      this.unexpected();
		    }
		    this.next();
		    this.finishNode(node, "PrivateIdentifier");

		    // For validating existence
		    if (this.options.checkPrivateFields) {
		      if (this.privateNameStack.length === 0) {
		        this.raise(node.start, ("Private field '#" + (node.name) + "' must be declared in an enclosing class"));
		      } else {
		        this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
		      }
		    }

		    return node
		  };

		  // Parses yield expression inside generator.

		  pp$5.parseYield = function(forInit) {
		    if (!this.yieldPos) { this.yieldPos = this.start; }

		    var node = this.startNode();
		    this.next();
		    if (this.type === types$1.semi || this.canInsertSemicolon() || (this.type !== types$1.star && !this.type.startsExpr)) {
		      node.delegate = false;
		      node.argument = null;
		    } else {
		      node.delegate = this.eat(types$1.star);
		      node.argument = this.parseMaybeAssign(forInit);
		    }
		    return this.finishNode(node, "YieldExpression")
		  };

		  pp$5.parseAwait = function(forInit) {
		    if (!this.awaitPos) { this.awaitPos = this.start; }

		    var node = this.startNode();
		    this.next();
		    node.argument = this.parseMaybeUnary(null, true, false, forInit);
		    return this.finishNode(node, "AwaitExpression")
		  };

		  var pp$4 = Parser.prototype;

		  // This function is used to raise exceptions on parse errors. It
		  // takes an offset integer (into the current `input`) to indicate
		  // the location of the error, attaches the position to the end
		  // of the error message, and then raises a `SyntaxError` with that
		  // message.

		  pp$4.raise = function(pos, message) {
		    var loc = getLineInfo(this.input, pos);
		    message += " (" + loc.line + ":" + loc.column + ")";
		    var err = new SyntaxError(message);
		    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
		    throw err
		  };

		  pp$4.raiseRecoverable = pp$4.raise;

		  pp$4.curPosition = function() {
		    if (this.options.locations) {
		      return new Position(this.curLine, this.pos - this.lineStart)
		    }
		  };

		  var pp$3 = Parser.prototype;

		  var Scope = function Scope(flags) {
		    this.flags = flags;
		    // A list of var-declared names in the current lexical scope
		    this.var = [];
		    // A list of lexically-declared names in the current lexical scope
		    this.lexical = [];
		    // A list of lexically-declared FunctionDeclaration names in the current lexical scope
		    this.functions = [];
		    // A switch to disallow the identifier reference 'arguments'
		    this.inClassFieldInit = false;
		  };

		  // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

		  pp$3.enterScope = function(flags) {
		    this.scopeStack.push(new Scope(flags));
		  };

		  pp$3.exitScope = function() {
		    this.scopeStack.pop();
		  };

		  // The spec says:
		  // > At the top level of a function, or script, function declarations are
		  // > treated like var declarations rather than like lexical declarations.
		  pp$3.treatFunctionsAsVarInScope = function(scope) {
		    return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
		  };

		  pp$3.declareName = function(name, bindingType, pos) {
		    var redeclared = false;
		    if (bindingType === BIND_LEXICAL) {
		      var scope = this.currentScope();
		      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
		      scope.lexical.push(name);
		      if (this.inModule && (scope.flags & SCOPE_TOP))
		        { delete this.undefinedExports[name]; }
		    } else if (bindingType === BIND_SIMPLE_CATCH) {
		      var scope$1 = this.currentScope();
		      scope$1.lexical.push(name);
		    } else if (bindingType === BIND_FUNCTION) {
		      var scope$2 = this.currentScope();
		      if (this.treatFunctionsAsVar)
		        { redeclared = scope$2.lexical.indexOf(name) > -1; }
		      else
		        { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
		      scope$2.functions.push(name);
		    } else {
		      for (var i = this.scopeStack.length - 1; i >= 0; --i) {
		        var scope$3 = this.scopeStack[i];
		        if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
		            !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
		          redeclared = true;
		          break
		        }
		        scope$3.var.push(name);
		        if (this.inModule && (scope$3.flags & SCOPE_TOP))
		          { delete this.undefinedExports[name]; }
		        if (scope$3.flags & SCOPE_VAR) { break }
		      }
		    }
		    if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
		  };

		  pp$3.checkLocalExport = function(id) {
		    // scope.functions must be empty as Module code is always strict.
		    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
		        this.scopeStack[0].var.indexOf(id.name) === -1) {
		      this.undefinedExports[id.name] = id;
		    }
		  };

		  pp$3.currentScope = function() {
		    return this.scopeStack[this.scopeStack.length - 1]
		  };

		  pp$3.currentVarScope = function() {
		    for (var i = this.scopeStack.length - 1;; i--) {
		      var scope = this.scopeStack[i];
		      if (scope.flags & SCOPE_VAR) { return scope }
		    }
		  };

		  // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
		  pp$3.currentThisScope = function() {
		    for (var i = this.scopeStack.length - 1;; i--) {
		      var scope = this.scopeStack[i];
		      if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
		    }
		  };

		  var Node = function Node(parser, pos, loc) {
		    this.type = "";
		    this.start = pos;
		    this.end = 0;
		    if (parser.options.locations)
		      { this.loc = new SourceLocation(parser, loc); }
		    if (parser.options.directSourceFile)
		      { this.sourceFile = parser.options.directSourceFile; }
		    if (parser.options.ranges)
		      { this.range = [pos, 0]; }
		  };

		  // Start an AST node, attaching a start offset.

		  var pp$2 = Parser.prototype;

		  pp$2.startNode = function() {
		    return new Node(this, this.start, this.startLoc)
		  };

		  pp$2.startNodeAt = function(pos, loc) {
		    return new Node(this, pos, loc)
		  };

		  // Finish an AST node, adding `type` and `end` properties.

		  function finishNodeAt(node, type, pos, loc) {
		    node.type = type;
		    node.end = pos;
		    if (this.options.locations)
		      { node.loc.end = loc; }
		    if (this.options.ranges)
		      { node.range[1] = pos; }
		    return node
		  }

		  pp$2.finishNode = function(node, type) {
		    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
		  };

		  // Finish node at given position

		  pp$2.finishNodeAt = function(node, type, pos, loc) {
		    return finishNodeAt.call(this, node, type, pos, loc)
		  };

		  pp$2.copyNode = function(node) {
		    var newNode = new Node(this, node.start, this.startLoc);
		    for (var prop in node) { newNode[prop] = node[prop]; }
		    return newNode
		  };

		  // This file contains Unicode properties extracted from the ECMAScript specification.
		  // The lists are extracted like so:
		  // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

		  // #table-binary-unicode-properties
		  var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
		  var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
		  var ecma11BinaryProperties = ecma10BinaryProperties;
		  var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
		  var ecma13BinaryProperties = ecma12BinaryProperties;
		  var ecma14BinaryProperties = ecma13BinaryProperties;

		  var unicodeBinaryProperties = {
		    9: ecma9BinaryProperties,
		    10: ecma10BinaryProperties,
		    11: ecma11BinaryProperties,
		    12: ecma12BinaryProperties,
		    13: ecma13BinaryProperties,
		    14: ecma14BinaryProperties
		  };

		  // #table-binary-unicode-properties-of-strings
		  var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";

		  var unicodeBinaryPropertiesOfStrings = {
		    9: "",
		    10: "",
		    11: "",
		    12: "",
		    13: "",
		    14: ecma14BinaryPropertiesOfStrings
		  };

		  // #table-unicode-general-category-values
		  var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

		  // #table-unicode-script-values
		  var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
		  var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
		  var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
		  var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
		  var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
		  var ecma14ScriptValues = ecma13ScriptValues + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";

		  var unicodeScriptValues = {
		    9: ecma9ScriptValues,
		    10: ecma10ScriptValues,
		    11: ecma11ScriptValues,
		    12: ecma12ScriptValues,
		    13: ecma13ScriptValues,
		    14: ecma14ScriptValues
		  };

		  var data = {};
		  function buildUnicodeData(ecmaVersion) {
		    var d = data[ecmaVersion] = {
		      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
		      binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
		      nonBinary: {
		        General_Category: wordsRegexp(unicodeGeneralCategoryValues),
		        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
		      }
		    };
		    d.nonBinary.Script_Extensions = d.nonBinary.Script;

		    d.nonBinary.gc = d.nonBinary.General_Category;
		    d.nonBinary.sc = d.nonBinary.Script;
		    d.nonBinary.scx = d.nonBinary.Script_Extensions;
		  }

		  for (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
		    var ecmaVersion = list[i];

		    buildUnicodeData(ecmaVersion);
		  }

		  var pp$1 = Parser.prototype;

		  var RegExpValidationState = function RegExpValidationState(parser) {
		    this.parser = parser;
		    this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
		    this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
		    this.source = "";
		    this.flags = "";
		    this.start = 0;
		    this.switchU = false;
		    this.switchV = false;
		    this.switchN = false;
		    this.pos = 0;
		    this.lastIntValue = 0;
		    this.lastStringValue = "";
		    this.lastAssertionIsQuantifiable = false;
		    this.numCapturingParens = 0;
		    this.maxBackReference = 0;
		    this.groupNames = [];
		    this.backReferenceNames = [];
		  };

		  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
		    var unicodeSets = flags.indexOf("v") !== -1;
		    var unicode = flags.indexOf("u") !== -1;
		    this.start = start | 0;
		    this.source = pattern + "";
		    this.flags = flags;
		    if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
		      this.switchU = true;
		      this.switchV = true;
		      this.switchN = true;
		    } else {
		      this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
		      this.switchV = false;
		      this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
		    }
		  };

		  RegExpValidationState.prototype.raise = function raise (message) {
		    this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
		  };

		  // If u flag is given, this returns the code point at the index (it combines a surrogate pair).
		  // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
		  RegExpValidationState.prototype.at = function at (i, forceU) {
		      if ( forceU === void 0 ) forceU = false;

		    var s = this.source;
		    var l = s.length;
		    if (i >= l) {
		      return -1
		    }
		    var c = s.charCodeAt(i);
		    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
		      return c
		    }
		    var next = s.charCodeAt(i + 1);
		    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
		  };

		  RegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {
		      if ( forceU === void 0 ) forceU = false;

		    var s = this.source;
		    var l = s.length;
		    if (i >= l) {
		      return l
		    }
		    var c = s.charCodeAt(i), next;
		    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
		        (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
		      return i + 1
		    }
		    return i + 2
		  };

		  RegExpValidationState.prototype.current = function current (forceU) {
		      if ( forceU === void 0 ) forceU = false;

		    return this.at(this.pos, forceU)
		  };

		  RegExpValidationState.prototype.lookahead = function lookahead (forceU) {
		      if ( forceU === void 0 ) forceU = false;

		    return this.at(this.nextIndex(this.pos, forceU), forceU)
		  };

		  RegExpValidationState.prototype.advance = function advance (forceU) {
		      if ( forceU === void 0 ) forceU = false;

		    this.pos = this.nextIndex(this.pos, forceU);
		  };

		  RegExpValidationState.prototype.eat = function eat (ch, forceU) {
		      if ( forceU === void 0 ) forceU = false;

		    if (this.current(forceU) === ch) {
		      this.advance(forceU);
		      return true
		    }
		    return false
		  };

		  RegExpValidationState.prototype.eatChars = function eatChars (chs, forceU) {
		      if ( forceU === void 0 ) forceU = false;

		    var pos = this.pos;
		    for (var i = 0, list = chs; i < list.length; i += 1) {
		      var ch = list[i];

		        var current = this.at(pos, forceU);
		      if (current === -1 || current !== ch) {
		        return false
		      }
		      pos = this.nextIndex(pos, forceU);
		    }
		    this.pos = pos;
		    return true
		  };

		  /**
		   * Validate the flags part of a given RegExpLiteral.
		   *
		   * @param {RegExpValidationState} state The state to validate RegExp.
		   * @returns {void}
		   */
		  pp$1.validateRegExpFlags = function(state) {
		    var validFlags = state.validFlags;
		    var flags = state.flags;

		    var u = false;
		    var v = false;

		    for (var i = 0; i < flags.length; i++) {
		      var flag = flags.charAt(i);
		      if (validFlags.indexOf(flag) === -1) {
		        this.raise(state.start, "Invalid regular expression flag");
		      }
		      if (flags.indexOf(flag, i + 1) > -1) {
		        this.raise(state.start, "Duplicate regular expression flag");
		      }
		      if (flag === "u") { u = true; }
		      if (flag === "v") { v = true; }
		    }
		    if (this.options.ecmaVersion >= 15 && u && v) {
		      this.raise(state.start, "Invalid regular expression flag");
		    }
		  };

		  /**
		   * Validate the pattern part of a given RegExpLiteral.
		   *
		   * @param {RegExpValidationState} state The state to validate RegExp.
		   * @returns {void}
		   */
		  pp$1.validateRegExpPattern = function(state) {
		    this.regexp_pattern(state);

		    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
		    // parsing contains a |GroupName|, reparse with the goal symbol
		    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
		    // exception if _P_ did not conform to the grammar, if any elements of _P_
		    // were not matched by the parse, or if any Early Error conditions exist.
		    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
		      state.switchN = true;
		      this.regexp_pattern(state);
		    }
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
		  pp$1.regexp_pattern = function(state) {
		    state.pos = 0;
		    state.lastIntValue = 0;
		    state.lastStringValue = "";
		    state.lastAssertionIsQuantifiable = false;
		    state.numCapturingParens = 0;
		    state.maxBackReference = 0;
		    state.groupNames.length = 0;
		    state.backReferenceNames.length = 0;

		    this.regexp_disjunction(state);

		    if (state.pos !== state.source.length) {
		      // Make the same messages as V8.
		      if (state.eat(0x29 /* ) */)) {
		        state.raise("Unmatched ')'");
		      }
		      if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {
		        state.raise("Lone quantifier brackets");
		      }
		    }
		    if (state.maxBackReference > state.numCapturingParens) {
		      state.raise("Invalid escape");
		    }
		    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
		      var name = list[i];

		      if (state.groupNames.indexOf(name) === -1) {
		        state.raise("Invalid named capture referenced");
		      }
		    }
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
		  pp$1.regexp_disjunction = function(state) {
		    this.regexp_alternative(state);
		    while (state.eat(0x7C /* | */)) {
		      this.regexp_alternative(state);
		    }

		    // Make the same message as V8.
		    if (this.regexp_eatQuantifier(state, true)) {
		      state.raise("Nothing to repeat");
		    }
		    if (state.eat(0x7B /* { */)) {
		      state.raise("Lone quantifier brackets");
		    }
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
		  pp$1.regexp_alternative = function(state) {
		    while (state.pos < state.source.length && this.regexp_eatTerm(state))
		      { }
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
		  pp$1.regexp_eatTerm = function(state) {
		    if (this.regexp_eatAssertion(state)) {
		      // Handle `QuantifiableAssertion Quantifier` alternative.
		      // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
		      // is a QuantifiableAssertion.
		      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
		        // Make the same message as V8.
		        if (state.switchU) {
		          state.raise("Invalid quantifier");
		        }
		      }
		      return true
		    }

		    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
		      this.regexp_eatQuantifier(state);
		      return true
		    }

		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
		  pp$1.regexp_eatAssertion = function(state) {
		    var start = state.pos;
		    state.lastAssertionIsQuantifiable = false;

		    // ^, $
		    if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
		      return true
		    }

		    // \b \B
		    if (state.eat(0x5C /* \ */)) {
		      if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
		        return true
		      }
		      state.pos = start;
		    }

		    // Lookahead / Lookbehind
		    if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
		      var lookbehind = false;
		      if (this.options.ecmaVersion >= 9) {
		        lookbehind = state.eat(0x3C /* < */);
		      }
		      if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
		        this.regexp_disjunction(state);
		        if (!state.eat(0x29 /* ) */)) {
		          state.raise("Unterminated group");
		        }
		        state.lastAssertionIsQuantifiable = !lookbehind;
		        return true
		      }
		    }

		    state.pos = start;
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
		  pp$1.regexp_eatQuantifier = function(state, noError) {
		    if ( noError === void 0 ) noError = false;

		    if (this.regexp_eatQuantifierPrefix(state, noError)) {
		      state.eat(0x3F /* ? */);
		      return true
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
		  pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
		    return (
		      state.eat(0x2A /* * */) ||
		      state.eat(0x2B /* + */) ||
		      state.eat(0x3F /* ? */) ||
		      this.regexp_eatBracedQuantifier(state, noError)
		    )
		  };
		  pp$1.regexp_eatBracedQuantifier = function(state, noError) {
		    var start = state.pos;
		    if (state.eat(0x7B /* { */)) {
		      var min = 0, max = -1;
		      if (this.regexp_eatDecimalDigits(state)) {
		        min = state.lastIntValue;
		        if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
		          max = state.lastIntValue;
		        }
		        if (state.eat(0x7D /* } */)) {
		          // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
		          if (max !== -1 && max < min && !noError) {
		            state.raise("numbers out of order in {} quantifier");
		          }
		          return true
		        }
		      }
		      if (state.switchU && !noError) {
		        state.raise("Incomplete quantifier");
		      }
		      state.pos = start;
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
		  pp$1.regexp_eatAtom = function(state) {
		    return (
		      this.regexp_eatPatternCharacters(state) ||
		      state.eat(0x2E /* . */) ||
		      this.regexp_eatReverseSolidusAtomEscape(state) ||
		      this.regexp_eatCharacterClass(state) ||
		      this.regexp_eatUncapturingGroup(state) ||
		      this.regexp_eatCapturingGroup(state)
		    )
		  };
		  pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
		    var start = state.pos;
		    if (state.eat(0x5C /* \ */)) {
		      if (this.regexp_eatAtomEscape(state)) {
		        return true
		      }
		      state.pos = start;
		    }
		    return false
		  };
		  pp$1.regexp_eatUncapturingGroup = function(state) {
		    var start = state.pos;
		    if (state.eat(0x28 /* ( */)) {
		      if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
		        this.regexp_disjunction(state);
		        if (state.eat(0x29 /* ) */)) {
		          return true
		        }
		        state.raise("Unterminated group");
		      }
		      state.pos = start;
		    }
		    return false
		  };
		  pp$1.regexp_eatCapturingGroup = function(state) {
		    if (state.eat(0x28 /* ( */)) {
		      if (this.options.ecmaVersion >= 9) {
		        this.regexp_groupSpecifier(state);
		      } else if (state.current() === 0x3F /* ? */) {
		        state.raise("Invalid group");
		      }
		      this.regexp_disjunction(state);
		      if (state.eat(0x29 /* ) */)) {
		        state.numCapturingParens += 1;
		        return true
		      }
		      state.raise("Unterminated group");
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
		  pp$1.regexp_eatExtendedAtom = function(state) {
		    return (
		      state.eat(0x2E /* . */) ||
		      this.regexp_eatReverseSolidusAtomEscape(state) ||
		      this.regexp_eatCharacterClass(state) ||
		      this.regexp_eatUncapturingGroup(state) ||
		      this.regexp_eatCapturingGroup(state) ||
		      this.regexp_eatInvalidBracedQuantifier(state) ||
		      this.regexp_eatExtendedPatternCharacter(state)
		    )
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
		  pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
		    if (this.regexp_eatBracedQuantifier(state, true)) {
		      state.raise("Nothing to repeat");
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
		  pp$1.regexp_eatSyntaxCharacter = function(state) {
		    var ch = state.current();
		    if (isSyntaxCharacter(ch)) {
		      state.lastIntValue = ch;
		      state.advance();
		      return true
		    }
		    return false
		  };
		  function isSyntaxCharacter(ch) {
		    return (
		      ch === 0x24 /* $ */ ||
		      ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
		      ch === 0x2E /* . */ ||
		      ch === 0x3F /* ? */ ||
		      ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
		      ch >= 0x7B /* { */ && ch <= 0x7D /* } */
		    )
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
		  // But eat eager.
		  pp$1.regexp_eatPatternCharacters = function(state) {
		    var start = state.pos;
		    var ch = 0;
		    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
		      state.advance();
		    }
		    return state.pos !== start
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
		  pp$1.regexp_eatExtendedPatternCharacter = function(state) {
		    var ch = state.current();
		    if (
		      ch !== -1 &&
		      ch !== 0x24 /* $ */ &&
		      !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
		      ch !== 0x2E /* . */ &&
		      ch !== 0x3F /* ? */ &&
		      ch !== 0x5B /* [ */ &&
		      ch !== 0x5E /* ^ */ &&
		      ch !== 0x7C /* | */
		    ) {
		      state.advance();
		      return true
		    }
		    return false
		  };

		  // GroupSpecifier ::
		  //   [empty]
		  //   `?` GroupName
		  pp$1.regexp_groupSpecifier = function(state) {
		    if (state.eat(0x3F /* ? */)) {
		      if (this.regexp_eatGroupName(state)) {
		        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
		          state.raise("Duplicate capture group name");
		        }
		        state.groupNames.push(state.lastStringValue);
		        return
		      }
		      state.raise("Invalid group");
		    }
		  };

		  // GroupName ::
		  //   `<` RegExpIdentifierName `>`
		  // Note: this updates `state.lastStringValue` property with the eaten name.
		  pp$1.regexp_eatGroupName = function(state) {
		    state.lastStringValue = "";
		    if (state.eat(0x3C /* < */)) {
		      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
		        return true
		      }
		      state.raise("Invalid capture group name");
		    }
		    return false
		  };

		  // RegExpIdentifierName ::
		  //   RegExpIdentifierStart
		  //   RegExpIdentifierName RegExpIdentifierPart
		  // Note: this updates `state.lastStringValue` property with the eaten name.
		  pp$1.regexp_eatRegExpIdentifierName = function(state) {
		    state.lastStringValue = "";
		    if (this.regexp_eatRegExpIdentifierStart(state)) {
		      state.lastStringValue += codePointToString(state.lastIntValue);
		      while (this.regexp_eatRegExpIdentifierPart(state)) {
		        state.lastStringValue += codePointToString(state.lastIntValue);
		      }
		      return true
		    }
		    return false
		  };

		  // RegExpIdentifierStart ::
		  //   UnicodeIDStart
		  //   `$`
		  //   `_`
		  //   `\` RegExpUnicodeEscapeSequence[+U]
		  pp$1.regexp_eatRegExpIdentifierStart = function(state) {
		    var start = state.pos;
		    var forceU = this.options.ecmaVersion >= 11;
		    var ch = state.current(forceU);
		    state.advance(forceU);

		    if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
		      ch = state.lastIntValue;
		    }
		    if (isRegExpIdentifierStart(ch)) {
		      state.lastIntValue = ch;
		      return true
		    }

		    state.pos = start;
		    return false
		  };
		  function isRegExpIdentifierStart(ch) {
		    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
		  }

		  // RegExpIdentifierPart ::
		  //   UnicodeIDContinue
		  //   `$`
		  //   `_`
		  //   `\` RegExpUnicodeEscapeSequence[+U]
		  //   <ZWNJ>
		  //   <ZWJ>
		  pp$1.regexp_eatRegExpIdentifierPart = function(state) {
		    var start = state.pos;
		    var forceU = this.options.ecmaVersion >= 11;
		    var ch = state.current(forceU);
		    state.advance(forceU);

		    if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
		      ch = state.lastIntValue;
		    }
		    if (isRegExpIdentifierPart(ch)) {
		      state.lastIntValue = ch;
		      return true
		    }

		    state.pos = start;
		    return false
		  };
		  function isRegExpIdentifierPart(ch) {
		    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
		  pp$1.regexp_eatAtomEscape = function(state) {
		    if (
		      this.regexp_eatBackReference(state) ||
		      this.regexp_eatCharacterClassEscape(state) ||
		      this.regexp_eatCharacterEscape(state) ||
		      (state.switchN && this.regexp_eatKGroupName(state))
		    ) {
		      return true
		    }
		    if (state.switchU) {
		      // Make the same message as V8.
		      if (state.current() === 0x63 /* c */) {
		        state.raise("Invalid unicode escape");
		      }
		      state.raise("Invalid escape");
		    }
		    return false
		  };
		  pp$1.regexp_eatBackReference = function(state) {
		    var start = state.pos;
		    if (this.regexp_eatDecimalEscape(state)) {
		      var n = state.lastIntValue;
		      if (state.switchU) {
		        // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
		        if (n > state.maxBackReference) {
		          state.maxBackReference = n;
		        }
		        return true
		      }
		      if (n <= state.numCapturingParens) {
		        return true
		      }
		      state.pos = start;
		    }
		    return false
		  };
		  pp$1.regexp_eatKGroupName = function(state) {
		    if (state.eat(0x6B /* k */)) {
		      if (this.regexp_eatGroupName(state)) {
		        state.backReferenceNames.push(state.lastStringValue);
		        return true
		      }
		      state.raise("Invalid named reference");
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
		  pp$1.regexp_eatCharacterEscape = function(state) {
		    return (
		      this.regexp_eatControlEscape(state) ||
		      this.regexp_eatCControlLetter(state) ||
		      this.regexp_eatZero(state) ||
		      this.regexp_eatHexEscapeSequence(state) ||
		      this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||
		      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
		      this.regexp_eatIdentityEscape(state)
		    )
		  };
		  pp$1.regexp_eatCControlLetter = function(state) {
		    var start = state.pos;
		    if (state.eat(0x63 /* c */)) {
		      if (this.regexp_eatControlLetter(state)) {
		        return true
		      }
		      state.pos = start;
		    }
		    return false
		  };
		  pp$1.regexp_eatZero = function(state) {
		    if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
		      state.lastIntValue = 0;
		      state.advance();
		      return true
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
		  pp$1.regexp_eatControlEscape = function(state) {
		    var ch = state.current();
		    if (ch === 0x74 /* t */) {
		      state.lastIntValue = 0x09; /* \t */
		      state.advance();
		      return true
		    }
		    if (ch === 0x6E /* n */) {
		      state.lastIntValue = 0x0A; /* \n */
		      state.advance();
		      return true
		    }
		    if (ch === 0x76 /* v */) {
		      state.lastIntValue = 0x0B; /* \v */
		      state.advance();
		      return true
		    }
		    if (ch === 0x66 /* f */) {
		      state.lastIntValue = 0x0C; /* \f */
		      state.advance();
		      return true
		    }
		    if (ch === 0x72 /* r */) {
		      state.lastIntValue = 0x0D; /* \r */
		      state.advance();
		      return true
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
		  pp$1.regexp_eatControlLetter = function(state) {
		    var ch = state.current();
		    if (isControlLetter(ch)) {
		      state.lastIntValue = ch % 0x20;
		      state.advance();
		      return true
		    }
		    return false
		  };
		  function isControlLetter(ch) {
		    return (
		      (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
		      (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
		    )
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
		  pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
		    if ( forceU === void 0 ) forceU = false;

		    var start = state.pos;
		    var switchU = forceU || state.switchU;

		    if (state.eat(0x75 /* u */)) {
		      if (this.regexp_eatFixedHexDigits(state, 4)) {
		        var lead = state.lastIntValue;
		        if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
		          var leadSurrogateEnd = state.pos;
		          if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
		            var trail = state.lastIntValue;
		            if (trail >= 0xDC00 && trail <= 0xDFFF) {
		              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
		              return true
		            }
		          }
		          state.pos = leadSurrogateEnd;
		          state.lastIntValue = lead;
		        }
		        return true
		      }
		      if (
		        switchU &&
		        state.eat(0x7B /* { */) &&
		        this.regexp_eatHexDigits(state) &&
		        state.eat(0x7D /* } */) &&
		        isValidUnicode(state.lastIntValue)
		      ) {
		        return true
		      }
		      if (switchU) {
		        state.raise("Invalid unicode escape");
		      }
		      state.pos = start;
		    }

		    return false
		  };
		  function isValidUnicode(ch) {
		    return ch >= 0 && ch <= 0x10FFFF
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
		  pp$1.regexp_eatIdentityEscape = function(state) {
		    if (state.switchU) {
		      if (this.regexp_eatSyntaxCharacter(state)) {
		        return true
		      }
		      if (state.eat(0x2F /* / */)) {
		        state.lastIntValue = 0x2F; /* / */
		        return true
		      }
		      return false
		    }

		    var ch = state.current();
		    if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
		      state.lastIntValue = ch;
		      state.advance();
		      return true
		    }

		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
		  pp$1.regexp_eatDecimalEscape = function(state) {
		    state.lastIntValue = 0;
		    var ch = state.current();
		    if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
		      do {
		        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
		        state.advance();
		      } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
		      return true
		    }
		    return false
		  };

		  // Return values used by character set parsing methods, needed to
		  // forbid negation of sets that can match strings.
		  var CharSetNone = 0; // Nothing parsed
		  var CharSetOk = 1; // Construct parsed, cannot contain strings
		  var CharSetString = 2; // Construct parsed, can contain strings

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
		  pp$1.regexp_eatCharacterClassEscape = function(state) {
		    var ch = state.current();

		    if (isCharacterClassEscape(ch)) {
		      state.lastIntValue = -1;
		      state.advance();
		      return CharSetOk
		    }

		    var negate = false;
		    if (
		      state.switchU &&
		      this.options.ecmaVersion >= 9 &&
		      ((negate = ch === 0x50 /* P */) || ch === 0x70 /* p */)
		    ) {
		      state.lastIntValue = -1;
		      state.advance();
		      var result;
		      if (
		        state.eat(0x7B /* { */) &&
		        (result = this.regexp_eatUnicodePropertyValueExpression(state)) &&
		        state.eat(0x7D /* } */)
		      ) {
		        if (negate && result === CharSetString) { state.raise("Invalid property name"); }
		        return result
		      }
		      state.raise("Invalid property name");
		    }

		    return CharSetNone
		  };

		  function isCharacterClassEscape(ch) {
		    return (
		      ch === 0x64 /* d */ ||
		      ch === 0x44 /* D */ ||
		      ch === 0x73 /* s */ ||
		      ch === 0x53 /* S */ ||
		      ch === 0x77 /* w */ ||
		      ch === 0x57 /* W */
		    )
		  }

		  // UnicodePropertyValueExpression ::
		  //   UnicodePropertyName `=` UnicodePropertyValue
		  //   LoneUnicodePropertyNameOrValue
		  pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
		    var start = state.pos;

		    // UnicodePropertyName `=` UnicodePropertyValue
		    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
		      var name = state.lastStringValue;
		      if (this.regexp_eatUnicodePropertyValue(state)) {
		        var value = state.lastStringValue;
		        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
		        return CharSetOk
		      }
		    }
		    state.pos = start;

		    // LoneUnicodePropertyNameOrValue
		    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
		      var nameOrValue = state.lastStringValue;
		      return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue)
		    }
		    return CharSetNone
		  };

		  pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
		    if (!hasOwn(state.unicodeProperties.nonBinary, name))
		      { state.raise("Invalid property name"); }
		    if (!state.unicodeProperties.nonBinary[name].test(value))
		      { state.raise("Invalid property value"); }
		  };

		  pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
		    if (state.unicodeProperties.binary.test(nameOrValue)) { return CharSetOk }
		    if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) { return CharSetString }
		    state.raise("Invalid property name");
		  };

		  // UnicodePropertyName ::
		  //   UnicodePropertyNameCharacters
		  pp$1.regexp_eatUnicodePropertyName = function(state) {
		    var ch = 0;
		    state.lastStringValue = "";
		    while (isUnicodePropertyNameCharacter(ch = state.current())) {
		      state.lastStringValue += codePointToString(ch);
		      state.advance();
		    }
		    return state.lastStringValue !== ""
		  };

		  function isUnicodePropertyNameCharacter(ch) {
		    return isControlLetter(ch) || ch === 0x5F /* _ */
		  }

		  // UnicodePropertyValue ::
		  //   UnicodePropertyValueCharacters
		  pp$1.regexp_eatUnicodePropertyValue = function(state) {
		    var ch = 0;
		    state.lastStringValue = "";
		    while (isUnicodePropertyValueCharacter(ch = state.current())) {
		      state.lastStringValue += codePointToString(ch);
		      state.advance();
		    }
		    return state.lastStringValue !== ""
		  };
		  function isUnicodePropertyValueCharacter(ch) {
		    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
		  }

		  // LoneUnicodePropertyNameOrValue ::
		  //   UnicodePropertyValueCharacters
		  pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
		    return this.regexp_eatUnicodePropertyValue(state)
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
		  pp$1.regexp_eatCharacterClass = function(state) {
		    if (state.eat(0x5B /* [ */)) {
		      var negate = state.eat(0x5E /* ^ */);
		      var result = this.regexp_classContents(state);
		      if (!state.eat(0x5D /* ] */))
		        { state.raise("Unterminated character class"); }
		      if (negate && result === CharSetString)
		        { state.raise("Negated character class may contain strings"); }
		      return true
		    }
		    return false
		  };

		  // https://tc39.es/ecma262/#prod-ClassContents
		  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
		  pp$1.regexp_classContents = function(state) {
		    if (state.current() === 0x5D /* ] */) { return CharSetOk }
		    if (state.switchV) { return this.regexp_classSetExpression(state) }
		    this.regexp_nonEmptyClassRanges(state);
		    return CharSetOk
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
		  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
		  pp$1.regexp_nonEmptyClassRanges = function(state) {
		    while (this.regexp_eatClassAtom(state)) {
		      var left = state.lastIntValue;
		      if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
		        var right = state.lastIntValue;
		        if (state.switchU && (left === -1 || right === -1)) {
		          state.raise("Invalid character class");
		        }
		        if (left !== -1 && right !== -1 && left > right) {
		          state.raise("Range out of order in character class");
		        }
		      }
		    }
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
		  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
		  pp$1.regexp_eatClassAtom = function(state) {
		    var start = state.pos;

		    if (state.eat(0x5C /* \ */)) {
		      if (this.regexp_eatClassEscape(state)) {
		        return true
		      }
		      if (state.switchU) {
		        // Make the same message as V8.
		        var ch$1 = state.current();
		        if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
		          state.raise("Invalid class escape");
		        }
		        state.raise("Invalid escape");
		      }
		      state.pos = start;
		    }

		    var ch = state.current();
		    if (ch !== 0x5D /* ] */) {
		      state.lastIntValue = ch;
		      state.advance();
		      return true
		    }

		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
		  pp$1.regexp_eatClassEscape = function(state) {
		    var start = state.pos;

		    if (state.eat(0x62 /* b */)) {
		      state.lastIntValue = 0x08; /* <BS> */
		      return true
		    }

		    if (state.switchU && state.eat(0x2D /* - */)) {
		      state.lastIntValue = 0x2D; /* - */
		      return true
		    }

		    if (!state.switchU && state.eat(0x63 /* c */)) {
		      if (this.regexp_eatClassControlLetter(state)) {
		        return true
		      }
		      state.pos = start;
		    }

		    return (
		      this.regexp_eatCharacterClassEscape(state) ||
		      this.regexp_eatCharacterEscape(state)
		    )
		  };

		  // https://tc39.es/ecma262/#prod-ClassSetExpression
		  // https://tc39.es/ecma262/#prod-ClassUnion
		  // https://tc39.es/ecma262/#prod-ClassIntersection
		  // https://tc39.es/ecma262/#prod-ClassSubtraction
		  pp$1.regexp_classSetExpression = function(state) {
		    var result = CharSetOk, subResult;
		    if (this.regexp_eatClassSetRange(state)) ; else if (subResult = this.regexp_eatClassSetOperand(state)) {
		      if (subResult === CharSetString) { result = CharSetString; }
		      // https://tc39.es/ecma262/#prod-ClassIntersection
		      var start = state.pos;
		      while (state.eatChars([0x26, 0x26] /* && */)) {
		        if (
		          state.current() !== 0x26 /* & */ &&
		          (subResult = this.regexp_eatClassSetOperand(state))
		        ) {
		          if (subResult !== CharSetString) { result = CharSetOk; }
		          continue
		        }
		        state.raise("Invalid character in character class");
		      }
		      if (start !== state.pos) { return result }
		      // https://tc39.es/ecma262/#prod-ClassSubtraction
		      while (state.eatChars([0x2D, 0x2D] /* -- */)) {
		        if (this.regexp_eatClassSetOperand(state)) { continue }
		        state.raise("Invalid character in character class");
		      }
		      if (start !== state.pos) { return result }
		    } else {
		      state.raise("Invalid character in character class");
		    }
		    // https://tc39.es/ecma262/#prod-ClassUnion
		    for (;;) {
		      if (this.regexp_eatClassSetRange(state)) { continue }
		      subResult = this.regexp_eatClassSetOperand(state);
		      if (!subResult) { return result }
		      if (subResult === CharSetString) { result = CharSetString; }
		    }
		  };

		  // https://tc39.es/ecma262/#prod-ClassSetRange
		  pp$1.regexp_eatClassSetRange = function(state) {
		    var start = state.pos;
		    if (this.regexp_eatClassSetCharacter(state)) {
		      var left = state.lastIntValue;
		      if (state.eat(0x2D /* - */) && this.regexp_eatClassSetCharacter(state)) {
		        var right = state.lastIntValue;
		        if (left !== -1 && right !== -1 && left > right) {
		          state.raise("Range out of order in character class");
		        }
		        return true
		      }
		      state.pos = start;
		    }
		    return false
		  };

		  // https://tc39.es/ecma262/#prod-ClassSetOperand
		  pp$1.regexp_eatClassSetOperand = function(state) {
		    if (this.regexp_eatClassSetCharacter(state)) { return CharSetOk }
		    return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state)
		  };

		  // https://tc39.es/ecma262/#prod-NestedClass
		  pp$1.regexp_eatNestedClass = function(state) {
		    var start = state.pos;
		    if (state.eat(0x5B /* [ */)) {
		      var negate = state.eat(0x5E /* ^ */);
		      var result = this.regexp_classContents(state);
		      if (state.eat(0x5D /* ] */)) {
		        if (negate && result === CharSetString) {
		          state.raise("Negated character class may contain strings");
		        }
		        return result
		      }
		      state.pos = start;
		    }
		    if (state.eat(0x5C /* \ */)) {
		      var result$1 = this.regexp_eatCharacterClassEscape(state);
		      if (result$1) {
		        return result$1
		      }
		      state.pos = start;
		    }
		    return null
		  };

		  // https://tc39.es/ecma262/#prod-ClassStringDisjunction
		  pp$1.regexp_eatClassStringDisjunction = function(state) {
		    var start = state.pos;
		    if (state.eatChars([0x5C, 0x71] /* \q */)) {
		      if (state.eat(0x7B /* { */)) {
		        var result = this.regexp_classStringDisjunctionContents(state);
		        if (state.eat(0x7D /* } */)) {
		          return result
		        }
		      } else {
		        // Make the same message as V8.
		        state.raise("Invalid escape");
		      }
		      state.pos = start;
		    }
		    return null
		  };

		  // https://tc39.es/ecma262/#prod-ClassStringDisjunctionContents
		  pp$1.regexp_classStringDisjunctionContents = function(state) {
		    var result = this.regexp_classString(state);
		    while (state.eat(0x7C /* | */)) {
		      if (this.regexp_classString(state) === CharSetString) { result = CharSetString; }
		    }
		    return result
		  };

		  // https://tc39.es/ecma262/#prod-ClassString
		  // https://tc39.es/ecma262/#prod-NonEmptyClassString
		  pp$1.regexp_classString = function(state) {
		    var count = 0;
		    while (this.regexp_eatClassSetCharacter(state)) { count++; }
		    return count === 1 ? CharSetOk : CharSetString
		  };

		  // https://tc39.es/ecma262/#prod-ClassSetCharacter
		  pp$1.regexp_eatClassSetCharacter = function(state) {
		    var start = state.pos;
		    if (state.eat(0x5C /* \ */)) {
		      if (
		        this.regexp_eatCharacterEscape(state) ||
		        this.regexp_eatClassSetReservedPunctuator(state)
		      ) {
		        return true
		      }
		      if (state.eat(0x62 /* b */)) {
		        state.lastIntValue = 0x08; /* <BS> */
		        return true
		      }
		      state.pos = start;
		      return false
		    }
		    var ch = state.current();
		    if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) { return false }
		    if (isClassSetSyntaxCharacter(ch)) { return false }
		    state.advance();
		    state.lastIntValue = ch;
		    return true
		  };

		  // https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator
		  function isClassSetReservedDoublePunctuatorCharacter(ch) {
		    return (
		      ch === 0x21 /* ! */ ||
		      ch >= 0x23 /* # */ && ch <= 0x26 /* & */ ||
		      ch >= 0x2A /* * */ && ch <= 0x2C /* , */ ||
		      ch === 0x2E /* . */ ||
		      ch >= 0x3A /* : */ && ch <= 0x40 /* @ */ ||
		      ch === 0x5E /* ^ */ ||
		      ch === 0x60 /* ` */ ||
		      ch === 0x7E /* ~ */
		    )
		  }

		  // https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter
		  function isClassSetSyntaxCharacter(ch) {
		    return (
		      ch === 0x28 /* ( */ ||
		      ch === 0x29 /* ) */ ||
		      ch === 0x2D /* - */ ||
		      ch === 0x2F /* / */ ||
		      ch >= 0x5B /* [ */ && ch <= 0x5D /* ] */ ||
		      ch >= 0x7B /* { */ && ch <= 0x7D /* } */
		    )
		  }

		  // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator
		  pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
		    var ch = state.current();
		    if (isClassSetReservedPunctuator(ch)) {
		      state.lastIntValue = ch;
		      state.advance();
		      return true
		    }
		    return false
		  };

		  // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator
		  function isClassSetReservedPunctuator(ch) {
		    return (
		      ch === 0x21 /* ! */ ||
		      ch === 0x23 /* # */ ||
		      ch === 0x25 /* % */ ||
		      ch === 0x26 /* & */ ||
		      ch === 0x2C /* , */ ||
		      ch === 0x2D /* - */ ||
		      ch >= 0x3A /* : */ && ch <= 0x3E /* > */ ||
		      ch === 0x40 /* @ */ ||
		      ch === 0x60 /* ` */ ||
		      ch === 0x7E /* ~ */
		    )
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
		  pp$1.regexp_eatClassControlLetter = function(state) {
		    var ch = state.current();
		    if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
		      state.lastIntValue = ch % 0x20;
		      state.advance();
		      return true
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
		  pp$1.regexp_eatHexEscapeSequence = function(state) {
		    var start = state.pos;
		    if (state.eat(0x78 /* x */)) {
		      if (this.regexp_eatFixedHexDigits(state, 2)) {
		        return true
		      }
		      if (state.switchU) {
		        state.raise("Invalid escape");
		      }
		      state.pos = start;
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
		  pp$1.regexp_eatDecimalDigits = function(state) {
		    var start = state.pos;
		    var ch = 0;
		    state.lastIntValue = 0;
		    while (isDecimalDigit(ch = state.current())) {
		      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
		      state.advance();
		    }
		    return state.pos !== start
		  };
		  function isDecimalDigit(ch) {
		    return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
		  pp$1.regexp_eatHexDigits = function(state) {
		    var start = state.pos;
		    var ch = 0;
		    state.lastIntValue = 0;
		    while (isHexDigit(ch = state.current())) {
		      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
		      state.advance();
		    }
		    return state.pos !== start
		  };
		  function isHexDigit(ch) {
		    return (
		      (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
		      (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
		      (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
		    )
		  }
		  function hexToInt(ch) {
		    if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
		      return 10 + (ch - 0x41 /* A */)
		    }
		    if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
		      return 10 + (ch - 0x61 /* a */)
		    }
		    return ch - 0x30 /* 0 */
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
		  // Allows only 0-377(octal) i.e. 0-255(decimal).
		  pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
		    if (this.regexp_eatOctalDigit(state)) {
		      var n1 = state.lastIntValue;
		      if (this.regexp_eatOctalDigit(state)) {
		        var n2 = state.lastIntValue;
		        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
		          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
		        } else {
		          state.lastIntValue = n1 * 8 + n2;
		        }
		      } else {
		        state.lastIntValue = n1;
		      }
		      return true
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
		  pp$1.regexp_eatOctalDigit = function(state) {
		    var ch = state.current();
		    if (isOctalDigit(ch)) {
		      state.lastIntValue = ch - 0x30; /* 0 */
		      state.advance();
		      return true
		    }
		    state.lastIntValue = 0;
		    return false
		  };
		  function isOctalDigit(ch) {
		    return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
		  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
		  // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
		  pp$1.regexp_eatFixedHexDigits = function(state, length) {
		    var start = state.pos;
		    state.lastIntValue = 0;
		    for (var i = 0; i < length; ++i) {
		      var ch = state.current();
		      if (!isHexDigit(ch)) {
		        state.pos = start;
		        return false
		      }
		      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
		      state.advance();
		    }
		    return true
		  };

		  // Object type used to represent tokens. Note that normally, tokens
		  // simply exist as properties on the parser object. This is only
		  // used for the onToken callback and the external tokenizer.

		  var Token = function Token(p) {
		    this.type = p.type;
		    this.value = p.value;
		    this.start = p.start;
		    this.end = p.end;
		    if (p.options.locations)
		      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
		    if (p.options.ranges)
		      { this.range = [p.start, p.end]; }
		  };

		  // ## Tokenizer

		  var pp = Parser.prototype;

		  // Move to the next token

		  pp.next = function(ignoreEscapeSequenceInKeyword) {
		    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
		      { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
		    if (this.options.onToken)
		      { this.options.onToken(new Token(this)); }

		    this.lastTokEnd = this.end;
		    this.lastTokStart = this.start;
		    this.lastTokEndLoc = this.endLoc;
		    this.lastTokStartLoc = this.startLoc;
		    this.nextToken();
		  };

		  pp.getToken = function() {
		    this.next();
		    return new Token(this)
		  };

		  // If we're in an ES6 environment, make parsers iterable
		  if (typeof Symbol !== "undefined")
		    { pp[Symbol.iterator] = function() {
		      var this$1$1 = this;

		      return {
		        next: function () {
		          var token = this$1$1.getToken();
		          return {
		            done: token.type === types$1.eof,
		            value: token
		          }
		        }
		      }
		    }; }

		  // Toggle strict mode. Re-reads the next number or string to please
		  // pedantic tests (`"use strict"; 010;` should fail).

		  // Read a single token, updating the parser object's token-related
		  // properties.

		  pp.nextToken = function() {
		    var curContext = this.curContext();
		    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

		    this.start = this.pos;
		    if (this.options.locations) { this.startLoc = this.curPosition(); }
		    if (this.pos >= this.input.length) { return this.finishToken(types$1.eof) }

		    if (curContext.override) { return curContext.override(this) }
		    else { this.readToken(this.fullCharCodeAtPos()); }
		  };

		  pp.readToken = function(code) {
		    // Identifier or keyword. '\uXXXX' sequences are allowed in
		    // identifiers, so '\' also dispatches to that.
		    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
		      { return this.readWord() }

		    return this.getTokenFromCode(code)
		  };

		  pp.fullCharCodeAtPos = function() {
		    var code = this.input.charCodeAt(this.pos);
		    if (code <= 0xd7ff || code >= 0xdc00) { return code }
		    var next = this.input.charCodeAt(this.pos + 1);
		    return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00
		  };

		  pp.skipBlockComment = function() {
		    var startLoc = this.options.onComment && this.curPosition();
		    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
		    if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
		    this.pos = end + 2;
		    if (this.options.locations) {
		      for (var nextBreak = (void 0), pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {
		        ++this.curLine;
		        pos = this.lineStart = nextBreak;
		      }
		    }
		    if (this.options.onComment)
		      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
		                             startLoc, this.curPosition()); }
		  };

		  pp.skipLineComment = function(startSkip) {
		    var start = this.pos;
		    var startLoc = this.options.onComment && this.curPosition();
		    var ch = this.input.charCodeAt(this.pos += startSkip);
		    while (this.pos < this.input.length && !isNewLine(ch)) {
		      ch = this.input.charCodeAt(++this.pos);
		    }
		    if (this.options.onComment)
		      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
		                             startLoc, this.curPosition()); }
		  };

		  // Called at the start of the parse and after every token. Skips
		  // whitespace and comments, and.

		  pp.skipSpace = function() {
		    loop: while (this.pos < this.input.length) {
		      var ch = this.input.charCodeAt(this.pos);
		      switch (ch) {
		      case 32: case 160: // ' '
		        ++this.pos;
		        break
		      case 13:
		        if (this.input.charCodeAt(this.pos + 1) === 10) {
		          ++this.pos;
		        }
		      case 10: case 8232: case 8233:
		        ++this.pos;
		        if (this.options.locations) {
		          ++this.curLine;
		          this.lineStart = this.pos;
		        }
		        break
		      case 47: // '/'
		        switch (this.input.charCodeAt(this.pos + 1)) {
		        case 42: // '*'
		          this.skipBlockComment();
		          break
		        case 47:
		          this.skipLineComment(2);
		          break
		        default:
		          break loop
		        }
		        break
		      default:
		        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
		          ++this.pos;
		        } else {
		          break loop
		        }
		      }
		    }
		  };

		  // Called at the end of every token. Sets `end`, `val`, and
		  // maintains `context` and `exprAllowed`, and skips the space after
		  // the token, so that the next one's `start` will point at the
		  // right position.

		  pp.finishToken = function(type, val) {
		    this.end = this.pos;
		    if (this.options.locations) { this.endLoc = this.curPosition(); }
		    var prevType = this.type;
		    this.type = type;
		    this.value = val;

		    this.updateContext(prevType);
		  };

		  // ### Token reading

		  // This is the function that is called to fetch the next token. It
		  // is somewhat obscure, because it works in character codes rather
		  // than characters, and because operator parsing has been inlined
		  // into it.
		  //
		  // All in the name of speed.
		  //
		  pp.readToken_dot = function() {
		    var next = this.input.charCodeAt(this.pos + 1);
		    if (next >= 48 && next <= 57) { return this.readNumber(true) }
		    var next2 = this.input.charCodeAt(this.pos + 2);
		    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
		      this.pos += 3;
		      return this.finishToken(types$1.ellipsis)
		    } else {
		      ++this.pos;
		      return this.finishToken(types$1.dot)
		    }
		  };

		  pp.readToken_slash = function() { // '/'
		    var next = this.input.charCodeAt(this.pos + 1);
		    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
		    if (next === 61) { return this.finishOp(types$1.assign, 2) }
		    return this.finishOp(types$1.slash, 1)
		  };

		  pp.readToken_mult_modulo_exp = function(code) { // '%*'
		    var next = this.input.charCodeAt(this.pos + 1);
		    var size = 1;
		    var tokentype = code === 42 ? types$1.star : types$1.modulo;

		    // exponentiation operator ** and **=
		    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
		      ++size;
		      tokentype = types$1.starstar;
		      next = this.input.charCodeAt(this.pos + 2);
		    }

		    if (next === 61) { return this.finishOp(types$1.assign, size + 1) }
		    return this.finishOp(tokentype, size)
		  };

		  pp.readToken_pipe_amp = function(code) { // '|&'
		    var next = this.input.charCodeAt(this.pos + 1);
		    if (next === code) {
		      if (this.options.ecmaVersion >= 12) {
		        var next2 = this.input.charCodeAt(this.pos + 2);
		        if (next2 === 61) { return this.finishOp(types$1.assign, 3) }
		      }
		      return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2)
		    }
		    if (next === 61) { return this.finishOp(types$1.assign, 2) }
		    return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1)
		  };

		  pp.readToken_caret = function() { // '^'
		    var next = this.input.charCodeAt(this.pos + 1);
		    if (next === 61) { return this.finishOp(types$1.assign, 2) }
		    return this.finishOp(types$1.bitwiseXOR, 1)
		  };

		  pp.readToken_plus_min = function(code) { // '+-'
		    var next = this.input.charCodeAt(this.pos + 1);
		    if (next === code) {
		      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
		          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
		        // A `-->` line comment
		        this.skipLineComment(3);
		        this.skipSpace();
		        return this.nextToken()
		      }
		      return this.finishOp(types$1.incDec, 2)
		    }
		    if (next === 61) { return this.finishOp(types$1.assign, 2) }
		    return this.finishOp(types$1.plusMin, 1)
		  };

		  pp.readToken_lt_gt = function(code) { // '<>'
		    var next = this.input.charCodeAt(this.pos + 1);
		    var size = 1;
		    if (next === code) {
		      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
		      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types$1.assign, size + 1) }
		      return this.finishOp(types$1.bitShift, size)
		    }
		    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
		        this.input.charCodeAt(this.pos + 3) === 45) {
		      // `<!--`, an XML-style comment that should be interpreted as a line comment
		      this.skipLineComment(4);
		      this.skipSpace();
		      return this.nextToken()
		    }
		    if (next === 61) { size = 2; }
		    return this.finishOp(types$1.relational, size)
		  };

		  pp.readToken_eq_excl = function(code) { // '=!'
		    var next = this.input.charCodeAt(this.pos + 1);
		    if (next === 61) { return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
		    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
		      this.pos += 2;
		      return this.finishToken(types$1.arrow)
		    }
		    return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1)
		  };

		  pp.readToken_question = function() { // '?'
		    var ecmaVersion = this.options.ecmaVersion;
		    if (ecmaVersion >= 11) {
		      var next = this.input.charCodeAt(this.pos + 1);
		      if (next === 46) {
		        var next2 = this.input.charCodeAt(this.pos + 2);
		        if (next2 < 48 || next2 > 57) { return this.finishOp(types$1.questionDot, 2) }
		      }
		      if (next === 63) {
		        if (ecmaVersion >= 12) {
		          var next2$1 = this.input.charCodeAt(this.pos + 2);
		          if (next2$1 === 61) { return this.finishOp(types$1.assign, 3) }
		        }
		        return this.finishOp(types$1.coalesce, 2)
		      }
		    }
		    return this.finishOp(types$1.question, 1)
		  };

		  pp.readToken_numberSign = function() { // '#'
		    var ecmaVersion = this.options.ecmaVersion;
		    var code = 35; // '#'
		    if (ecmaVersion >= 13) {
		      ++this.pos;
		      code = this.fullCharCodeAtPos();
		      if (isIdentifierStart(code, true) || code === 92 /* '\' */) {
		        return this.finishToken(types$1.privateId, this.readWord1())
		      }
		    }

		    this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
		  };

		  pp.getTokenFromCode = function(code) {
		    switch (code) {
		    // The interpretation of a dot depends on whether it is followed
		    // by a digit or another two dots.
		    case 46: // '.'
		      return this.readToken_dot()

		    // Punctuation tokens.
		    case 40: ++this.pos; return this.finishToken(types$1.parenL)
		    case 41: ++this.pos; return this.finishToken(types$1.parenR)
		    case 59: ++this.pos; return this.finishToken(types$1.semi)
		    case 44: ++this.pos; return this.finishToken(types$1.comma)
		    case 91: ++this.pos; return this.finishToken(types$1.bracketL)
		    case 93: ++this.pos; return this.finishToken(types$1.bracketR)
		    case 123: ++this.pos; return this.finishToken(types$1.braceL)
		    case 125: ++this.pos; return this.finishToken(types$1.braceR)
		    case 58: ++this.pos; return this.finishToken(types$1.colon)

		    case 96: // '`'
		      if (this.options.ecmaVersion < 6) { break }
		      ++this.pos;
		      return this.finishToken(types$1.backQuote)

		    case 48: // '0'
		      var next = this.input.charCodeAt(this.pos + 1);
		      if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
		      if (this.options.ecmaVersion >= 6) {
		        if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
		        if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
		      }

		    // Anything else beginning with a digit is an integer, octal
		    // number, or float.
		    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
		      return this.readNumber(false)

		    // Quotes produce strings.
		    case 34: case 39: // '"', "'"
		      return this.readString(code)

		    // Operators are parsed inline in tiny state machines. '=' (61) is
		    // often referred to. `finishOp` simply skips the amount of
		    // characters it is given as second argument, and returns a token
		    // of the type given by its first argument.
		    case 47: // '/'
		      return this.readToken_slash()

		    case 37: case 42: // '%*'
		      return this.readToken_mult_modulo_exp(code)

		    case 124: case 38: // '|&'
		      return this.readToken_pipe_amp(code)

		    case 94: // '^'
		      return this.readToken_caret()

		    case 43: case 45: // '+-'
		      return this.readToken_plus_min(code)

		    case 60: case 62: // '<>'
		      return this.readToken_lt_gt(code)

		    case 61: case 33: // '=!'
		      return this.readToken_eq_excl(code)

		    case 63: // '?'
		      return this.readToken_question()

		    case 126: // '~'
		      return this.finishOp(types$1.prefix, 1)

		    case 35: // '#'
		      return this.readToken_numberSign()
		    }

		    this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
		  };

		  pp.finishOp = function(type, size) {
		    var str = this.input.slice(this.pos, this.pos + size);
		    this.pos += size;
		    return this.finishToken(type, str)
		  };

		  pp.readRegexp = function() {
		    var escaped, inClass, start = this.pos;
		    for (;;) {
		      if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
		      var ch = this.input.charAt(this.pos);
		      if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
		      if (!escaped) {
		        if (ch === "[") { inClass = true; }
		        else if (ch === "]" && inClass) { inClass = false; }
		        else if (ch === "/" && !inClass) { break }
		        escaped = ch === "\\";
		      } else { escaped = false; }
		      ++this.pos;
		    }
		    var pattern = this.input.slice(start, this.pos);
		    ++this.pos;
		    var flagsStart = this.pos;
		    var flags = this.readWord1();
		    if (this.containsEsc) { this.unexpected(flagsStart); }

		    // Validate pattern
		    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
		    state.reset(start, pattern, flags);
		    this.validateRegExpFlags(state);
		    this.validateRegExpPattern(state);

		    // Create Literal#value property value.
		    var value = null;
		    try {
		      value = new RegExp(pattern, flags);
		    } catch (e) {
		      // ESTree requires null if it failed to instantiate RegExp object.
		      // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
		    }

		    return this.finishToken(types$1.regexp, {pattern: pattern, flags: flags, value: value})
		  };

		  // Read an integer in the given radix. Return null if zero digits
		  // were read, the integer value otherwise. When `len` is given, this
		  // will return `null` unless the integer has exactly `len` digits.

		  pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
		    // `len` is used for character escape sequences. In that case, disallow separators.
		    var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;

		    // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)
		    // and isn't fraction part nor exponent part. In that case, if the first digit
		    // is zero then disallow separators.
		    var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;

		    var start = this.pos, total = 0, lastCode = 0;
		    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
		      var code = this.input.charCodeAt(this.pos), val = (void 0);

		      if (allowSeparators && code === 95) {
		        if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"); }
		        if (lastCode === 95) { this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"); }
		        if (i === 0) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"); }
		        lastCode = code;
		        continue
		      }

		      if (code >= 97) { val = code - 97 + 10; } // a
		      else if (code >= 65) { val = code - 65 + 10; } // A
		      else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
		      else { val = Infinity; }
		      if (val >= radix) { break }
		      lastCode = code;
		      total = total * radix + val;
		    }

		    if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"); }
		    if (this.pos === start || len != null && this.pos - start !== len) { return null }

		    return total
		  };

		  function stringToNumber(str, isLegacyOctalNumericLiteral) {
		    if (isLegacyOctalNumericLiteral) {
		      return parseInt(str, 8)
		    }

		    // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.
		    return parseFloat(str.replace(/_/g, ""))
		  }

		  function stringToBigInt(str) {
		    if (typeof BigInt !== "function") {
		      return null
		    }

		    // `BigInt(value)` throws syntax error if the string contains numeric separators.
		    return BigInt(str.replace(/_/g, ""))
		  }

		  pp.readRadixNumber = function(radix) {
		    var start = this.pos;
		    this.pos += 2; // 0x
		    var val = this.readInt(radix);
		    if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
		    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
		      val = stringToBigInt(this.input.slice(start, this.pos));
		      ++this.pos;
		    } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
		    return this.finishToken(types$1.num, val)
		  };

		  // Read an integer, octal integer, or floating-point number.

		  pp.readNumber = function(startsWithDot) {
		    var start = this.pos;
		    if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, "Invalid number"); }
		    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
		    if (octal && this.strict) { this.raise(start, "Invalid number"); }
		    var next = this.input.charCodeAt(this.pos);
		    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
		      var val$1 = stringToBigInt(this.input.slice(start, this.pos));
		      ++this.pos;
		      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
		      return this.finishToken(types$1.num, val$1)
		    }
		    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
		    if (next === 46 && !octal) { // '.'
		      ++this.pos;
		      this.readInt(10);
		      next = this.input.charCodeAt(this.pos);
		    }
		    if ((next === 69 || next === 101) && !octal) { // 'eE'
		      next = this.input.charCodeAt(++this.pos);
		      if (next === 43 || next === 45) { ++this.pos; } // '+-'
		      if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
		    }
		    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

		    var val = stringToNumber(this.input.slice(start, this.pos), octal);
		    return this.finishToken(types$1.num, val)
		  };

		  // Read a string value, interpreting backslash-escapes.

		  pp.readCodePoint = function() {
		    var ch = this.input.charCodeAt(this.pos), code;

		    if (ch === 123) { // '{'
		      if (this.options.ecmaVersion < 6) { this.unexpected(); }
		      var codePos = ++this.pos;
		      code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
		      ++this.pos;
		      if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
		    } else {
		      code = this.readHexChar(4);
		    }
		    return code
		  };

		  pp.readString = function(quote) {
		    var out = "", chunkStart = ++this.pos;
		    for (;;) {
		      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
		      var ch = this.input.charCodeAt(this.pos);
		      if (ch === quote) { break }
		      if (ch === 92) { // '\'
		        out += this.input.slice(chunkStart, this.pos);
		        out += this.readEscapedChar(false);
		        chunkStart = this.pos;
		      } else if (ch === 0x2028 || ch === 0x2029) {
		        if (this.options.ecmaVersion < 10) { this.raise(this.start, "Unterminated string constant"); }
		        ++this.pos;
		        if (this.options.locations) {
		          this.curLine++;
		          this.lineStart = this.pos;
		        }
		      } else {
		        if (isNewLine(ch)) { this.raise(this.start, "Unterminated string constant"); }
		        ++this.pos;
		      }
		    }
		    out += this.input.slice(chunkStart, this.pos++);
		    return this.finishToken(types$1.string, out)
		  };

		  // Reads template string tokens.

		  var INVALID_TEMPLATE_ESCAPE_ERROR = {};

		  pp.tryReadTemplateToken = function() {
		    this.inTemplateElement = true;
		    try {
		      this.readTmplToken();
		    } catch (err) {
		      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
		        this.readInvalidTemplateToken();
		      } else {
		        throw err
		      }
		    }

		    this.inTemplateElement = false;
		  };

		  pp.invalidStringToken = function(position, message) {
		    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
		      throw INVALID_TEMPLATE_ESCAPE_ERROR
		    } else {
		      this.raise(position, message);
		    }
		  };

		  pp.readTmplToken = function() {
		    var out = "", chunkStart = this.pos;
		    for (;;) {
		      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
		      var ch = this.input.charCodeAt(this.pos);
		      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
		        if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
		          if (ch === 36) {
		            this.pos += 2;
		            return this.finishToken(types$1.dollarBraceL)
		          } else {
		            ++this.pos;
		            return this.finishToken(types$1.backQuote)
		          }
		        }
		        out += this.input.slice(chunkStart, this.pos);
		        return this.finishToken(types$1.template, out)
		      }
		      if (ch === 92) { // '\'
		        out += this.input.slice(chunkStart, this.pos);
		        out += this.readEscapedChar(true);
		        chunkStart = this.pos;
		      } else if (isNewLine(ch)) {
		        out += this.input.slice(chunkStart, this.pos);
		        ++this.pos;
		        switch (ch) {
		        case 13:
		          if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
		        case 10:
		          out += "\n";
		          break
		        default:
		          out += String.fromCharCode(ch);
		          break
		        }
		        if (this.options.locations) {
		          ++this.curLine;
		          this.lineStart = this.pos;
		        }
		        chunkStart = this.pos;
		      } else {
		        ++this.pos;
		      }
		    }
		  };

		  // Reads a template token to search for the end, without validating any escape sequences
		  pp.readInvalidTemplateToken = function() {
		    for (; this.pos < this.input.length; this.pos++) {
		      switch (this.input[this.pos]) {
		      case "\\":
		        ++this.pos;
		        break

		      case "$":
		        if (this.input[this.pos + 1] !== "{") {
		          break
		        }

		      // falls through
		      case "`":
		        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos))

		      // no default
		      }
		    }
		    this.raise(this.start, "Unterminated template");
		  };

		  // Used to read escaped characters

		  pp.readEscapedChar = function(inTemplate) {
		    var ch = this.input.charCodeAt(++this.pos);
		    ++this.pos;
		    switch (ch) {
		    case 110: return "\n" // 'n' -> '\n'
		    case 114: return "\r" // 'r' -> '\r'
		    case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
		    case 117: return codePointToString(this.readCodePoint()) // 'u'
		    case 116: return "\t" // 't' -> '\t'
		    case 98: return "\b" // 'b' -> '\b'
		    case 118: return "\u000b" // 'v' -> '\u000b'
		    case 102: return "\f" // 'f' -> '\f'
		    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
		    case 10: // ' \n'
		      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
		      return ""
		    case 56:
		    case 57:
		      if (this.strict) {
		        this.invalidStringToken(
		          this.pos - 1,
		          "Invalid escape sequence"
		        );
		      }
		      if (inTemplate) {
		        var codePos = this.pos - 1;

		        this.invalidStringToken(
		          codePos,
		          "Invalid escape sequence in template string"
		        );
		      }
		    default:
		      if (ch >= 48 && ch <= 55) {
		        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
		        var octal = parseInt(octalStr, 8);
		        if (octal > 255) {
		          octalStr = octalStr.slice(0, -1);
		          octal = parseInt(octalStr, 8);
		        }
		        this.pos += octalStr.length - 1;
		        ch = this.input.charCodeAt(this.pos);
		        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
		          this.invalidStringToken(
		            this.pos - 1 - octalStr.length,
		            inTemplate
		              ? "Octal literal in template string"
		              : "Octal literal in strict mode"
		          );
		        }
		        return String.fromCharCode(octal)
		      }
		      if (isNewLine(ch)) {
		        // Unicode new line characters after \ get removed from output in both
		        // template literals and strings
		        return ""
		      }
		      return String.fromCharCode(ch)
		    }
		  };

		  // Used to read character escape sequences ('\x', '\u', '\U').

		  pp.readHexChar = function(len) {
		    var codePos = this.pos;
		    var n = this.readInt(16, len);
		    if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
		    return n
		  };

		  // Read an identifier, and return it as a string. Sets `this.containsEsc`
		  // to whether the word contained a '\u' escape.
		  //
		  // Incrementally adds only escaped chars, adding other chunks as-is
		  // as a micro-optimization.

		  pp.readWord1 = function() {
		    this.containsEsc = false;
		    var word = "", first = true, chunkStart = this.pos;
		    var astral = this.options.ecmaVersion >= 6;
		    while (this.pos < this.input.length) {
		      var ch = this.fullCharCodeAtPos();
		      if (isIdentifierChar(ch, astral)) {
		        this.pos += ch <= 0xffff ? 1 : 2;
		      } else if (ch === 92) { // "\"
		        this.containsEsc = true;
		        word += this.input.slice(chunkStart, this.pos);
		        var escStart = this.pos;
		        if (this.input.charCodeAt(++this.pos) !== 117) // "u"
		          { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
		        ++this.pos;
		        var esc = this.readCodePoint();
		        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
		          { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
		        word += codePointToString(esc);
		        chunkStart = this.pos;
		      } else {
		        break
		      }
		      first = false;
		    }
		    return word + this.input.slice(chunkStart, this.pos)
		  };

		  // Read an identifier or keyword token. Will check for reserved
		  // words when necessary.

		  pp.readWord = function() {
		    var word = this.readWord1();
		    var type = types$1.name;
		    if (this.keywords.test(word)) {
		      type = keywords[word];
		    }
		    return this.finishToken(type, word)
		  };

		  // Acorn is a tiny, fast JavaScript parser written in JavaScript.
		  //
		  // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
		  // various contributors and released under an MIT license.
		  //
		  // Git repositories for Acorn are available at
		  //
		  //     http://marijnhaverbeke.nl/git/acorn
		  //     https://github.com/acornjs/acorn.git
		  //
		  // Please use the [github bug tracker][ghbt] to report issues.
		  //
		  // [ghbt]: https://github.com/acornjs/acorn/issues
		  //
		  // [walk]: util/walk.js


		  var version = "8.11.2";

		  Parser.acorn = {
		    Parser: Parser,
		    version: version,
		    defaultOptions: defaultOptions,
		    Position: Position,
		    SourceLocation: SourceLocation,
		    getLineInfo: getLineInfo,
		    Node: Node,
		    TokenType: TokenType,
		    tokTypes: types$1,
		    keywordTypes: keywords,
		    TokContext: TokContext,
		    tokContexts: types,
		    isIdentifierChar: isIdentifierChar,
		    isIdentifierStart: isIdentifierStart,
		    Token: Token,
		    isNewLine: isNewLine,
		    lineBreak: lineBreak,
		    lineBreakG: lineBreakG,
		    nonASCIIwhitespace: nonASCIIwhitespace
		  };

		  // The main exported interface (under `self.acorn` when in the
		  // browser) is a `parse` function that takes a code string and
		  // returns an abstract syntax tree as specified by [Mozilla parser
		  // API][api].
		  //
		  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

		  function parse(input, options) {
		    return Parser.parse(input, options)
		  }

		  // This function tries to parse a single expression at a given
		  // offset in a string. Useful for parsing mixed-language formats
		  // that embed JavaScript expressions.

		  function parseExpressionAt(input, pos, options) {
		    return Parser.parseExpressionAt(input, pos, options)
		  }

		  // Acorn is organized as a tokenizer and a recursive-descent parser.
		  // The `tokenizer` export provides an interface to the tokenizer.

		  function tokenizer(input, options) {
		    return Parser.tokenizer(input, options)
		  }

		  exports.Node = Node;
		  exports.Parser = Parser;
		  exports.Position = Position;
		  exports.SourceLocation = SourceLocation;
		  exports.TokContext = TokContext;
		  exports.Token = Token;
		  exports.TokenType = TokenType;
		  exports.defaultOptions = defaultOptions;
		  exports.getLineInfo = getLineInfo;
		  exports.isIdentifierChar = isIdentifierChar;
		  exports.isIdentifierStart = isIdentifierStart;
		  exports.isNewLine = isNewLine;
		  exports.keywordTypes = keywords;
		  exports.lineBreak = lineBreak;
		  exports.lineBreakG = lineBreakG;
		  exports.nonASCIIwhitespace = nonASCIIwhitespace;
		  exports.parse = parse;
		  exports.parseExpressionAt = parseExpressionAt;
		  exports.tokContexts = types;
		  exports.tokTypes = types$1;
		  exports.tokenizer = tokenizer;
		  exports.version = version;

		})); 
	} (acorn, acorn.exports));
	return acorn.exports;
}

var hasRequiredDist$5;

function requireDist$5 () {
	if (hasRequiredDist$5) return dist$8;
	hasRequiredDist$5 = 1;

	const acorn = requireAcorn();
	const node_module = require$$1$3;
	const fs = require$$2$1;
	const node_url = require$$3$1;
	const ufo = requireDist$8();
	const pathe = requireDist$6();
	const pkgTypes = requireDist$4();
	const assert = require$$7;
	const process$1 = require$$8;
	const path = require$$9;
	const v8 = require$$10;
	const node_util = require$$11;

	function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

	const fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
	const assert__default = /*#__PURE__*/_interopDefaultCompat(assert);
	const process__default = /*#__PURE__*/_interopDefaultCompat(process$1);
	const path__default = /*#__PURE__*/_interopDefaultCompat(path);
	const v8__default = /*#__PURE__*/_interopDefaultCompat(v8);

	const BUILTIN_MODULES = new Set(node_module.builtinModules);
	function normalizeSlash(string_) {
	  return string_.replace(/\\/g, "/");
	}
	function pcall(function_, ...arguments_) {
	  try {
	    return Promise.resolve(function_(...arguments_)).catch(
	      (error) => perr(error)
	    );
	  } catch (error) {
	    return perr(error);
	  }
	}
	function perr(_error) {
	  const error = new Error(_error);
	  error.code = _error.code;
	  Error.captureStackTrace(error, pcall);
	  return Promise.reject(error);
	}
	function isObject(value) {
	  return value !== null && typeof value === "object";
	}
	function matchAll(regex, string, addition) {
	  const matches = [];
	  for (const match of string.matchAll(regex)) {
	    matches.push({
	      ...addition,
	      ...match.groups,
	      code: match[0],
	      start: match.index,
	      end: match.index + match[0].length
	    });
	  }
	  return matches;
	}
	function clearImports(imports) {
	  return (imports || "").replace(/(\/\/[^\n]*\n|\/\*.*\*\/)/g, "").replace(/\s+/g, " ");
	}
	function getImportNames(cleanedImports) {
	  const topLevelImports = cleanedImports.replace(/{([^}]*)}/, "");
	  const namespacedImport = topLevelImports.match(/\* as \s*(\S*)/)?.[1];
	  const defaultImport = topLevelImports.split(",").find((index) => !/[*{}]/.test(index))?.trim() || void 0;
	  return {
	    namespacedImport,
	    defaultImport
	  };
	}

	/**
	 * @typedef ErrnoExceptionFields
	 * @property {number | undefined} [errnode]
	 * @property {string | undefined} [code]
	 * @property {string | undefined} [path]
	 * @property {string | undefined} [syscall]
	 * @property {string | undefined} [url]
	 *
	 * @typedef {Error & ErrnoExceptionFields} ErrnoException
	 */


	const isWindows = process__default.platform === 'win32';

	const own$1 = {}.hasOwnProperty;

	const classRegExp = /^([A-Z][a-z\d]*)+$/;
	// Sorted by a rough estimate on most frequently used entries.
	const kTypes = new Set([
	  'string',
	  'function',
	  'number',
	  'object',
	  // Accept 'Function' and 'Object' as alternative to the lower cased version.
	  'Function',
	  'Object',
	  'boolean',
	  'bigint',
	  'symbol'
	]);

	const codes = {};

	/**
	 * Create a list string in the form like 'A and B' or 'A, B, ..., and Z'.
	 * We cannot use Intl.ListFormat because it's not available in
	 * --without-intl builds.
	 *
	 * @param {Array<string>} array
	 *   An array of strings.
	 * @param {string} [type]
	 *   The list type to be inserted before the last element.
	 * @returns {string}
	 */
	function formatList(array, type = 'and') {
	  return array.length < 3
	    ? array.join(` ${type} `)
	    : `${array.slice(0, -1).join(', ')}, ${type} ${array[array.length - 1]}`
	}

	/** @type {Map<string, MessageFunction | string>} */
	const messages = new Map();
	const nodeInternalPrefix = '__node_internal_';
	/** @type {number} */
	let userStackTraceLimit;

	codes.ERR_INVALID_ARG_TYPE = createError(
	  'ERR_INVALID_ARG_TYPE',
	  /**
	   * @param {string} name
	   * @param {Array<string> | string} expected
	   * @param {unknown} actual
	   */
	  (name, expected, actual) => {
	    assert__default(typeof name === 'string', "'name' must be a string");
	    if (!Array.isArray(expected)) {
	      expected = [expected];
	    }

	    let message = 'The ';
	    if (name.endsWith(' argument')) {
	      // For cases like 'first argument'
	      message += `${name} `;
	    } else {
	      const type = name.includes('.') ? 'property' : 'argument';
	      message += `"${name}" ${type} `;
	    }

	    message += 'must be ';

	    /** @type {Array<string>} */
	    const types = [];
	    /** @type {Array<string>} */
	    const instances = [];
	    /** @type {Array<string>} */
	    const other = [];

	    for (const value of expected) {
	      assert__default(
	        typeof value === 'string',
	        'All expected entries have to be of type string'
	      );

	      if (kTypes.has(value)) {
	        types.push(value.toLowerCase());
	      } else if (classRegExp.exec(value) === null) {
	        assert__default(
	          value !== 'object',
	          'The value "object" should be written as "Object"'
	        );
	        other.push(value);
	      } else {
	        instances.push(value);
	      }
	    }

	    // Special handle `object` in case other instances are allowed to outline
	    // the differences between each other.
	    if (instances.length > 0) {
	      const pos = types.indexOf('object');
	      if (pos !== -1) {
	        types.slice(pos, 1);
	        instances.push('Object');
	      }
	    }

	    if (types.length > 0) {
	      message += `${types.length > 1 ? 'one of type' : 'of type'} ${formatList(
	        types,
	        'or'
	      )}`;
	      if (instances.length > 0 || other.length > 0) message += ' or ';
	    }

	    if (instances.length > 0) {
	      message += `an instance of ${formatList(instances, 'or')}`;
	      if (other.length > 0) message += ' or ';
	    }

	    if (other.length > 0) {
	      if (other.length > 1) {
	        message += `one of ${formatList(other, 'or')}`;
	      } else {
	        if (other[0].toLowerCase() !== other[0]) message += 'an ';
	        message += `${other[0]}`;
	      }
	    }

	    message += `. Received ${determineSpecificType(actual)}`;

	    return message
	  },
	  TypeError
	);

	codes.ERR_INVALID_MODULE_SPECIFIER = createError(
	  'ERR_INVALID_MODULE_SPECIFIER',
	  /**
	   * @param {string} request
	   * @param {string} reason
	   * @param {string} [base]
	   */
	  (request, reason, base = undefined) => {
	    return `Invalid module "${request}" ${reason}${
	      base ? ` imported from ${base}` : ''
	    }`
	  },
	  TypeError
	);

	codes.ERR_INVALID_PACKAGE_CONFIG = createError(
	  'ERR_INVALID_PACKAGE_CONFIG',
	  /**
	   * @param {string} path
	   * @param {string} [base]
	   * @param {string} [message]
	   */
	  (path, base, message) => {
	    return `Invalid package config ${path}${
	      base ? ` while importing ${base}` : ''
	    }${message ? `. ${message}` : ''}`
	  },
	  Error
	);

	codes.ERR_INVALID_PACKAGE_TARGET = createError(
	  'ERR_INVALID_PACKAGE_TARGET',
	  /**
	   * @param {string} pkgPath
	   * @param {string} key
	   * @param {unknown} target
	   * @param {boolean} [isImport=false]
	   * @param {string} [base]
	   */
	  (pkgPath, key, target, isImport = false, base = undefined) => {
	    const relError =
	      typeof target === 'string' &&
	      !isImport &&
	      target.length > 0 &&
	      !target.startsWith('./');
	    if (key === '.') {
	      assert__default(isImport === false);
	      return (
	        `Invalid "exports" main target ${JSON.stringify(target)} defined ` +
	        `in the package config ${pkgPath}package.json${
	          base ? ` imported from ${base}` : ''
	        }${relError ? '; targets must start with "./"' : ''}`
	      )
	    }

	    return `Invalid "${
	      isImport ? 'imports' : 'exports'
	    }" target ${JSON.stringify(
	      target
	    )} defined for '${key}' in the package config ${pkgPath}package.json${
	      base ? ` imported from ${base}` : ''
	    }${relError ? '; targets must start with "./"' : ''}`
	  },
	  Error
	);

	codes.ERR_MODULE_NOT_FOUND = createError(
	  'ERR_MODULE_NOT_FOUND',
	  /**
	   * @param {string} path
	   * @param {string} base
	   * @param {string} [type]
	   */
	  (path, base, type = 'package') => {
	    return `Cannot find ${type} '${path}' imported from ${base}`
	  },
	  Error
	);

	codes.ERR_NETWORK_IMPORT_DISALLOWED = createError(
	  'ERR_NETWORK_IMPORT_DISALLOWED',
	  "import of '%s' by %s is not supported: %s",
	  Error
	);

	codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(
	  'ERR_PACKAGE_IMPORT_NOT_DEFINED',
	  /**
	   * @param {string} specifier
	   * @param {string} packagePath
	   * @param {string} base
	   */
	  (specifier, packagePath, base) => {
	    return `Package import specifier "${specifier}" is not defined${
	      packagePath ? ` in package ${packagePath}package.json` : ''
	    } imported from ${base}`
	  },
	  TypeError
	);

	codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(
	  'ERR_PACKAGE_PATH_NOT_EXPORTED',
	  /**
	   * @param {string} pkgPath
	   * @param {string} subpath
	   * @param {string} [base]
	   */
	  (pkgPath, subpath, base = undefined) => {
	    if (subpath === '.')
	      return `No "exports" main defined in ${pkgPath}package.json${
	        base ? ` imported from ${base}` : ''
	      }`
	    return `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${
	      base ? ` imported from ${base}` : ''
	    }`
	  },
	  Error
	);

	codes.ERR_UNSUPPORTED_DIR_IMPORT = createError(
	  'ERR_UNSUPPORTED_DIR_IMPORT',
	  "Directory import '%s' is not supported " +
	    'resolving ES modules imported from %s',
	  Error
	);

	codes.ERR_UNKNOWN_FILE_EXTENSION = createError(
	  'ERR_UNKNOWN_FILE_EXTENSION',
	  /**
	   * @param {string} ext
	   * @param {string} path
	   */
	  (ext, path) => {
	    return `Unknown file extension "${ext}" for ${path}`
	  },
	  TypeError
	);

	codes.ERR_INVALID_ARG_VALUE = createError(
	  'ERR_INVALID_ARG_VALUE',
	  /**
	   * @param {string} name
	   * @param {unknown} value
	   * @param {string} [reason='is invalid']
	   */
	  (name, value, reason = 'is invalid') => {
	    let inspected = node_util.inspect(value);

	    if (inspected.length > 128) {
	      inspected = `${inspected.slice(0, 128)}...`;
	    }

	    const type = name.includes('.') ? 'property' : 'argument';

	    return `The ${type} '${name}' ${reason}. Received ${inspected}`
	  },
	  TypeError
	  // Note: extra classes have been shaken out.
	  // , RangeError
	);

	codes.ERR_UNSUPPORTED_ESM_URL_SCHEME = createError(
	  'ERR_UNSUPPORTED_ESM_URL_SCHEME',
	  /**
	   * @param {URL} url
	   * @param {Array<string>} supported
	   */
	  (url, supported) => {
	    let message = `Only URLs with a scheme in: ${formatList(
	      supported
	    )} are supported by the default ESM loader`;

	    if (isWindows && url.protocol.length === 2) {
	      message += '. On Windows, absolute paths must be valid file:// URLs';
	    }

	    message += `. Received protocol '${url.protocol}'`;
	    return message
	  },
	  Error
	);

	/**
	 * Utility function for registering the error codes. Only used here. Exported
	 * *only* to allow for testing.
	 * @param {string} sym
	 * @param {MessageFunction | string} value
	 * @param {ErrorConstructor} def
	 * @returns {new (...args: Array<any>) => Error}
	 */
	function createError(sym, value, def) {
	  // Special case for SystemError that formats the error message differently
	  // The SystemErrors only have SystemError as their base classes.
	  messages.set(sym, value);

	  return makeNodeErrorWithCode(def, sym)
	}

	/**
	 * @param {ErrorConstructor} Base
	 * @param {string} key
	 * @returns {ErrorConstructor}
	 */
	function makeNodeErrorWithCode(Base, key) {
	  // @ts-expect-error It’s a Node error.
	  return NodeError
	  /**
	   * @param {Array<unknown>} args
	   */
	  function NodeError(...args) {
	    const limit = Error.stackTraceLimit;
	    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
	    const error = new Base();
	    // Reset the limit and setting the name property.
	    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
	    const message = getMessage(key, args, error);
	    Object.defineProperties(error, {
	      // Note: no need to implement `kIsNodeError` symbol, would be hard,
	      // probably.
	      message: {
	        value: message,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      },
	      toString: {
	        /** @this {Error} */
	        value() {
	          return `${this.name} [${key}]: ${this.message}`
	        },
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });

	    captureLargerStackTrace(error);
	    // @ts-expect-error It’s a Node error.
	    error.code = key;
	    return error
	  }
	}

	/**
	 * @returns {boolean}
	 */
	function isErrorStackTraceLimitWritable() {
	  // Do no touch Error.stackTraceLimit as V8 would attempt to install
	  // it again during deserialization.
	  try {
	    // @ts-expect-error: not in types?
	    if (v8__default.startupSnapshot.isBuildingSnapshot()) {
	      return false
	    }
	  } catch {}

	  const desc = Object.getOwnPropertyDescriptor(Error, 'stackTraceLimit');
	  if (desc === undefined) {
	    return Object.isExtensible(Error)
	  }

	  return own$1.call(desc, 'writable') && desc.writable !== undefined
	    ? desc.writable
	    : desc.set !== undefined
	}

	/**
	 * This function removes unnecessary frames from Node.js core errors.
	 * @template {(...args: unknown[]) => unknown} T
	 * @param {T} fn
	 * @returns {T}
	 */
	function hideStackFrames(fn) {
	  // We rename the functions that will be hidden to cut off the stacktrace
	  // at the outermost one
	  const hidden = nodeInternalPrefix + fn.name;
	  Object.defineProperty(fn, 'name', {value: hidden});
	  return fn
	}

	const captureLargerStackTrace = hideStackFrames(
	  /**
	   * @param {Error} error
	   * @returns {Error}
	   */
	  // @ts-expect-error: fine
	  function (error) {
	    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
	    if (stackTraceLimitIsWritable) {
	      userStackTraceLimit = Error.stackTraceLimit;
	      Error.stackTraceLimit = Number.POSITIVE_INFINITY;
	    }

	    Error.captureStackTrace(error);

	    // Reset the limit
	    if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;

	    return error
	  }
	);

	/**
	 * @param {string} key
	 * @param {Array<unknown>} args
	 * @param {Error} self
	 * @returns {string}
	 */
	function getMessage(key, args, self) {
	  const message = messages.get(key);
	  assert__default(message !== undefined, 'expected `message` to be found');

	  if (typeof message === 'function') {
	    assert__default(
	      message.length <= args.length, // Default options do not count.
	      `Code: ${key}; The provided arguments length (${args.length}) does not ` +
	        `match the required ones (${message.length}).`
	    );
	    return Reflect.apply(message, self, args)
	  }

	  const regex = /%[dfijoOs]/g;
	  let expectedLength = 0;
	  while (regex.exec(message) !== null) expectedLength++;
	  assert__default(
	    expectedLength === args.length,
	    `Code: ${key}; The provided arguments length (${args.length}) does not ` +
	      `match the required ones (${expectedLength}).`
	  );
	  if (args.length === 0) return message

	  args.unshift(message);
	  return Reflect.apply(node_util.format, null, args)
	}

	/**
	 * Determine the specific type of a value for type-mismatch errors.
	 * @param {unknown} value
	 * @returns {string}
	 */
	function determineSpecificType(value) {
	  if (value === null || value === undefined) {
	    return String(value)
	  }

	  if (typeof value === 'function' && value.name) {
	    return `function ${value.name}`
	  }

	  if (typeof value === 'object') {
	    if (value.constructor && value.constructor.name) {
	      return `an instance of ${value.constructor.name}`
	    }

	    return `${node_util.inspect(value, {depth: -1})}`
	  }

	  let inspected = node_util.inspect(value, {colors: false});

	  if (inspected.length > 28) {
	    inspected = `${inspected.slice(0, 25)}...`;
	  }

	  return `type ${typeof value} (${inspected})`
	}

	// Manually “tree shaken” from:
	// <https://github.com/nodejs/node/blob/3e74590/lib/internal/modules/package_json_reader.js>
	// Last checked on: Apr 24, 2023.
	// Removed the native dependency.
	// Also: no need to cache, we do that in resolve already.


	const reader = {read};
	const packageJsonReader = reader;

	/**
	 * @param {string} jsonPath
	 * @returns {{string: string | undefined}}
	 */
	function read(jsonPath) {
	  try {
	    const string = fs__default.readFileSync(
	      path__default.toNamespacedPath(path__default.join(path__default.dirname(jsonPath), 'package.json')),
	      'utf8'
	    );
	    return {string}
	  } catch (error) {
	    const exception = /** @type {ErrnoException} */ (error);

	    if (exception.code === 'ENOENT') {
	      return {string: undefined}
	      // Throw all other errors.
	      /* c8 ignore next 4 */
	    }

	    throw exception
	  }
	}

	// Manually “tree shaken” from:
	// <https://github.com/nodejs/node/blob/3e74590/lib/internal/modules/esm/package_config.js>
	// Last checked on: Apr 24, 2023.


	const {ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG$1} = codes;

	/** @type {Map<string, PackageConfig>} */
	const packageJsonCache = new Map();

	/**
	 * @param {string} path
	 * @param {URL | string} specifier Note: `specifier` is actually optional, not base.
	 * @param {URL} [base]
	 * @returns {PackageConfig}
	 */
	function getPackageConfig(path, specifier, base) {
	  const existing = packageJsonCache.get(path);
	  if (existing !== undefined) {
	    return existing
	  }

	  const source = packageJsonReader.read(path).string;

	  if (source === undefined) {
	    /** @type {PackageConfig} */
	    const packageConfig = {
	      pjsonPath: path,
	      exists: false,
	      main: undefined,
	      name: undefined,
	      type: 'none',
	      exports: undefined,
	      imports: undefined
	    };
	    packageJsonCache.set(path, packageConfig);
	    return packageConfig
	  }

	  /** @type {Record<string, unknown>} */
	  let packageJson;
	  try {
	    packageJson = JSON.parse(source);
	  } catch (error) {
	    const exception = /** @type {ErrnoException} */ (error);

	    throw new ERR_INVALID_PACKAGE_CONFIG$1(
	      path,
	      (base ? `"${specifier}" from ` : '') + node_url.fileURLToPath(base || specifier),
	      exception.message
	    )
	  }

	  const {exports, imports, main, name, type} = packageJson;

	  /** @type {PackageConfig} */
	  const packageConfig = {
	    pjsonPath: path,
	    exists: true,
	    main: typeof main === 'string' ? main : undefined,
	    name: typeof name === 'string' ? name : undefined,
	    type: type === 'module' || type === 'commonjs' ? type : 'none',
	    // @ts-expect-error Assume `Record<string, unknown>`.
	    exports,
	    // @ts-expect-error Assume `Record<string, unknown>`.
	    imports: imports && typeof imports === 'object' ? imports : undefined
	  };
	  packageJsonCache.set(path, packageConfig);
	  return packageConfig
	}

	/**
	 * @param {URL} resolved
	 * @returns {PackageConfig}
	 */
	function getPackageScopeConfig(resolved) {
	  let packageJsonUrl = new node_url.URL('package.json', resolved);

	  while (true) {
	    const packageJsonPath = packageJsonUrl.pathname;

	    if (packageJsonPath.endsWith('node_modules/package.json')) break

	    const packageConfig = getPackageConfig(
	      node_url.fileURLToPath(packageJsonUrl),
	      resolved
	    );
	    if (packageConfig.exists) return packageConfig

	    const lastPackageJsonUrl = packageJsonUrl;
	    packageJsonUrl = new node_url.URL('../package.json', packageJsonUrl);

	    // Terminates at root where ../package.json equals ../../package.json
	    // (can't just check "/package.json" for Windows support).
	    if (packageJsonUrl.pathname === lastPackageJsonUrl.pathname) break
	  }

	  const packageJsonPath = node_url.fileURLToPath(packageJsonUrl);
	  /** @type {PackageConfig} */
	  const packageConfig = {
	    pjsonPath: packageJsonPath,
	    exists: false,
	    main: undefined,
	    name: undefined,
	    type: 'none',
	    exports: undefined,
	    imports: undefined
	  };
	  packageJsonCache.set(packageJsonPath, packageConfig);
	  return packageConfig
	}

	// Manually “tree shaken” from:
	// <https://github.com/nodejs/node/blob/3e74590/lib/internal/modules/esm/resolve.js>
	// Last checked on: Apr 24, 2023.
	//
	// This file solves a circular dependency.
	// In Node.js, `getPackageType` is in `resolve.js`.
	// `resolve.js` imports `get-format.js`, which needs `getPackageType`.
	// We split that up so that bundlers don’t fail.


	/**
	 * @param {URL} url
	 * @returns {PackageType}
	 */
	function getPackageType(url) {
	  const packageConfig = getPackageScopeConfig(url);
	  return packageConfig.type
	}

	// Manually “tree shaken” from:
	// <https://github.com/nodejs/node/blob/3e74590/lib/internal/modules/esm/get_format.js>
	// Last checked on: Apr 24, 2023.


	const {ERR_UNKNOWN_FILE_EXTENSION} = codes;

	const hasOwnProperty = {}.hasOwnProperty;

	/** @type {Record<string, string>} */
	const extensionFormatMap = {
	  // @ts-expect-error: hush.
	  __proto__: null,
	  '.cjs': 'commonjs',
	  '.js': 'module',
	  '.json': 'json',
	  '.mjs': 'module'
	};

	/**
	 * @param {string | null} mime
	 * @returns {string | null}
	 */
	function mimeToFormat(mime) {
	  if (
	    mime &&
	    /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime)
	  )
	    return 'module'
	  if (mime === 'application/json') return 'json'
	  return null
	}

	/**
	 * @callback ProtocolHandler
	 * @param {URL} parsed
	 * @param {{parentURL: string}} context
	 * @param {boolean} ignoreErrors
	 * @returns {string | null | void}
	 */

	/**
	 * @type {Record<string, ProtocolHandler>}
	 */
	const protocolHandlers = {
	  // @ts-expect-error: hush.
	  __proto__: null,
	  'data:': getDataProtocolModuleFormat,
	  'file:': getFileProtocolModuleFormat,
	  'http:': getHttpProtocolModuleFormat,
	  'https:': getHttpProtocolModuleFormat,
	  'node:'() {
	    return 'builtin'
	  }
	};

	/**
	 * @param {URL} parsed
	 */
	function getDataProtocolModuleFormat(parsed) {
	  const {1: mime} = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(
	    parsed.pathname
	  ) || [null, null, null];
	  return mimeToFormat(mime)
	}

	/**
	 * Returns the file extension from a URL.
	 *
	 * Should give similar result to
	 * `require('node:path').extname(require('node:url').fileURLToPath(url))`
	 * when used with a `file:` URL.
	 *
	 * @param {URL} url
	 * @returns {string}
	 */
	function extname(url) {
	  const pathname = url.pathname;
	  let index = pathname.length;

	  while (index--) {
	    const code = pathname.codePointAt(index);

	    if (code === 47 /* `/` */) {
	      return ''
	    }

	    if (code === 46 /* `.` */) {
	      return pathname.codePointAt(index - 1) === 47 /* `/` */
	        ? ''
	        : pathname.slice(index)
	    }
	  }

	  return ''
	}

	/**
	 * @type {ProtocolHandler}
	 */
	function getFileProtocolModuleFormat(url, _context, ignoreErrors) {
	  const ext = extname(url);

	  if (ext === '.js') {
	    return getPackageType(url) === 'module' ? 'module' : 'commonjs'
	  }

	  const format = extensionFormatMap[ext];
	  if (format) return format

	  // Explicit undefined return indicates load hook should rerun format check
	  if (ignoreErrors) {
	    return undefined
	  }

	  const filepath = node_url.fileURLToPath(url);
	  throw new ERR_UNKNOWN_FILE_EXTENSION(ext, filepath)
	}

	function getHttpProtocolModuleFormat() {
	  // To do: HTTPS imports.
	}

	/**
	 * @param {URL} url
	 * @param {{parentURL: string}} context
	 * @returns {string | null}
	 */
	function defaultGetFormatWithoutErrors(url, context) {
	  if (!hasOwnProperty.call(protocolHandlers, url.protocol)) {
	    return null
	  }

	  return protocolHandlers[url.protocol](url, context, true) || null
	}

	// Manually “tree shaken” from:
	// <https://github.com/nodejs/node/blob/3e74590/lib/internal/modules/esm/resolve.js>
	// Last checked on: Apr 24, 2023.


	const RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];

	const {
	  ERR_NETWORK_IMPORT_DISALLOWED,
	  ERR_INVALID_MODULE_SPECIFIER,
	  ERR_INVALID_PACKAGE_CONFIG,
	  ERR_INVALID_PACKAGE_TARGET,
	  ERR_MODULE_NOT_FOUND,
	  ERR_PACKAGE_IMPORT_NOT_DEFINED,
	  ERR_PACKAGE_PATH_NOT_EXPORTED,
	  ERR_UNSUPPORTED_DIR_IMPORT,
	  ERR_UNSUPPORTED_ESM_URL_SCHEME
	} = codes;

	const own = {}.hasOwnProperty;

	const invalidSegmentRegEx =
	  /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
	const deprecatedInvalidSegmentRegEx =
	  /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
	const invalidPackageNameRegEx = /^\.|%|\\/;
	const patternRegEx = /\*/g;
	const encodedSepRegEx = /%2f|%5c/i;
	/** @type {Set<string>} */
	const emittedPackageWarnings = new Set();

	const doubleSlashRegEx = /[/\\]{2}/;

	/**
	 *
	 * @param {string} target
	 * @param {string} request
	 * @param {string} match
	 * @param {URL} packageJsonUrl
	 * @param {boolean} internal
	 * @param {URL} base
	 * @param {boolean} isTarget
	 */
	function emitInvalidSegmentDeprecation(
	  target,
	  request,
	  match,
	  packageJsonUrl,
	  internal,
	  base,
	  isTarget
	) {
	  const pjsonPath = node_url.fileURLToPath(packageJsonUrl);
	  const double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
	  process__default.emitWarning(
	    `Use of deprecated ${
	      double ? 'double slash' : 'leading or trailing slash matching'
	    } resolving "${target}" for module ` +
	      `request "${request}" ${
	        request === match ? '' : `matched to "${match}" `
	      }in the "${
	        internal ? 'imports' : 'exports'
	      }" field module resolution of the package at ${pjsonPath}${
	        base ? ` imported from ${node_url.fileURLToPath(base)}` : ''
	      }.`,
	    'DeprecationWarning',
	    'DEP0166'
	  );
	}

	/**
	 * @param {URL} url
	 * @param {URL} packageJsonUrl
	 * @param {URL} base
	 * @param {unknown} [main]
	 * @returns {void}
	 */
	function emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {
	  const format = defaultGetFormatWithoutErrors(url, {parentURL: base.href});
	  if (format !== 'module') return
	  const path = node_url.fileURLToPath(url.href);
	  const pkgPath = node_url.fileURLToPath(new node_url.URL('.', packageJsonUrl));
	  const basePath = node_url.fileURLToPath(base);
	  if (main)
	    process__default.emitWarning(
	      `Package ${pkgPath} has a "main" field set to ${JSON.stringify(main)}, ` +
	        `excluding the full filename and extension to the resolved file at "${path.slice(
	          pkgPath.length
	        )}", imported from ${basePath}.\n Automatic extension resolution of the "main" field is` +
	        'deprecated for ES modules.',
	      'DeprecationWarning',
	      'DEP0151'
	    );
	  else
	    process__default.emitWarning(
	      `No "main" or "exports" field defined in the package.json for ${pkgPath} resolving the main entry point "${path.slice(
	        pkgPath.length
	      )}", imported from ${basePath}.\nDefault "index" lookups for the main are deprecated for ES modules.`,
	      'DeprecationWarning',
	      'DEP0151'
	    );
	}

	/**
	 * @param {string} path
	 * @returns {Stats}
	 */
	function tryStatSync(path) {
	  // Note: from Node 15 onwards we can use `throwIfNoEntry: false` instead.
	  try {
	    return fs.statSync(path)
	  } catch {
	    return new fs.Stats()
	  }
	}

	/**
	 * Legacy CommonJS main resolution:
	 * 1. let M = pkg_url + (json main field)
	 * 2. TRY(M, M.js, M.json, M.node)
	 * 3. TRY(M/index.js, M/index.json, M/index.node)
	 * 4. TRY(pkg_url/index.js, pkg_url/index.json, pkg_url/index.node)
	 * 5. NOT_FOUND
	 *
	 * @param {URL} url
	 * @returns {boolean}
	 */
	function fileExists(url) {
	  const stats = fs.statSync(url, {throwIfNoEntry: false});
	  const isFile = stats ? stats.isFile() : undefined;
	  return isFile === null || isFile === undefined ? false : isFile
	}

	/**
	 * @param {URL} packageJsonUrl
	 * @param {PackageConfig} packageConfig
	 * @param {URL} base
	 * @returns {URL}
	 */
	function legacyMainResolve(packageJsonUrl, packageConfig, base) {
	  /** @type {URL | undefined} */
	  let guess;
	  if (packageConfig.main !== undefined) {
	    guess = new node_url.URL(packageConfig.main, packageJsonUrl);
	    // Note: fs check redundances will be handled by Descriptor cache here.
	    if (fileExists(guess)) return guess

	    const tries = [
	      `./${packageConfig.main}.js`,
	      `./${packageConfig.main}.json`,
	      `./${packageConfig.main}.node`,
	      `./${packageConfig.main}/index.js`,
	      `./${packageConfig.main}/index.json`,
	      `./${packageConfig.main}/index.node`
	    ];
	    let i = -1;

	    while (++i < tries.length) {
	      guess = new node_url.URL(tries[i], packageJsonUrl);
	      if (fileExists(guess)) break
	      guess = undefined;
	    }

	    if (guess) {
	      emitLegacyIndexDeprecation(
	        guess,
	        packageJsonUrl,
	        base,
	        packageConfig.main
	      );
	      return guess
	    }
	    // Fallthrough.
	  }

	  const tries = ['./index.js', './index.json', './index.node'];
	  let i = -1;

	  while (++i < tries.length) {
	    guess = new node_url.URL(tries[i], packageJsonUrl);
	    if (fileExists(guess)) break
	    guess = undefined;
	  }

	  if (guess) {
	    emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
	    return guess
	  }

	  // Not found.
	  throw new ERR_MODULE_NOT_FOUND(
	    node_url.fileURLToPath(new node_url.URL('.', packageJsonUrl)),
	    node_url.fileURLToPath(base)
	  )
	}

	/**
	 * @param {URL} resolved
	 * @param {URL} base
	 * @param {boolean} [preserveSymlinks]
	 * @returns {URL}
	 */
	function finalizeResolution(resolved, base, preserveSymlinks) {
	  if (encodedSepRegEx.exec(resolved.pathname) !== null)
	    throw new ERR_INVALID_MODULE_SPECIFIER(
	      resolved.pathname,
	      'must not include encoded "/" or "\\" characters',
	      node_url.fileURLToPath(base)
	    )

	  const filePath = node_url.fileURLToPath(resolved);

	  const stats = tryStatSync(
	    filePath.endsWith('/') ? filePath.slice(-1) : filePath
	  );

	  if (stats.isDirectory()) {
	    const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, node_url.fileURLToPath(base));
	    // @ts-expect-error Add this for `import.meta.resolve`.
	    error.url = String(resolved);
	    throw error
	  }

	  if (!stats.isFile()) {
	    throw new ERR_MODULE_NOT_FOUND(
	      filePath || resolved.pathname,
	      base && node_url.fileURLToPath(base),
	      'module'
	    )
	  }

	  if (!preserveSymlinks) {
	    const real = fs.realpathSync(filePath);
	    const {search, hash} = resolved;
	    resolved = node_url.pathToFileURL(real + (filePath.endsWith(path__default.sep) ? '/' : ''));
	    resolved.search = search;
	    resolved.hash = hash;
	  }

	  return resolved
	}

	/**
	 * @param {string} specifier
	 * @param {URL | undefined} packageJsonUrl
	 * @param {URL} base
	 * @returns {Error}
	 */
	function importNotDefined(specifier, packageJsonUrl, base) {
	  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(
	    specifier,
	    packageJsonUrl && node_url.fileURLToPath(new node_url.URL('.', packageJsonUrl)),
	    node_url.fileURLToPath(base)
	  )
	}

	/**
	 * @param {string} subpath
	 * @param {URL} packageJsonUrl
	 * @param {URL} base
	 * @returns {Error}
	 */
	function exportsNotFound(subpath, packageJsonUrl, base) {
	  return new ERR_PACKAGE_PATH_NOT_EXPORTED(
	    node_url.fileURLToPath(new node_url.URL('.', packageJsonUrl)),
	    subpath,
	    base && node_url.fileURLToPath(base)
	  )
	}

	/**
	 * @param {string} request
	 * @param {string} match
	 * @param {URL} packageJsonUrl
	 * @param {boolean} internal
	 * @param {URL} [base]
	 * @returns {never}
	 */
	function throwInvalidSubpath(request, match, packageJsonUrl, internal, base) {
	  const reason = `request is not a valid match in pattern "${match}" for the "${
	    internal ? 'imports' : 'exports'
	  }" resolution of ${node_url.fileURLToPath(packageJsonUrl)}`;
	  throw new ERR_INVALID_MODULE_SPECIFIER(
	    request,
	    reason,
	    base && node_url.fileURLToPath(base)
	  )
	}

	/**
	 * @param {string} subpath
	 * @param {unknown} target
	 * @param {URL} packageJsonUrl
	 * @param {boolean} internal
	 * @param {URL} [base]
	 * @returns {Error}
	 */
	function invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
	  target =
	    typeof target === 'object' && target !== null
	      ? JSON.stringify(target, null, '')
	      : `${target}`;

	  return new ERR_INVALID_PACKAGE_TARGET(
	    node_url.fileURLToPath(new node_url.URL('.', packageJsonUrl)),
	    subpath,
	    target,
	    internal,
	    base && node_url.fileURLToPath(base)
	  )
	}

	/**
	 * @param {string} target
	 * @param {string} subpath
	 * @param {string} match
	 * @param {URL} packageJsonUrl
	 * @param {URL} base
	 * @param {boolean} pattern
	 * @param {boolean} internal
	 * @param {boolean} isPathMap
	 * @param {Set<string> | undefined} conditions
	 * @returns {URL}
	 */
	function resolvePackageTargetString(
	  target,
	  subpath,
	  match,
	  packageJsonUrl,
	  base,
	  pattern,
	  internal,
	  isPathMap,
	  conditions
	) {
	  if (subpath !== '' && !pattern && target[target.length - 1] !== '/')
	    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base)

	  if (!target.startsWith('./')) {
	    if (internal && !target.startsWith('../') && !target.startsWith('/')) {
	      let isURL = false;

	      try {
	        new node_url.URL(target);
	        isURL = true;
	      } catch {
	        // Continue regardless of error.
	      }

	      if (!isURL) {
	        const exportTarget = pattern
	          ? RegExpPrototypeSymbolReplace.call(
	              patternRegEx,
	              target,
	              () => subpath
	            )
	          : target + subpath;

	        return packageResolve(exportTarget, packageJsonUrl, conditions)
	      }
	    }

	    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base)
	  }

	  if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {
	    if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
	      if (!isPathMap) {
	        const request = pattern
	          ? match.replace('*', () => subpath)
	          : match + subpath;
	        const resolvedTarget = pattern
	          ? RegExpPrototypeSymbolReplace.call(
	              patternRegEx,
	              target,
	              () => subpath
	            )
	          : target;
	        emitInvalidSegmentDeprecation(
	          resolvedTarget,
	          request,
	          match,
	          packageJsonUrl,
	          internal,
	          base,
	          true
	        );
	      }
	    } else {
	      throw invalidPackageTarget(match, target, packageJsonUrl, internal, base)
	    }
	  }

	  const resolved = new node_url.URL(target, packageJsonUrl);
	  const resolvedPath = resolved.pathname;
	  const packagePath = new node_url.URL('.', packageJsonUrl).pathname;

	  if (!resolvedPath.startsWith(packagePath))
	    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base)

	  if (subpath === '') return resolved

	  if (invalidSegmentRegEx.exec(subpath) !== null) {
	    const request = pattern
	      ? match.replace('*', () => subpath)
	      : match + subpath;
	    if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
	      if (!isPathMap) {
	        const resolvedTarget = pattern
	          ? RegExpPrototypeSymbolReplace.call(
	              patternRegEx,
	              target,
	              () => subpath
	            )
	          : target;
	        emitInvalidSegmentDeprecation(
	          resolvedTarget,
	          request,
	          match,
	          packageJsonUrl,
	          internal,
	          base,
	          false
	        );
	      }
	    } else {
	      throwInvalidSubpath(request, match, packageJsonUrl, internal, base);
	    }
	  }

	  if (pattern) {
	    return new node_url.URL(
	      RegExpPrototypeSymbolReplace.call(
	        patternRegEx,
	        resolved.href,
	        () => subpath
	      )
	    )
	  }

	  return new node_url.URL(subpath, resolved)
	}

	/**
	 * @param {string} key
	 * @returns {boolean}
	 */
	function isArrayIndex(key) {
	  const keyNumber = Number(key);
	  if (`${keyNumber}` !== key) return false
	  return keyNumber >= 0 && keyNumber < 0xff_ff_ff_ff
	}

	/**
	 * @param {URL} packageJsonUrl
	 * @param {unknown} target
	 * @param {string} subpath
	 * @param {string} packageSubpath
	 * @param {URL} base
	 * @param {boolean} pattern
	 * @param {boolean} internal
	 * @param {boolean} isPathMap
	 * @param {Set<string> | undefined} conditions
	 * @returns {URL | null}
	 */
	function resolvePackageTarget(
	  packageJsonUrl,
	  target,
	  subpath,
	  packageSubpath,
	  base,
	  pattern,
	  internal,
	  isPathMap,
	  conditions
	) {
	  if (typeof target === 'string') {
	    return resolvePackageTargetString(
	      target,
	      subpath,
	      packageSubpath,
	      packageJsonUrl,
	      base,
	      pattern,
	      internal,
	      isPathMap,
	      conditions
	    )
	  }

	  if (Array.isArray(target)) {
	    /** @type {Array<unknown>} */
	    const targetList = target;
	    if (targetList.length === 0) return null

	    /** @type {ErrnoException | null | undefined} */
	    let lastException;
	    let i = -1;

	    while (++i < targetList.length) {
	      const targetItem = targetList[i];
	      /** @type {URL | null} */
	      let resolveResult;
	      try {
	        resolveResult = resolvePackageTarget(
	          packageJsonUrl,
	          targetItem,
	          subpath,
	          packageSubpath,
	          base,
	          pattern,
	          internal,
	          isPathMap,
	          conditions
	        );
	      } catch (error) {
	        const exception = /** @type {ErrnoException} */ (error);
	        lastException = exception;
	        if (exception.code === 'ERR_INVALID_PACKAGE_TARGET') continue
	        throw error
	      }

	      if (resolveResult === undefined) continue

	      if (resolveResult === null) {
	        lastException = null;
	        continue
	      }

	      return resolveResult
	    }

	    if (lastException === undefined || lastException === null) {
	      return null
	    }

	    throw lastException
	  }

	  if (typeof target === 'object' && target !== null) {
	    const keys = Object.getOwnPropertyNames(target);
	    let i = -1;

	    while (++i < keys.length) {
	      const key = keys[i];
	      if (isArrayIndex(key)) {
	        throw new ERR_INVALID_PACKAGE_CONFIG(
	          node_url.fileURLToPath(packageJsonUrl),
	          base,
	          '"exports" cannot contain numeric property keys.'
	        )
	      }
	    }

	    i = -1;

	    while (++i < keys.length) {
	      const key = keys[i];
	      if (key === 'default' || (conditions && conditions.has(key))) {
	        // @ts-expect-error: indexable.
	        const conditionalTarget = /** @type {unknown} */ (target[key]);
	        const resolveResult = resolvePackageTarget(
	          packageJsonUrl,
	          conditionalTarget,
	          subpath,
	          packageSubpath,
	          base,
	          pattern,
	          internal,
	          isPathMap,
	          conditions
	        );
	        if (resolveResult === undefined) continue
	        return resolveResult
	      }
	    }

	    return null
	  }

	  if (target === null) {
	    return null
	  }

	  throw invalidPackageTarget(
	    packageSubpath,
	    target,
	    packageJsonUrl,
	    internal,
	    base
	  )
	}

	/**
	 * @param {unknown} exports
	 * @param {URL} packageJsonUrl
	 * @param {URL} base
	 * @returns {boolean}
	 */
	function isConditionalExportsMainSugar(exports, packageJsonUrl, base) {
	  if (typeof exports === 'string' || Array.isArray(exports)) return true
	  if (typeof exports !== 'object' || exports === null) return false

	  const keys = Object.getOwnPropertyNames(exports);
	  let isConditionalSugar = false;
	  let i = 0;
	  let j = -1;
	  while (++j < keys.length) {
	    const key = keys[j];
	    const curIsConditionalSugar = key === '' || key[0] !== '.';
	    if (i++ === 0) {
	      isConditionalSugar = curIsConditionalSugar;
	    } else if (isConditionalSugar !== curIsConditionalSugar) {
	      throw new ERR_INVALID_PACKAGE_CONFIG(
	        node_url.fileURLToPath(packageJsonUrl),
	        base,
	        '"exports" cannot contain some keys starting with \'.\' and some not.' +
	          ' The exports object must either be an object of package subpath keys' +
	          ' or an object of main entry condition name keys only.'
	      )
	    }
	  }

	  return isConditionalSugar
	}

	/**
	 * @param {string} match
	 * @param {URL} pjsonUrl
	 * @param {URL} base
	 */
	function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
	  const pjsonPath = node_url.fileURLToPath(pjsonUrl);
	  if (emittedPackageWarnings.has(pjsonPath + '|' + match)) return
	  emittedPackageWarnings.add(pjsonPath + '|' + match);
	  process__default.emitWarning(
	    `Use of deprecated trailing slash pattern mapping "${match}" in the ` +
	      `"exports" field module resolution of the package at ${pjsonPath}${
	        base ? ` imported from ${node_url.fileURLToPath(base)}` : ''
	      }. Mapping specifiers ending in "/" is no longer supported.`,
	    'DeprecationWarning',
	    'DEP0155'
	  );
	}

	/**
	 * @param {URL} packageJsonUrl
	 * @param {string} packageSubpath
	 * @param {Record<string, unknown>} packageConfig
	 * @param {URL} base
	 * @param {Set<string> | undefined} conditions
	 * @returns {URL}
	 */
	function packageExportsResolve(
	  packageJsonUrl,
	  packageSubpath,
	  packageConfig,
	  base,
	  conditions
	) {
	  let exports = packageConfig.exports;

	  if (isConditionalExportsMainSugar(exports, packageJsonUrl, base)) {
	    exports = {'.': exports};
	  }

	  if (
	    own.call(exports, packageSubpath) &&
	    !packageSubpath.includes('*') &&
	    !packageSubpath.endsWith('/')
	  ) {
	    // @ts-expect-error: indexable.
	    const target = exports[packageSubpath];
	    const resolveResult = resolvePackageTarget(
	      packageJsonUrl,
	      target,
	      '',
	      packageSubpath,
	      base,
	      false,
	      false,
	      false,
	      conditions
	    );
	    if (resolveResult === null || resolveResult === undefined) {
	      throw exportsNotFound(packageSubpath, packageJsonUrl, base)
	    }

	    return resolveResult
	  }

	  let bestMatch = '';
	  let bestMatchSubpath = '';
	  const keys = Object.getOwnPropertyNames(exports);
	  let i = -1;

	  while (++i < keys.length) {
	    const key = keys[i];
	    const patternIndex = key.indexOf('*');

	    if (
	      patternIndex !== -1 &&
	      packageSubpath.startsWith(key.slice(0, patternIndex))
	    ) {
	      // When this reaches EOL, this can throw at the top of the whole function:
	      //
	      // if (StringPrototypeEndsWith(packageSubpath, '/'))
	      //   throwInvalidSubpath(packageSubpath)
	      //
	      // To match "imports" and the spec.
	      if (packageSubpath.endsWith('/')) {
	        emitTrailingSlashPatternDeprecation(
	          packageSubpath,
	          packageJsonUrl,
	          base
	        );
	      }

	      const patternTrailer = key.slice(patternIndex + 1);

	      if (
	        packageSubpath.length >= key.length &&
	        packageSubpath.endsWith(patternTrailer) &&
	        patternKeyCompare(bestMatch, key) === 1 &&
	        key.lastIndexOf('*') === patternIndex
	      ) {
	        bestMatch = key;
	        bestMatchSubpath = packageSubpath.slice(
	          patternIndex,
	          packageSubpath.length - patternTrailer.length
	        );
	      }
	    }
	  }

	  if (bestMatch) {
	    // @ts-expect-error: indexable.
	    const target = /** @type {unknown} */ (exports[bestMatch]);
	    const resolveResult = resolvePackageTarget(
	      packageJsonUrl,
	      target,
	      bestMatchSubpath,
	      bestMatch,
	      base,
	      true,
	      false,
	      packageSubpath.endsWith('/'),
	      conditions
	    );

	    if (resolveResult === null || resolveResult === undefined) {
	      throw exportsNotFound(packageSubpath, packageJsonUrl, base)
	    }

	    return resolveResult
	  }

	  throw exportsNotFound(packageSubpath, packageJsonUrl, base)
	}

	/**
	 * @param {string} a
	 * @param {string} b
	 */
	function patternKeyCompare(a, b) {
	  const aPatternIndex = a.indexOf('*');
	  const bPatternIndex = b.indexOf('*');
	  const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
	  const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
	  if (baseLengthA > baseLengthB) return -1
	  if (baseLengthB > baseLengthA) return 1
	  if (aPatternIndex === -1) return 1
	  if (bPatternIndex === -1) return -1
	  if (a.length > b.length) return -1
	  if (b.length > a.length) return 1
	  return 0
	}

	/**
	 * @param {string} name
	 * @param {URL} base
	 * @param {Set<string>} [conditions]
	 * @returns {URL}
	 */
	function packageImportsResolve(name, base, conditions) {
	  if (name === '#' || name.startsWith('#/') || name.endsWith('/')) {
	    const reason = 'is not a valid internal imports specifier name';
	    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, node_url.fileURLToPath(base))
	  }

	  /** @type {URL | undefined} */
	  let packageJsonUrl;

	  const packageConfig = getPackageScopeConfig(base);

	  if (packageConfig.exists) {
	    packageJsonUrl = node_url.pathToFileURL(packageConfig.pjsonPath);
	    const imports = packageConfig.imports;
	    if (imports) {
	      if (own.call(imports, name) && !name.includes('*')) {
	        const resolveResult = resolvePackageTarget(
	          packageJsonUrl,
	          imports[name],
	          '',
	          name,
	          base,
	          false,
	          true,
	          false,
	          conditions
	        );
	        if (resolveResult !== null && resolveResult !== undefined) {
	          return resolveResult
	        }
	      } else {
	        let bestMatch = '';
	        let bestMatchSubpath = '';
	        const keys = Object.getOwnPropertyNames(imports);
	        let i = -1;

	        while (++i < keys.length) {
	          const key = keys[i];
	          const patternIndex = key.indexOf('*');

	          if (patternIndex !== -1 && name.startsWith(key.slice(0, -1))) {
	            const patternTrailer = key.slice(patternIndex + 1);
	            if (
	              name.length >= key.length &&
	              name.endsWith(patternTrailer) &&
	              patternKeyCompare(bestMatch, key) === 1 &&
	              key.lastIndexOf('*') === patternIndex
	            ) {
	              bestMatch = key;
	              bestMatchSubpath = name.slice(
	                patternIndex,
	                name.length - patternTrailer.length
	              );
	            }
	          }
	        }

	        if (bestMatch) {
	          const target = imports[bestMatch];
	          const resolveResult = resolvePackageTarget(
	            packageJsonUrl,
	            target,
	            bestMatchSubpath,
	            bestMatch,
	            base,
	            true,
	            true,
	            false,
	            conditions
	          );

	          if (resolveResult !== null && resolveResult !== undefined) {
	            return resolveResult
	          }
	        }
	      }
	    }
	  }

	  throw importNotDefined(name, packageJsonUrl, base)
	}

	// Note: In Node.js, `getPackageType` is here.
	// To prevent a circular dependency, we move it to
	// `resolve-get-package-type.js`.

	/**
	 * @param {string} specifier
	 * @param {URL} base
	 */
	function parsePackageName(specifier, base) {
	  let separatorIndex = specifier.indexOf('/');
	  let validPackageName = true;
	  let isScoped = false;
	  if (specifier[0] === '@') {
	    isScoped = true;
	    if (separatorIndex === -1 || specifier.length === 0) {
	      validPackageName = false;
	    } else {
	      separatorIndex = specifier.indexOf('/', separatorIndex + 1);
	    }
	  }

	  const packageName =
	    separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);

	  // Package name cannot have leading . and cannot have percent-encoding or
	  // \\ separators.
	  if (invalidPackageNameRegEx.exec(packageName) !== null) {
	    validPackageName = false;
	  }

	  if (!validPackageName) {
	    throw new ERR_INVALID_MODULE_SPECIFIER(
	      specifier,
	      'is not a valid package name',
	      node_url.fileURLToPath(base)
	    )
	  }

	  const packageSubpath =
	    '.' + (separatorIndex === -1 ? '' : specifier.slice(separatorIndex));

	  return {packageName, packageSubpath, isScoped}
	}

	/**
	 * @param {string} specifier
	 * @param {URL} base
	 * @param {Set<string> | undefined} conditions
	 * @returns {URL}
	 */
	function packageResolve(specifier, base, conditions) {
	  if (node_module.builtinModules.includes(specifier)) {
	    return new node_url.URL('node:' + specifier)
	  }

	  const {packageName, packageSubpath, isScoped} = parsePackageName(
	    specifier,
	    base
	  );

	  // ResolveSelf
	  const packageConfig = getPackageScopeConfig(base);

	  // Can’t test.
	  /* c8 ignore next 16 */
	  if (packageConfig.exists) {
	    const packageJsonUrl = node_url.pathToFileURL(packageConfig.pjsonPath);
	    if (
	      packageConfig.name === packageName &&
	      packageConfig.exports !== undefined &&
	      packageConfig.exports !== null
	    ) {
	      return packageExportsResolve(
	        packageJsonUrl,
	        packageSubpath,
	        packageConfig,
	        base,
	        conditions
	      )
	    }
	  }

	  let packageJsonUrl = new node_url.URL(
	    './node_modules/' + packageName + '/package.json',
	    base
	  );
	  let packageJsonPath = node_url.fileURLToPath(packageJsonUrl);
	  /** @type {string} */
	  let lastPath;
	  do {
	    const stat = tryStatSync(packageJsonPath.slice(0, -13));
	    if (!stat.isDirectory()) {
	      lastPath = packageJsonPath;
	      packageJsonUrl = new node_url.URL(
	        (isScoped ? '../../../../node_modules/' : '../../../node_modules/') +
	          packageName +
	          '/package.json',
	        packageJsonUrl
	      );
	      packageJsonPath = node_url.fileURLToPath(packageJsonUrl);
	      continue
	    }

	    // Package match.
	    const packageConfig = getPackageConfig(packageJsonPath, specifier, base);
	    if (packageConfig.exports !== undefined && packageConfig.exports !== null) {
	      return packageExportsResolve(
	        packageJsonUrl,
	        packageSubpath,
	        packageConfig,
	        base,
	        conditions
	      )
	    }

	    if (packageSubpath === '.') {
	      return legacyMainResolve(packageJsonUrl, packageConfig, base)
	    }

	    return new node_url.URL(packageSubpath, packageJsonUrl)
	    // Cross-platform root check.
	  } while (packageJsonPath.length !== lastPath.length)

	  throw new ERR_MODULE_NOT_FOUND(packageName, node_url.fileURLToPath(base))
	}

	/**
	 * @param {string} specifier
	 * @returns {boolean}
	 */
	function isRelativeSpecifier(specifier) {
	  if (specifier[0] === '.') {
	    if (specifier.length === 1 || specifier[1] === '/') return true
	    if (
	      specifier[1] === '.' &&
	      (specifier.length === 2 || specifier[2] === '/')
	    ) {
	      return true
	    }
	  }

	  return false
	}

	/**
	 * @param {string} specifier
	 * @returns {boolean}
	 */
	function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
	  if (specifier === '') return false
	  if (specifier[0] === '/') return true
	  return isRelativeSpecifier(specifier)
	}

	/**
	 * The “Resolver Algorithm Specification” as detailed in the Node docs (which is
	 * sync and slightly lower-level than `resolve`).
	 *
	 * @param {string} specifier
	 *   `/example.js`, `./example.js`, `../example.js`, `some-package`, `fs`, etc.
	 * @param {URL} base
	 *   Full URL (to a file) that `specifier` is resolved relative from.
	 * @param {Set<string>} [conditions]
	 *   Conditions.
	 * @param {boolean} [preserveSymlinks]
	 *   Keep symlinks instead of resolving them.
	 * @returns {URL}
	 *   A URL object to the found thing.
	 */
	function moduleResolve(specifier, base, conditions, preserveSymlinks) {
	  const protocol = base.protocol;
	  const isRemote = protocol === 'http:' || protocol === 'https:';
	  // Order swapped from spec for minor perf gain.
	  // Ok since relative URLs cannot parse as URLs.
	  /** @type {URL | undefined} */
	  let resolved;

	  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
	    resolved = new node_url.URL(specifier, base);
	  } else if (!isRemote && specifier[0] === '#') {
	    resolved = packageImportsResolve(specifier, base, conditions);
	  } else {
	    try {
	      resolved = new node_url.URL(specifier);
	    } catch {
	      if (!isRemote) {
	        resolved = packageResolve(specifier, base, conditions);
	      }
	    }
	  }

	  assert__default(resolved !== undefined, 'expected to be defined');

	  if (resolved.protocol !== 'file:') {
	    return resolved
	  }

	  return finalizeResolution(resolved, base, preserveSymlinks)
	}

	function fileURLToPath(id) {
	  if (typeof id === "string" && !id.startsWith("file://")) {
	    return normalizeSlash(id);
	  }
	  return normalizeSlash(node_url.fileURLToPath(id));
	}
	const INVALID_CHAR_RE = /[\u0000-\u001F"#$&*+,/:;<=>?@[\]^`{|}\u007F]+/g;
	function sanitizeURIComponent(name = "", replacement = "_") {
	  return name.replace(INVALID_CHAR_RE, replacement).replace(/%../g, replacement);
	}
	function sanitizeFilePath(filePath = "") {
	  return filePath.replace(/\?.*$/, "").split(/[/\\]/g).map((p) => sanitizeURIComponent(p)).join("/").replace(/^([A-Za-z])_\//, "$1:/");
	}
	function normalizeid(id) {
	  if (typeof id !== "string") {
	    id = id.toString();
	  }
	  if (/(node|data|http|https|file):/.test(id)) {
	    return id;
	  }
	  if (BUILTIN_MODULES.has(id)) {
	    return "node:" + id;
	  }
	  return "file://" + encodeURI(normalizeSlash(id));
	}
	async function loadURL(url) {
	  const code = await fs.promises.readFile(fileURLToPath(url), "utf8");
	  return code;
	}
	function toDataURL(code) {
	  const base64 = Buffer.from(code).toString("base64");
	  return `data:text/javascript;base64,${base64}`;
	}
	function isNodeBuiltin(id = "") {
	  id = id.replace(/^node:/, "").split("/")[0];
	  return BUILTIN_MODULES.has(id);
	}
	const ProtocolRegex = /^(?<proto>.{2,}?):.+$/;
	function getProtocol(id) {
	  const proto = id.match(ProtocolRegex);
	  return proto ? proto.groups.proto : void 0;
	}

	const DEFAULT_CONDITIONS_SET = /* @__PURE__ */ new Set(["node", "import"]);
	const DEFAULT_URL = node_url.pathToFileURL(process.cwd());
	const DEFAULT_EXTENSIONS = [".mjs", ".cjs", ".js", ".json"];
	const NOT_FOUND_ERRORS = /* @__PURE__ */ new Set([
	  "ERR_MODULE_NOT_FOUND",
	  "ERR_UNSUPPORTED_DIR_IMPORT",
	  "MODULE_NOT_FOUND",
	  "ERR_PACKAGE_PATH_NOT_EXPORTED"
	]);
	function _tryModuleResolve(id, url, conditions) {
	  try {
	    return moduleResolve(id, url, conditions);
	  } catch (error) {
	    if (!NOT_FOUND_ERRORS.has(error.code)) {
	      throw error;
	    }
	  }
	}
	function _resolve(id, options = {}) {
	  if (/(node|data|http|https):/.test(id)) {
	    return id;
	  }
	  if (BUILTIN_MODULES.has(id)) {
	    return "node:" + id;
	  }
	  if (pathe.isAbsolute(id) && fs.existsSync(id)) {
	    const realPath2 = fs.realpathSync(fileURLToPath(id));
	    return node_url.pathToFileURL(realPath2).toString();
	  }
	  const conditionsSet = options.conditions ? new Set(options.conditions) : DEFAULT_CONDITIONS_SET;
	  const _urls = (Array.isArray(options.url) ? options.url : [options.url]).filter(Boolean).map((u) => new URL(normalizeid(u.toString())));
	  if (_urls.length === 0) {
	    _urls.push(DEFAULT_URL);
	  }
	  const urls = [..._urls];
	  for (const url of _urls) {
	    if (url.protocol === "file:") {
	      urls.push(
	        new URL("./", url),
	        // If url is directory
	        new URL(ufo.joinURL(url.pathname, "_index.js"), url),
	        // TODO: Remove in next major version?
	        new URL("node_modules", url)
	      );
	    }
	  }
	  let resolved;
	  for (const url of urls) {
	    resolved = _tryModuleResolve(id, url, conditionsSet);
	    if (resolved) {
	      break;
	    }
	    for (const prefix of ["", "/index"]) {
	      for (const extension of options.extensions || DEFAULT_EXTENSIONS) {
	        resolved = _tryModuleResolve(
	          id + prefix + extension,
	          url,
	          conditionsSet
	        );
	        if (resolved) {
	          break;
	        }
	      }
	      if (resolved) {
	        break;
	      }
	    }
	    if (resolved) {
	      break;
	    }
	  }
	  if (!resolved) {
	    const error = new Error(
	      `Cannot find module ${id} imported from ${urls.join(", ")}`
	    );
	    error.code = "ERR_MODULE_NOT_FOUND";
	    throw error;
	  }
	  const realPath = fs.realpathSync(fileURLToPath(resolved));
	  return node_url.pathToFileURL(realPath).toString();
	}
	function resolveSync(id, options) {
	  return _resolve(id, options);
	}
	function resolve(id, options) {
	  return pcall(resolveSync, id, options);
	}
	function resolvePathSync(id, options) {
	  return fileURLToPath(resolveSync(id, options));
	}
	function resolvePath(id, options) {
	  return pcall(resolvePathSync, id, options);
	}
	function createResolve(defaults) {
	  return (id, url) => {
	    return resolve(id, { url, ...defaults });
	  };
	}
	const NODE_MODULES_RE = /^(.+\/node_modules\/)([^/@]+|@[^/]+\/[^/]+)(\/?.*?)?$/;
	function parseNodeModulePath(path) {
	  if (!path) {
	    return {};
	  }
	  path = pathe.normalize(fileURLToPath(path));
	  const match = NODE_MODULES_RE.exec(path);
	  if (!match) {
	    return {};
	  }
	  const [, dir, name, subpath] = match;
	  return {
	    dir,
	    name,
	    subpath: subpath ? `.${subpath}` : void 0
	  };
	}
	async function lookupNodeModuleSubpath(path) {
	  path = pathe.normalize(fileURLToPath(path));
	  const { name, subpath } = parseNodeModulePath(path);
	  if (!name || !subpath) {
	    return subpath;
	  }
	  const { exports } = await pkgTypes.readPackageJSON(path).catch(() => {
	  }) || {};
	  if (exports) {
	    const resolvedSubpath = _findSubpath(subpath, exports);
	    if (resolvedSubpath) {
	      return resolvedSubpath;
	    }
	  }
	  return subpath;
	}
	function _findSubpath(subpath, exports) {
	  if (typeof exports === "string") {
	    exports = { ".": exports };
	  }
	  if (!subpath.startsWith(".")) {
	    subpath = subpath.startsWith("/") ? `.${subpath}` : `./${subpath}`;
	  }
	  if (subpath in exports) {
	    return subpath;
	  }
	  const flattenedExports = _flattenExports(exports);
	  const [foundPath] = (
	    // eslint-disable-next-line @typescript-eslint/no-unused-vars
	    flattenedExports.find(([_, resolved]) => resolved === subpath) || []
	  );
	  return foundPath;
	}
	function _flattenExports(exports, path) {
	  return Object.entries(exports).flatMap(
	    ([key, value]) => typeof value === "string" ? [[path ?? key, value]] : _flattenExports(value, path ?? key)
	  );
	}

	const ESM_STATIC_IMPORT_RE = /(?<=\s|^|;)import\s*([\s"']*(?<imports>[\p{L}\p{M}\w\t\n\r $*,/{}@.]+)from\s*)?["']\s*(?<specifier>(?<="\s*)[^"]*[^\s"](?=\s*")|(?<='\s*)[^']*[^\s'](?=\s*'))\s*["'][\s;]*/gmu;
	const DYNAMIC_IMPORT_RE = /import\s*\((?<expression>(?:[^()]+|\((?:[^()]+|\([^()]*\))*\))*)\)/gm;
	const IMPORT_NAMED_TYPE_RE = /(?<=\s|^|;)import\s*type\s+([\s"']*(?<imports>[\w\t\n\r $*,/{}]+)from\s*)?["']\s*(?<specifier>(?<="\s*)[^"]*[^\s"](?=\s*")|(?<='\s*)[^']*[^\s'](?=\s*'))\s*["'][\s;]*/gm;
	const EXPORT_DECAL_RE = /\bexport\s+(?<declaration>(async function\s*\*?|function\s*\*?|let|const enum|const|enum|var|class))\s+\*?(?<name>[\w$]+)/g;
	const EXPORT_DECAL_TYPE_RE = /\bexport\s+(?<declaration>(interface|type|declare (async function|function|let|const enum|const|enum|var|class)))\s+(?<name>[\w$]+)/g;
	const EXPORT_NAMED_RE = /\bexport\s+{(?<exports>[^}]+?)[\s,]*}(\s*from\s*["']\s*(?<specifier>(?<="\s*)[^"]*[^\s"](?=\s*")|(?<='\s*)[^']*[^\s'](?=\s*'))\s*["'][^\n;]*)?/g;
	const EXPORT_NAMED_TYPE_RE = /\bexport\s+type\s+{(?<exports>[^}]+?)[\s,]*}(\s*from\s*["']\s*(?<specifier>(?<="\s*)[^"]*[^\s"](?=\s*")|(?<='\s*)[^']*[^\s'](?=\s*'))\s*["'][^\n;]*)?/g;
	const EXPORT_NAMED_DESTRUCT = /\bexport\s+(let|var|const)\s+(?:{(?<exports1>[^}]+?)[\s,]*}|\[(?<exports2>[^\]]+?)[\s,]*])\s+=/gm;
	const EXPORT_STAR_RE = /\bexport\s*(\*)(\s*as\s+(?<name>[\w$]+)\s+)?\s*(\s*from\s*["']\s*(?<specifier>(?<="\s*)[^"]*[^\s"](?=\s*")|(?<='\s*)[^']*[^\s'](?=\s*'))\s*["'][^\n;]*)?/g;
	const EXPORT_DEFAULT_RE = /\bexport\s+default\s+/g;
	const TYPE_RE = /^\s*?type\s/;
	function findStaticImports(code) {
	  return matchAll(ESM_STATIC_IMPORT_RE, code, { type: "static" });
	}
	function findDynamicImports(code) {
	  return matchAll(DYNAMIC_IMPORT_RE, code, { type: "dynamic" });
	}
	function findTypeImports(code) {
	  return [
	    ...matchAll(IMPORT_NAMED_TYPE_RE, code, { type: "type" }),
	    ...matchAll(ESM_STATIC_IMPORT_RE, code, { type: "static" }).filter(
	      (match) => /[^A-Za-z]type\s/.test(match.imports)
	    )
	  ];
	}
	function parseStaticImport(matched) {
	  const cleanedImports = clearImports(matched.imports);
	  const namedImports = {};
	  for (const namedImport of cleanedImports.match(/{([^}]*)}/)?.[1]?.split(",") || []) {
	    const [, source = namedImport.trim(), importName = source] = namedImport.match(/^\s*(\S*) as (\S*)\s*$/) || [];
	    if (source && !TYPE_RE.test(source)) {
	      namedImports[source] = importName;
	    }
	  }
	  const { namespacedImport, defaultImport } = getImportNames(cleanedImports);
	  return {
	    ...matched,
	    defaultImport,
	    namespacedImport,
	    namedImports
	  };
	}
	function parseTypeImport(matched) {
	  if (matched.type === "type") {
	    return parseStaticImport(matched);
	  }
	  const cleanedImports = clearImports(matched.imports);
	  const namedImports = {};
	  for (const namedImport of cleanedImports.match(/{([^}]*)}/)?.[1]?.split(",") || []) {
	    const [, source = namedImport.trim(), importName = source] = (() => {
	      return /\s+as\s+/.test(namedImport) ? namedImport.match(/^\s*type\s+(\S*) as (\S*)\s*$/) || [] : namedImport.match(/^\s*type\s+(\S*)\s*$/) || [];
	    })();
	    if (source && TYPE_RE.test(namedImport)) {
	      namedImports[source] = importName;
	    }
	  }
	  const { namespacedImport, defaultImport } = getImportNames(cleanedImports);
	  return {
	    ...matched,
	    defaultImport,
	    namespacedImport,
	    namedImports
	  };
	}
	function findExports(code) {
	  const declaredExports = matchAll(EXPORT_DECAL_RE, code, {
	    type: "declaration"
	  });
	  const namedExports = normalizeNamedExports(
	    matchAll(EXPORT_NAMED_RE, code, {
	      type: "named"
	    })
	  );
	  const destructuredExports = matchAll(
	    EXPORT_NAMED_DESTRUCT,
	    code,
	    { type: "named" }
	  );
	  for (const namedExport of destructuredExports) {
	    namedExport.exports = namedExport.exports1 || namedExport.exports2;
	    namedExport.names = namedExport.exports.replace(/^\r?\n?/, "").split(/\s*,\s*/g).filter((name) => !TYPE_RE.test(name)).map(
	      (name) => name.replace(/^.*?\s*:\s*/, "").replace(/\s*=\s*.*$/, "").trim()
	    );
	  }
	  const defaultExport = matchAll(EXPORT_DEFAULT_RE, code, {
	    type: "default",
	    name: "default"
	  });
	  const starExports = matchAll(EXPORT_STAR_RE, code, {
	    type: "star"
	  });
	  const exports = normalizeExports([
	    ...declaredExports,
	    ...namedExports,
	    ...destructuredExports,
	    ...defaultExport,
	    ...starExports
	  ]);
	  if (exports.length === 0) {
	    return [];
	  }
	  const exportLocations = _tryGetExportLocations(code);
	  if (exportLocations && exportLocations.length === 0) {
	    return [];
	  }
	  return exports.filter(
	    (exp) => !exportLocations || _isExportStatement(exportLocations, exp)
	  ).filter((exp, index, exports2) => {
	    const nextExport = exports2[index + 1];
	    return !nextExport || exp.type !== nextExport.type || !exp.name || exp.name !== nextExport.name;
	  });
	}
	function findTypeExports(code) {
	  const declaredExports = matchAll(
	    EXPORT_DECAL_TYPE_RE,
	    code,
	    { type: "declaration" }
	  );
	  const namedExports = normalizeNamedExports(
	    matchAll(EXPORT_NAMED_TYPE_RE, code, {
	      type: "named"
	    })
	  );
	  const exports = normalizeExports([
	    ...declaredExports,
	    ...namedExports
	  ]);
	  if (exports.length === 0) {
	    return [];
	  }
	  const exportLocations = _tryGetExportLocations(code);
	  if (exportLocations && exportLocations.length === 0) {
	    return [];
	  }
	  return exports.filter(
	    (exp) => !exportLocations || _isExportStatement(exportLocations, exp)
	  ).filter((exp, index, exports2) => {
	    const nextExport = exports2[index + 1];
	    return !nextExport || exp.type !== nextExport.type || !exp.name || exp.name !== nextExport.name;
	  });
	}
	function normalizeExports(exports) {
	  for (const exp of exports) {
	    if (!exp.name && exp.names && exp.names.length === 1) {
	      exp.name = exp.names[0];
	    }
	    if (exp.name === "default" && exp.type !== "default") {
	      exp._type = exp.type;
	      exp.type = "default";
	    }
	    if (!exp.names && exp.name) {
	      exp.names = [exp.name];
	    }
	  }
	  return exports;
	}
	function normalizeNamedExports(namedExports) {
	  for (const namedExport of namedExports) {
	    namedExport.names = namedExport.exports.replace(/^\r?\n?/, "").split(/\s*,\s*/g).filter((name) => !TYPE_RE.test(name)).map((name) => name.replace(/^.*?\sas\s/, "").trim());
	  }
	  return namedExports;
	}
	function findExportNames(code) {
	  return findExports(code).flatMap((exp) => exp.names).filter(Boolean);
	}
	async function resolveModuleExportNames(id, options) {
	  const url = await resolvePath(id, options);
	  const code = await loadURL(url);
	  const exports = findExports(code);
	  const exportNames = new Set(
	    exports.flatMap((exp) => exp.names).filter(Boolean)
	  );
	  for (const exp of exports) {
	    if (exp.type === "star") {
	      const subExports = await resolveModuleExportNames(exp.specifier, {
	        ...options,
	        url
	      });
	      for (const subExport of subExports) {
	        exportNames.add(subExport);
	      }
	    }
	  }
	  return [...exportNames];
	}
	function _isExportStatement(exportsLocation, exp) {
	  return exportsLocation.some((location) => {
	    return exp.start <= location.start && exp.end >= location.end;
	  });
	}
	function _tryGetExportLocations(code) {
	  try {
	    return _getExportLocations(code);
	  } catch {
	  }
	}
	function _getExportLocations(code) {
	  const tokens = acorn.tokenizer(code, {
	    ecmaVersion: "latest",
	    sourceType: "module",
	    allowHashBang: true,
	    allowAwaitOutsideFunction: true,
	    allowImportExportEverywhere: true
	  });
	  const locations = [];
	  for (const token of tokens) {
	    if (token.type.label === "export") {
	      locations.push({
	        start: token.start,
	        end: token.end
	      });
	    }
	  }
	  return locations;
	}

	function createCommonJS(url) {
	  const __filename = fileURLToPath(url);
	  const __dirname = path.dirname(__filename);
	  let _nativeRequire;
	  const getNativeRequire = () => _nativeRequire || (_nativeRequire = node_module.createRequire(url));
	  function require(id) {
	    return getNativeRequire()(id);
	  }
	  require.resolve = (id, options) => getNativeRequire().resolve(id, options);
	  return {
	    __filename,
	    __dirname,
	    require
	  };
	}
	function interopDefault(sourceModule) {
	  if (!isObject(sourceModule) || !("default" in sourceModule)) {
	    return sourceModule;
	  }
	  const newModule = sourceModule.default;
	  for (const key in sourceModule) {
	    if (key === "default") {
	      try {
	        if (!(key in newModule)) {
	          Object.defineProperty(newModule, key, {
	            enumerable: false,
	            configurable: false,
	            get() {
	              return newModule;
	            }
	          });
	        }
	      } catch {
	      }
	    } else {
	      try {
	        if (!(key in newModule)) {
	          Object.defineProperty(newModule, key, {
	            enumerable: true,
	            configurable: true,
	            get() {
	              return sourceModule[key];
	            }
	          });
	        }
	      } catch {
	      }
	    }
	  }
	  return newModule;
	}

	const EVAL_ESM_IMPORT_RE = /(?<=import .* from ["'])([^"']+)(?=["'])|(?<=export .* from ["'])([^"']+)(?=["'])|(?<=import\s*["'])([^"']+)(?=["'])|(?<=import\s*\(["'])([^"']+)(?=["']\))/g;
	async function loadModule(id, options = {}) {
	  const url = await resolve(id, options);
	  const code = await loadURL(url);
	  return evalModule(code, { ...options, url });
	}
	async function evalModule(code, options = {}) {
	  const transformed = await transformModule(code, options);
	  const dataURL = toDataURL(transformed);
	  return import(dataURL).catch((error) => {
	    error.stack = error.stack.replace(
	      new RegExp(dataURL, "g"),
	      options.url || "_mlly_eval_"
	    );
	    throw error;
	  });
	}
	function transformModule(code, options) {
	  if (options.url && options.url.endsWith(".json")) {
	    return Promise.resolve("export default " + code);
	  }
	  if (options.url) {
	    code = code.replace(/import\.meta\.url/g, `'${options.url}'`);
	  }
	  return Promise.resolve(code);
	}
	async function resolveImports(code, options) {
	  const imports = [...code.matchAll(EVAL_ESM_IMPORT_RE)].map((m) => m[0]);
	  if (imports.length === 0) {
	    return code;
	  }
	  const uniqueImports = [...new Set(imports)];
	  const resolved = /* @__PURE__ */ new Map();
	  await Promise.all(
	    uniqueImports.map(async (id) => {
	      let url = await resolve(id, options);
	      if (url.endsWith(".json")) {
	        const code2 = await loadURL(url);
	        url = toDataURL(await transformModule(code2, { url }));
	      }
	      resolved.set(id, url);
	    })
	  );
	  const re = new RegExp(
	    uniqueImports.map((index) => `(${index})`).join("|"),
	    "g"
	  );
	  return code.replace(re, (id) => resolved.get(id));
	}

	const ESM_RE = /([\s;]|^)(import[\s\w*,{}]*from|import\s*["'*{]|export\b\s*(?:[*{]|default|class|type|function|const|var|let|async function)|import\.meta\b)/m;
	const BUILTIN_EXTENSIONS = /* @__PURE__ */ new Set([".mjs", ".cjs", ".node", ".wasm"]);
	function hasESMSyntax(code) {
	  return ESM_RE.test(code);
	}
	const CJS_RE = /([\s;]|^)(module.exports\b|exports\.\w|require\s*\(|global\.\w)/m;
	function hasCJSSyntax(code) {
	  return CJS_RE.test(code);
	}
	function detectSyntax(code) {
	  const hasESM = hasESMSyntax(code);
	  const hasCJS = hasCJSSyntax(code);
	  return {
	    hasESM,
	    hasCJS,
	    isMixed: hasESM && hasCJS
	  };
	}
	const validNodeImportDefaults = {
	  allowedProtocols: ["node", "file", "data"]
	};
	async function isValidNodeImport(id, _options = {}) {
	  if (isNodeBuiltin(id)) {
	    return true;
	  }
	  const options = { ...validNodeImportDefaults, ..._options };
	  const proto = getProtocol(id);
	  if (proto && !options.allowedProtocols.includes(proto)) {
	    return false;
	  }
	  if (proto === "data") {
	    return true;
	  }
	  const resolvedPath = await resolvePath(id, options);
	  const extension = pathe.extname(resolvedPath);
	  if (BUILTIN_EXTENSIONS.has(extension)) {
	    return true;
	  }
	  if (extension !== ".js") {
	    return false;
	  }
	  const package_ = await pkgTypes.readPackageJSON(resolvedPath).catch(() => {
	  });
	  if (package_?.type === "module") {
	    return true;
	  }
	  if (/\.(\w+-)?esm?(-\w+)?\.js$|\/(esm?)\//.test(resolvedPath)) {
	    return false;
	  }
	  const code = options.code || await fs.promises.readFile(resolvedPath, "utf8").catch(() => {
	  }) || "";
	  return !hasESMSyntax(code);
	}

	dist$8.DYNAMIC_IMPORT_RE = DYNAMIC_IMPORT_RE;
	dist$8.ESM_STATIC_IMPORT_RE = ESM_STATIC_IMPORT_RE;
	dist$8.EXPORT_DECAL_RE = EXPORT_DECAL_RE;
	dist$8.EXPORT_DECAL_TYPE_RE = EXPORT_DECAL_TYPE_RE;
	dist$8.createCommonJS = createCommonJS;
	dist$8.createResolve = createResolve;
	dist$8.detectSyntax = detectSyntax;
	dist$8.evalModule = evalModule;
	dist$8.fileURLToPath = fileURLToPath;
	dist$8.findDynamicImports = findDynamicImports;
	dist$8.findExportNames = findExportNames;
	dist$8.findExports = findExports;
	dist$8.findStaticImports = findStaticImports;
	dist$8.findTypeExports = findTypeExports;
	dist$8.findTypeImports = findTypeImports;
	dist$8.getProtocol = getProtocol;
	dist$8.hasCJSSyntax = hasCJSSyntax;
	dist$8.hasESMSyntax = hasESMSyntax;
	dist$8.interopDefault = interopDefault;
	dist$8.isNodeBuiltin = isNodeBuiltin;
	dist$8.isValidNodeImport = isValidNodeImport;
	dist$8.loadModule = loadModule;
	dist$8.loadURL = loadURL;
	dist$8.lookupNodeModuleSubpath = lookupNodeModuleSubpath;
	dist$8.normalizeid = normalizeid;
	dist$8.parseNodeModulePath = parseNodeModulePath;
	dist$8.parseStaticImport = parseStaticImport;
	dist$8.parseTypeImport = parseTypeImport;
	dist$8.resolve = resolve;
	dist$8.resolveImports = resolveImports;
	dist$8.resolveModuleExportNames = resolveModuleExportNames;
	dist$8.resolvePath = resolvePath;
	dist$8.resolvePathSync = resolvePathSync;
	dist$8.resolveSync = resolveSync;
	dist$8.sanitizeFilePath = sanitizeFilePath;
	dist$8.sanitizeURIComponent = sanitizeURIComponent;
	dist$8.toDataURL = toDataURL;
	dist$8.transformModule = transformModule;
	return dist$8;
}

var hasRequiredDist$4;

function requireDist$4 () {
	if (hasRequiredDist$4) return dist$a;
	hasRequiredDist$4 = 1;

	const node_fs = require$$2$1;
	const pathe = requireDist$6();
	const mlly = requireDist$5();

	const defaultFindOptions = {
	  startingFrom: ".",
	  rootPattern: /^node_modules$/,
	  reverse: false,
	  test: (filePath) => {
	    try {
	      if (node_fs.statSync(filePath).isFile()) {
	        return true;
	      }
	    } catch {
	    }
	  }
	};
	async function findFile(filename, _options = {}) {
	  const options = { ...defaultFindOptions, ..._options };
	  const basePath = pathe.resolve(options.startingFrom);
	  const leadingSlash = basePath[0] === "/";
	  const segments = basePath.split("/").filter(Boolean);
	  if (leadingSlash) {
	    segments[0] = "/" + segments[0];
	  }
	  let root = segments.findIndex((r) => r.match(options.rootPattern));
	  if (root === -1) {
	    root = 0;
	  }
	  if (!options.reverse) {
	    for (let index = segments.length; index > root; index--) {
	      const filePath = pathe.join(...segments.slice(0, index), filename);
	      if (await options.test(filePath)) {
	        return filePath;
	      }
	    }
	  } else {
	    for (let index = root + 1; index <= segments.length; index++) {
	      const filePath = pathe.join(...segments.slice(0, index), filename);
	      if (await options.test(filePath)) {
	        return filePath;
	      }
	    }
	  }
	  throw new Error(
	    `Cannot find matching ${filename} in ${options.startingFrom} or parent directories`
	  );
	}
	function findNearestFile(filename, _options = {}) {
	  return findFile(filename, _options);
	}
	function findFarthestFile(filename, _options = {}) {
	  return findFile(filename, { ..._options, reverse: true });
	}

	function definePackageJSON(package_) {
	  return package_;
	}
	function defineTSConfig(tsconfig) {
	  return tsconfig;
	}
	const FileCache = /* @__PURE__ */ new Map();
	async function readPackageJSON(id, options = {}) {
	  const resolvedPath = await resolvePackageJSON(id, options);
	  const cache = options.cache && typeof options.cache !== "boolean" ? options.cache : FileCache;
	  if (options.cache && cache.has(resolvedPath)) {
	    return cache.get(resolvedPath);
	  }
	  const blob = await node_fs.promises.readFile(resolvedPath, "utf8");
	  const parsed = JSON.parse(blob);
	  cache.set(resolvedPath, parsed);
	  return parsed;
	}
	async function writePackageJSON(path, package_) {
	  await node_fs.promises.writeFile(path, JSON.stringify(package_, void 0, 2));
	}
	async function readTSConfig(id, options = {}) {
	  const resolvedPath = await resolveTSConfig(id, options);
	  const cache = options.cache && typeof options.cache !== "boolean" ? options.cache : FileCache;
	  if (options.cache && cache.has(resolvedPath)) {
	    return cache.get(resolvedPath);
	  }
	  const blob = await node_fs.promises.readFile(resolvedPath, "utf8");
	  const jsonc = await import('./chunks/main.mjs');
	  const parsed = jsonc.parse(blob);
	  cache.set(resolvedPath, parsed);
	  return parsed;
	}
	async function writeTSConfig(path, tsconfig) {
	  await node_fs.promises.writeFile(path, JSON.stringify(tsconfig, void 0, 2));
	}
	async function resolvePackageJSON(id = process.cwd(), options = {}) {
	  const resolvedPath = pathe.isAbsolute(id) ? id : await mlly.resolvePath(id, options);
	  return findNearestFile("package.json", {
	    startingFrom: resolvedPath,
	    ...options
	  });
	}
	async function resolveTSConfig(id = process.cwd(), options = {}) {
	  const resolvedPath = pathe.isAbsolute(id) ? id : await mlly.resolvePath(id, options);
	  return findNearestFile("tsconfig.json", {
	    startingFrom: resolvedPath,
	    ...options
	  });
	}
	const lockFiles = [
	  "yarn.lock",
	  "package-lock.json",
	  "pnpm-lock.yaml",
	  "npm-shrinkwrap.json",
	  "bun.lockb"
	];
	async function resolveLockfile(id = process.cwd(), options = {}) {
	  const resolvedPath = pathe.isAbsolute(id) ? id : await mlly.resolvePath(id, options);
	  const _options = { startingFrom: resolvedPath, ...options };
	  for (const lockFile of lockFiles) {
	    try {
	      return await findNearestFile(lockFile, _options);
	    } catch {
	    }
	  }
	  throw new Error("No lockfile found from " + id);
	}
	async function findWorkspaceDir(id = process.cwd(), options = {}) {
	  const resolvedPath = pathe.isAbsolute(id) ? id : await mlly.resolvePath(id, options);
	  const _options = { startingFrom: resolvedPath, ...options };
	  try {
	    const r = await findNearestFile(".git/config", _options);
	    return pathe.resolve(r, "../..");
	  } catch {
	  }
	  try {
	    const r = await resolveLockfile(resolvedPath, {
	      ..._options,
	      reverse: true
	    });
	    return pathe.dirname(r);
	  } catch {
	  }
	  try {
	    const r = await findFile(resolvedPath, _options);
	    return pathe.dirname(r);
	  } catch {
	  }
	  throw new Error("Cannot detect workspace root from " + id);
	}

	dist$a.definePackageJSON = definePackageJSON;
	dist$a.defineTSConfig = defineTSConfig;
	dist$a.findFarthestFile = findFarthestFile;
	dist$a.findFile = findFile;
	dist$a.findNearestFile = findNearestFile;
	dist$a.findWorkspaceDir = findWorkspaceDir;
	dist$a.readPackageJSON = readPackageJSON;
	dist$a.readTSConfig = readTSConfig;
	dist$a.resolveLockfile = resolveLockfile;
	dist$a.resolvePackageJSON = resolvePackageJSON;
	dist$a.resolveTSConfig = resolveTSConfig;
	dist$a.writePackageJSON = writePackageJSON;
	dist$a.writeTSConfig = writeTSConfig;
	return dist$a;
}

var hasRequiredDist$3;

function requireDist$3 () {
	if (hasRequiredDist$3) return dist$d;
	hasRequiredDist$3 = 1;

	const acorn = requireAcorn$1();
	const node_module = require$$1$3;
	const fs = require$$2$1;
	const ufo = requireDist$8();
	const pathe = requireDist$7();
	const pkgTypes = requireDist$4();
	const node_url = require$$3$1;
	const assert = require$$7;
	const process$1 = require$$8;
	const path = require$$9;
	const v8 = require$$10;
	const node_util = require$$11;

	function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

	const fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
	const assert__default = /*#__PURE__*/_interopDefaultCompat(assert);
	const process__default = /*#__PURE__*/_interopDefaultCompat(process$1);
	const path__default = /*#__PURE__*/_interopDefaultCompat(path);
	const v8__default = /*#__PURE__*/_interopDefaultCompat(v8);

	const BUILTIN_MODULES = new Set(node_module.builtinModules);
	function normalizeSlash(path) {
	  return path.replace(/\\/g, "/");
	}
	function isObject(value) {
	  return value !== null && typeof value === "object";
	}
	function matchAll(regex, string, addition) {
	  const matches = [];
	  for (const match of string.matchAll(regex)) {
	    matches.push({
	      ...addition,
	      ...match.groups,
	      code: match[0],
	      start: match.index,
	      end: (match.index || 0) + match[0].length
	    });
	  }
	  return matches;
	}
	function clearImports(imports) {
	  return (imports || "").replace(/(\/\/[^\n]*\n|\/\*.*\*\/)/g, "").replace(/\s+/g, " ");
	}
	function getImportNames(cleanedImports) {
	  const topLevelImports = cleanedImports.replace(/{([^}]*)}/, "");
	  const namespacedImport = topLevelImports.match(/\* as \s*(\S*)/)?.[1];
	  const defaultImport = topLevelImports.split(",").find((index) => !/[*{}]/.test(index))?.trim() || void 0;
	  return {
	    namespacedImport,
	    defaultImport
	  };
	}

	/**
	 * @typedef ErrnoExceptionFields
	 * @property {number | undefined} [errnode]
	 * @property {string | undefined} [code]
	 * @property {string | undefined} [path]
	 * @property {string | undefined} [syscall]
	 * @property {string | undefined} [url]
	 *
	 * @typedef {Error & ErrnoExceptionFields} ErrnoException
	 */


	const own$1 = {}.hasOwnProperty;

	const classRegExp = /^([A-Z][a-z\d]*)+$/;
	// Sorted by a rough estimate on most frequently used entries.
	const kTypes = new Set([
	  'string',
	  'function',
	  'number',
	  'object',
	  // Accept 'Function' and 'Object' as alternative to the lower cased version.
	  'Function',
	  'Object',
	  'boolean',
	  'bigint',
	  'symbol'
	]);

	const codes = {};

	/**
	 * Create a list string in the form like 'A and B' or 'A, B, ..., and Z'.
	 * We cannot use Intl.ListFormat because it's not available in
	 * --without-intl builds.
	 *
	 * @param {Array<string>} array
	 *   An array of strings.
	 * @param {string} [type]
	 *   The list type to be inserted before the last element.
	 * @returns {string}
	 */
	function formatList(array, type = 'and') {
	  return array.length < 3
	    ? array.join(` ${type} `)
	    : `${array.slice(0, -1).join(', ')}, ${type} ${array[array.length - 1]}`
	}

	/** @type {Map<string, MessageFunction | string>} */
	const messages = new Map();
	const nodeInternalPrefix = '__node_internal_';
	/** @type {number} */
	let userStackTraceLimit;

	codes.ERR_INVALID_ARG_TYPE = createError(
	  'ERR_INVALID_ARG_TYPE',
	  /**
	   * @param {string} name
	   * @param {Array<string> | string} expected
	   * @param {unknown} actual
	   */
	  (name, expected, actual) => {
	    assert__default(typeof name === 'string', "'name' must be a string");
	    if (!Array.isArray(expected)) {
	      expected = [expected];
	    }

	    let message = 'The ';
	    if (name.endsWith(' argument')) {
	      // For cases like 'first argument'
	      message += `${name} `;
	    } else {
	      const type = name.includes('.') ? 'property' : 'argument';
	      message += `"${name}" ${type} `;
	    }

	    message += 'must be ';

	    /** @type {Array<string>} */
	    const types = [];
	    /** @type {Array<string>} */
	    const instances = [];
	    /** @type {Array<string>} */
	    const other = [];

	    for (const value of expected) {
	      assert__default(
	        typeof value === 'string',
	        'All expected entries have to be of type string'
	      );

	      if (kTypes.has(value)) {
	        types.push(value.toLowerCase());
	      } else if (classRegExp.exec(value) === null) {
	        assert__default(
	          value !== 'object',
	          'The value "object" should be written as "Object"'
	        );
	        other.push(value);
	      } else {
	        instances.push(value);
	      }
	    }

	    // Special handle `object` in case other instances are allowed to outline
	    // the differences between each other.
	    if (instances.length > 0) {
	      const pos = types.indexOf('object');
	      if (pos !== -1) {
	        types.slice(pos, 1);
	        instances.push('Object');
	      }
	    }

	    if (types.length > 0) {
	      message += `${types.length > 1 ? 'one of type' : 'of type'} ${formatList(
	        types,
	        'or'
	      )}`;
	      if (instances.length > 0 || other.length > 0) message += ' or ';
	    }

	    if (instances.length > 0) {
	      message += `an instance of ${formatList(instances, 'or')}`;
	      if (other.length > 0) message += ' or ';
	    }

	    if (other.length > 0) {
	      if (other.length > 1) {
	        message += `one of ${formatList(other, 'or')}`;
	      } else {
	        if (other[0].toLowerCase() !== other[0]) message += 'an ';
	        message += `${other[0]}`;
	      }
	    }

	    message += `. Received ${determineSpecificType(actual)}`;

	    return message
	  },
	  TypeError
	);

	codes.ERR_INVALID_MODULE_SPECIFIER = createError(
	  'ERR_INVALID_MODULE_SPECIFIER',
	  /**
	   * @param {string} request
	   * @param {string} reason
	   * @param {string} [base]
	   */
	  (request, reason, base = undefined) => {
	    return `Invalid module "${request}" ${reason}${
	      base ? ` imported from ${base}` : ''
	    }`
	  },
	  TypeError
	);

	codes.ERR_INVALID_PACKAGE_CONFIG = createError(
	  'ERR_INVALID_PACKAGE_CONFIG',
	  /**
	   * @param {string} path
	   * @param {string} [base]
	   * @param {string} [message]
	   */
	  (path, base, message) => {
	    return `Invalid package config ${path}${
	      base ? ` while importing ${base}` : ''
	    }${message ? `. ${message}` : ''}`
	  },
	  Error
	);

	codes.ERR_INVALID_PACKAGE_TARGET = createError(
	  'ERR_INVALID_PACKAGE_TARGET',
	  /**
	   * @param {string} pkgPath
	   * @param {string} key
	   * @param {unknown} target
	   * @param {boolean} [isImport=false]
	   * @param {string} [base]
	   */
	  (pkgPath, key, target, isImport = false, base = undefined) => {
	    const relError =
	      typeof target === 'string' &&
	      !isImport &&
	      target.length > 0 &&
	      !target.startsWith('./');
	    if (key === '.') {
	      assert__default(isImport === false);
	      return (
	        `Invalid "exports" main target ${JSON.stringify(target)} defined ` +
	        `in the package config ${pkgPath}package.json${
	          base ? ` imported from ${base}` : ''
	        }${relError ? '; targets must start with "./"' : ''}`
	      )
	    }

	    return `Invalid "${
	      isImport ? 'imports' : 'exports'
	    }" target ${JSON.stringify(
	      target
	    )} defined for '${key}' in the package config ${pkgPath}package.json${
	      base ? ` imported from ${base}` : ''
	    }${relError ? '; targets must start with "./"' : ''}`
	  },
	  Error
	);

	codes.ERR_MODULE_NOT_FOUND = createError(
	  'ERR_MODULE_NOT_FOUND',
	  /**
	   * @param {string} path
	   * @param {string} base
	   * @param {boolean} [exactUrl]
	   */
	  (path, base, exactUrl = false) => {
	    return `Cannot find ${
	      exactUrl ? 'module' : 'package'
	    } '${path}' imported from ${base}`
	  },
	  Error
	);

	codes.ERR_NETWORK_IMPORT_DISALLOWED = createError(
	  'ERR_NETWORK_IMPORT_DISALLOWED',
	  "import of '%s' by %s is not supported: %s",
	  Error
	);

	codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(
	  'ERR_PACKAGE_IMPORT_NOT_DEFINED',
	  /**
	   * @param {string} specifier
	   * @param {string} packagePath
	   * @param {string} base
	   */
	  (specifier, packagePath, base) => {
	    return `Package import specifier "${specifier}" is not defined${
	      packagePath ? ` in package ${packagePath}package.json` : ''
	    } imported from ${base}`
	  },
	  TypeError
	);

	codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(
	  'ERR_PACKAGE_PATH_NOT_EXPORTED',
	  /**
	   * @param {string} pkgPath
	   * @param {string} subpath
	   * @param {string} [base]
	   */
	  (pkgPath, subpath, base = undefined) => {
	    if (subpath === '.')
	      return `No "exports" main defined in ${pkgPath}package.json${
	        base ? ` imported from ${base}` : ''
	      }`
	    return `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${
	      base ? ` imported from ${base}` : ''
	    }`
	  },
	  Error
	);

	codes.ERR_UNSUPPORTED_DIR_IMPORT = createError(
	  'ERR_UNSUPPORTED_DIR_IMPORT',
	  "Directory import '%s' is not supported " +
	    'resolving ES modules imported from %s',
	  Error
	);

	codes.ERR_UNKNOWN_FILE_EXTENSION = createError(
	  'ERR_UNKNOWN_FILE_EXTENSION',
	  /**
	   * @param {string} ext
	   * @param {string} path
	   */
	  (ext, path) => {
	    return `Unknown file extension "${ext}" for ${path}`
	  },
	  TypeError
	);

	codes.ERR_INVALID_ARG_VALUE = createError(
	  'ERR_INVALID_ARG_VALUE',
	  /**
	   * @param {string} name
	   * @param {unknown} value
	   * @param {string} [reason='is invalid']
	   */
	  (name, value, reason = 'is invalid') => {
	    let inspected = node_util.inspect(value);

	    if (inspected.length > 128) {
	      inspected = `${inspected.slice(0, 128)}...`;
	    }

	    const type = name.includes('.') ? 'property' : 'argument';

	    return `The ${type} '${name}' ${reason}. Received ${inspected}`
	  },
	  TypeError
	  // Note: extra classes have been shaken out.
	  // , RangeError
	);

	/**
	 * Utility function for registering the error codes. Only used here. Exported
	 * *only* to allow for testing.
	 * @param {string} sym
	 * @param {MessageFunction | string} value
	 * @param {ErrorConstructor} def
	 * @returns {new (...args: Array<any>) => Error}
	 */
	function createError(sym, value, def) {
	  // Special case for SystemError that formats the error message differently
	  // The SystemErrors only have SystemError as their base classes.
	  messages.set(sym, value);

	  return makeNodeErrorWithCode(def, sym)
	}

	/**
	 * @param {ErrorConstructor} Base
	 * @param {string} key
	 * @returns {ErrorConstructor}
	 */
	function makeNodeErrorWithCode(Base, key) {
	  // @ts-expect-error It’s a Node error.
	  return NodeError
	  /**
	   * @param {Array<unknown>} args
	   */
	  function NodeError(...args) {
	    const limit = Error.stackTraceLimit;
	    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
	    const error = new Base();
	    // Reset the limit and setting the name property.
	    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
	    const message = getMessage(key, args, error);
	    Object.defineProperties(error, {
	      // Note: no need to implement `kIsNodeError` symbol, would be hard,
	      // probably.
	      message: {
	        value: message,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      },
	      toString: {
	        /** @this {Error} */
	        value() {
	          return `${this.name} [${key}]: ${this.message}`
	        },
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });

	    captureLargerStackTrace(error);
	    // @ts-expect-error It’s a Node error.
	    error.code = key;
	    return error
	  }
	}

	/**
	 * @returns {boolean}
	 */
	function isErrorStackTraceLimitWritable() {
	  // Do no touch Error.stackTraceLimit as V8 would attempt to install
	  // it again during deserialization.
	  try {
	    // @ts-expect-error: not in types?
	    if (v8__default.startupSnapshot.isBuildingSnapshot()) {
	      return false
	    }
	  } catch {}

	  const desc = Object.getOwnPropertyDescriptor(Error, 'stackTraceLimit');
	  if (desc === undefined) {
	    return Object.isExtensible(Error)
	  }

	  return own$1.call(desc, 'writable') && desc.writable !== undefined
	    ? desc.writable
	    : desc.set !== undefined
	}

	/**
	 * This function removes unnecessary frames from Node.js core errors.
	 * @template {(...args: unknown[]) => unknown} T
	 * @param {T} fn
	 * @returns {T}
	 */
	function hideStackFrames(fn) {
	  // We rename the functions that will be hidden to cut off the stacktrace
	  // at the outermost one
	  const hidden = nodeInternalPrefix + fn.name;
	  Object.defineProperty(fn, 'name', {value: hidden});
	  return fn
	}

	const captureLargerStackTrace = hideStackFrames(
	  /**
	   * @param {Error} error
	   * @returns {Error}
	   */
	  // @ts-expect-error: fine
	  function (error) {
	    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
	    if (stackTraceLimitIsWritable) {
	      userStackTraceLimit = Error.stackTraceLimit;
	      Error.stackTraceLimit = Number.POSITIVE_INFINITY;
	    }

	    Error.captureStackTrace(error);

	    // Reset the limit
	    if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;

	    return error
	  }
	);

	/**
	 * @param {string} key
	 * @param {Array<unknown>} args
	 * @param {Error} self
	 * @returns {string}
	 */
	function getMessage(key, args, self) {
	  const message = messages.get(key);
	  assert__default(message !== undefined, 'expected `message` to be found');

	  if (typeof message === 'function') {
	    assert__default(
	      message.length <= args.length, // Default options do not count.
	      `Code: ${key}; The provided arguments length (${args.length}) does not ` +
	        `match the required ones (${message.length}).`
	    );
	    return Reflect.apply(message, self, args)
	  }

	  const regex = /%[dfijoOs]/g;
	  let expectedLength = 0;
	  while (regex.exec(message) !== null) expectedLength++;
	  assert__default(
	    expectedLength === args.length,
	    `Code: ${key}; The provided arguments length (${args.length}) does not ` +
	      `match the required ones (${expectedLength}).`
	  );
	  if (args.length === 0) return message

	  args.unshift(message);
	  return Reflect.apply(node_util.format, null, args)
	}

	/**
	 * Determine the specific type of a value for type-mismatch errors.
	 * @param {unknown} value
	 * @returns {string}
	 */
	function determineSpecificType(value) {
	  if (value === null || value === undefined) {
	    return String(value)
	  }

	  if (typeof value === 'function' && value.name) {
	    return `function ${value.name}`
	  }

	  if (typeof value === 'object') {
	    if (value.constructor && value.constructor.name) {
	      return `an instance of ${value.constructor.name}`
	    }

	    return `${node_util.inspect(value, {depth: -1})}`
	  }

	  let inspected = node_util.inspect(value, {colors: false});

	  if (inspected.length > 28) {
	    inspected = `${inspected.slice(0, 25)}...`;
	  }

	  return `type ${typeof value} (${inspected})`
	}

	// Manually “tree shaken” from:
	// <https://github.com/nodejs/node/blob/45f5c9b/lib/internal/modules/package_json_reader.js>
	// Last checked on: Nov 2, 2023.
	// Removed the native dependency.
	// Also: no need to cache, we do that in resolve already.


	const hasOwnProperty$1 = {}.hasOwnProperty;

	const {ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG$1} = codes;

	/** @type {Map<string, PackageConfig>} */
	const cache = new Map();

	const reader = {read};
	const packageJsonReader = reader;

	/**
	 * @param {string} jsonPath
	 * @param {{specifier: URL | string, base?: URL}} options
	 * @returns {PackageConfig}
	 */
	function read(jsonPath, {base, specifier}) {
	  const existing = cache.get(jsonPath);

	  if (existing) {
	    return existing
	  }

	  /** @type {string | undefined} */
	  let string;

	  try {
	    string = fs__default.readFileSync(path__default.toNamespacedPath(jsonPath), 'utf8');
	  } catch (error) {
	    const exception = /** @type {ErrnoException} */ (error);

	    if (exception.code !== 'ENOENT') {
	      throw exception
	    }
	  }

	  /** @type {PackageConfig} */
	  const result = {
	    exists: false,
	    pjsonPath: jsonPath,
	    main: undefined,
	    name: undefined,
	    type: 'none', // Ignore unknown types for forwards compatibility
	    exports: undefined,
	    imports: undefined
	  };

	  if (string !== undefined) {
	    /** @type {Record<string, unknown>} */
	    let parsed;

	    try {
	      parsed = JSON.parse(string);
	    } catch (error_) {
	      const cause = /** @type {ErrnoException} */ (error_);
	      const error = new ERR_INVALID_PACKAGE_CONFIG$1(
	        jsonPath,
	        (base ? `"${specifier}" from ` : '') + node_url.fileURLToPath(base || specifier),
	        cause.message
	      );
	      // @ts-expect-error: fine.
	      error.cause = cause;
	      throw error
	    }

	    result.exists = true;

	    if (
	      hasOwnProperty$1.call(parsed, 'name') &&
	      typeof parsed.name === 'string'
	    ) {
	      result.name = parsed.name;
	    }

	    if (
	      hasOwnProperty$1.call(parsed, 'main') &&
	      typeof parsed.main === 'string'
	    ) {
	      result.main = parsed.main;
	    }

	    if (hasOwnProperty$1.call(parsed, 'exports')) {
	      // @ts-expect-error: assume valid.
	      result.exports = parsed.exports;
	    }

	    if (hasOwnProperty$1.call(parsed, 'imports')) {
	      // @ts-expect-error: assume valid.
	      result.imports = parsed.imports;
	    }

	    // Ignore unknown types for forwards compatibility
	    if (
	      hasOwnProperty$1.call(parsed, 'type') &&
	      (parsed.type === 'commonjs' || parsed.type === 'module')
	    ) {
	      result.type = parsed.type;
	    }
	  }

	  cache.set(jsonPath, result);

	  return result
	}

	// Manually “tree shaken” from:
	// <https://github.com/nodejs/node/blob/45f5c9b/lib/internal/modules/esm/package_config.js>
	// Last checked on: Nov 2, 2023.


	/**
	 * @param {URL | string} resolved
	 * @returns {PackageConfig}
	 */
	function getPackageScopeConfig(resolved) {
	  let packageJSONUrl = new node_url.URL('package.json', resolved);

	  while (true) {
	    const packageJSONPath = packageJSONUrl.pathname;
	    if (packageJSONPath.endsWith('node_modules/package.json')) {
	      break
	    }

	    const packageConfig = packageJsonReader.read(
	      node_url.fileURLToPath(packageJSONUrl),
	      {specifier: resolved}
	    );

	    if (packageConfig.exists) {
	      return packageConfig
	    }

	    const lastPackageJSONUrl = packageJSONUrl;
	    packageJSONUrl = new node_url.URL('../package.json', packageJSONUrl);

	    // Terminates at root where ../package.json equals ../../package.json
	    // (can't just check "/package.json" for Windows support).
	    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {
	      break
	    }
	  }

	  const packageJSONPath = node_url.fileURLToPath(packageJSONUrl);

	  return {
	    pjsonPath: packageJSONPath,
	    exists: false,
	    main: undefined,
	    name: undefined,
	    type: 'none',
	    exports: undefined,
	    imports: undefined
	  }
	}

	// Manually “tree shaken” from:
	// <https://github.com/nodejs/node/blob/45f5c9b/lib/internal/modules/esm/resolve.js>
	// Last checked on: Nov 2, 2023.
	//
	// This file solves a circular dependency.
	// In Node.js, `getPackageType` is in `resolve.js`.
	// `resolve.js` imports `get-format.js`, which needs `getPackageType`.
	// We split that up so that bundlers don’t fail.


	/**
	 * @param {URL} url
	 * @returns {PackageType}
	 */
	function getPackageType(url) {
	  const packageConfig = getPackageScopeConfig(url);
	  return packageConfig.type
	}

	// Manually “tree shaken” from:
	// <https://github.com/nodejs/node/blob/45f5c9b/lib/internal/modules/esm/get_format.js>
	// Last checked on: Nov 2, 2023.


	const {ERR_UNKNOWN_FILE_EXTENSION} = codes;

	const hasOwnProperty = {}.hasOwnProperty;

	/** @type {Record<string, string>} */
	const extensionFormatMap = {
	  // @ts-expect-error: hush.
	  __proto__: null,
	  '.cjs': 'commonjs',
	  '.js': 'module',
	  '.json': 'json',
	  '.mjs': 'module'
	};

	/**
	 * @param {string | null} mime
	 * @returns {string | null}
	 */
	function mimeToFormat(mime) {
	  if (
	    mime &&
	    /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime)
	  )
	    return 'module'
	  if (mime === 'application/json') return 'json'
	  return null
	}

	/**
	 * @callback ProtocolHandler
	 * @param {URL} parsed
	 * @param {{parentURL: string, source?: Buffer}} context
	 * @param {boolean} ignoreErrors
	 * @returns {string | null | void}
	 */

	/**
	 * @type {Record<string, ProtocolHandler>}
	 */
	const protocolHandlers = {
	  // @ts-expect-error: hush.
	  __proto__: null,
	  'data:': getDataProtocolModuleFormat,
	  'file:': getFileProtocolModuleFormat,
	  'http:': getHttpProtocolModuleFormat,
	  'https:': getHttpProtocolModuleFormat,
	  'node:'() {
	    return 'builtin'
	  }
	};

	/**
	 * @param {URL} parsed
	 */
	function getDataProtocolModuleFormat(parsed) {
	  const {1: mime} = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(
	    parsed.pathname
	  ) || [null, null, null];
	  return mimeToFormat(mime)
	}

	/**
	 * Returns the file extension from a URL.
	 *
	 * Should give similar result to
	 * `require('node:path').extname(require('node:url').fileURLToPath(url))`
	 * when used with a `file:` URL.
	 *
	 * @param {URL} url
	 * @returns {string}
	 */
	function extname(url) {
	  const pathname = url.pathname;
	  let index = pathname.length;

	  while (index--) {
	    const code = pathname.codePointAt(index);

	    if (code === 47 /* `/` */) {
	      return ''
	    }

	    if (code === 46 /* `.` */) {
	      return pathname.codePointAt(index - 1) === 47 /* `/` */
	        ? ''
	        : pathname.slice(index)
	    }
	  }

	  return ''
	}

	/**
	 * @type {ProtocolHandler}
	 */
	function getFileProtocolModuleFormat(url, _context, ignoreErrors) {
	  const ext = extname(url);

	  if (ext === '.js') {
	    const packageType = getPackageType(url);

	    if (packageType !== 'none') {
	      return packageType
	    }

	    return 'commonjs'
	  }

	  if (ext === '') {
	    const packageType = getPackageType(url);

	    // Legacy behavior
	    if (packageType === 'none' || packageType === 'commonjs') {
	      return 'commonjs'
	    }

	    // Note: we don’t implement WASM, so we don’t need
	    // `getFormatOfExtensionlessFile` from `formats`.
	    return 'module'
	  }

	  const format = extensionFormatMap[ext];
	  if (format) return format

	  // Explicit undefined return indicates load hook should rerun format check
	  if (ignoreErrors) {
	    return undefined
	  }

	  const filepath = node_url.fileURLToPath(url);
	  throw new ERR_UNKNOWN_FILE_EXTENSION(ext, filepath)
	}

	function getHttpProtocolModuleFormat() {
	  // To do: HTTPS imports.
	}

	/**
	 * @param {URL} url
	 * @param {{parentURL: string}} context
	 * @returns {string | null}
	 */
	function defaultGetFormatWithoutErrors(url, context) {
	  const protocol = url.protocol;

	  if (!hasOwnProperty.call(protocolHandlers, protocol)) {
	    return null
	  }

	  return protocolHandlers[protocol](url, context, true) || null
	}

	// Manually “tree shaken” from:
	// <https://github.com/nodejs/node/blob/45f5c9b/lib/internal/modules/esm/resolve.js>
	// Last checked on: Nov 2, 2023.


	const RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];

	const {
	  ERR_NETWORK_IMPORT_DISALLOWED,
	  ERR_INVALID_MODULE_SPECIFIER,
	  ERR_INVALID_PACKAGE_CONFIG,
	  ERR_INVALID_PACKAGE_TARGET,
	  ERR_MODULE_NOT_FOUND,
	  ERR_PACKAGE_IMPORT_NOT_DEFINED,
	  ERR_PACKAGE_PATH_NOT_EXPORTED,
	  ERR_UNSUPPORTED_DIR_IMPORT
	} = codes;

	const own = {}.hasOwnProperty;

	const invalidSegmentRegEx =
	  /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
	const deprecatedInvalidSegmentRegEx =
	  /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
	const invalidPackageNameRegEx = /^\.|%|\\/;
	const patternRegEx = /\*/g;
	const encodedSepRegEx = /%2f|%5c/i;
	/** @type {Set<string>} */
	const emittedPackageWarnings = new Set();

	const doubleSlashRegEx = /[/\\]{2}/;

	/**
	 *
	 * @param {string} target
	 * @param {string} request
	 * @param {string} match
	 * @param {URL} packageJsonUrl
	 * @param {boolean} internal
	 * @param {URL} base
	 * @param {boolean} isTarget
	 */
	function emitInvalidSegmentDeprecation(
	  target,
	  request,
	  match,
	  packageJsonUrl,
	  internal,
	  base,
	  isTarget
	) {
	  // @ts-expect-error: apparently it does exist, TS.
	  if (process__default.noDeprecation) {
	    return
	  }

	  const pjsonPath = node_url.fileURLToPath(packageJsonUrl);
	  const double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
	  process__default.emitWarning(
	    `Use of deprecated ${
	      double ? 'double slash' : 'leading or trailing slash matching'
	    } resolving "${target}" for module ` +
	      `request "${request}" ${
	        request === match ? '' : `matched to "${match}" `
	      }in the "${
	        internal ? 'imports' : 'exports'
	      }" field module resolution of the package at ${pjsonPath}${
	        base ? ` imported from ${node_url.fileURLToPath(base)}` : ''
	      }.`,
	    'DeprecationWarning',
	    'DEP0166'
	  );
	}

	/**
	 * @param {URL} url
	 * @param {URL} packageJsonUrl
	 * @param {URL} base
	 * @param {string} [main]
	 * @returns {void}
	 */
	function emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {
	  // @ts-expect-error: apparently it does exist, TS.
	  if (process__default.noDeprecation) {
	    return
	  }

	  const format = defaultGetFormatWithoutErrors(url, {parentURL: base.href});
	  if (format !== 'module') return
	  const urlPath = node_url.fileURLToPath(url.href);
	  const pkgPath = node_url.fileURLToPath(new node_url.URL('.', packageJsonUrl));
	  const basePath = node_url.fileURLToPath(base);
	  if (!main) {
	    process__default.emitWarning(
	      `No "main" or "exports" field defined in the package.json for ${pkgPath} resolving the main entry point "${urlPath.slice(
	        pkgPath.length
	      )}", imported from ${basePath}.\nDefault "index" lookups for the main are deprecated for ES modules.`,
	      'DeprecationWarning',
	      'DEP0151'
	    );
	  } else if (path__default.resolve(pkgPath, main) !== urlPath) {
	    process__default.emitWarning(
	      `Package ${pkgPath} has a "main" field set to "${main}", ` +
	        `excluding the full filename and extension to the resolved file at "${urlPath.slice(
	          pkgPath.length
	        )}", imported from ${basePath}.\n Automatic extension resolution of the "main" field is ` +
	        'deprecated for ES modules.',
	      'DeprecationWarning',
	      'DEP0151'
	    );
	  }
	}

	/**
	 * @param {string} path
	 * @returns {Stats}
	 */
	function tryStatSync(path) {
	  // Note: from Node 15 onwards we can use `throwIfNoEntry: false` instead.
	  try {
	    return fs.statSync(path)
	  } catch {
	    return new fs.Stats()
	  }
	}

	/**
	 * Legacy CommonJS main resolution:
	 * 1. let M = pkg_url + (json main field)
	 * 2. TRY(M, M.js, M.json, M.node)
	 * 3. TRY(M/index.js, M/index.json, M/index.node)
	 * 4. TRY(pkg_url/index.js, pkg_url/index.json, pkg_url/index.node)
	 * 5. NOT_FOUND
	 *
	 * @param {URL} url
	 * @returns {boolean}
	 */
	function fileExists(url) {
	  const stats = fs.statSync(url, {throwIfNoEntry: false});
	  const isFile = stats ? stats.isFile() : undefined;
	  return isFile === null || isFile === undefined ? false : isFile
	}

	/**
	 * @param {URL} packageJsonUrl
	 * @param {PackageConfig} packageConfig
	 * @param {URL} base
	 * @returns {URL}
	 */
	function legacyMainResolve(packageJsonUrl, packageConfig, base) {
	  /** @type {URL | undefined} */
	  let guess;
	  if (packageConfig.main !== undefined) {
	    guess = new node_url.URL(packageConfig.main, packageJsonUrl);
	    // Note: fs check redundances will be handled by Descriptor cache here.
	    if (fileExists(guess)) return guess

	    const tries = [
	      `./${packageConfig.main}.js`,
	      `./${packageConfig.main}.json`,
	      `./${packageConfig.main}.node`,
	      `./${packageConfig.main}/index.js`,
	      `./${packageConfig.main}/index.json`,
	      `./${packageConfig.main}/index.node`
	    ];
	    let i = -1;

	    while (++i < tries.length) {
	      guess = new node_url.URL(tries[i], packageJsonUrl);
	      if (fileExists(guess)) break
	      guess = undefined;
	    }

	    if (guess) {
	      emitLegacyIndexDeprecation(
	        guess,
	        packageJsonUrl,
	        base,
	        packageConfig.main
	      );
	      return guess
	    }
	    // Fallthrough.
	  }

	  const tries = ['./index.js', './index.json', './index.node'];
	  let i = -1;

	  while (++i < tries.length) {
	    guess = new node_url.URL(tries[i], packageJsonUrl);
	    if (fileExists(guess)) break
	    guess = undefined;
	  }

	  if (guess) {
	    emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
	    return guess
	  }

	  // Not found.
	  throw new ERR_MODULE_NOT_FOUND(
	    node_url.fileURLToPath(new node_url.URL('.', packageJsonUrl)),
	    node_url.fileURLToPath(base)
	  )
	}

	/**
	 * @param {URL} resolved
	 * @param {URL} base
	 * @param {boolean} [preserveSymlinks]
	 * @returns {URL}
	 */
	function finalizeResolution(resolved, base, preserveSymlinks) {
	  if (encodedSepRegEx.exec(resolved.pathname) !== null) {
	    throw new ERR_INVALID_MODULE_SPECIFIER(
	      resolved.pathname,
	      'must not include encoded "/" or "\\" characters',
	      node_url.fileURLToPath(base)
	    )
	  }

	  /** @type {string} */
	  let filePath;

	  try {
	    filePath = node_url.fileURLToPath(resolved);
	  } catch (error) {
	    const cause = /** @type {ErrnoException} */ (error);
	    Object.defineProperty(cause, 'input', {value: String(resolved)});
	    Object.defineProperty(cause, 'module', {value: String(base)});
	    throw cause
	  }

	  const stats = tryStatSync(
	    filePath.endsWith('/') ? filePath.slice(-1) : filePath
	  );

	  if (stats.isDirectory()) {
	    const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, node_url.fileURLToPath(base));
	    // @ts-expect-error Add this for `import.meta.resolve`.
	    error.url = String(resolved);
	    throw error
	  }

	  if (!stats.isFile()) {
	    const error = new ERR_MODULE_NOT_FOUND(
	      filePath || resolved.pathname,
	      base && node_url.fileURLToPath(base),
	      true
	    );
	    // @ts-expect-error Add this for `import.meta.resolve`.
	    error.url = String(resolved);
	    throw error
	  }

	  if (!preserveSymlinks) {
	    const real = fs.realpathSync(filePath);
	    const {search, hash} = resolved;
	    resolved = node_url.pathToFileURL(real + (filePath.endsWith(path__default.sep) ? '/' : ''));
	    resolved.search = search;
	    resolved.hash = hash;
	  }

	  return resolved
	}

	/**
	 * @param {string} specifier
	 * @param {URL | undefined} packageJsonUrl
	 * @param {URL} base
	 * @returns {Error}
	 */
	function importNotDefined(specifier, packageJsonUrl, base) {
	  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(
	    specifier,
	    packageJsonUrl && node_url.fileURLToPath(new node_url.URL('.', packageJsonUrl)),
	    node_url.fileURLToPath(base)
	  )
	}

	/**
	 * @param {string} subpath
	 * @param {URL} packageJsonUrl
	 * @param {URL} base
	 * @returns {Error}
	 */
	function exportsNotFound(subpath, packageJsonUrl, base) {
	  return new ERR_PACKAGE_PATH_NOT_EXPORTED(
	    node_url.fileURLToPath(new node_url.URL('.', packageJsonUrl)),
	    subpath,
	    base && node_url.fileURLToPath(base)
	  )
	}

	/**
	 * @param {string} request
	 * @param {string} match
	 * @param {URL} packageJsonUrl
	 * @param {boolean} internal
	 * @param {URL} [base]
	 * @returns {never}
	 */
	function throwInvalidSubpath(request, match, packageJsonUrl, internal, base) {
	  const reason = `request is not a valid match in pattern "${match}" for the "${
	    internal ? 'imports' : 'exports'
	  }" resolution of ${node_url.fileURLToPath(packageJsonUrl)}`;
	  throw new ERR_INVALID_MODULE_SPECIFIER(
	    request,
	    reason,
	    base && node_url.fileURLToPath(base)
	  )
	}

	/**
	 * @param {string} subpath
	 * @param {unknown} target
	 * @param {URL} packageJsonUrl
	 * @param {boolean} internal
	 * @param {URL} [base]
	 * @returns {Error}
	 */
	function invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
	  target =
	    typeof target === 'object' && target !== null
	      ? JSON.stringify(target, null, '')
	      : `${target}`;

	  return new ERR_INVALID_PACKAGE_TARGET(
	    node_url.fileURLToPath(new node_url.URL('.', packageJsonUrl)),
	    subpath,
	    target,
	    internal,
	    base && node_url.fileURLToPath(base)
	  )
	}

	/**
	 * @param {string} target
	 * @param {string} subpath
	 * @param {string} match
	 * @param {URL} packageJsonUrl
	 * @param {URL} base
	 * @param {boolean} pattern
	 * @param {boolean} internal
	 * @param {boolean} isPathMap
	 * @param {Set<string> | undefined} conditions
	 * @returns {URL}
	 */
	function resolvePackageTargetString(
	  target,
	  subpath,
	  match,
	  packageJsonUrl,
	  base,
	  pattern,
	  internal,
	  isPathMap,
	  conditions
	) {
	  if (subpath !== '' && !pattern && target[target.length - 1] !== '/')
	    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base)

	  if (!target.startsWith('./')) {
	    if (internal && !target.startsWith('../') && !target.startsWith('/')) {
	      let isURL = false;

	      try {
	        new node_url.URL(target);
	        isURL = true;
	      } catch {
	        // Continue regardless of error.
	      }

	      if (!isURL) {
	        const exportTarget = pattern
	          ? RegExpPrototypeSymbolReplace.call(
	              patternRegEx,
	              target,
	              () => subpath
	            )
	          : target + subpath;

	        return packageResolve(exportTarget, packageJsonUrl, conditions)
	      }
	    }

	    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base)
	  }

	  if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {
	    if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
	      if (!isPathMap) {
	        const request = pattern
	          ? match.replace('*', () => subpath)
	          : match + subpath;
	        const resolvedTarget = pattern
	          ? RegExpPrototypeSymbolReplace.call(
	              patternRegEx,
	              target,
	              () => subpath
	            )
	          : target;
	        emitInvalidSegmentDeprecation(
	          resolvedTarget,
	          request,
	          match,
	          packageJsonUrl,
	          internal,
	          base,
	          true
	        );
	      }
	    } else {
	      throw invalidPackageTarget(match, target, packageJsonUrl, internal, base)
	    }
	  }

	  const resolved = new node_url.URL(target, packageJsonUrl);
	  const resolvedPath = resolved.pathname;
	  const packagePath = new node_url.URL('.', packageJsonUrl).pathname;

	  if (!resolvedPath.startsWith(packagePath))
	    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base)

	  if (subpath === '') return resolved

	  if (invalidSegmentRegEx.exec(subpath) !== null) {
	    const request = pattern
	      ? match.replace('*', () => subpath)
	      : match + subpath;
	    if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
	      if (!isPathMap) {
	        const resolvedTarget = pattern
	          ? RegExpPrototypeSymbolReplace.call(
	              patternRegEx,
	              target,
	              () => subpath
	            )
	          : target;
	        emitInvalidSegmentDeprecation(
	          resolvedTarget,
	          request,
	          match,
	          packageJsonUrl,
	          internal,
	          base,
	          false
	        );
	      }
	    } else {
	      throwInvalidSubpath(request, match, packageJsonUrl, internal, base);
	    }
	  }

	  if (pattern) {
	    return new node_url.URL(
	      RegExpPrototypeSymbolReplace.call(
	        patternRegEx,
	        resolved.href,
	        () => subpath
	      )
	    )
	  }

	  return new node_url.URL(subpath, resolved)
	}

	/**
	 * @param {string} key
	 * @returns {boolean}
	 */
	function isArrayIndex(key) {
	  const keyNumber = Number(key);
	  if (`${keyNumber}` !== key) return false
	  return keyNumber >= 0 && keyNumber < 0xff_ff_ff_ff
	}

	/**
	 * @param {URL} packageJsonUrl
	 * @param {unknown} target
	 * @param {string} subpath
	 * @param {string} packageSubpath
	 * @param {URL} base
	 * @param {boolean} pattern
	 * @param {boolean} internal
	 * @param {boolean} isPathMap
	 * @param {Set<string> | undefined} conditions
	 * @returns {URL | null}
	 */
	function resolvePackageTarget(
	  packageJsonUrl,
	  target,
	  subpath,
	  packageSubpath,
	  base,
	  pattern,
	  internal,
	  isPathMap,
	  conditions
	) {
	  if (typeof target === 'string') {
	    return resolvePackageTargetString(
	      target,
	      subpath,
	      packageSubpath,
	      packageJsonUrl,
	      base,
	      pattern,
	      internal,
	      isPathMap,
	      conditions
	    )
	  }

	  if (Array.isArray(target)) {
	    /** @type {Array<unknown>} */
	    const targetList = target;
	    if (targetList.length === 0) return null

	    /** @type {ErrnoException | null | undefined} */
	    let lastException;
	    let i = -1;

	    while (++i < targetList.length) {
	      const targetItem = targetList[i];
	      /** @type {URL | null} */
	      let resolveResult;
	      try {
	        resolveResult = resolvePackageTarget(
	          packageJsonUrl,
	          targetItem,
	          subpath,
	          packageSubpath,
	          base,
	          pattern,
	          internal,
	          isPathMap,
	          conditions
	        );
	      } catch (error) {
	        const exception = /** @type {ErrnoException} */ (error);
	        lastException = exception;
	        if (exception.code === 'ERR_INVALID_PACKAGE_TARGET') continue
	        throw error
	      }

	      if (resolveResult === undefined) continue

	      if (resolveResult === null) {
	        lastException = null;
	        continue
	      }

	      return resolveResult
	    }

	    if (lastException === undefined || lastException === null) {
	      return null
	    }

	    throw lastException
	  }

	  if (typeof target === 'object' && target !== null) {
	    const keys = Object.getOwnPropertyNames(target);
	    let i = -1;

	    while (++i < keys.length) {
	      const key = keys[i];
	      if (isArrayIndex(key)) {
	        throw new ERR_INVALID_PACKAGE_CONFIG(
	          node_url.fileURLToPath(packageJsonUrl),
	          base,
	          '"exports" cannot contain numeric property keys.'
	        )
	      }
	    }

	    i = -1;

	    while (++i < keys.length) {
	      const key = keys[i];
	      if (key === 'default' || (conditions && conditions.has(key))) {
	        // @ts-expect-error: indexable.
	        const conditionalTarget = /** @type {unknown} */ (target[key]);
	        const resolveResult = resolvePackageTarget(
	          packageJsonUrl,
	          conditionalTarget,
	          subpath,
	          packageSubpath,
	          base,
	          pattern,
	          internal,
	          isPathMap,
	          conditions
	        );
	        if (resolveResult === undefined) continue
	        return resolveResult
	      }
	    }

	    return null
	  }

	  if (target === null) {
	    return null
	  }

	  throw invalidPackageTarget(
	    packageSubpath,
	    target,
	    packageJsonUrl,
	    internal,
	    base
	  )
	}

	/**
	 * @param {unknown} exports
	 * @param {URL} packageJsonUrl
	 * @param {URL} base
	 * @returns {boolean}
	 */
	function isConditionalExportsMainSugar(exports, packageJsonUrl, base) {
	  if (typeof exports === 'string' || Array.isArray(exports)) return true
	  if (typeof exports !== 'object' || exports === null) return false

	  const keys = Object.getOwnPropertyNames(exports);
	  let isConditionalSugar = false;
	  let i = 0;
	  let j = -1;
	  while (++j < keys.length) {
	    const key = keys[j];
	    const curIsConditionalSugar = key === '' || key[0] !== '.';
	    if (i++ === 0) {
	      isConditionalSugar = curIsConditionalSugar;
	    } else if (isConditionalSugar !== curIsConditionalSugar) {
	      throw new ERR_INVALID_PACKAGE_CONFIG(
	        node_url.fileURLToPath(packageJsonUrl),
	        base,
	        '"exports" cannot contain some keys starting with \'.\' and some not.' +
	          ' The exports object must either be an object of package subpath keys' +
	          ' or an object of main entry condition name keys only.'
	      )
	    }
	  }

	  return isConditionalSugar
	}

	/**
	 * @param {string} match
	 * @param {URL} pjsonUrl
	 * @param {URL} base
	 */
	function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
	  // @ts-expect-error: apparently it does exist, TS.
	  if (process__default.noDeprecation) {
	    return
	  }

	  const pjsonPath = node_url.fileURLToPath(pjsonUrl);
	  if (emittedPackageWarnings.has(pjsonPath + '|' + match)) return
	  emittedPackageWarnings.add(pjsonPath + '|' + match);
	  process__default.emitWarning(
	    `Use of deprecated trailing slash pattern mapping "${match}" in the ` +
	      `"exports" field module resolution of the package at ${pjsonPath}${
	        base ? ` imported from ${node_url.fileURLToPath(base)}` : ''
	      }. Mapping specifiers ending in "/" is no longer supported.`,
	    'DeprecationWarning',
	    'DEP0155'
	  );
	}

	/**
	 * @param {URL} packageJsonUrl
	 * @param {string} packageSubpath
	 * @param {Record<string, unknown>} packageConfig
	 * @param {URL} base
	 * @param {Set<string> | undefined} conditions
	 * @returns {URL}
	 */
	function packageExportsResolve(
	  packageJsonUrl,
	  packageSubpath,
	  packageConfig,
	  base,
	  conditions
	) {
	  let exports = packageConfig.exports;

	  if (isConditionalExportsMainSugar(exports, packageJsonUrl, base)) {
	    exports = {'.': exports};
	  }

	  if (
	    own.call(exports, packageSubpath) &&
	    !packageSubpath.includes('*') &&
	    !packageSubpath.endsWith('/')
	  ) {
	    // @ts-expect-error: indexable.
	    const target = exports[packageSubpath];
	    const resolveResult = resolvePackageTarget(
	      packageJsonUrl,
	      target,
	      '',
	      packageSubpath,
	      base,
	      false,
	      false,
	      false,
	      conditions
	    );
	    if (resolveResult === null || resolveResult === undefined) {
	      throw exportsNotFound(packageSubpath, packageJsonUrl, base)
	    }

	    return resolveResult
	  }

	  let bestMatch = '';
	  let bestMatchSubpath = '';
	  const keys = Object.getOwnPropertyNames(exports);
	  let i = -1;

	  while (++i < keys.length) {
	    const key = keys[i];
	    const patternIndex = key.indexOf('*');

	    if (
	      patternIndex !== -1 &&
	      packageSubpath.startsWith(key.slice(0, patternIndex))
	    ) {
	      // When this reaches EOL, this can throw at the top of the whole function:
	      //
	      // if (StringPrototypeEndsWith(packageSubpath, '/'))
	      //   throwInvalidSubpath(packageSubpath)
	      //
	      // To match "imports" and the spec.
	      if (packageSubpath.endsWith('/')) {
	        emitTrailingSlashPatternDeprecation(
	          packageSubpath,
	          packageJsonUrl,
	          base
	        );
	      }

	      const patternTrailer = key.slice(patternIndex + 1);

	      if (
	        packageSubpath.length >= key.length &&
	        packageSubpath.endsWith(patternTrailer) &&
	        patternKeyCompare(bestMatch, key) === 1 &&
	        key.lastIndexOf('*') === patternIndex
	      ) {
	        bestMatch = key;
	        bestMatchSubpath = packageSubpath.slice(
	          patternIndex,
	          packageSubpath.length - patternTrailer.length
	        );
	      }
	    }
	  }

	  if (bestMatch) {
	    // @ts-expect-error: indexable.
	    const target = /** @type {unknown} */ (exports[bestMatch]);
	    const resolveResult = resolvePackageTarget(
	      packageJsonUrl,
	      target,
	      bestMatchSubpath,
	      bestMatch,
	      base,
	      true,
	      false,
	      packageSubpath.endsWith('/'),
	      conditions
	    );

	    if (resolveResult === null || resolveResult === undefined) {
	      throw exportsNotFound(packageSubpath, packageJsonUrl, base)
	    }

	    return resolveResult
	  }

	  throw exportsNotFound(packageSubpath, packageJsonUrl, base)
	}

	/**
	 * @param {string} a
	 * @param {string} b
	 */
	function patternKeyCompare(a, b) {
	  const aPatternIndex = a.indexOf('*');
	  const bPatternIndex = b.indexOf('*');
	  const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
	  const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
	  if (baseLengthA > baseLengthB) return -1
	  if (baseLengthB > baseLengthA) return 1
	  if (aPatternIndex === -1) return 1
	  if (bPatternIndex === -1) return -1
	  if (a.length > b.length) return -1
	  if (b.length > a.length) return 1
	  return 0
	}

	/**
	 * @param {string} name
	 * @param {URL} base
	 * @param {Set<string>} [conditions]
	 * @returns {URL}
	 */
	function packageImportsResolve(name, base, conditions) {
	  if (name === '#' || name.startsWith('#/') || name.endsWith('/')) {
	    const reason = 'is not a valid internal imports specifier name';
	    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, node_url.fileURLToPath(base))
	  }

	  /** @type {URL | undefined} */
	  let packageJsonUrl;

	  const packageConfig = getPackageScopeConfig(base);

	  if (packageConfig.exists) {
	    packageJsonUrl = node_url.pathToFileURL(packageConfig.pjsonPath);
	    const imports = packageConfig.imports;
	    if (imports) {
	      if (own.call(imports, name) && !name.includes('*')) {
	        const resolveResult = resolvePackageTarget(
	          packageJsonUrl,
	          imports[name],
	          '',
	          name,
	          base,
	          false,
	          true,
	          false,
	          conditions
	        );
	        if (resolveResult !== null && resolveResult !== undefined) {
	          return resolveResult
	        }
	      } else {
	        let bestMatch = '';
	        let bestMatchSubpath = '';
	        const keys = Object.getOwnPropertyNames(imports);
	        let i = -1;

	        while (++i < keys.length) {
	          const key = keys[i];
	          const patternIndex = key.indexOf('*');

	          if (patternIndex !== -1 && name.startsWith(key.slice(0, -1))) {
	            const patternTrailer = key.slice(patternIndex + 1);
	            if (
	              name.length >= key.length &&
	              name.endsWith(patternTrailer) &&
	              patternKeyCompare(bestMatch, key) === 1 &&
	              key.lastIndexOf('*') === patternIndex
	            ) {
	              bestMatch = key;
	              bestMatchSubpath = name.slice(
	                patternIndex,
	                name.length - patternTrailer.length
	              );
	            }
	          }
	        }

	        if (bestMatch) {
	          const target = imports[bestMatch];
	          const resolveResult = resolvePackageTarget(
	            packageJsonUrl,
	            target,
	            bestMatchSubpath,
	            bestMatch,
	            base,
	            true,
	            true,
	            false,
	            conditions
	          );

	          if (resolveResult !== null && resolveResult !== undefined) {
	            return resolveResult
	          }
	        }
	      }
	    }
	  }

	  throw importNotDefined(name, packageJsonUrl, base)
	}

	// Note: In Node.js, `getPackageType` is here.
	// To prevent a circular dependency, we move it to
	// `resolve-get-package-type.js`.

	/**
	 * @param {string} specifier
	 * @param {URL} base
	 */
	function parsePackageName(specifier, base) {
	  let separatorIndex = specifier.indexOf('/');
	  let validPackageName = true;
	  let isScoped = false;
	  if (specifier[0] === '@') {
	    isScoped = true;
	    if (separatorIndex === -1 || specifier.length === 0) {
	      validPackageName = false;
	    } else {
	      separatorIndex = specifier.indexOf('/', separatorIndex + 1);
	    }
	  }

	  const packageName =
	    separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);

	  // Package name cannot have leading . and cannot have percent-encoding or
	  // \\ separators.
	  if (invalidPackageNameRegEx.exec(packageName) !== null) {
	    validPackageName = false;
	  }

	  if (!validPackageName) {
	    throw new ERR_INVALID_MODULE_SPECIFIER(
	      specifier,
	      'is not a valid package name',
	      node_url.fileURLToPath(base)
	    )
	  }

	  const packageSubpath =
	    '.' + (separatorIndex === -1 ? '' : specifier.slice(separatorIndex));

	  return {packageName, packageSubpath, isScoped}
	}

	/**
	 * @param {string} specifier
	 * @param {URL} base
	 * @param {Set<string> | undefined} conditions
	 * @returns {URL}
	 */
	function packageResolve(specifier, base, conditions) {
	  if (node_module.builtinModules.includes(specifier)) {
	    return new node_url.URL('node:' + specifier)
	  }

	  const {packageName, packageSubpath, isScoped} = parsePackageName(
	    specifier,
	    base
	  );

	  // ResolveSelf
	  const packageConfig = getPackageScopeConfig(base);

	  // Can’t test.
	  /* c8 ignore next 16 */
	  if (packageConfig.exists) {
	    const packageJsonUrl = node_url.pathToFileURL(packageConfig.pjsonPath);
	    if (
	      packageConfig.name === packageName &&
	      packageConfig.exports !== undefined &&
	      packageConfig.exports !== null
	    ) {
	      return packageExportsResolve(
	        packageJsonUrl,
	        packageSubpath,
	        packageConfig,
	        base,
	        conditions
	      )
	    }
	  }

	  let packageJsonUrl = new node_url.URL(
	    './node_modules/' + packageName + '/package.json',
	    base
	  );
	  let packageJsonPath = node_url.fileURLToPath(packageJsonUrl);
	  /** @type {string} */
	  let lastPath;
	  do {
	    const stat = tryStatSync(packageJsonPath.slice(0, -13));
	    if (!stat.isDirectory()) {
	      lastPath = packageJsonPath;
	      packageJsonUrl = new node_url.URL(
	        (isScoped ? '../../../../node_modules/' : '../../../node_modules/') +
	          packageName +
	          '/package.json',
	        packageJsonUrl
	      );
	      packageJsonPath = node_url.fileURLToPath(packageJsonUrl);
	      continue
	    }

	    // Package match.
	    const packageConfig = packageJsonReader.read(packageJsonPath, {
	      base,
	      specifier
	    });
	    if (packageConfig.exports !== undefined && packageConfig.exports !== null) {
	      return packageExportsResolve(
	        packageJsonUrl,
	        packageSubpath,
	        packageConfig,
	        base,
	        conditions
	      )
	    }

	    if (packageSubpath === '.') {
	      return legacyMainResolve(packageJsonUrl, packageConfig, base)
	    }

	    return new node_url.URL(packageSubpath, packageJsonUrl)
	    // Cross-platform root check.
	  } while (packageJsonPath.length !== lastPath.length)

	  throw new ERR_MODULE_NOT_FOUND(packageName, node_url.fileURLToPath(base), false)
	}

	/**
	 * @param {string} specifier
	 * @returns {boolean}
	 */
	function isRelativeSpecifier(specifier) {
	  if (specifier[0] === '.') {
	    if (specifier.length === 1 || specifier[1] === '/') return true
	    if (
	      specifier[1] === '.' &&
	      (specifier.length === 2 || specifier[2] === '/')
	    ) {
	      return true
	    }
	  }

	  return false
	}

	/**
	 * @param {string} specifier
	 * @returns {boolean}
	 */
	function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
	  if (specifier === '') return false
	  if (specifier[0] === '/') return true
	  return isRelativeSpecifier(specifier)
	}

	/**
	 * The “Resolver Algorithm Specification” as detailed in the Node docs (which is
	 * sync and slightly lower-level than `resolve`).
	 *
	 * @param {string} specifier
	 *   `/example.js`, `./example.js`, `../example.js`, `some-package`, `fs`, etc.
	 * @param {URL} base
	 *   Full URL (to a file) that `specifier` is resolved relative from.
	 * @param {Set<string>} [conditions]
	 *   Conditions.
	 * @param {boolean} [preserveSymlinks]
	 *   Keep symlinks instead of resolving them.
	 * @returns {URL}
	 *   A URL object to the found thing.
	 */
	function moduleResolve(specifier, base, conditions, preserveSymlinks) {
	  const protocol = base.protocol;
	  const isRemote = protocol === 'http:' || protocol === 'https:';
	  // Order swapped from spec for minor perf gain.
	  // Ok since relative URLs cannot parse as URLs.
	  /** @type {URL | undefined} */
	  let resolved;

	  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
	    resolved = new node_url.URL(specifier, base);
	  } else if (!isRemote && specifier[0] === '#') {
	    resolved = packageImportsResolve(specifier, base, conditions);
	  } else {
	    try {
	      resolved = new node_url.URL(specifier);
	    } catch {
	      if (!isRemote) {
	        resolved = packageResolve(specifier, base, conditions);
	      }
	    }
	  }

	  assert__default(resolved !== undefined, 'expected to be defined');

	  if (resolved.protocol !== 'file:') {
	    return resolved
	  }

	  return finalizeResolution(resolved, base, preserveSymlinks)
	}

	function fileURLToPath(id) {
	  if (typeof id === "string" && !id.startsWith("file://")) {
	    return normalizeSlash(id);
	  }
	  return normalizeSlash(node_url.fileURLToPath(id));
	}
	function pathToFileURL(id) {
	  return node_url.pathToFileURL(fileURLToPath(id)).toString();
	}
	const INVALID_CHAR_RE = /[\u0000-\u001F"#$&*+,/:;<=>?@[\]^`{|}\u007F]+/g;
	function sanitizeURIComponent(name = "", replacement = "_") {
	  return name.replace(INVALID_CHAR_RE, replacement).replace(/%../g, replacement);
	}
	function sanitizeFilePath(filePath = "") {
	  return filePath.replace(/\?.*$/, "").split(/[/\\]/g).map((p) => sanitizeURIComponent(p)).join("/").replace(/^([A-Za-z])_\//, "$1:/");
	}
	function normalizeid(id) {
	  if (typeof id !== "string") {
	    id = id.toString();
	  }
	  if (/(node|data|http|https|file):/.test(id)) {
	    return id;
	  }
	  if (BUILTIN_MODULES.has(id)) {
	    return "node:" + id;
	  }
	  return "file://" + encodeURI(normalizeSlash(id));
	}
	async function loadURL(url) {
	  const code = await fs.promises.readFile(fileURLToPath(url), "utf8");
	  return code;
	}
	function toDataURL(code) {
	  const base64 = Buffer.from(code).toString("base64");
	  return `data:text/javascript;base64,${base64}`;
	}
	function isNodeBuiltin(id = "") {
	  id = id.replace(/^node:/, "").split("/")[0];
	  return BUILTIN_MODULES.has(id);
	}
	const ProtocolRegex = /^(?<proto>.{2,}?):.+$/;
	function getProtocol(id) {
	  const proto = id.match(ProtocolRegex);
	  return proto ? proto.groups?.proto : void 0;
	}

	const DEFAULT_CONDITIONS_SET = /* @__PURE__ */ new Set(["node", "import"]);
	const DEFAULT_EXTENSIONS = [".mjs", ".cjs", ".js", ".json"];
	const NOT_FOUND_ERRORS = /* @__PURE__ */ new Set([
	  "ERR_MODULE_NOT_FOUND",
	  "ERR_UNSUPPORTED_DIR_IMPORT",
	  "MODULE_NOT_FOUND",
	  "ERR_PACKAGE_PATH_NOT_EXPORTED"
	]);
	function _tryModuleResolve(id, url, conditions) {
	  try {
	    return moduleResolve(id, url, conditions);
	  } catch (error) {
	    if (!NOT_FOUND_ERRORS.has(error?.code)) {
	      throw error;
	    }
	  }
	}
	function _resolve(id, options = {}) {
	  if (typeof id !== "string") {
	    if (id instanceof URL) {
	      id = fileURLToPath(id);
	    } else {
	      throw new TypeError("input must be a `string` or `URL`");
	    }
	  }
	  if (/(node|data|http|https):/.test(id)) {
	    return id;
	  }
	  if (BUILTIN_MODULES.has(id)) {
	    return "node:" + id;
	  }
	  if (id.startsWith("file://")) {
	    id = fileURLToPath(id);
	  }
	  if (pathe.isAbsolute(id)) {
	    try {
	      const stat = fs.statSync(id);
	      if (stat.isFile()) {
	        return pathToFileURL(id);
	      }
	    } catch (error) {
	      if (error?.code !== "ENOENT") {
	        throw error;
	      }
	    }
	  }
	  const conditionsSet = options.conditions ? new Set(options.conditions) : DEFAULT_CONDITIONS_SET;
	  const _urls = (Array.isArray(options.url) ? options.url : [options.url]).filter(Boolean).map((url) => new URL(normalizeid(url.toString())));
	  if (_urls.length === 0) {
	    _urls.push(new URL(pathToFileURL(process.cwd())));
	  }
	  const urls = [..._urls];
	  for (const url of _urls) {
	    if (url.protocol === "file:") {
	      urls.push(
	        new URL("./", url),
	        // If url is directory
	        new URL(ufo.joinURL(url.pathname, "_index.js"), url),
	        // TODO: Remove in next major version?
	        new URL("node_modules", url)
	      );
	    }
	  }
	  let resolved;
	  for (const url of urls) {
	    resolved = _tryModuleResolve(id, url, conditionsSet);
	    if (resolved) {
	      break;
	    }
	    for (const prefix of ["", "/index"]) {
	      for (const extension of options.extensions || DEFAULT_EXTENSIONS) {
	        resolved = _tryModuleResolve(
	          id + prefix + extension,
	          url,
	          conditionsSet
	        );
	        if (resolved) {
	          break;
	        }
	      }
	      if (resolved) {
	        break;
	      }
	    }
	    if (resolved) {
	      break;
	    }
	  }
	  if (!resolved) {
	    const error = new Error(
	      `Cannot find module ${id} imported from ${urls.join(", ")}`
	    );
	    error.code = "ERR_MODULE_NOT_FOUND";
	    throw error;
	  }
	  return pathToFileURL(resolved);
	}
	function resolveSync(id, options) {
	  return _resolve(id, options);
	}
	function resolve(id, options) {
	  try {
	    return Promise.resolve(resolveSync(id, options));
	  } catch (error) {
	    return Promise.reject(error);
	  }
	}
	function resolvePathSync(id, options) {
	  return fileURLToPath(resolveSync(id, options));
	}
	function resolvePath(id, options) {
	  try {
	    return Promise.resolve(resolvePathSync(id, options));
	  } catch (error) {
	    return Promise.reject(error);
	  }
	}
	function createResolve(defaults) {
	  return (id, url) => {
	    return resolve(id, { url, ...defaults });
	  };
	}
	const NODE_MODULES_RE = /^(.+\/node_modules\/)([^/@]+|@[^/]+\/[^/]+)(\/?.*?)?$/;
	function parseNodeModulePath(path) {
	  if (!path) {
	    return {};
	  }
	  path = pathe.normalize(fileURLToPath(path));
	  const match = NODE_MODULES_RE.exec(path);
	  if (!match) {
	    return {};
	  }
	  const [, dir, name, subpath] = match;
	  return {
	    dir,
	    name,
	    subpath: subpath ? `.${subpath}` : void 0
	  };
	}
	async function lookupNodeModuleSubpath(path) {
	  path = pathe.normalize(fileURLToPath(path));
	  const { name, subpath } = parseNodeModulePath(path);
	  if (!name || !subpath) {
	    return subpath;
	  }
	  const { exports } = await pkgTypes.readPackageJSON(path).catch(() => {
	  }) || {};
	  if (exports) {
	    const resolvedSubpath = _findSubpath(subpath, exports);
	    if (resolvedSubpath) {
	      return resolvedSubpath;
	    }
	  }
	  return subpath;
	}
	function _findSubpath(subpath, exports) {
	  if (typeof exports === "string") {
	    exports = { ".": exports };
	  }
	  if (!subpath.startsWith(".")) {
	    subpath = subpath.startsWith("/") ? `.${subpath}` : `./${subpath}`;
	  }
	  if (subpath in (exports || {})) {
	    return subpath;
	  }
	  return _flattenExports(exports).find((p) => p.fsPath === subpath)?.subpath;
	}
	function _flattenExports(exports = {}, parentSubpath = "./") {
	  return Object.entries(exports).flatMap(([key, value]) => {
	    const [subpath, condition] = key.startsWith(".") ? [key.slice(1), void 0] : ["", key];
	    const _subPath = ufo.joinURL(parentSubpath, subpath);
	    if (typeof value === "string") {
	      return [{ subpath: _subPath, fsPath: value, condition }];
	    } else {
	      return _flattenExports(value, _subPath);
	    }
	  });
	}

	const ESM_STATIC_IMPORT_RE = /(?<=\s|^|;|\})import\s*([\s"']*(?<imports>[\p{L}\p{M}\w\t\n\r $*,/{}@.]+)from\s*)?["']\s*(?<specifier>(?<="\s*)[^"]*[^\s"](?=\s*")|(?<='\s*)[^']*[^\s'](?=\s*'))\s*["'][\s;]*/gmu;
	const DYNAMIC_IMPORT_RE = /import\s*\((?<expression>(?:[^()]+|\((?:[^()]+|\([^()]*\))*\))*)\)/gm;
	const IMPORT_NAMED_TYPE_RE = /(?<=\s|^|;|})import\s*type\s+([\s"']*(?<imports>[\w\t\n\r $*,/{}]+)from\s*)?["']\s*(?<specifier>(?<="\s*)[^"]*[^\s"](?=\s*")|(?<='\s*)[^']*[^\s'](?=\s*'))\s*["'][\s;]*/gm;
	const EXPORT_DECAL_RE = /\bexport\s+(?<declaration>(async function\s*\*?|function\s*\*?|let|const enum|const|enum|var|class))\s+\*?(?<name>[\w$]+)(?<extraNames>.*,\s*[\w$]+)*/g;
	const EXPORT_DECAL_TYPE_RE = /\bexport\s+(?<declaration>(interface|type|declare (async function|function|let|const enum|const|enum|var|class)))\s+(?<name>[\w$]+)/g;
	const EXPORT_NAMED_RE = /\bexport\s+{(?<exports>[^}]+?)[\s,]*}(\s*from\s*["']\s*(?<specifier>(?<="\s*)[^"]*[^\s"](?=\s*")|(?<='\s*)[^']*[^\s'](?=\s*'))\s*["'][^\n;]*)?/g;
	const EXPORT_NAMED_TYPE_RE = /\bexport\s+type\s+{(?<exports>[^}]+?)[\s,]*}(\s*from\s*["']\s*(?<specifier>(?<="\s*)[^"]*[^\s"](?=\s*")|(?<='\s*)[^']*[^\s'](?=\s*'))\s*["'][^\n;]*)?/g;
	const EXPORT_NAMED_DESTRUCT = /\bexport\s+(let|var|const)\s+(?:{(?<exports1>[^}]+?)[\s,]*}|\[(?<exports2>[^\]]+?)[\s,]*])\s+=/gm;
	const EXPORT_STAR_RE = /\bexport\s*(\*)(\s*as\s+(?<name>[\w$]+)\s+)?\s*(\s*from\s*["']\s*(?<specifier>(?<="\s*)[^"]*[^\s"](?=\s*")|(?<='\s*)[^']*[^\s'](?=\s*'))\s*["'][^\n;]*)?/g;
	const EXPORT_DEFAULT_RE = /\bexport\s+default\s+(async function|function|class|true|false|\W|\d)|\bexport\s+default\s+(?<defaultName>.*)/g;
	const TYPE_RE = /^\s*?type\s/;
	function findStaticImports(code) {
	  return _filterStatement(
	    _tryGetLocations(code, "import"),
	    matchAll(ESM_STATIC_IMPORT_RE, code, { type: "static" })
	  );
	}
	function findDynamicImports(code) {
	  return _filterStatement(
	    _tryGetLocations(code, "import"),
	    matchAll(DYNAMIC_IMPORT_RE, code, { type: "dynamic" })
	  );
	}
	function findTypeImports(code) {
	  return [
	    ...matchAll(IMPORT_NAMED_TYPE_RE, code, { type: "type" }),
	    ...matchAll(ESM_STATIC_IMPORT_RE, code, { type: "static" }).filter(
	      (match) => /[^A-Za-z]type\s/.test(match.imports)
	    )
	  ];
	}
	function parseStaticImport(matched) {
	  const cleanedImports = clearImports(matched.imports);
	  const namedImports = {};
	  const _matches = cleanedImports.match(/{([^}]*)}/)?.[1]?.split(",") || [];
	  for (const namedImport of _matches) {
	    const _match = namedImport.match(/^\s*(\S*) as (\S*)\s*$/);
	    const source = _match?.[1] || namedImport.trim();
	    const importName = _match?.[2] || source;
	    if (source && !TYPE_RE.test(source)) {
	      namedImports[source] = importName;
	    }
	  }
	  const { namespacedImport, defaultImport } = getImportNames(cleanedImports);
	  return {
	    ...matched,
	    defaultImport,
	    namespacedImport,
	    namedImports
	  };
	}
	function parseTypeImport(matched) {
	  if (matched.type === "type") {
	    return parseStaticImport(matched);
	  }
	  const cleanedImports = clearImports(matched.imports);
	  const namedImports = {};
	  const _matches = cleanedImports.match(/{([^}]*)}/)?.[1]?.split(",") || [];
	  for (const namedImport of _matches) {
	    const _match = /\s+as\s+/.test(namedImport) ? namedImport.match(/^\s*type\s+(\S*) as (\S*)\s*$/) : namedImport.match(/^\s*type\s+(\S*)\s*$/);
	    const source = _match?.[1] || namedImport.trim();
	    const importName = _match?.[2] || source;
	    if (source && TYPE_RE.test(namedImport)) {
	      namedImports[source] = importName;
	    }
	  }
	  const { namespacedImport, defaultImport } = getImportNames(cleanedImports);
	  return {
	    ...matched,
	    defaultImport,
	    namespacedImport,
	    namedImports
	  };
	}
	function findExports(code) {
	  const declaredExports = matchAll(EXPORT_DECAL_RE, code, {
	    type: "declaration"
	  });
	  for (const declaredExport of declaredExports) {
	    const extraNamesStr = declaredExport.extraNames;
	    if (extraNamesStr) {
	      const extraNames = matchAll(/,\s*(?<name>\w+)/g, extraNamesStr, {}).map(
	        (m) => m.name
	      );
	      declaredExport.names = [declaredExport.name, ...extraNames];
	    }
	    delete declaredExport.extraNames;
	  }
	  const namedExports = normalizeNamedExports(
	    matchAll(EXPORT_NAMED_RE, code, {
	      type: "named"
	    })
	  );
	  const destructuredExports = matchAll(
	    EXPORT_NAMED_DESTRUCT,
	    code,
	    { type: "named" }
	  );
	  for (const namedExport of destructuredExports) {
	    namedExport.exports = namedExport.exports1 || namedExport.exports2;
	    namedExport.names = namedExport.exports.replace(/^\r?\n?/, "").split(/\s*,\s*/g).filter((name) => !TYPE_RE.test(name)).map(
	      (name) => name.replace(/^.*?\s*:\s*/, "").replace(/\s*=\s*.*$/, "").trim()
	    );
	  }
	  const defaultExport = matchAll(EXPORT_DEFAULT_RE, code, {
	    type: "default",
	    name: "default"
	  });
	  const starExports = matchAll(EXPORT_STAR_RE, code, {
	    type: "star"
	  });
	  const exports = normalizeExports([
	    ...declaredExports,
	    ...namedExports,
	    ...destructuredExports,
	    ...defaultExport,
	    ...starExports
	  ]);
	  if (exports.length === 0) {
	    return [];
	  }
	  const exportLocations = _tryGetLocations(code, "export");
	  if (exportLocations && exportLocations.length === 0) {
	    return [];
	  }
	  return (
	    // Filter false positive export matches
	    _filterStatement(exportLocations, exports).filter((exp, index, exports2) => {
	      const nextExport = exports2[index + 1];
	      return !nextExport || exp.type !== nextExport.type || !exp.name || exp.name !== nextExport.name;
	    })
	  );
	}
	function findTypeExports(code) {
	  const declaredExports = matchAll(
	    EXPORT_DECAL_TYPE_RE,
	    code,
	    { type: "declaration" }
	  );
	  const namedExports = normalizeNamedExports(
	    matchAll(EXPORT_NAMED_TYPE_RE, code, {
	      type: "named"
	    })
	  );
	  const exports = normalizeExports([
	    ...declaredExports,
	    ...namedExports
	  ]);
	  if (exports.length === 0) {
	    return [];
	  }
	  const exportLocations = _tryGetLocations(code, "export");
	  if (exportLocations && exportLocations.length === 0) {
	    return [];
	  }
	  return (
	    // Filter false positive export matches
	    _filterStatement(exportLocations, exports).filter((exp, index, exports2) => {
	      const nextExport = exports2[index + 1];
	      return !nextExport || exp.type !== nextExport.type || !exp.name || exp.name !== nextExport.name;
	    })
	  );
	}
	function normalizeExports(exports) {
	  for (const exp of exports) {
	    if (!exp.name && exp.names && exp.names.length === 1) {
	      exp.name = exp.names[0];
	    }
	    if (exp.name === "default" && exp.type !== "default") {
	      exp._type = exp.type;
	      exp.type = "default";
	    }
	    if (!exp.names && exp.name) {
	      exp.names = [exp.name];
	    }
	    if (exp.type === "declaration" && exp.declaration) {
	      exp.declarationType = exp.declaration.replace(
	        /^declare\s*/,
	        ""
	      );
	    }
	  }
	  return exports;
	}
	function normalizeNamedExports(namedExports) {
	  for (const namedExport of namedExports) {
	    namedExport.names = namedExport.exports.replace(/^\r?\n?/, "").split(/\s*,\s*/g).filter((name) => !TYPE_RE.test(name)).map((name) => name.replace(/^.*?\sas\s/, "").trim());
	  }
	  return namedExports;
	}
	function findExportNames(code) {
	  return findExports(code).flatMap((exp) => exp.names).filter(Boolean);
	}
	async function resolveModuleExportNames(id, options) {
	  const url = await resolvePath(id, options);
	  const code = await loadURL(url);
	  const exports = findExports(code);
	  const exportNames = new Set(
	    exports.flatMap((exp) => exp.names).filter(Boolean)
	  );
	  for (const exp of exports) {
	    if (exp.type !== "star" || !exp.specifier) {
	      continue;
	    }
	    const subExports = await resolveModuleExportNames(exp.specifier, {
	      ...options,
	      url
	    });
	    for (const subExport of subExports) {
	      exportNames.add(subExport);
	    }
	  }
	  return [...exportNames];
	}
	function _filterStatement(locations, statements) {
	  return statements.filter((exp) => {
	    return !locations || locations.some((location) => {
	      return exp.start <= location.start && exp.end >= location.end;
	    });
	  });
	}
	function _tryGetLocations(code, label) {
	  try {
	    return _getLocations(code, label);
	  } catch {
	  }
	}
	function _getLocations(code, label) {
	  const tokens = acorn.tokenizer(code, {
	    ecmaVersion: "latest",
	    sourceType: "module",
	    allowHashBang: true,
	    allowAwaitOutsideFunction: true,
	    allowImportExportEverywhere: true
	  });
	  const locations = [];
	  for (const token of tokens) {
	    if (token.type.label === label) {
	      locations.push({
	        start: token.start,
	        end: token.end
	      });
	    }
	  }
	  return locations;
	}

	function createCommonJS(url) {
	  const __filename = fileURLToPath(url);
	  const __dirname = path.dirname(__filename);
	  let _nativeRequire;
	  const getNativeRequire = () => {
	    if (!_nativeRequire) {
	      _nativeRequire = node_module.createRequire(url);
	    }
	    return _nativeRequire;
	  };
	  function require(id) {
	    return getNativeRequire()(id);
	  }
	  require.resolve = function requireResolve(id, options) {
	    return getNativeRequire().resolve(id, options);
	  };
	  return {
	    __filename,
	    __dirname,
	    require
	  };
	}
	function interopDefault(sourceModule, opts = {}) {
	  if (!isObject(sourceModule) || !("default" in sourceModule)) {
	    return sourceModule;
	  }
	  const defaultValue = sourceModule.default;
	  if (defaultValue === void 0 || defaultValue === null) {
	    return sourceModule;
	  }
	  if (typeof defaultValue !== "object") {
	    return opts.preferNamespace ? sourceModule : defaultValue;
	  }
	  for (const key in sourceModule) {
	    if (key === "default") {
	      try {
	        if (!(key in defaultValue)) {
	          Object.defineProperty(defaultValue, key, {
	            enumerable: false,
	            configurable: false,
	            get() {
	              return defaultValue;
	            }
	          });
	        }
	      } catch {
	      }
	    } else {
	      try {
	        if (!(key in defaultValue)) {
	          Object.defineProperty(defaultValue, key, {
	            enumerable: true,
	            configurable: true,
	            get() {
	              return sourceModule[key];
	            }
	          });
	        }
	      } catch {
	      }
	    }
	  }
	  return defaultValue;
	}

	const EVAL_ESM_IMPORT_RE = /(?<=import .* from ["'])([^"']+)(?=["'])|(?<=export .* from ["'])([^"']+)(?=["'])|(?<=import\s*["'])([^"']+)(?=["'])|(?<=import\s*\(["'])([^"']+)(?=["']\))/g;
	async function loadModule(id, options = {}) {
	  const url = await resolve(id, options);
	  const code = await loadURL(url);
	  return evalModule(code, { ...options, url });
	}
	async function evalModule(code, options = {}) {
	  const transformed = await transformModule(code, options);
	  const dataURL = toDataURL(transformed);
	  return import(dataURL).catch((error) => {
	    error.stack = error.stack.replace(
	      new RegExp(dataURL, "g"),
	      options.url || "_mlly_eval_"
	    );
	    throw error;
	  });
	}
	function transformModule(code, options = {}) {
	  if (options.url && options.url.endsWith(".json")) {
	    return Promise.resolve("export default " + code);
	  }
	  if (options.url) {
	    code = code.replace(/import\.meta\.url/g, `'${options.url}'`);
	  }
	  return Promise.resolve(code);
	}
	async function resolveImports(code, options) {
	  const imports = [...code.matchAll(EVAL_ESM_IMPORT_RE)].map((m) => m[0]);
	  if (imports.length === 0) {
	    return code;
	  }
	  const uniqueImports = [...new Set(imports)];
	  const resolved = /* @__PURE__ */ new Map();
	  await Promise.all(
	    uniqueImports.map(async (id) => {
	      let url = await resolve(id, options);
	      if (url.endsWith(".json")) {
	        const code2 = await loadURL(url);
	        url = toDataURL(await transformModule(code2, { url }));
	      }
	      resolved.set(id, url);
	    })
	  );
	  const re = new RegExp(
	    uniqueImports.map((index) => `(${index})`).join("|"),
	    "g"
	  );
	  return code.replace(re, (id) => resolved.get(id));
	}

	const ESM_RE = /([\s;]|^)(import[\s\w*,{}]*from|import\s*["'*{]|export\b\s*(?:[*{]|default|class|type|function|const|var|let|async function)|import\.meta\b)/m;
	const CJS_RE = /([\s;]|^)(module.exports\b|exports\.\w|require\s*\(|global\.\w)/m;
	const COMMENT_RE = /\/\*.+?\*\/|\/\/.*(?=[nr])/g;
	const BUILTIN_EXTENSIONS = /* @__PURE__ */ new Set([".mjs", ".cjs", ".node", ".wasm"]);
	function hasESMSyntax(code, opts = {}) {
	  if (opts.stripComments) {
	    code = code.replace(COMMENT_RE, "");
	  }
	  return ESM_RE.test(code);
	}
	function hasCJSSyntax(code, opts = {}) {
	  if (opts.stripComments) {
	    code = code.replace(COMMENT_RE, "");
	  }
	  return CJS_RE.test(code);
	}
	function detectSyntax(code, opts = {}) {
	  if (opts.stripComments) {
	    code = code.replace(COMMENT_RE, "");
	  }
	  const hasESM = hasESMSyntax(code, {});
	  const hasCJS = hasCJSSyntax(code, {});
	  return {
	    hasESM,
	    hasCJS,
	    isMixed: hasESM && hasCJS
	  };
	}
	const validNodeImportDefaults = {
	  allowedProtocols: ["node", "file", "data"]
	};
	async function isValidNodeImport(id, _options = {}) {
	  if (isNodeBuiltin(id)) {
	    return true;
	  }
	  const options = { ...validNodeImportDefaults, ..._options };
	  const proto = getProtocol(id);
	  if (proto && !options.allowedProtocols?.includes(proto)) {
	    return false;
	  }
	  if (proto === "data") {
	    return true;
	  }
	  const resolvedPath = await resolvePath(id, options);
	  const extension = pathe.extname(resolvedPath);
	  if (BUILTIN_EXTENSIONS.has(extension)) {
	    return true;
	  }
	  if (extension !== ".js") {
	    return false;
	  }
	  const package_ = await pkgTypes.readPackageJSON(resolvedPath).catch(() => {
	  });
	  if (package_?.type === "module") {
	    return true;
	  }
	  if (/\.(\w+-)?esm?(-\w+)?\.js$|\/(esm?)\//.test(resolvedPath)) {
	    return false;
	  }
	  const code = options.code || await fs.promises.readFile(resolvedPath, "utf8").catch(() => {
	  }) || "";
	  return !hasESMSyntax(code);
	}

	dist$d.DYNAMIC_IMPORT_RE = DYNAMIC_IMPORT_RE;
	dist$d.ESM_STATIC_IMPORT_RE = ESM_STATIC_IMPORT_RE;
	dist$d.EXPORT_DECAL_RE = EXPORT_DECAL_RE;
	dist$d.EXPORT_DECAL_TYPE_RE = EXPORT_DECAL_TYPE_RE;
	dist$d.createCommonJS = createCommonJS;
	dist$d.createResolve = createResolve;
	dist$d.detectSyntax = detectSyntax;
	dist$d.evalModule = evalModule;
	dist$d.fileURLToPath = fileURLToPath;
	dist$d.findDynamicImports = findDynamicImports;
	dist$d.findExportNames = findExportNames;
	dist$d.findExports = findExports;
	dist$d.findStaticImports = findStaticImports;
	dist$d.findTypeExports = findTypeExports;
	dist$d.findTypeImports = findTypeImports;
	dist$d.getProtocol = getProtocol;
	dist$d.hasCJSSyntax = hasCJSSyntax;
	dist$d.hasESMSyntax = hasESMSyntax;
	dist$d.interopDefault = interopDefault;
	dist$d.isNodeBuiltin = isNodeBuiltin;
	dist$d.isValidNodeImport = isValidNodeImport;
	dist$d.loadModule = loadModule;
	dist$d.loadURL = loadURL;
	dist$d.lookupNodeModuleSubpath = lookupNodeModuleSubpath;
	dist$d.normalizeid = normalizeid;
	dist$d.parseNodeModulePath = parseNodeModulePath;
	dist$d.parseStaticImport = parseStaticImport;
	dist$d.parseTypeImport = parseTypeImport;
	dist$d.pathToFileURL = pathToFileURL;
	dist$d.resolve = resolve;
	dist$d.resolveImports = resolveImports;
	dist$d.resolveModuleExportNames = resolveModuleExportNames;
	dist$d.resolvePath = resolvePath;
	dist$d.resolvePathSync = resolvePathSync;
	dist$d.resolveSync = resolveSync;
	dist$d.sanitizeFilePath = sanitizeFilePath;
	dist$d.sanitizeURIComponent = sanitizeURIComponent;
	dist$d.toDataURL = toDataURL;
	dist$d.transformModule = transformModule;
	return dist$d;
}

var hasRequiredDist$2;

function requireDist$2 () {
	if (hasRequiredDist$2) return dist$e;
	hasRequiredDist$2 = 1;

	const path = require$$9;
	const fs = require$$2$1;
	const fsp = require$$2$2;
	const process = require$$8;
	const mlly = requireDist$3();
	const node_url = require$$3$1;

	function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

	const path__default = /*#__PURE__*/_interopDefaultCompat(path);
	const fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
	const fsp__default = /*#__PURE__*/_interopDefaultCompat(fsp);
	const process__default = /*#__PURE__*/_interopDefaultCompat(process);

	/*
	How it works:
	`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.
	*/

	class Node {
		value;
		next;

		constructor(value) {
			this.value = value;
		}
	}

	class Queue {
		#head;
		#tail;
		#size;

		constructor() {
			this.clear();
		}

		enqueue(value) {
			const node = new Node(value);

			if (this.#head) {
				this.#tail.next = node;
				this.#tail = node;
			} else {
				this.#head = node;
				this.#tail = node;
			}

			this.#size++;
		}

		dequeue() {
			const current = this.#head;
			if (!current) {
				return;
			}

			this.#head = this.#head.next;
			this.#size--;
			return current.value;
		}

		clear() {
			this.#head = undefined;
			this.#tail = undefined;
			this.#size = 0;
		}

		get size() {
			return this.#size;
		}

		* [Symbol.iterator]() {
			let current = this.#head;

			while (current) {
				yield current.value;
				current = current.next;
			}
		}
	}

	function pLimit(concurrency) {
		if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
			throw new TypeError('Expected `concurrency` to be a number from 1 and up');
		}

		const queue = new Queue();
		let activeCount = 0;

		const next = () => {
			activeCount--;

			if (queue.size > 0) {
				queue.dequeue()();
			}
		};

		const run = async (fn, resolve, args) => {
			activeCount++;

			const result = (async () => fn(...args))();

			resolve(result);

			try {
				await result;
			} catch {}

			next();
		};

		const enqueue = (fn, resolve, args) => {
			queue.enqueue(run.bind(undefined, fn, resolve, args));

			(async () => {
				// This function needs to wait until the next microtask before comparing
				// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously
				// when the run function is dequeued and called. The comparison in the if-statement
				// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.
				await Promise.resolve();

				if (activeCount < concurrency && queue.size > 0) {
					queue.dequeue()();
				}
			})();
		};

		const generator = (fn, ...args) => new Promise(resolve => {
			enqueue(fn, resolve, args);
		});

		Object.defineProperties(generator, {
			activeCount: {
				get: () => activeCount,
			},
			pendingCount: {
				get: () => queue.size,
			},
			clearQueue: {
				value: () => {
					queue.clear();
				},
			},
		});

		return generator;
	}

	class EndError extends Error {
		constructor(value) {
			super();
			this.value = value;
		}
	}

	// The input can also be a promise, so we await it.
	const testElement = async (element, tester) => tester(await element);

	// The input can also be a promise, so we `Promise.all()` them both.
	const finder = async element => {
		const values = await Promise.all(element);
		if (values[1] === true) {
			throw new EndError(values[0]);
		}

		return false;
	};

	async function pLocate(
		iterable,
		tester,
		{
			concurrency = Number.POSITIVE_INFINITY,
			preserveOrder = true,
		} = {},
	) {
		const limit = pLimit(concurrency);

		// Start all the promises concurrently with optional limit.
		const items = [...iterable].map(element => [element, limit(testElement, element, tester)]);

		// Check the promises either serially or concurrently.
		const checkLimit = pLimit(preserveOrder ? 1 : Number.POSITIVE_INFINITY);

		try {
			await Promise.all(items.map(element => checkLimit(finder, element)));
		} catch (error) {
			if (error instanceof EndError) {
				return error.value;
			}

			throw error;
		}
	}

	const typeMappings = {
		directory: 'isDirectory',
		file: 'isFile',
	};

	function checkType(type) {
		if (Object.hasOwnProperty.call(typeMappings, type)) {
			return;
		}

		throw new Error(`Invalid type specified: ${type}`);
	}

	const matchType = (type, stat) => stat[typeMappings[type]]();

	const toPath$1 = urlOrPath => urlOrPath instanceof URL ? node_url.fileURLToPath(urlOrPath) : urlOrPath;

	async function locatePath(
		paths,
		{
			cwd = process__default.cwd(),
			type = 'file',
			allowSymlinks = true,
			concurrency,
			preserveOrder,
		} = {},
	) {
		checkType(type);
		cwd = toPath$1(cwd);

		const statFunction = allowSymlinks ? fs.promises.stat : fs.promises.lstat;

		return pLocate(paths, async path_ => {
			try {
				const stat = await statFunction(path__default.resolve(cwd, path_));
				return matchType(type, stat);
			} catch {
				return false;
			}
		}, {concurrency, preserveOrder});
	}

	const toPath = urlOrPath => urlOrPath instanceof URL ? node_url.fileURLToPath(urlOrPath) : urlOrPath;

	const findUpStop = Symbol('findUpStop');

	async function findUpMultiple(name, options = {}) {
		let directory = path__default.resolve(toPath(options.cwd) || '');
		const {root} = path__default.parse(directory);
		const stopAt = path__default.resolve(directory, options.stopAt || root);
		const limit = options.limit || Number.POSITIVE_INFINITY;
		const paths = [name].flat();

		const runMatcher = async locateOptions => {
			if (typeof name !== 'function') {
				return locatePath(paths, locateOptions);
			}

			const foundPath = await name(locateOptions.cwd);
			if (typeof foundPath === 'string') {
				return locatePath([foundPath], locateOptions);
			}

			return foundPath;
		};

		const matches = [];
		// eslint-disable-next-line no-constant-condition
		while (true) {
			// eslint-disable-next-line no-await-in-loop
			const foundPath = await runMatcher({...options, cwd: directory});

			if (foundPath === findUpStop) {
				break;
			}

			if (foundPath) {
				matches.push(path__default.resolve(directory, foundPath));
			}

			if (directory === stopAt || matches.length >= limit) {
				break;
			}

			directory = path__default.dirname(directory);
		}

		return matches;
	}

	async function findUp(name, options = {}) {
		const matches = await findUpMultiple(name, {...options, limit: 1});
		return matches[0];
	}

	function _resolve(path$1, options = {}) {
	  if (options.platform === "auto" || !options.platform)
	    options.platform = process__default.platform === "win32" ? "win32" : "posix";
	  const modulePath = mlly.resolvePathSync(path$1, {
	    url: options.paths
	  });
	  if (options.platform === "win32")
	    return path.win32.normalize(modulePath);
	  return modulePath;
	}
	function resolveModule(name, options = {}) {
	  try {
	    return _resolve(name, options);
	  } catch (e) {
	    return void 0;
	  }
	}
	async function importModule(path) {
	  const i = await import(path);
	  if (i)
	    return mlly.interopDefault(i);
	  return i;
	}
	function isPackageExists(name, options = {}) {
	  return !!resolvePackage(name, options);
	}
	function getPackageJsonPath(name, options = {}) {
	  const entry = resolvePackage(name, options);
	  if (!entry)
	    return;
	  return searchPackageJSON(entry);
	}
	async function getPackageInfo(name, options = {}) {
	  const packageJsonPath = getPackageJsonPath(name, options);
	  if (!packageJsonPath)
	    return;
	  const packageJson = JSON.parse(await fs__default.promises.readFile(packageJsonPath, "utf8"));
	  return {
	    name,
	    version: packageJson.version,
	    rootPath: path.dirname(packageJsonPath),
	    packageJsonPath,
	    packageJson
	  };
	}
	function getPackageInfoSync(name, options = {}) {
	  const packageJsonPath = getPackageJsonPath(name, options);
	  if (!packageJsonPath)
	    return;
	  const packageJson = JSON.parse(fs__default.readFileSync(packageJsonPath, "utf8"));
	  return {
	    name,
	    version: packageJson.version,
	    rootPath: path.dirname(packageJsonPath),
	    packageJsonPath,
	    packageJson
	  };
	}
	function resolvePackage(name, options = {}) {
	  try {
	    return _resolve(`${name}/package.json`, options);
	  } catch {
	  }
	  try {
	    return _resolve(name, options);
	  } catch (e) {
	    if (e.code !== "MODULE_NOT_FOUND" && e.code !== "ERR_MODULE_NOT_FOUND")
	      console.error(e);
	    return false;
	  }
	}
	function searchPackageJSON(dir) {
	  let packageJsonPath;
	  while (true) {
	    if (!dir)
	      return;
	    const newDir = path.dirname(dir);
	    if (newDir === dir)
	      return;
	    dir = newDir;
	    packageJsonPath = path.join(dir, "package.json");
	    if (fs__default.existsSync(packageJsonPath))
	      break;
	  }
	  return packageJsonPath;
	}
	async function loadPackageJSON(cwd = process__default.cwd()) {
	  const path = await findUp("package.json", { cwd });
	  if (!path || !fs__default.existsSync(path))
	    return null;
	  return JSON.parse(await fsp__default.readFile(path, "utf-8"));
	}
	async function isPackageListed(name, cwd) {
	  const pkg = await loadPackageJSON(cwd) || {};
	  return name in (pkg.dependencies || {}) || name in (pkg.devDependencies || {});
	}

	dist$e.getPackageInfo = getPackageInfo;
	dist$e.getPackageInfoSync = getPackageInfoSync;
	dist$e.importModule = importModule;
	dist$e.isPackageExists = isPackageExists;
	dist$e.isPackageListed = isPackageListed;
	dist$e.loadPackageJSON = loadPackageJSON;
	dist$e.resolveModule = resolveModule;
	return dist$e;
}

var installPkg = {};

var findUp = {exports: {}};

var locatePath = {exports: {}};

var yoctoQueue;
var hasRequiredYoctoQueue;

function requireYoctoQueue () {
	if (hasRequiredYoctoQueue) return yoctoQueue;
	hasRequiredYoctoQueue = 1;
	class Node {
		/// value;
		/// next;

		constructor(value) {
			this.value = value;

			// TODO: Remove this when targeting Node.js 12.
			this.next = undefined;
		}
	}

	class Queue {
		// TODO: Use private class fields when targeting Node.js 12.
		// #_head;
		// #_tail;
		// #_size;

		constructor() {
			this.clear();
		}

		enqueue(value) {
			const node = new Node(value);

			if (this._head) {
				this._tail.next = node;
				this._tail = node;
			} else {
				this._head = node;
				this._tail = node;
			}

			this._size++;
		}

		dequeue() {
			const current = this._head;
			if (!current) {
				return;
			}

			this._head = this._head.next;
			this._size--;
			return current.value;
		}

		clear() {
			this._head = undefined;
			this._tail = undefined;
			this._size = 0;
		}

		get size() {
			return this._size;
		}

		* [Symbol.iterator]() {
			let current = this._head;

			while (current) {
				yield current.value;
				current = current.next;
			}
		}
	}

	yoctoQueue = Queue;
	return yoctoQueue;
}

var pLimit_1;
var hasRequiredPLimit;

function requirePLimit () {
	if (hasRequiredPLimit) return pLimit_1;
	hasRequiredPLimit = 1;
	const Queue = requireYoctoQueue();

	const pLimit = concurrency => {
		if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
			throw new TypeError('Expected `concurrency` to be a number from 1 and up');
		}

		const queue = new Queue();
		let activeCount = 0;

		const next = () => {
			activeCount--;

			if (queue.size > 0) {
				queue.dequeue()();
			}
		};

		const run = async (fn, resolve, ...args) => {
			activeCount++;

			const result = (async () => fn(...args))();

			resolve(result);

			try {
				await result;
			} catch {}

			next();
		};

		const enqueue = (fn, resolve, ...args) => {
			queue.enqueue(run.bind(null, fn, resolve, ...args));

			(async () => {
				// This function needs to wait until the next microtask before comparing
				// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously
				// when the run function is dequeued and called. The comparison in the if-statement
				// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.
				await Promise.resolve();

				if (activeCount < concurrency && queue.size > 0) {
					queue.dequeue()();
				}
			})();
		};

		const generator = (fn, ...args) => new Promise(resolve => {
			enqueue(fn, resolve, ...args);
		});

		Object.defineProperties(generator, {
			activeCount: {
				get: () => activeCount
			},
			pendingCount: {
				get: () => queue.size
			},
			clearQueue: {
				value: () => {
					queue.clear();
				}
			}
		});

		return generator;
	};

	pLimit_1 = pLimit;
	return pLimit_1;
}

var pLocate_1;
var hasRequiredPLocate;

function requirePLocate () {
	if (hasRequiredPLocate) return pLocate_1;
	hasRequiredPLocate = 1;
	const pLimit = requirePLimit();

	class EndError extends Error {
		constructor(value) {
			super();
			this.value = value;
		}
	}

	// The input can also be a promise, so we await it
	const testElement = async (element, tester) => tester(await element);

	// The input can also be a promise, so we `Promise.all()` them both
	const finder = async element => {
		const values = await Promise.all(element);
		if (values[1] === true) {
			throw new EndError(values[0]);
		}

		return false;
	};

	const pLocate = async (iterable, tester, options) => {
		options = {
			concurrency: Infinity,
			preserveOrder: true,
			...options
		};

		const limit = pLimit(options.concurrency);

		// Start all the promises concurrently with optional limit
		const items = [...iterable].map(element => [element, limit(testElement, element, tester)]);

		// Check the promises either serially or concurrently
		const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);

		try {
			await Promise.all(items.map(element => checkLimit(finder, element)));
		} catch (error) {
			if (error instanceof EndError) {
				return error.value;
			}

			throw error;
		}
	};

	pLocate_1 = pLocate;
	return pLocate_1;
}

var hasRequiredLocatePath;

function requireLocatePath () {
	if (hasRequiredLocatePath) return locatePath.exports;
	hasRequiredLocatePath = 1;
	const path = require$$0$4;
	const fs = require$$0$5;
	const {promisify} = require$$1$2;
	const pLocate = requirePLocate();

	const fsStat = promisify(fs.stat);
	const fsLStat = promisify(fs.lstat);

	const typeMappings = {
		directory: 'isDirectory',
		file: 'isFile'
	};

	function checkType({type}) {
		if (type in typeMappings) {
			return;
		}

		throw new Error(`Invalid type specified: ${type}`);
	}

	const matchType = (type, stat) => type === undefined || stat[typeMappings[type]]();

	locatePath.exports = async (paths, options) => {
		options = {
			cwd: process.cwd(),
			type: 'file',
			allowSymlinks: true,
			...options
		};

		checkType(options);

		const statFn = options.allowSymlinks ? fsStat : fsLStat;

		return pLocate(paths, async path_ => {
			try {
				const stat = await statFn(path.resolve(options.cwd, path_));
				return matchType(options.type, stat);
			} catch {
				return false;
			}
		}, options);
	};

	locatePath.exports.sync = (paths, options) => {
		options = {
			cwd: process.cwd(),
			allowSymlinks: true,
			type: 'file',
			...options
		};

		checkType(options);

		const statFn = options.allowSymlinks ? fs.statSync : fs.lstatSync;

		for (const path_ of paths) {
			try {
				const stat = statFn(path.resolve(options.cwd, path_));

				if (matchType(options.type, stat)) {
					return path_;
				}
			} catch {}
		}
	};
	return locatePath.exports;
}

var pathExists = {exports: {}};

var hasRequiredPathExists;

function requirePathExists () {
	if (hasRequiredPathExists) return pathExists.exports;
	hasRequiredPathExists = 1;
	const fs = require$$0$5;
	const {promisify} = require$$1$2;

	const pAccess = promisify(fs.access);

	pathExists.exports = async path => {
		try {
			await pAccess(path);
			return true;
		} catch (_) {
			return false;
		}
	};

	pathExists.exports.sync = path => {
		try {
			fs.accessSync(path);
			return true;
		} catch (_) {
			return false;
		}
	};
	return pathExists.exports;
}

var hasRequiredFindUp;

function requireFindUp () {
	if (hasRequiredFindUp) return findUp.exports;
	hasRequiredFindUp = 1;
	(function (module) {
		const path = require$$0$4;
		const locatePath = requireLocatePath();
		const pathExists = requirePathExists();

		const stop = Symbol('findUp.stop');

		module.exports = async (name, options = {}) => {
			let directory = path.resolve(options.cwd || '');
			const {root} = path.parse(directory);
			const paths = [].concat(name);

			const runMatcher = async locateOptions => {
				if (typeof name !== 'function') {
					return locatePath(paths, locateOptions);
				}

				const foundPath = await name(locateOptions.cwd);
				if (typeof foundPath === 'string') {
					return locatePath([foundPath], locateOptions);
				}

				return foundPath;
			};

			// eslint-disable-next-line no-constant-condition
			while (true) {
				// eslint-disable-next-line no-await-in-loop
				const foundPath = await runMatcher({...options, cwd: directory});

				if (foundPath === stop) {
					return;
				}

				if (foundPath) {
					return path.resolve(directory, foundPath);
				}

				if (directory === root) {
					return;
				}

				directory = path.dirname(directory);
			}
		};

		module.exports.sync = (name, options = {}) => {
			let directory = path.resolve(options.cwd || '');
			const {root} = path.parse(directory);
			const paths = [].concat(name);

			const runMatcher = locateOptions => {
				if (typeof name !== 'function') {
					return locatePath.sync(paths, locateOptions);
				}

				const foundPath = name(locateOptions.cwd);
				if (typeof foundPath === 'string') {
					return locatePath.sync([foundPath], locateOptions);
				}

				return foundPath;
			};

			// eslint-disable-next-line no-constant-condition
			while (true) {
				const foundPath = runMatcher({...options, cwd: directory});

				if (foundPath === stop) {
					return;
				}

				if (foundPath) {
					return path.resolve(directory, foundPath);
				}

				if (directory === root) {
					return;
				}

				directory = path.dirname(directory);
			}
		};

		module.exports.exists = pathExists;

		module.exports.sync.exists = pathExists.sync;

		module.exports.stop = stop; 
	} (findUp));
	return findUp.exports;
}

var execa = {exports: {}};

var crossSpawn = {exports: {}};

var windows;
var hasRequiredWindows;

function requireWindows () {
	if (hasRequiredWindows) return windows;
	hasRequiredWindows = 1;
	windows = isexe;
	isexe.sync = sync;

	var fs = require$$0$5;

	function checkPathExt (path, options) {
	  var pathext = options.pathExt !== undefined ?
	    options.pathExt : process.env.PATHEXT;

	  if (!pathext) {
	    return true
	  }

	  pathext = pathext.split(';');
	  if (pathext.indexOf('') !== -1) {
	    return true
	  }
	  for (var i = 0; i < pathext.length; i++) {
	    var p = pathext[i].toLowerCase();
	    if (p && path.substr(-p.length).toLowerCase() === p) {
	      return true
	    }
	  }
	  return false
	}

	function checkStat (stat, path, options) {
	  if (!stat.isSymbolicLink() && !stat.isFile()) {
	    return false
	  }
	  return checkPathExt(path, options)
	}

	function isexe (path, options, cb) {
	  fs.stat(path, function (er, stat) {
	    cb(er, er ? false : checkStat(stat, path, options));
	  });
	}

	function sync (path, options) {
	  return checkStat(fs.statSync(path), path, options)
	}
	return windows;
}

var mode;
var hasRequiredMode;

function requireMode () {
	if (hasRequiredMode) return mode;
	hasRequiredMode = 1;
	mode = isexe;
	isexe.sync = sync;

	var fs = require$$0$5;

	function isexe (path, options, cb) {
	  fs.stat(path, function (er, stat) {
	    cb(er, er ? false : checkStat(stat, options));
	  });
	}

	function sync (path, options) {
	  return checkStat(fs.statSync(path), options)
	}

	function checkStat (stat, options) {
	  return stat.isFile() && checkMode(stat, options)
	}

	function checkMode (stat, options) {
	  var mod = stat.mode;
	  var uid = stat.uid;
	  var gid = stat.gid;

	  var myUid = options.uid !== undefined ?
	    options.uid : process.getuid && process.getuid();
	  var myGid = options.gid !== undefined ?
	    options.gid : process.getgid && process.getgid();

	  var u = parseInt('100', 8);
	  var g = parseInt('010', 8);
	  var o = parseInt('001', 8);
	  var ug = u | g;

	  var ret = (mod & o) ||
	    (mod & g) && gid === myGid ||
	    (mod & u) && uid === myUid ||
	    (mod & ug) && myUid === 0;

	  return ret
	}
	return mode;
}

var isexe_1;
var hasRequiredIsexe;

function requireIsexe () {
	if (hasRequiredIsexe) return isexe_1;
	hasRequiredIsexe = 1;
	var core;
	if (process.platform === 'win32' || commonjsGlobal.TESTING_WINDOWS) {
	  core = requireWindows();
	} else {
	  core = requireMode();
	}

	isexe_1 = isexe;
	isexe.sync = sync;

	function isexe (path, options, cb) {
	  if (typeof options === 'function') {
	    cb = options;
	    options = {};
	  }

	  if (!cb) {
	    if (typeof Promise !== 'function') {
	      throw new TypeError('callback not provided')
	    }

	    return new Promise(function (resolve, reject) {
	      isexe(path, options || {}, function (er, is) {
	        if (er) {
	          reject(er);
	        } else {
	          resolve(is);
	        }
	      });
	    })
	  }

	  core(path, options || {}, function (er, is) {
	    // ignore EACCES because that just means we aren't allowed to run it
	    if (er) {
	      if (er.code === 'EACCES' || options && options.ignoreErrors) {
	        er = null;
	        is = false;
	      }
	    }
	    cb(er, is);
	  });
	}

	function sync (path, options) {
	  // my kingdom for a filtered catch
	  try {
	    return core.sync(path, options || {})
	  } catch (er) {
	    if (options && options.ignoreErrors || er.code === 'EACCES') {
	      return false
	    } else {
	      throw er
	    }
	  }
	}
	return isexe_1;
}

var which_1;
var hasRequiredWhich;

function requireWhich () {
	if (hasRequiredWhich) return which_1;
	hasRequiredWhich = 1;
	const isWindows = process.platform === 'win32' ||
	    process.env.OSTYPE === 'cygwin' ||
	    process.env.OSTYPE === 'msys';

	const path = require$$0$4;
	const COLON = isWindows ? ';' : ':';
	const isexe = requireIsexe();

	const getNotFoundError = (cmd) =>
	  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' });

	const getPathInfo = (cmd, opt) => {
	  const colon = opt.colon || COLON;

	  // If it has a slash, then we don't bother searching the pathenv.
	  // just check the file itself, and that's it.
	  const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? ['']
	    : (
	      [
	        // windows always checks the cwd first
	        ...(isWindows ? [process.cwd()] : []),
	        ...(opt.path || process.env.PATH ||
	          /* istanbul ignore next: very unusual */ '').split(colon),
	      ]
	    );
	  const pathExtExe = isWindows
	    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'
	    : '';
	  const pathExt = isWindows ? pathExtExe.split(colon) : [''];

	  if (isWindows) {
	    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')
	      pathExt.unshift('');
	  }

	  return {
	    pathEnv,
	    pathExt,
	    pathExtExe,
	  }
	};

	const which = (cmd, opt, cb) => {
	  if (typeof opt === 'function') {
	    cb = opt;
	    opt = {};
	  }
	  if (!opt)
	    opt = {};

	  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
	  const found = [];

	  const step = i => new Promise((resolve, reject) => {
	    if (i === pathEnv.length)
	      return opt.all && found.length ? resolve(found)
	        : reject(getNotFoundError(cmd))

	    const ppRaw = pathEnv[i];
	    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;

	    const pCmd = path.join(pathPart, cmd);
	    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
	      : pCmd;

	    resolve(subStep(p, i, 0));
	  });

	  const subStep = (p, i, ii) => new Promise((resolve, reject) => {
	    if (ii === pathExt.length)
	      return resolve(step(i + 1))
	    const ext = pathExt[ii];
	    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
	      if (!er && is) {
	        if (opt.all)
	          found.push(p + ext);
	        else
	          return resolve(p + ext)
	      }
	      return resolve(subStep(p, i, ii + 1))
	    });
	  });

	  return cb ? step(0).then(res => cb(null, res), cb) : step(0)
	};

	const whichSync = (cmd, opt) => {
	  opt = opt || {};

	  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
	  const found = [];

	  for (let i = 0; i < pathEnv.length; i ++) {
	    const ppRaw = pathEnv[i];
	    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;

	    const pCmd = path.join(pathPart, cmd);
	    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
	      : pCmd;

	    for (let j = 0; j < pathExt.length; j ++) {
	      const cur = p + pathExt[j];
	      try {
	        const is = isexe.sync(cur, { pathExt: pathExtExe });
	        if (is) {
	          if (opt.all)
	            found.push(cur);
	          else
	            return cur
	        }
	      } catch (ex) {}
	    }
	  }

	  if (opt.all && found.length)
	    return found

	  if (opt.nothrow)
	    return null

	  throw getNotFoundError(cmd)
	};

	which_1 = which;
	which.sync = whichSync;
	return which_1;
}

var pathKey = {exports: {}};

var hasRequiredPathKey;

function requirePathKey () {
	if (hasRequiredPathKey) return pathKey.exports;
	hasRequiredPathKey = 1;

	const pathKey$1 = (options = {}) => {
		const environment = options.env || process.env;
		const platform = options.platform || process.platform;

		if (platform !== 'win32') {
			return 'PATH';
		}

		return Object.keys(environment).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';
	};

	pathKey.exports = pathKey$1;
	// TODO: Remove this for the next major release
	pathKey.exports.default = pathKey$1;
	return pathKey.exports;
}

var resolveCommand_1;
var hasRequiredResolveCommand;

function requireResolveCommand () {
	if (hasRequiredResolveCommand) return resolveCommand_1;
	hasRequiredResolveCommand = 1;

	const path = require$$0$4;
	const which = requireWhich();
	const getPathKey = requirePathKey();

	function resolveCommandAttempt(parsed, withoutPathExt) {
	    const env = parsed.options.env || process.env;
	    const cwd = process.cwd();
	    const hasCustomCwd = parsed.options.cwd != null;
	    // Worker threads do not have process.chdir()
	    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;

	    // If a custom `cwd` was specified, we need to change the process cwd
	    // because `which` will do stat calls but does not support a custom cwd
	    if (shouldSwitchCwd) {
	        try {
	            process.chdir(parsed.options.cwd);
	        } catch (err) {
	            /* Empty */
	        }
	    }

	    let resolved;

	    try {
	        resolved = which.sync(parsed.command, {
	            path: env[getPathKey({ env })],
	            pathExt: withoutPathExt ? path.delimiter : undefined,
	        });
	    } catch (e) {
	        /* Empty */
	    } finally {
	        if (shouldSwitchCwd) {
	            process.chdir(cwd);
	        }
	    }

	    // If we successfully resolved, ensure that an absolute path is returned
	    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it
	    if (resolved) {
	        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);
	    }

	    return resolved;
	}

	function resolveCommand(parsed) {
	    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
	}

	resolveCommand_1 = resolveCommand;
	return resolveCommand_1;
}

var _escape = {};

var hasRequired_escape;

function require_escape () {
	if (hasRequired_escape) return _escape;
	hasRequired_escape = 1;

	// See http://www.robvanderwoude.com/escapechars.php
	const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;

	function escapeCommand(arg) {
	    // Escape meta chars
	    arg = arg.replace(metaCharsRegExp, '^$1');

	    return arg;
	}

	function escapeArgument(arg, doubleEscapeMetaChars) {
	    // Convert to string
	    arg = `${arg}`;

	    // Algorithm below is based on https://qntm.org/cmd

	    // Sequence of backslashes followed by a double quote:
	    // double up all the backslashes and escape the double quote
	    arg = arg.replace(/(\\*)"/g, '$1$1\\"');

	    // Sequence of backslashes followed by the end of the string
	    // (which will become a double quote later):
	    // double up all the backslashes
	    arg = arg.replace(/(\\*)$/, '$1$1');

	    // All other backslashes occur literally

	    // Quote the whole thing:
	    arg = `"${arg}"`;

	    // Escape meta chars
	    arg = arg.replace(metaCharsRegExp, '^$1');

	    // Double escape meta chars if necessary
	    if (doubleEscapeMetaChars) {
	        arg = arg.replace(metaCharsRegExp, '^$1');
	    }

	    return arg;
	}

	_escape.command = escapeCommand;
	_escape.argument = escapeArgument;
	return _escape;
}

var shebangRegex;
var hasRequiredShebangRegex;

function requireShebangRegex () {
	if (hasRequiredShebangRegex) return shebangRegex;
	hasRequiredShebangRegex = 1;
	shebangRegex = /^#!(.*)/;
	return shebangRegex;
}

var shebangCommand;
var hasRequiredShebangCommand;

function requireShebangCommand () {
	if (hasRequiredShebangCommand) return shebangCommand;
	hasRequiredShebangCommand = 1;
	const shebangRegex = requireShebangRegex();

	shebangCommand = (string = '') => {
		const match = string.match(shebangRegex);

		if (!match) {
			return null;
		}

		const [path, argument] = match[0].replace(/#! ?/, '').split(' ');
		const binary = path.split('/').pop();

		if (binary === 'env') {
			return argument;
		}

		return argument ? `${binary} ${argument}` : binary;
	};
	return shebangCommand;
}

var readShebang_1;
var hasRequiredReadShebang;

function requireReadShebang () {
	if (hasRequiredReadShebang) return readShebang_1;
	hasRequiredReadShebang = 1;

	const fs = require$$0$5;
	const shebangCommand = requireShebangCommand();

	function readShebang(command) {
	    // Read the first 150 bytes from the file
	    const size = 150;
	    const buffer = Buffer.alloc(size);

	    let fd;

	    try {
	        fd = fs.openSync(command, 'r');
	        fs.readSync(fd, buffer, 0, size, 0);
	        fs.closeSync(fd);
	    } catch (e) { /* Empty */ }

	    // Attempt to extract shebang (null is returned if not a shebang)
	    return shebangCommand(buffer.toString());
	}

	readShebang_1 = readShebang;
	return readShebang_1;
}

var parse_1;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse_1;
	hasRequiredParse = 1;

	const path = require$$0$4;
	const resolveCommand = requireResolveCommand();
	const escape = require_escape();
	const readShebang = requireReadShebang();

	const isWin = process.platform === 'win32';
	const isExecutableRegExp = /\.(?:com|exe)$/i;
	const isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;

	function detectShebang(parsed) {
	    parsed.file = resolveCommand(parsed);

	    const shebang = parsed.file && readShebang(parsed.file);

	    if (shebang) {
	        parsed.args.unshift(parsed.file);
	        parsed.command = shebang;

	        return resolveCommand(parsed);
	    }

	    return parsed.file;
	}

	function parseNonShell(parsed) {
	    if (!isWin) {
	        return parsed;
	    }

	    // Detect & add support for shebangs
	    const commandFile = detectShebang(parsed);

	    // We don't need a shell if the command filename is an executable
	    const needsShell = !isExecutableRegExp.test(commandFile);

	    // If a shell is required, use cmd.exe and take care of escaping everything correctly
	    // Note that `forceShell` is an hidden option used only in tests
	    if (parsed.options.forceShell || needsShell) {
	        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`
	        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument
	        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,
	        // we need to double escape them
	        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);

	        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\bar)
	        // This is necessary otherwise it will always fail with ENOENT in those cases
	        parsed.command = path.normalize(parsed.command);

	        // Escape command & arguments
	        parsed.command = escape.command(parsed.command);
	        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));

	        const shellCommand = [parsed.command].concat(parsed.args).join(' ');

	        parsed.args = ['/d', '/s', '/c', `"${shellCommand}"`];
	        parsed.command = process.env.comspec || 'cmd.exe';
	        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped
	    }

	    return parsed;
	}

	function parse(command, args, options) {
	    // Normalize arguments, similar to nodejs
	    if (args && !Array.isArray(args)) {
	        options = args;
	        args = null;
	    }

	    args = args ? args.slice(0) : []; // Clone array to avoid changing the original
	    options = Object.assign({}, options); // Clone object to avoid changing the original

	    // Build our parsed object
	    const parsed = {
	        command,
	        args,
	        options,
	        file: undefined,
	        original: {
	            command,
	            args,
	        },
	    };

	    // Delegate further parsing to shell or non-shell
	    return options.shell ? parsed : parseNonShell(parsed);
	}

	parse_1 = parse;
	return parse_1;
}

var enoent;
var hasRequiredEnoent;

function requireEnoent () {
	if (hasRequiredEnoent) return enoent;
	hasRequiredEnoent = 1;

	const isWin = process.platform === 'win32';

	function notFoundError(original, syscall) {
	    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
	        code: 'ENOENT',
	        errno: 'ENOENT',
	        syscall: `${syscall} ${original.command}`,
	        path: original.command,
	        spawnargs: original.args,
	    });
	}

	function hookChildProcess(cp, parsed) {
	    if (!isWin) {
	        return;
	    }

	    const originalEmit = cp.emit;

	    cp.emit = function (name, arg1) {
	        // If emitting "exit" event and exit code is 1, we need to check if
	        // the command exists and emit an "error" instead
	        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16
	        if (name === 'exit') {
	            const err = verifyENOENT(arg1, parsed);

	            if (err) {
	                return originalEmit.call(cp, 'error', err);
	            }
	        }

	        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params
	    };
	}

	function verifyENOENT(status, parsed) {
	    if (isWin && status === 1 && !parsed.file) {
	        return notFoundError(parsed.original, 'spawn');
	    }

	    return null;
	}

	function verifyENOENTSync(status, parsed) {
	    if (isWin && status === 1 && !parsed.file) {
	        return notFoundError(parsed.original, 'spawnSync');
	    }

	    return null;
	}

	enoent = {
	    hookChildProcess,
	    verifyENOENT,
	    verifyENOENTSync,
	    notFoundError,
	};
	return enoent;
}

var hasRequiredCrossSpawn;

function requireCrossSpawn () {
	if (hasRequiredCrossSpawn) return crossSpawn.exports;
	hasRequiredCrossSpawn = 1;

	const cp = require$$0$6;
	const parse = requireParse();
	const enoent = requireEnoent();

	function spawn(command, args, options) {
	    // Parse the arguments
	    const parsed = parse(command, args, options);

	    // Spawn the child process
	    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);

	    // Hook into child process "exit" event to emit an error if the command
	    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
	    enoent.hookChildProcess(spawned, parsed);

	    return spawned;
	}

	function spawnSync(command, args, options) {
	    // Parse the arguments
	    const parsed = parse(command, args, options);

	    // Spawn the child process
	    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);

	    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
	    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);

	    return result;
	}

	crossSpawn.exports = spawn;
	crossSpawn.exports.spawn = spawn;
	crossSpawn.exports.sync = spawnSync;

	crossSpawn.exports._parse = parse;
	crossSpawn.exports._enoent = enoent;
	return crossSpawn.exports;
}

var stripFinalNewline;
var hasRequiredStripFinalNewline;

function requireStripFinalNewline () {
	if (hasRequiredStripFinalNewline) return stripFinalNewline;
	hasRequiredStripFinalNewline = 1;

	stripFinalNewline = input => {
		const LF = typeof input === 'string' ? '\n' : '\n'.charCodeAt();
		const CR = typeof input === 'string' ? '\r' : '\r'.charCodeAt();

		if (input[input.length - 1] === LF) {
			input = input.slice(0, input.length - 1);
		}

		if (input[input.length - 1] === CR) {
			input = input.slice(0, input.length - 1);
		}

		return input;
	};
	return stripFinalNewline;
}

var npmRunPath = {exports: {}};

npmRunPath.exports;

var hasRequiredNpmRunPath;

function requireNpmRunPath () {
	if (hasRequiredNpmRunPath) return npmRunPath.exports;
	hasRequiredNpmRunPath = 1;
	(function (module) {
		const path = require$$0$4;
		const pathKey = requirePathKey();

		const npmRunPath = options => {
			options = {
				cwd: process.cwd(),
				path: process.env[pathKey()],
				execPath: process.execPath,
				...options
			};

			let previous;
			let cwdPath = path.resolve(options.cwd);
			const result = [];

			while (previous !== cwdPath) {
				result.push(path.join(cwdPath, 'node_modules/.bin'));
				previous = cwdPath;
				cwdPath = path.resolve(cwdPath, '..');
			}

			// Ensure the running `node` binary is used
			const execPathDir = path.resolve(options.cwd, options.execPath, '..');
			result.push(execPathDir);

			return result.concat(options.path).join(path.delimiter);
		};

		module.exports = npmRunPath;
		// TODO: Remove this for the next major release
		module.exports.default = npmRunPath;

		module.exports.env = options => {
			options = {
				env: process.env,
				...options
			};

			const env = {...options.env};
			const path = pathKey({env});

			options.path = env[path];
			env[path] = module.exports(options);

			return env;
		}; 
	} (npmRunPath));
	return npmRunPath.exports;
}

var onetime = {exports: {}};

var mimicFn = {exports: {}};

var hasRequiredMimicFn;

function requireMimicFn () {
	if (hasRequiredMimicFn) return mimicFn.exports;
	hasRequiredMimicFn = 1;

	const mimicFn$1 = (to, from) => {
		for (const prop of Reflect.ownKeys(from)) {
			Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
		}

		return to;
	};

	mimicFn.exports = mimicFn$1;
	// TODO: Remove this for the next major release
	mimicFn.exports.default = mimicFn$1;
	return mimicFn.exports;
}

var hasRequiredOnetime;

function requireOnetime () {
	if (hasRequiredOnetime) return onetime.exports;
	hasRequiredOnetime = 1;
	const mimicFn = requireMimicFn();

	const calledFunctions = new WeakMap();

	const onetime$1 = (function_, options = {}) => {
		if (typeof function_ !== 'function') {
			throw new TypeError('Expected a function');
		}

		let returnValue;
		let callCount = 0;
		const functionName = function_.displayName || function_.name || '<anonymous>';

		const onetime = function (...arguments_) {
			calledFunctions.set(onetime, ++callCount);

			if (callCount === 1) {
				returnValue = function_.apply(this, arguments_);
				function_ = null;
			} else if (options.throw === true) {
				throw new Error(`Function \`${functionName}\` can only be called once`);
			}

			return returnValue;
		};

		mimicFn(onetime, function_);
		calledFunctions.set(onetime, callCount);

		return onetime;
	};

	onetime.exports = onetime$1;
	// TODO: Remove this for the next major release
	onetime.exports.default = onetime$1;

	onetime.exports.callCount = function_ => {
		if (!calledFunctions.has(function_)) {
			throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
		}

		return calledFunctions.get(function_);
	};
	return onetime.exports;
}

var main$3 = {};

var signals$1 = {};

var core$7 = {};

var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return core$7;
	hasRequiredCore = 1;
Object.defineProperty(core$7,"__esModule",{value:true});core$7.SIGNALS=void 0;

	const SIGNALS=[
	{
	name:"SIGHUP",
	number:1,
	action:"terminate",
	description:"Terminal closed",
	standard:"posix"},

	{
	name:"SIGINT",
	number:2,
	action:"terminate",
	description:"User interruption with CTRL-C",
	standard:"ansi"},

	{
	name:"SIGQUIT",
	number:3,
	action:"core",
	description:"User interruption with CTRL-\\",
	standard:"posix"},

	{
	name:"SIGILL",
	number:4,
	action:"core",
	description:"Invalid machine instruction",
	standard:"ansi"},

	{
	name:"SIGTRAP",
	number:5,
	action:"core",
	description:"Debugger breakpoint",
	standard:"posix"},

	{
	name:"SIGABRT",
	number:6,
	action:"core",
	description:"Aborted",
	standard:"ansi"},

	{
	name:"SIGIOT",
	number:6,
	action:"core",
	description:"Aborted",
	standard:"bsd"},

	{
	name:"SIGBUS",
	number:7,
	action:"core",
	description:
	"Bus error due to misaligned, non-existing address or paging error",
	standard:"bsd"},

	{
	name:"SIGEMT",
	number:7,
	action:"terminate",
	description:"Command should be emulated but is not implemented",
	standard:"other"},

	{
	name:"SIGFPE",
	number:8,
	action:"core",
	description:"Floating point arithmetic error",
	standard:"ansi"},

	{
	name:"SIGKILL",
	number:9,
	action:"terminate",
	description:"Forced termination",
	standard:"posix",
	forced:true},

	{
	name:"SIGUSR1",
	number:10,
	action:"terminate",
	description:"Application-specific signal",
	standard:"posix"},

	{
	name:"SIGSEGV",
	number:11,
	action:"core",
	description:"Segmentation fault",
	standard:"ansi"},

	{
	name:"SIGUSR2",
	number:12,
	action:"terminate",
	description:"Application-specific signal",
	standard:"posix"},

	{
	name:"SIGPIPE",
	number:13,
	action:"terminate",
	description:"Broken pipe or socket",
	standard:"posix"},

	{
	name:"SIGALRM",
	number:14,
	action:"terminate",
	description:"Timeout or timer",
	standard:"posix"},

	{
	name:"SIGTERM",
	number:15,
	action:"terminate",
	description:"Termination",
	standard:"ansi"},

	{
	name:"SIGSTKFLT",
	number:16,
	action:"terminate",
	description:"Stack is empty or overflowed",
	standard:"other"},

	{
	name:"SIGCHLD",
	number:17,
	action:"ignore",
	description:"Child process terminated, paused or unpaused",
	standard:"posix"},

	{
	name:"SIGCLD",
	number:17,
	action:"ignore",
	description:"Child process terminated, paused or unpaused",
	standard:"other"},

	{
	name:"SIGCONT",
	number:18,
	action:"unpause",
	description:"Unpaused",
	standard:"posix",
	forced:true},

	{
	name:"SIGSTOP",
	number:19,
	action:"pause",
	description:"Paused",
	standard:"posix",
	forced:true},

	{
	name:"SIGTSTP",
	number:20,
	action:"pause",
	description:"Paused using CTRL-Z or \"suspend\"",
	standard:"posix"},

	{
	name:"SIGTTIN",
	number:21,
	action:"pause",
	description:"Background process cannot read terminal input",
	standard:"posix"},

	{
	name:"SIGBREAK",
	number:21,
	action:"terminate",
	description:"User interruption with CTRL-BREAK",
	standard:"other"},

	{
	name:"SIGTTOU",
	number:22,
	action:"pause",
	description:"Background process cannot write to terminal output",
	standard:"posix"},

	{
	name:"SIGURG",
	number:23,
	action:"ignore",
	description:"Socket received out-of-band data",
	standard:"bsd"},

	{
	name:"SIGXCPU",
	number:24,
	action:"core",
	description:"Process timed out",
	standard:"bsd"},

	{
	name:"SIGXFSZ",
	number:25,
	action:"core",
	description:"File too big",
	standard:"bsd"},

	{
	name:"SIGVTALRM",
	number:26,
	action:"terminate",
	description:"Timeout or timer",
	standard:"bsd"},

	{
	name:"SIGPROF",
	number:27,
	action:"terminate",
	description:"Timeout or timer",
	standard:"bsd"},

	{
	name:"SIGWINCH",
	number:28,
	action:"ignore",
	description:"Terminal window size changed",
	standard:"bsd"},

	{
	name:"SIGIO",
	number:29,
	action:"terminate",
	description:"I/O is available",
	standard:"other"},

	{
	name:"SIGPOLL",
	number:29,
	action:"terminate",
	description:"Watched event",
	standard:"other"},

	{
	name:"SIGINFO",
	number:29,
	action:"ignore",
	description:"Request for process information",
	standard:"other"},

	{
	name:"SIGPWR",
	number:30,
	action:"terminate",
	description:"Device running out of power",
	standard:"systemv"},

	{
	name:"SIGSYS",
	number:31,
	action:"core",
	description:"Invalid system call",
	standard:"other"},

	{
	name:"SIGUNUSED",
	number:31,
	action:"terminate",
	description:"Invalid system call",
	standard:"other"}];core$7.SIGNALS=SIGNALS;
	
	return core$7;
}

var realtime = {};

var hasRequiredRealtime;

function requireRealtime () {
	if (hasRequiredRealtime) return realtime;
	hasRequiredRealtime = 1;
Object.defineProperty(realtime,"__esModule",{value:true});realtime.SIGRTMAX=realtime.getRealtimeSignals=void 0;
	const getRealtimeSignals=function(){
	const length=SIGRTMAX-SIGRTMIN+1;
	return Array.from({length},getRealtimeSignal);
	};realtime.getRealtimeSignals=getRealtimeSignals;

	const getRealtimeSignal=function(value,index){
	return {
	name:`SIGRT${index+1}`,
	number:SIGRTMIN+index,
	action:"terminate",
	description:"Application-specific signal (realtime)",
	standard:"posix"};

	};

	const SIGRTMIN=34;
	const SIGRTMAX=64;realtime.SIGRTMAX=SIGRTMAX;
	
	return realtime;
}

var hasRequiredSignals$1;

function requireSignals$1 () {
	if (hasRequiredSignals$1) return signals$1;
	hasRequiredSignals$1 = 1;
Object.defineProperty(signals$1,"__esModule",{value:true});signals$1.getSignals=void 0;var _os=require$$0$3;

	var _core=requireCore();
	var _realtime=requireRealtime();



	const getSignals=function(){
	const realtimeSignals=(0, _realtime.getRealtimeSignals)();
	const signals=[..._core.SIGNALS,...realtimeSignals].map(normalizeSignal);
	return signals;
	};signals$1.getSignals=getSignals;







	const normalizeSignal=function({
	name,
	number:defaultNumber,
	description,
	action,
	forced=false,
	standard})
	{
	const{
	signals:{[name]:constantSignal}}=
	_os.constants;
	const supported=constantSignal!==undefined;
	const number=supported?constantSignal:defaultNumber;
	return {name,number,description,supported,action,forced,standard};
	};
	
	return signals$1;
}

var hasRequiredMain;

function requireMain () {
	if (hasRequiredMain) return main$3;
	hasRequiredMain = 1;
Object.defineProperty(main$3,"__esModule",{value:true});main$3.signalsByNumber=main$3.signalsByName=void 0;var _os=require$$0$3;

	var _signals=requireSignals$1();
	var _realtime=requireRealtime();



	const getSignalsByName=function(){
	const signals=(0, _signals.getSignals)();
	return signals.reduce(getSignalByName,{});
	};

	const getSignalByName=function(
	signalByNameMemo,
	{name,number,description,supported,action,forced,standard})
	{
	return {
	...signalByNameMemo,
	[name]:{name,number,description,supported,action,forced,standard}};

	};

	const signalsByName=getSignalsByName();main$3.signalsByName=signalsByName;




	const getSignalsByNumber=function(){
	const signals=(0, _signals.getSignals)();
	const length=_realtime.SIGRTMAX+1;
	const signalsA=Array.from({length},(value,number)=>
	getSignalByNumber(number,signals));

	return Object.assign({},...signalsA);
	};

	const getSignalByNumber=function(number,signals){
	const signal=findSignalByNumber(number,signals);

	if(signal===undefined){
	return {};
	}

	const{name,description,supported,action,forced,standard}=signal;
	return {
	[number]:{
	name,
	number,
	description,
	supported,
	action,
	forced,
	standard}};


	};



	const findSignalByNumber=function(number,signals){
	const signal=signals.find(({name})=>_os.constants.signals[name]===number);

	if(signal!==undefined){
	return signal;
	}

	return signals.find(signalA=>signalA.number===number);
	};

	const signalsByNumber=getSignalsByNumber();main$3.signalsByNumber=signalsByNumber;
	
	return main$3;
}

var error$2;
var hasRequiredError;

function requireError () {
	if (hasRequiredError) return error$2;
	hasRequiredError = 1;
	const {signalsByName} = requireMain();

	const getErrorPrefix = ({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled}) => {
		if (timedOut) {
			return `timed out after ${timeout} milliseconds`;
		}

		if (isCanceled) {
			return 'was canceled';
		}

		if (errorCode !== undefined) {
			return `failed with ${errorCode}`;
		}

		if (signal !== undefined) {
			return `was killed with ${signal} (${signalDescription})`;
		}

		if (exitCode !== undefined) {
			return `failed with exit code ${exitCode}`;
		}

		return 'failed';
	};

	const makeError = ({
		stdout,
		stderr,
		all,
		error,
		signal,
		exitCode,
		command,
		escapedCommand,
		timedOut,
		isCanceled,
		killed,
		parsed: {options: {timeout}}
	}) => {
		// `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.
		// We normalize them to `undefined`
		exitCode = exitCode === null ? undefined : exitCode;
		signal = signal === null ? undefined : signal;
		const signalDescription = signal === undefined ? undefined : signalsByName[signal].description;

		const errorCode = error && error.code;

		const prefix = getErrorPrefix({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled});
		const execaMessage = `Command ${prefix}: ${command}`;
		const isError = Object.prototype.toString.call(error) === '[object Error]';
		const shortMessage = isError ? `${execaMessage}\n${error.message}` : execaMessage;
		const message = [shortMessage, stderr, stdout].filter(Boolean).join('\n');

		if (isError) {
			error.originalMessage = error.message;
			error.message = message;
		} else {
			error = new Error(message);
		}

		error.shortMessage = shortMessage;
		error.command = command;
		error.escapedCommand = escapedCommand;
		error.exitCode = exitCode;
		error.signal = signal;
		error.signalDescription = signalDescription;
		error.stdout = stdout;
		error.stderr = stderr;

		if (all !== undefined) {
			error.all = all;
		}

		if ('bufferedData' in error) {
			delete error.bufferedData;
		}

		error.failed = true;
		error.timedOut = Boolean(timedOut);
		error.isCanceled = isCanceled;
		error.killed = killed && !timedOut;

		return error;
	};

	error$2 = makeError;
	return error$2;
}

var stdio = {exports: {}};

var hasRequiredStdio;

function requireStdio () {
	if (hasRequiredStdio) return stdio.exports;
	hasRequiredStdio = 1;
	const aliases = ['stdin', 'stdout', 'stderr'];

	const hasAlias = options => aliases.some(alias => options[alias] !== undefined);

	const normalizeStdio = options => {
		if (!options) {
			return;
		}

		const {stdio} = options;

		if (stdio === undefined) {
			return aliases.map(alias => options[alias]);
		}

		if (hasAlias(options)) {
			throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map(alias => `\`${alias}\``).join(', ')}`);
		}

		if (typeof stdio === 'string') {
			return stdio;
		}

		if (!Array.isArray(stdio)) {
			throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
		}

		const length = Math.max(stdio.length, aliases.length);
		return Array.from({length}, (value, index) => stdio[index]);
	};

	stdio.exports = normalizeStdio;

	// `ipc` is pushed unless it is already present
	stdio.exports.node = options => {
		const stdio = normalizeStdio(options);

		if (stdio === 'ipc') {
			return 'ipc';
		}

		if (stdio === undefined || typeof stdio === 'string') {
			return [stdio, stdio, stdio, 'ipc'];
		}

		if (stdio.includes('ipc')) {
			return stdio;
		}

		return [...stdio, 'ipc'];
	};
	return stdio.exports;
}

var signalExit = {exports: {}};

var signals = {exports: {}};

var hasRequiredSignals;

function requireSignals () {
	if (hasRequiredSignals) return signals.exports;
	hasRequiredSignals = 1;
	(function (module) {
		// This is not the set of all possible signals.
		//
		// It IS, however, the set of all signals that trigger
		// an exit on either Linux or BSD systems.  Linux is a
		// superset of the signal names supported on BSD, and
		// the unknown signals just fail to register, so we can
		// catch that easily enough.
		//
		// Don't bother with SIGKILL.  It's uncatchable, which
		// means that we can't fire any callbacks anyway.
		//
		// If a user does happen to register a handler on a non-
		// fatal signal like SIGWINCH or something, and then
		// exit, it'll end up firing `process.emit('exit')`, so
		// the handler will be fired anyway.
		//
		// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
		// artificially, inherently leave the process in a
		// state from which it is not safe to try and enter JS
		// listeners.
		module.exports = [
		  'SIGABRT',
		  'SIGALRM',
		  'SIGHUP',
		  'SIGINT',
		  'SIGTERM'
		];

		if (process.platform !== 'win32') {
		  module.exports.push(
		    'SIGVTALRM',
		    'SIGXCPU',
		    'SIGXFSZ',
		    'SIGUSR2',
		    'SIGTRAP',
		    'SIGSYS',
		    'SIGQUIT',
		    'SIGIOT'
		    // should detect profiler and enable/disable accordingly.
		    // see #21
		    // 'SIGPROF'
		  );
		}

		if (process.platform === 'linux') {
		  module.exports.push(
		    'SIGIO',
		    'SIGPOLL',
		    'SIGPWR',
		    'SIGSTKFLT',
		    'SIGUNUSED'
		  );
		} 
	} (signals));
	return signals.exports;
}

var hasRequiredSignalExit;

function requireSignalExit () {
	if (hasRequiredSignalExit) return signalExit.exports;
	hasRequiredSignalExit = 1;
	// Note: since nyc uses this module to output coverage, any lines
	// that are in the direct sync flow of nyc's outputCoverage are
	// ignored, since we can never get coverage for them.
	// grab a reference to node's real process object right away
	var process = commonjsGlobal.process;

	const processOk = function (process) {
	  return process &&
	    typeof process === 'object' &&
	    typeof process.removeListener === 'function' &&
	    typeof process.emit === 'function' &&
	    typeof process.reallyExit === 'function' &&
	    typeof process.listeners === 'function' &&
	    typeof process.kill === 'function' &&
	    typeof process.pid === 'number' &&
	    typeof process.on === 'function'
	};

	// some kind of non-node environment, just no-op
	/* istanbul ignore if */
	if (!processOk(process)) {
	  signalExit.exports = function () {
	    return function () {}
	  };
	} else {
	  var assert = require$$0$7;
	  var signals = requireSignals();
	  var isWin = /^win/i.test(process.platform);

	  var EE = require$$2$3;
	  /* istanbul ignore if */
	  if (typeof EE !== 'function') {
	    EE = EE.EventEmitter;
	  }

	  var emitter;
	  if (process.__signal_exit_emitter__) {
	    emitter = process.__signal_exit_emitter__;
	  } else {
	    emitter = process.__signal_exit_emitter__ = new EE();
	    emitter.count = 0;
	    emitter.emitted = {};
	  }

	  // Because this emitter is a global, we have to check to see if a
	  // previous version of this library failed to enable infinite listeners.
	  // I know what you're about to say.  But literally everything about
	  // signal-exit is a compromise with evil.  Get used to it.
	  if (!emitter.infinite) {
	    emitter.setMaxListeners(Infinity);
	    emitter.infinite = true;
	  }

	  signalExit.exports = function (cb, opts) {
	    /* istanbul ignore if */
	    if (!processOk(commonjsGlobal.process)) {
	      return function () {}
	    }
	    assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler');

	    if (loaded === false) {
	      load();
	    }

	    var ev = 'exit';
	    if (opts && opts.alwaysLast) {
	      ev = 'afterexit';
	    }

	    var remove = function () {
	      emitter.removeListener(ev, cb);
	      if (emitter.listeners('exit').length === 0 &&
	          emitter.listeners('afterexit').length === 0) {
	        unload();
	      }
	    };
	    emitter.on(ev, cb);

	    return remove
	  };

	  var unload = function unload () {
	    if (!loaded || !processOk(commonjsGlobal.process)) {
	      return
	    }
	    loaded = false;

	    signals.forEach(function (sig) {
	      try {
	        process.removeListener(sig, sigListeners[sig]);
	      } catch (er) {}
	    });
	    process.emit = originalProcessEmit;
	    process.reallyExit = originalProcessReallyExit;
	    emitter.count -= 1;
	  };
	  signalExit.exports.unload = unload;

	  var emit = function emit (event, code, signal) {
	    /* istanbul ignore if */
	    if (emitter.emitted[event]) {
	      return
	    }
	    emitter.emitted[event] = true;
	    emitter.emit(event, code, signal);
	  };

	  // { <signal>: <listener fn>, ... }
	  var sigListeners = {};
	  signals.forEach(function (sig) {
	    sigListeners[sig] = function listener () {
	      /* istanbul ignore if */
	      if (!processOk(commonjsGlobal.process)) {
	        return
	      }
	      // If there are no other listeners, an exit is coming!
	      // Simplest way: remove us and then re-send the signal.
	      // We know that this will kill the process, so we can
	      // safely emit now.
	      var listeners = process.listeners(sig);
	      if (listeners.length === emitter.count) {
	        unload();
	        emit('exit', null, sig);
	        /* istanbul ignore next */
	        emit('afterexit', null, sig);
	        /* istanbul ignore next */
	        if (isWin && sig === 'SIGHUP') {
	          // "SIGHUP" throws an `ENOSYS` error on Windows,
	          // so use a supported signal instead
	          sig = 'SIGINT';
	        }
	        /* istanbul ignore next */
	        process.kill(process.pid, sig);
	      }
	    };
	  });

	  signalExit.exports.signals = function () {
	    return signals
	  };

	  var loaded = false;

	  var load = function load () {
	    if (loaded || !processOk(commonjsGlobal.process)) {
	      return
	    }
	    loaded = true;

	    // This is the number of onSignalExit's that are in play.
	    // It's important so that we can count the correct number of
	    // listeners on signals, and don't wait for the other one to
	    // handle it instead of us.
	    emitter.count += 1;

	    signals = signals.filter(function (sig) {
	      try {
	        process.on(sig, sigListeners[sig]);
	        return true
	      } catch (er) {
	        return false
	      }
	    });

	    process.emit = processEmit;
	    process.reallyExit = processReallyExit;
	  };
	  signalExit.exports.load = load;

	  var originalProcessReallyExit = process.reallyExit;
	  var processReallyExit = function processReallyExit (code) {
	    /* istanbul ignore if */
	    if (!processOk(commonjsGlobal.process)) {
	      return
	    }
	    process.exitCode = code || /* istanbul ignore next */ 0;
	    emit('exit', process.exitCode, null);
	    /* istanbul ignore next */
	    emit('afterexit', process.exitCode, null);
	    /* istanbul ignore next */
	    originalProcessReallyExit.call(process, process.exitCode);
	  };

	  var originalProcessEmit = process.emit;
	  var processEmit = function processEmit (ev, arg) {
	    if (ev === 'exit' && processOk(commonjsGlobal.process)) {
	      /* istanbul ignore else */
	      if (arg !== undefined) {
	        process.exitCode = arg;
	      }
	      var ret = originalProcessEmit.apply(this, arguments);
	      /* istanbul ignore next */
	      emit('exit', process.exitCode, null);
	      /* istanbul ignore next */
	      emit('afterexit', process.exitCode, null);
	      /* istanbul ignore next */
	      return ret
	    } else {
	      return originalProcessEmit.apply(this, arguments)
	    }
	  };
	}
	return signalExit.exports;
}

var kill;
var hasRequiredKill;

function requireKill () {
	if (hasRequiredKill) return kill;
	hasRequiredKill = 1;
	const os = require$$0$3;
	const onExit = requireSignalExit();

	const DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;

	// Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior
	const spawnedKill = (kill, signal = 'SIGTERM', options = {}) => {
		const killResult = kill(signal);
		setKillTimeout(kill, signal, options, killResult);
		return killResult;
	};

	const setKillTimeout = (kill, signal, options, killResult) => {
		if (!shouldForceKill(signal, options, killResult)) {
			return;
		}

		const timeout = getForceKillAfterTimeout(options);
		const t = setTimeout(() => {
			kill('SIGKILL');
		}, timeout);

		// Guarded because there's no `.unref()` when `execa` is used in the renderer
		// process in Electron. This cannot be tested since we don't run tests in
		// Electron.
		// istanbul ignore else
		if (t.unref) {
			t.unref();
		}
	};

	const shouldForceKill = (signal, {forceKillAfterTimeout}, killResult) => {
		return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
	};

	const isSigterm = signal => {
		return signal === os.constants.signals.SIGTERM ||
			(typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM');
	};

	const getForceKillAfterTimeout = ({forceKillAfterTimeout = true}) => {
		if (forceKillAfterTimeout === true) {
			return DEFAULT_FORCE_KILL_TIMEOUT;
		}

		if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
			throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
		}

		return forceKillAfterTimeout;
	};

	// `childProcess.cancel()`
	const spawnedCancel = (spawned, context) => {
		const killResult = spawned.kill();

		if (killResult) {
			context.isCanceled = true;
		}
	};

	const timeoutKill = (spawned, signal, reject) => {
		spawned.kill(signal);
		reject(Object.assign(new Error('Timed out'), {timedOut: true, signal}));
	};

	// `timeout` option handling
	const setupTimeout = (spawned, {timeout, killSignal = 'SIGTERM'}, spawnedPromise) => {
		if (timeout === 0 || timeout === undefined) {
			return spawnedPromise;
		}

		let timeoutId;
		const timeoutPromise = new Promise((resolve, reject) => {
			timeoutId = setTimeout(() => {
				timeoutKill(spawned, killSignal, reject);
			}, timeout);
		});

		const safeSpawnedPromise = spawnedPromise.finally(() => {
			clearTimeout(timeoutId);
		});

		return Promise.race([timeoutPromise, safeSpawnedPromise]);
	};

	const validateTimeout = ({timeout}) => {
		if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {
			throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
		}
	};

	// `cleanup` option handling
	const setExitHandler = async (spawned, {cleanup, detached}, timedPromise) => {
		if (!cleanup || detached) {
			return timedPromise;
		}

		const removeExitHandler = onExit(() => {
			spawned.kill();
		});

		return timedPromise.finally(() => {
			removeExitHandler();
		});
	};

	kill = {
		spawnedKill,
		spawnedCancel,
		setupTimeout,
		validateTimeout,
		setExitHandler
	};
	return kill;
}

var isStream_1;
var hasRequiredIsStream;

function requireIsStream () {
	if (hasRequiredIsStream) return isStream_1;
	hasRequiredIsStream = 1;

	const isStream = stream =>
		stream !== null &&
		typeof stream === 'object' &&
		typeof stream.pipe === 'function';

	isStream.writable = stream =>
		isStream(stream) &&
		stream.writable !== false &&
		typeof stream._write === 'function' &&
		typeof stream._writableState === 'object';

	isStream.readable = stream =>
		isStream(stream) &&
		stream.readable !== false &&
		typeof stream._read === 'function' &&
		typeof stream._readableState === 'object';

	isStream.duplex = stream =>
		isStream.writable(stream) &&
		isStream.readable(stream);

	isStream.transform = stream =>
		isStream.duplex(stream) &&
		typeof stream._transform === 'function';

	isStream_1 = isStream;
	return isStream_1;
}

var getStream = {exports: {}};

var bufferStream;
var hasRequiredBufferStream;

function requireBufferStream () {
	if (hasRequiredBufferStream) return bufferStream;
	hasRequiredBufferStream = 1;
	const {PassThrough: PassThroughStream} = require$$0$8;

	bufferStream = options => {
		options = {...options};

		const {array} = options;
		let {encoding} = options;
		const isBuffer = encoding === 'buffer';
		let objectMode = false;

		if (array) {
			objectMode = !(encoding || isBuffer);
		} else {
			encoding = encoding || 'utf8';
		}

		if (isBuffer) {
			encoding = null;
		}

		const stream = new PassThroughStream({objectMode});

		if (encoding) {
			stream.setEncoding(encoding);
		}

		let length = 0;
		const chunks = [];

		stream.on('data', chunk => {
			chunks.push(chunk);

			if (objectMode) {
				length = chunks.length;
			} else {
				length += chunk.length;
			}
		});

		stream.getBufferedValue = () => {
			if (array) {
				return chunks;
			}

			return isBuffer ? Buffer.concat(chunks, length) : chunks.join('');
		};

		stream.getBufferedLength = () => length;

		return stream;
	};
	return bufferStream;
}

var hasRequiredGetStream;

function requireGetStream () {
	if (hasRequiredGetStream) return getStream.exports;
	hasRequiredGetStream = 1;
	const {constants: BufferConstants} = require$$0$9;
	const stream = require$$0$8;
	const {promisify} = require$$1$2;
	const bufferStream = requireBufferStream();

	const streamPipelinePromisified = promisify(stream.pipeline);

	class MaxBufferError extends Error {
		constructor() {
			super('maxBuffer exceeded');
			this.name = 'MaxBufferError';
		}
	}

	async function getStream$1(inputStream, options) {
		if (!inputStream) {
			throw new Error('Expected a stream');
		}

		options = {
			maxBuffer: Infinity,
			...options
		};

		const {maxBuffer} = options;
		const stream = bufferStream(options);

		await new Promise((resolve, reject) => {
			const rejectPromise = error => {
				// Don't retrieve an oversized buffer.
				if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
					error.bufferedData = stream.getBufferedValue();
				}

				reject(error);
			};

			(async () => {
				try {
					await streamPipelinePromisified(inputStream, stream);
					resolve();
				} catch (error) {
					rejectPromise(error);
				}
			})();

			stream.on('data', () => {
				if (stream.getBufferedLength() > maxBuffer) {
					rejectPromise(new MaxBufferError());
				}
			});
		});

		return stream.getBufferedValue();
	}

	getStream.exports = getStream$1;
	getStream.exports.buffer = (stream, options) => getStream$1(stream, {...options, encoding: 'buffer'});
	getStream.exports.array = (stream, options) => getStream$1(stream, {...options, array: true});
	getStream.exports.MaxBufferError = MaxBufferError;
	return getStream.exports;
}

var mergeStream;
var hasRequiredMergeStream;

function requireMergeStream () {
	if (hasRequiredMergeStream) return mergeStream;
	hasRequiredMergeStream = 1;

	const { PassThrough } = require$$0$8;

	mergeStream = function (/*streams...*/) {
	  var sources = [];
	  var output  = new PassThrough({objectMode: true});

	  output.setMaxListeners(0);

	  output.add = add;
	  output.isEmpty = isEmpty;

	  output.on('unpipe', remove);

	  Array.prototype.slice.call(arguments).forEach(add);

	  return output

	  function add (source) {
	    if (Array.isArray(source)) {
	      source.forEach(add);
	      return this
	    }

	    sources.push(source);
	    source.once('end', remove.bind(null, source));
	    source.once('error', output.emit.bind(output, 'error'));
	    source.pipe(output, {end: false});
	    return this
	  }

	  function isEmpty () {
	    return sources.length == 0;
	  }

	  function remove (source) {
	    sources = sources.filter(function (it) { return it !== source });
	    if (!sources.length && output.readable) { output.end(); }
	  }
	};
	return mergeStream;
}

var stream;
var hasRequiredStream;

function requireStream () {
	if (hasRequiredStream) return stream;
	hasRequiredStream = 1;
	const isStream = requireIsStream();
	const getStream = requireGetStream();
	const mergeStream = requireMergeStream();

	// `input` option
	const handleInput = (spawned, input) => {
		// Checking for stdin is workaround for https://github.com/nodejs/node/issues/26852
		// @todo remove `|| spawned.stdin === undefined` once we drop support for Node.js <=12.2.0
		if (input === undefined || spawned.stdin === undefined) {
			return;
		}

		if (isStream(input)) {
			input.pipe(spawned.stdin);
		} else {
			spawned.stdin.end(input);
		}
	};

	// `all` interleaves `stdout` and `stderr`
	const makeAllStream = (spawned, {all}) => {
		if (!all || (!spawned.stdout && !spawned.stderr)) {
			return;
		}

		const mixed = mergeStream();

		if (spawned.stdout) {
			mixed.add(spawned.stdout);
		}

		if (spawned.stderr) {
			mixed.add(spawned.stderr);
		}

		return mixed;
	};

	// On failure, `result.stdout|stderr|all` should contain the currently buffered stream
	const getBufferedData = async (stream, streamPromise) => {
		if (!stream) {
			return;
		}

		stream.destroy();

		try {
			return await streamPromise;
		} catch (error) {
			return error.bufferedData;
		}
	};

	const getStreamPromise = (stream, {encoding, buffer, maxBuffer}) => {
		if (!stream || !buffer) {
			return;
		}

		if (encoding) {
			return getStream(stream, {encoding, maxBuffer});
		}

		return getStream.buffer(stream, {maxBuffer});
	};

	// Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)
	const getSpawnedResult = async ({stdout, stderr, all}, {encoding, buffer, maxBuffer}, processDone) => {
		const stdoutPromise = getStreamPromise(stdout, {encoding, buffer, maxBuffer});
		const stderrPromise = getStreamPromise(stderr, {encoding, buffer, maxBuffer});
		const allPromise = getStreamPromise(all, {encoding, buffer, maxBuffer: maxBuffer * 2});

		try {
			return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
		} catch (error) {
			return Promise.all([
				{error, signal: error.signal, timedOut: error.timedOut},
				getBufferedData(stdout, stdoutPromise),
				getBufferedData(stderr, stderrPromise),
				getBufferedData(all, allPromise)
			]);
		}
	};

	const validateInputSync = ({input}) => {
		if (isStream(input)) {
			throw new TypeError('The `input` option cannot be a stream in sync mode');
		}
	};

	stream = {
		handleInput,
		makeAllStream,
		getSpawnedResult,
		validateInputSync
	};
	return stream;
}

var promise;
var hasRequiredPromise;

function requirePromise () {
	if (hasRequiredPromise) return promise;
	hasRequiredPromise = 1;

	const nativePromisePrototype = (async () => {})().constructor.prototype;
	const descriptors = ['then', 'catch', 'finally'].map(property => [
		property,
		Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
	]);

	// The return value is a mixin of `childProcess` and `Promise`
	const mergePromise = (spawned, promise) => {
		for (const [property, descriptor] of descriptors) {
			// Starting the main `promise` is deferred to avoid consuming streams
			const value = typeof promise === 'function' ?
				(...args) => Reflect.apply(descriptor.value, promise(), args) :
				descriptor.value.bind(promise);

			Reflect.defineProperty(spawned, property, {...descriptor, value});
		}

		return spawned;
	};

	// Use promises instead of `child_process` events
	const getSpawnedPromise = spawned => {
		return new Promise((resolve, reject) => {
			spawned.on('exit', (exitCode, signal) => {
				resolve({exitCode, signal});
			});

			spawned.on('error', error => {
				reject(error);
			});

			if (spawned.stdin) {
				spawned.stdin.on('error', error => {
					reject(error);
				});
			}
		});
	};

	promise = {
		mergePromise,
		getSpawnedPromise
	};
	return promise;
}

var command;
var hasRequiredCommand;

function requireCommand () {
	if (hasRequiredCommand) return command;
	hasRequiredCommand = 1;
	const normalizeArgs = (file, args = []) => {
		if (!Array.isArray(args)) {
			return [file];
		}

		return [file, ...args];
	};

	const NO_ESCAPE_REGEXP = /^[\w.-]+$/;
	const DOUBLE_QUOTES_REGEXP = /"/g;

	const escapeArg = arg => {
		if (typeof arg !== 'string' || NO_ESCAPE_REGEXP.test(arg)) {
			return arg;
		}

		return `"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\"')}"`;
	};

	const joinCommand = (file, args) => {
		return normalizeArgs(file, args).join(' ');
	};

	const getEscapedCommand = (file, args) => {
		return normalizeArgs(file, args).map(arg => escapeArg(arg)).join(' ');
	};

	const SPACES_REGEXP = / +/g;

	// Handle `execa.command()`
	const parseCommand = command => {
		const tokens = [];
		for (const token of command.trim().split(SPACES_REGEXP)) {
			// Allow spaces to be escaped by a backslash if not meant as a delimiter
			const previousToken = tokens[tokens.length - 1];
			if (previousToken && previousToken.endsWith('\\')) {
				// Merge previous token with current one
				tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
			} else {
				tokens.push(token);
			}
		}

		return tokens;
	};

	command = {
		joinCommand,
		getEscapedCommand,
		parseCommand
	};
	return command;
}

var hasRequiredExeca;

function requireExeca () {
	if (hasRequiredExeca) return execa.exports;
	hasRequiredExeca = 1;
	const path = require$$0$4;
	const childProcess = require$$0$6;
	const crossSpawn = requireCrossSpawn();
	const stripFinalNewline = requireStripFinalNewline();
	const npmRunPath = requireNpmRunPath();
	const onetime = requireOnetime();
	const makeError = requireError();
	const normalizeStdio = requireStdio();
	const {spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler} = requireKill();
	const {handleInput, getSpawnedResult, makeAllStream, validateInputSync} = requireStream();
	const {mergePromise, getSpawnedPromise} = requirePromise();
	const {joinCommand, parseCommand, getEscapedCommand} = requireCommand();

	const DEFAULT_MAX_BUFFER = 1000 * 1000 * 100;

	const getEnv = ({env: envOption, extendEnv, preferLocal, localDir, execPath}) => {
		const env = extendEnv ? {...process.env, ...envOption} : envOption;

		if (preferLocal) {
			return npmRunPath.env({env, cwd: localDir, execPath});
		}

		return env;
	};

	const handleArguments = (file, args, options = {}) => {
		const parsed = crossSpawn._parse(file, args, options);
		file = parsed.command;
		args = parsed.args;
		options = parsed.options;

		options = {
			maxBuffer: DEFAULT_MAX_BUFFER,
			buffer: true,
			stripFinalNewline: true,
			extendEnv: true,
			preferLocal: false,
			localDir: options.cwd || process.cwd(),
			execPath: process.execPath,
			encoding: 'utf8',
			reject: true,
			cleanup: true,
			all: false,
			windowsHide: true,
			...options
		};

		options.env = getEnv(options);

		options.stdio = normalizeStdio(options);

		if (process.platform === 'win32' && path.basename(file, '.exe') === 'cmd') {
			// #116
			args.unshift('/q');
		}

		return {file, args, options, parsed};
	};

	const handleOutput = (options, value, error) => {
		if (typeof value !== 'string' && !Buffer.isBuffer(value)) {
			// When `execa.sync()` errors, we normalize it to '' to mimic `execa()`
			return error === undefined ? undefined : '';
		}

		if (options.stripFinalNewline) {
			return stripFinalNewline(value);
		}

		return value;
	};

	const execa$1 = (file, args, options) => {
		const parsed = handleArguments(file, args, options);
		const command = joinCommand(file, args);
		const escapedCommand = getEscapedCommand(file, args);

		validateTimeout(parsed.options);

		let spawned;
		try {
			spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
		} catch (error) {
			// Ensure the returned error is always both a promise and a child process
			const dummySpawned = new childProcess.ChildProcess();
			const errorPromise = Promise.reject(makeError({
				error,
				stdout: '',
				stderr: '',
				all: '',
				command,
				escapedCommand,
				parsed,
				timedOut: false,
				isCanceled: false,
				killed: false
			}));
			return mergePromise(dummySpawned, errorPromise);
		}

		const spawnedPromise = getSpawnedPromise(spawned);
		const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
		const processDone = setExitHandler(spawned, parsed.options, timedPromise);

		const context = {isCanceled: false};

		spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
		spawned.cancel = spawnedCancel.bind(null, spawned, context);

		const handlePromise = async () => {
			const [{error, exitCode, signal, timedOut}, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
			const stdout = handleOutput(parsed.options, stdoutResult);
			const stderr = handleOutput(parsed.options, stderrResult);
			const all = handleOutput(parsed.options, allResult);

			if (error || exitCode !== 0 || signal !== null) {
				const returnedError = makeError({
					error,
					exitCode,
					signal,
					stdout,
					stderr,
					all,
					command,
					escapedCommand,
					parsed,
					timedOut,
					isCanceled: context.isCanceled,
					killed: spawned.killed
				});

				if (!parsed.options.reject) {
					return returnedError;
				}

				throw returnedError;
			}

			return {
				command,
				escapedCommand,
				exitCode: 0,
				stdout,
				stderr,
				all,
				failed: false,
				timedOut: false,
				isCanceled: false,
				killed: false
			};
		};

		const handlePromiseOnce = onetime(handlePromise);

		handleInput(spawned, parsed.options.input);

		spawned.all = makeAllStream(spawned, parsed.options);

		return mergePromise(spawned, handlePromiseOnce);
	};

	execa.exports = execa$1;

	execa.exports.sync = (file, args, options) => {
		const parsed = handleArguments(file, args, options);
		const command = joinCommand(file, args);
		const escapedCommand = getEscapedCommand(file, args);

		validateInputSync(parsed.options);

		let result;
		try {
			result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);
		} catch (error) {
			throw makeError({
				error,
				stdout: '',
				stderr: '',
				all: '',
				command,
				escapedCommand,
				parsed,
				timedOut: false,
				isCanceled: false,
				killed: false
			});
		}

		const stdout = handleOutput(parsed.options, result.stdout, result.error);
		const stderr = handleOutput(parsed.options, result.stderr, result.error);

		if (result.error || result.status !== 0 || result.signal !== null) {
			const error = makeError({
				stdout,
				stderr,
				error: result.error,
				signal: result.signal,
				exitCode: result.status,
				command,
				escapedCommand,
				parsed,
				timedOut: result.error && result.error.code === 'ETIMEDOUT',
				isCanceled: false,
				killed: result.signal !== null
			});

			if (!parsed.options.reject) {
				return error;
			}

			throw error;
		}

		return {
			command,
			escapedCommand,
			exitCode: 0,
			stdout,
			stderr,
			failed: false,
			timedOut: false,
			isCanceled: false,
			killed: false
		};
	};

	execa.exports.command = (command, options) => {
		const [file, ...args] = parseCommand(command);
		return execa$1(file, args, options);
	};

	execa.exports.commandSync = (command, options) => {
		const [file, ...args] = parseCommand(command);
		return execa$1.sync(file, args, options);
	};

	execa.exports.node = (scriptPath, args, options = {}) => {
		if (args && !Array.isArray(args) && typeof args === 'object') {
			options = args;
			args = [];
		}

		const stdio = normalizeStdio.node(options);
		const defaultExecArgv = process.execArgv.filter(arg => !arg.startsWith('--inspect'));

		const {
			nodePath = process.execPath,
			nodeOptions = defaultExecArgv
		} = options;

		return execa$1(
			nodePath,
			[
				...nodeOptions,
				scriptPath,
				...(Array.isArray(args) ? args : [])
			],
			{
				...options,
				stdin: undefined,
				stdout: undefined,
				stderr: undefined,
				stdio,
				shell: false
			}
		);
	};
	return execa.exports;
}

var dist$7;
var hasRequiredDist$1;

function requireDist$1 () {
	if (hasRequiredDist$1) return dist$7;
	hasRequiredDist$1 = 1;
	var __create = Object.create;
	var __defProp = Object.defineProperty;
	var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames = Object.getOwnPropertyNames;
	var __getProtoOf = Object.getPrototypeOf;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __export = (target, all) => {
	  for (var name in all)
	    __defProp(target, name, { get: all[name], enumerable: true });
	};
	var __copyProps = (to, from, except, desc) => {
	  if (from && typeof from === "object" || typeof from === "function") {
	    for (let key of __getOwnPropNames(from))
	      if (!__hasOwnProp.call(to, key) && key !== except)
	        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
	  }
	  return to;
	};
	var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
	  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
	  mod
	));
	var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

	// src/index.ts
	var src_exports = {};
	__export(src_exports, {
	  detectPackageManager: () => detectPackageManager,
	  installPackage: () => installPackage
	});
	dist$7 = __toCommonJS(src_exports);

	// src/detect.ts
	var import_fs = __toESM(require$$0$5);
	var import_path = __toESM(require$$0$4);
	var import_find_up = __toESM(requireFindUp());
	var AGENTS = ["pnpm", "yarn", "npm", "pnpm@6", "yarn@berry", "bun"];
	var LOCKS = {
	  "bun.lockb": "bun",
	  "pnpm-lock.yaml": "pnpm",
	  "yarn.lock": "yarn",
	  "package-lock.json": "npm",
	  "npm-shrinkwrap.json": "npm"
	};
	async function detectPackageManager(cwd = process.cwd()) {
	  let agent = null;
	  const lockPath = await (0, import_find_up.default)(Object.keys(LOCKS), { cwd });
	  let packageJsonPath;
	  if (lockPath)
	    packageJsonPath = import_path.default.resolve(lockPath, "../package.json");
	  else
	    packageJsonPath = await (0, import_find_up.default)("package.json", { cwd });
	  if (packageJsonPath && import_fs.default.existsSync(packageJsonPath)) {
	    try {
	      const pkg = JSON.parse(import_fs.default.readFileSync(packageJsonPath, "utf8"));
	      if (typeof pkg.packageManager === "string") {
	        const [name, version] = pkg.packageManager.split("@");
	        if (name === "yarn" && parseInt(version) > 1)
	          agent = "yarn@berry";
	        else if (name === "pnpm" && parseInt(version) < 7)
	          agent = "pnpm@6";
	        else if (name in AGENTS)
	          agent = name;
	        else
	          console.warn("[ni] Unknown packageManager:", pkg.packageManager);
	      }
	    } catch {
	    }
	  }
	  if (!agent && lockPath)
	    agent = LOCKS[import_path.default.basename(lockPath)];
	  return agent;
	}

	// src/install.ts
	var import_execa = __toESM(requireExeca());
	async function installPackage(names, options = {}) {
	  const detectedAgent = options.packageManager || await detectPackageManager(options.cwd) || "npm";
	  const [agent] = detectedAgent.split("@");
	  if (!Array.isArray(names))
	    names = [names];
	  const args = options.additionalArgs || [];
	  if (options.preferOffline) {
	    if (detectedAgent === "yarn@berry")
	      args.unshift("--cached");
	    else
	      args.unshift("--prefer-offline");
	  }
	  return (0, import_execa.default)(
	    agent,
	    [
	      agent === "yarn" ? "add" : "install",
	      options.dev ? "-D" : "",
	      ...args,
	      ...names
	    ].filter(Boolean),
	    {
	      stdio: options.silent ? "ignore" : "inherit",
	      cwd: options.cwd
	    }
	  );
	}
	return dist$7;
}

var dist$6 = {};

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist$6;
	hasRequiredDist = 1;

	function clamp(n, min, max) {
	  return Math.min(max, Math.max(min, n));
	}
	function sum(...args) {
	  return flattenArrayable(args).reduce((a, b) => a + b, 0);
	}
	function lerp(min, max, t) {
	  const interpolation = clamp(t, 0, 1);
	  return min + (max - min) * interpolation;
	}
	function remap(n, inMin, inMax, outMin, outMax) {
	  const interpolation = (n - inMin) / (inMax - inMin);
	  return lerp(outMin, outMax, interpolation);
	}

	function toArray(array) {
	  array = array ?? [];
	  return Array.isArray(array) ? array : [array];
	}
	function flattenArrayable(array) {
	  return toArray(array).flat(1);
	}
	function mergeArrayable(...args) {
	  return args.flatMap((i) => toArray(i));
	}
	function partition(array, ...filters) {
	  const result = Array.from({ length: filters.length + 1 }).fill(null).map(() => []);
	  array.forEach((e, idx, arr) => {
	    let i = 0;
	    for (const filter of filters) {
	      if (filter(e, idx, arr)) {
	        result[i].push(e);
	        return;
	      }
	      i += 1;
	    }
	    result[i].push(e);
	  });
	  return result;
	}
	function uniq(array) {
	  return Array.from(new Set(array));
	}
	function uniqueBy(array, equalFn) {
	  return array.reduce((acc, cur) => {
	    const index = acc.findIndex((item) => equalFn(cur, item));
	    if (index === -1)
	      acc.push(cur);
	    return acc;
	  }, []);
	}
	function last(array) {
	  return at(array, -1);
	}
	function remove(array, value) {
	  if (!array)
	    return false;
	  const index = array.indexOf(value);
	  if (index >= 0) {
	    array.splice(index, 1);
	    return true;
	  }
	  return false;
	}
	function at(array, index) {
	  const len = array.length;
	  if (!len)
	    return void 0;
	  if (index < 0)
	    index += len;
	  return array[index];
	}
	function range(...args) {
	  let start, stop, step;
	  if (args.length === 1) {
	    start = 0;
	    step = 1;
	    [stop] = args;
	  } else {
	    [start, stop, step = 1] = args;
	  }
	  const arr = [];
	  let current = start;
	  while (current < stop) {
	    arr.push(current);
	    current += step || 1;
	  }
	  return arr;
	}
	function move(arr, from, to) {
	  arr.splice(to, 0, arr.splice(from, 1)[0]);
	  return arr;
	}
	function clampArrayRange(n, arr) {
	  return clamp(n, 0, arr.length - 1);
	}
	function sample(arr, quantity) {
	  return Array.from({ length: quantity }, (_) => arr[Math.round(Math.random() * (arr.length - 1))]);
	}
	function shuffle(array) {
	  for (let i = array.length - 1; i > 0; i--) {
	    const j = Math.floor(Math.random() * (i + 1));
	    [array[i], array[j]] = [array[j], array[i]];
	  }
	  return array;
	}

	function assert(condition, message) {
	  if (!condition)
	    throw new Error(message);
	}
	const toString = (v) => Object.prototype.toString.call(v);
	function getTypeName(v) {
	  if (v === null)
	    return "null";
	  const type = toString(v).slice(8, -1).toLowerCase();
	  return typeof v === "object" || typeof v === "function" ? type : typeof v;
	}
	function noop() {
	}

	function isDeepEqual(value1, value2) {
	  const type1 = getTypeName(value1);
	  const type2 = getTypeName(value2);
	  if (type1 !== type2)
	    return false;
	  if (type1 === "array") {
	    if (value1.length !== value2.length)
	      return false;
	    return value1.every((item, i) => {
	      return isDeepEqual(item, value2[i]);
	    });
	  }
	  if (type1 === "object") {
	    const keyArr = Object.keys(value1);
	    if (keyArr.length !== Object.keys(value2).length)
	      return false;
	    return keyArr.every((key) => {
	      return isDeepEqual(value1[key], value2[key]);
	    });
	  }
	  return Object.is(value1, value2);
	}

	function notNullish(v) {
	  return v != null;
	}
	function noNull(v) {
	  return v !== null;
	}
	function notUndefined(v) {
	  return v !== void 0;
	}
	function isTruthy(v) {
	  return Boolean(v);
	}

	const isDef = (val) => typeof val !== "undefined";
	const isBoolean = (val) => typeof val === "boolean";
	const isFunction = (val) => typeof val === "function";
	const isNumber = (val) => typeof val === "number";
	const isString = (val) => typeof val === "string";
	const isObject = (val) => toString(val) === "[object Object]";
	const isUndefined = (val) => toString(val) === "[object Undefined]";
	const isNull = (val) => toString(val) === "[object Null]";
	const isRegExp = (val) => toString(val) === "[object RegExp]";
	const isDate = (val) => toString(val) === "[object Date]";
	const isWindow = (val) => typeof window !== "undefined" && toString(val) === "[object Window]";
	const isBrowser = typeof window !== "undefined";

	function slash(str) {
	  return str.replace(/\\/g, "/");
	}
	function ensurePrefix(prefix, str) {
	  if (!str.startsWith(prefix))
	    return prefix + str;
	  return str;
	}
	function ensureSuffix(suffix, str) {
	  if (!str.endsWith(suffix))
	    return str + suffix;
	  return str;
	}
	function template(str, ...args) {
	  const [firstArg, fallback] = args;
	  if (isObject(firstArg)) {
	    const vars = firstArg;
	    return str.replace(/{([\w\d]+)}/g, (_, key) => vars[key] || ((typeof fallback === "function" ? fallback(key) : fallback) ?? key));
	  } else {
	    return str.replace(/{(\d+)}/g, (_, key) => {
	      const index = Number(key);
	      if (Number.isNaN(index))
	        return key;
	      return args[index];
	    });
	  }
	}
	const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
	function randomStr(size = 16, dict = urlAlphabet) {
	  let id = "";
	  let i = size;
	  const len = dict.length;
	  while (i--)
	    id += dict[Math.random() * len | 0];
	  return id;
	}
	function capitalize(str) {
	  return str[0].toUpperCase() + str.slice(1).toLowerCase();
	}

	const timestamp = () => +Date.now();

	function batchInvoke(functions) {
	  functions.forEach((fn) => fn && fn());
	}
	function invoke(fn) {
	  return fn();
	}
	function tap(value, callback) {
	  callback(value);
	  return value;
	}

	function objectMap(obj, fn) {
	  return Object.fromEntries(
	    Object.entries(obj).map(([k, v]) => fn(k, v)).filter(notNullish)
	  );
	}
	function isKeyOf(obj, k) {
	  return k in obj;
	}
	function objectKeys(obj) {
	  return Object.keys(obj);
	}
	function objectEntries(obj) {
	  return Object.entries(obj);
	}
	function deepMerge(target, ...sources) {
	  if (!sources.length)
	    return target;
	  const source = sources.shift();
	  if (source === void 0)
	    return target;
	  if (isMergableObject(target) && isMergableObject(source)) {
	    objectKeys(source).forEach((key) => {
	      if (key === "__proto__" || key === "constructor" || key === "prototype")
	        return;
	      if (isMergableObject(source[key])) {
	        if (!target[key])
	          target[key] = {};
	        if (isMergableObject(target[key])) {
	          deepMerge(target[key], source[key]);
	        } else {
	          target[key] = source[key];
	        }
	      } else {
	        target[key] = source[key];
	      }
	    });
	  }
	  return deepMerge(target, ...sources);
	}
	function deepMergeWithArray(target, ...sources) {
	  if (!sources.length)
	    return target;
	  const source = sources.shift();
	  if (source === void 0)
	    return target;
	  if (Array.isArray(target) && Array.isArray(source))
	    target.push(...source);
	  if (isMergableObject(target) && isMergableObject(source)) {
	    objectKeys(source).forEach((key) => {
	      if (key === "__proto__" || key === "constructor" || key === "prototype")
	        return;
	      if (Array.isArray(source[key])) {
	        if (!target[key])
	          target[key] = [];
	        deepMergeWithArray(target[key], source[key]);
	      } else if (isMergableObject(source[key])) {
	        if (!target[key])
	          target[key] = {};
	        deepMergeWithArray(target[key], source[key]);
	      } else {
	        target[key] = source[key];
	      }
	    });
	  }
	  return deepMergeWithArray(target, ...sources);
	}
	function isMergableObject(item) {
	  return isObject(item) && !Array.isArray(item);
	}
	function objectPick(obj, keys, omitUndefined = false) {
	  return keys.reduce((n, k) => {
	    if (k in obj) {
	      if (!omitUndefined || obj[k] !== void 0)
	        n[k] = obj[k];
	    }
	    return n;
	  }, {});
	}
	function clearUndefined(obj) {
	  Object.keys(obj).forEach((key) => obj[key] === void 0 ? delete obj[key] : {});
	  return obj;
	}
	function hasOwnProperty(obj, v) {
	  if (obj == null)
	    return false;
	  return Object.prototype.hasOwnProperty.call(obj, v);
	}

	function createSingletonPromise(fn) {
	  let _promise;
	  function wrapper() {
	    if (!_promise)
	      _promise = fn();
	    return _promise;
	  }
	  wrapper.reset = async () => {
	    const _prev = _promise;
	    _promise = void 0;
	    if (_prev)
	      await _prev;
	  };
	  return wrapper;
	}
	function sleep(ms, callback) {
	  return new Promise(
	    (resolve) => setTimeout(async () => {
	      await (callback == null ? void 0 : callback());
	      resolve();
	    }, ms)
	  );
	}
	function createPromiseLock() {
	  const locks = [];
	  return {
	    async run(fn) {
	      const p = fn();
	      locks.push(p);
	      try {
	        return await p;
	      } finally {
	        remove(locks, p);
	      }
	    },
	    async wait() {
	      await Promise.allSettled(locks);
	    },
	    isWaiting() {
	      return Boolean(locks.length);
	    },
	    clear() {
	      locks.length = 0;
	    }
	  };
	}
	function createControlledPromise() {
	  let resolve, reject;
	  const promise = new Promise((_resolve, _reject) => {
	    resolve = _resolve;
	    reject = _reject;
	  });
	  promise.resolve = resolve;
	  promise.reject = reject;
	  return promise;
	}

	/* eslint-disable no-undefined,no-param-reassign,no-shadow */

	/**
	 * Throttle execution of a function. Especially useful for rate limiting
	 * execution of handlers on events like resize and scroll.
	 *
	 * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)
	 *                                            are most useful.
	 * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,
	 *                                            as-is, to `callback` when the throttled-function is executed.
	 * @param {object} [options] -              An object to configure options.
	 * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds
	 *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed
	 *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for
	 *                                            `delay` milliseconds, the internal counter is reset).
	 * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback
	 *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that
	 *                                            callback will never executed if both noLeading = true and noTrailing = true.
	 * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is
	 *                                            false (at end), schedule `callback` to execute after `delay` ms.
	 *
	 * @returns {Function} A new, throttled, function.
	 */
	function throttle (delay, callback, options) {
	  var _ref = options || {},
	      _ref$noTrailing = _ref.noTrailing,
	      noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing,
	      _ref$noLeading = _ref.noLeading,
	      noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading,
	      _ref$debounceMode = _ref.debounceMode,
	      debounceMode = _ref$debounceMode === void 0 ? undefined : _ref$debounceMode;
	  /*
	   * After wrapper has stopped being called, this timeout ensures that
	   * `callback` is executed at the proper times in `throttle` and `end`
	   * debounce modes.
	   */


	  var timeoutID;
	  var cancelled = false; // Keep track of the last time `callback` was executed.

	  var lastExec = 0; // Function to clear existing timeout

	  function clearExistingTimeout() {
	    if (timeoutID) {
	      clearTimeout(timeoutID);
	    }
	  } // Function to cancel next exec


	  function cancel(options) {
	    var _ref2 = options || {},
	        _ref2$upcomingOnly = _ref2.upcomingOnly,
	        upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;

	    clearExistingTimeout();
	    cancelled = !upcomingOnly;
	  }
	  /*
	   * The `wrapper` function encapsulates all of the throttling / debouncing
	   * functionality and when executed will limit the rate at which `callback`
	   * is executed.
	   */


	  function wrapper() {
	    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
	      arguments_[_key] = arguments[_key];
	    }

	    var self = this;
	    var elapsed = Date.now() - lastExec;

	    if (cancelled) {
	      return;
	    } // Execute `callback` and update the `lastExec` timestamp.


	    function exec() {
	      lastExec = Date.now();
	      callback.apply(self, arguments_);
	    }
	    /*
	     * If `debounceMode` is true (at begin) this is used to clear the flag
	     * to allow future `callback` executions.
	     */


	    function clear() {
	      timeoutID = undefined;
	    }

	    if (!noLeading && debounceMode && !timeoutID) {
	      /*
	       * Since `wrapper` is being called for the first time and
	       * `debounceMode` is true (at begin), execute `callback`
	       * and noLeading != true.
	       */
	      exec();
	    }

	    clearExistingTimeout();

	    if (debounceMode === undefined && elapsed > delay) {
	      if (noLeading) {
	        /*
	         * In throttle mode with noLeading, if `delay` time has
	         * been exceeded, update `lastExec` and schedule `callback`
	         * to execute after `delay` ms.
	         */
	        lastExec = Date.now();

	        if (!noTrailing) {
	          timeoutID = setTimeout(debounceMode ? clear : exec, delay);
	        }
	      } else {
	        /*
	         * In throttle mode without noLeading, if `delay` time has been exceeded, execute
	         * `callback`.
	         */
	        exec();
	      }
	    } else if (noTrailing !== true) {
	      /*
	       * In trailing throttle mode, since `delay` time has not been
	       * exceeded, schedule `callback` to execute `delay` ms after most
	       * recent execution.
	       *
	       * If `debounceMode` is true (at begin), schedule `clear` to execute
	       * after `delay` ms.
	       *
	       * If `debounceMode` is false (at end), schedule `callback` to
	       * execute after `delay` ms.
	       */
	      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
	    }
	  }

	  wrapper.cancel = cancel; // Return the wrapper function.

	  return wrapper;
	}

	/* eslint-disable no-undefined */
	/**
	 * Debounce execution of a function. Debouncing, unlike throttling,
	 * guarantees that a function is only executed a single time, either at the
	 * very beginning of a series of calls, or at the very end.
	 *
	 * @param {number} delay -               A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
	 * @param {Function} callback -          A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
	 *                                        to `callback` when the debounced-function is executed.
	 * @param {object} [options] -           An object to configure options.
	 * @param {boolean} [options.atBegin] -  Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
	 *                                        after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
	 *                                        (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
	 *
	 * @returns {Function} A new, debounced function.
	 */

	function debounce (delay, callback, options) {
	  var _ref = options || {},
	      _ref$atBegin = _ref.atBegin,
	      atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;

	  return throttle(delay, callback, {
	    debounceMode: atBegin !== false
	  });
	}

	/*
	How it works:
	`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.
	*/

	class Node {
		value;
		next;

		constructor(value) {
			this.value = value;
		}
	}

	class Queue {
		#head;
		#tail;
		#size;

		constructor() {
			this.clear();
		}

		enqueue(value) {
			const node = new Node(value);

			if (this.#head) {
				this.#tail.next = node;
				this.#tail = node;
			} else {
				this.#head = node;
				this.#tail = node;
			}

			this.#size++;
		}

		dequeue() {
			const current = this.#head;
			if (!current) {
				return;
			}

			this.#head = this.#head.next;
			this.#size--;
			return current.value;
		}

		clear() {
			this.#head = undefined;
			this.#tail = undefined;
			this.#size = 0;
		}

		get size() {
			return this.#size;
		}

		* [Symbol.iterator]() {
			let current = this.#head;

			while (current) {
				yield current.value;
				current = current.next;
			}
		}
	}

	const AsyncResource = {
		bind(fn, _type, thisArg) {
			return fn.bind(thisArg);
		},
	};

	function pLimit(concurrency) {
		if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
			throw new TypeError('Expected `concurrency` to be a number from 1 and up');
		}

		const queue = new Queue();
		let activeCount = 0;

		const next = () => {
			activeCount--;

			if (queue.size > 0) {
				queue.dequeue()();
			}
		};

		const run = async (function_, resolve, arguments_) => {
			activeCount++;

			const result = (async () => function_(...arguments_))();

			resolve(result);

			try {
				await result;
			} catch {}

			next();
		};

		const enqueue = (function_, resolve, arguments_) => {
			queue.enqueue(
				AsyncResource.bind(run.bind(undefined, function_, resolve, arguments_)),
			);

			(async () => {
				// This function needs to wait until the next microtask before comparing
				// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously
				// when the run function is dequeued and called. The comparison in the if-statement
				// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.
				await Promise.resolve();

				if (activeCount < concurrency && queue.size > 0) {
					queue.dequeue()();
				}
			})();
		};

		const generator = (function_, ...arguments_) => new Promise(resolve => {
			enqueue(function_, resolve, arguments_);
		});

		Object.defineProperties(generator, {
			activeCount: {
				get: () => activeCount,
			},
			pendingCount: {
				get: () => queue.size,
			},
			clearQueue: {
				value() {
					queue.clear();
				},
			},
		});

		return generator;
	}

	const VOID = Symbol("p-void");
	class PInstance extends Promise {
	  constructor(items = [], options) {
	    super(() => {
	    });
	    this.items = items;
	    this.options = options;
	    this.promises = /* @__PURE__ */ new Set();
	  }
	  get promise() {
	    var _a;
	    let batch;
	    const items = [...Array.from(this.items), ...Array.from(this.promises)];
	    if ((_a = this.options) == null ? void 0 : _a.concurrency) {
	      const limit = pLimit(this.options.concurrency);
	      batch = Promise.all(items.map((p2) => limit(() => p2)));
	    } else {
	      batch = Promise.all(items);
	    }
	    return batch.then((l) => l.filter((i) => i !== VOID));
	  }
	  add(...args) {
	    args.forEach((i) => {
	      this.promises.add(i);
	    });
	  }
	  map(fn) {
	    return new PInstance(
	      Array.from(this.items).map(async (i, idx) => {
	        const v = await i;
	        if (v === VOID)
	          return VOID;
	        return fn(v, idx);
	      }),
	      this.options
	    );
	  }
	  filter(fn) {
	    return new PInstance(
	      Array.from(this.items).map(async (i, idx) => {
	        const v = await i;
	        const r = await fn(v, idx);
	        if (!r)
	          return VOID;
	        return v;
	      }),
	      this.options
	    );
	  }
	  forEach(fn) {
	    return this.map(fn).then();
	  }
	  reduce(fn, initialValue) {
	    return this.promise.then((array) => array.reduce(fn, initialValue));
	  }
	  clear() {
	    this.promises.clear();
	  }
	  then(fn) {
	    const p2 = this.promise;
	    if (fn)
	      return p2.then(fn);
	    else
	      return p2;
	  }
	  catch(fn) {
	    return this.promise.catch(fn);
	  }
	  finally(fn) {
	    return this.promise.finally(fn);
	  }
	}
	function p(items, options) {
	  return new PInstance(items, options);
	}

	dist$6.assert = assert;
	dist$6.at = at;
	dist$6.batchInvoke = batchInvoke;
	dist$6.capitalize = capitalize;
	dist$6.clamp = clamp;
	dist$6.clampArrayRange = clampArrayRange;
	dist$6.clearUndefined = clearUndefined;
	dist$6.createControlledPromise = createControlledPromise;
	dist$6.createPromiseLock = createPromiseLock;
	dist$6.createSingletonPromise = createSingletonPromise;
	dist$6.debounce = debounce;
	dist$6.deepMerge = deepMerge;
	dist$6.deepMergeWithArray = deepMergeWithArray;
	dist$6.ensurePrefix = ensurePrefix;
	dist$6.ensureSuffix = ensureSuffix;
	dist$6.flattenArrayable = flattenArrayable;
	dist$6.getTypeName = getTypeName;
	dist$6.hasOwnProperty = hasOwnProperty;
	dist$6.invoke = invoke;
	dist$6.isBoolean = isBoolean;
	dist$6.isBrowser = isBrowser;
	dist$6.isDate = isDate;
	dist$6.isDeepEqual = isDeepEqual;
	dist$6.isDef = isDef;
	dist$6.isFunction = isFunction;
	dist$6.isKeyOf = isKeyOf;
	dist$6.isNull = isNull;
	dist$6.isNumber = isNumber;
	dist$6.isObject = isObject;
	dist$6.isRegExp = isRegExp;
	dist$6.isString = isString;
	dist$6.isTruthy = isTruthy;
	dist$6.isUndefined = isUndefined;
	dist$6.isWindow = isWindow;
	dist$6.last = last;
	dist$6.lerp = lerp;
	dist$6.mergeArrayable = mergeArrayable;
	dist$6.move = move;
	dist$6.noNull = noNull;
	dist$6.noop = noop;
	dist$6.notNullish = notNullish;
	dist$6.notUndefined = notUndefined;
	dist$6.objectEntries = objectEntries;
	dist$6.objectKeys = objectKeys;
	dist$6.objectMap = objectMap;
	dist$6.objectPick = objectPick;
	dist$6.p = p;
	dist$6.partition = partition;
	dist$6.randomStr = randomStr;
	dist$6.range = range;
	dist$6.remap = remap;
	dist$6.remove = remove;
	dist$6.sample = sample;
	dist$6.shuffle = shuffle;
	dist$6.slash = slash;
	dist$6.sleep = sleep;
	dist$6.sum = sum;
	dist$6.tap = tap;
	dist$6.template = template;
	dist$6.throttle = throttle;
	dist$6.timestamp = timestamp;
	dist$6.toArray = toArray;
	dist$6.toString = toString;
	dist$6.uniq = uniq;
	dist$6.uniqueBy = uniqueBy;
	return dist$6;
}

var cjs$1 = {};

var hasRequiredCjs;

function requireCjs () {
	if (hasRequiredCjs) return cjs$1;
	hasRequiredCjs = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.link = exports.trueColorBg = exports.trueColor = exports.ansi256Bg = exports.ansi256 = exports.bgLightGray = exports.bgLightCyan = exports.bgLightMagenta = exports.bgLightBlue = exports.bgLightYellow = exports.bgLightGreen = exports.bgLightRed = exports.bgGray = exports.bgWhite = exports.bgCyan = exports.bgMagenta = exports.bgBlue = exports.bgYellow = exports.bgGreen = exports.bgRed = exports.bgBlack = exports.lightCyan = exports.lightMagenta = exports.lightBlue = exports.lightYellow = exports.lightGreen = exports.lightRed = exports.lightGray = exports.gray = exports.white = exports.cyan = exports.magenta = exports.blue = exports.yellow = exports.green = exports.red = exports.black = exports.strikethrough = exports.hidden = exports.inverse = exports.underline = exports.italic = exports.dim = exports.bold = exports.reset = exports.stripColors = exports.options = void 0;
		let enabled = true;
		// Support both browser and node environments
		const globalVar = typeof self !== 'undefined'
		    ? self
		    : typeof window !== 'undefined'
		        ? window
		        : typeof commonjsGlobal !== 'undefined'
		            ? commonjsGlobal
		            : {};
		/**
		 * Detect how much colors the current terminal supports
		 */
		let supportLevel = 0 /* none */;
		if (globalVar.process && globalVar.process.env && globalVar.process.stdout) {
		    const { FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, COLORTERM } = globalVar.process.env;
		    if (NODE_DISABLE_COLORS || NO_COLOR || FORCE_COLOR === '0') {
		        enabled = false;
		    }
		    else if (FORCE_COLOR === '1' ||
		        FORCE_COLOR === '2' ||
		        FORCE_COLOR === '3') {
		        enabled = true;
		    }
		    else if (TERM === 'dumb') {
		        enabled = false;
		    }
		    else if ('CI' in globalVar.process.env &&
		        [
		            'TRAVIS',
		            'CIRCLECI',
		            'APPVEYOR',
		            'GITLAB_CI',
		            'GITHUB_ACTIONS',
		            'BUILDKITE',
		            'DRONE',
		        ].some(vendor => vendor in globalVar.process.env)) {
		        enabled = true;
		    }
		    else {
		        enabled = process.stdout.isTTY;
		    }
		    if (enabled) {
		        // Windows supports 24bit True Colors since Windows 10 revision #14931,
		        // see https://devblogs.microsoft.com/commandline/24-bit-color-in-the-windows-console/
		        if (process.platform === 'win32') {
		            supportLevel = 3 /* trueColor */;
		        }
		        else {
		            if (COLORTERM && (COLORTERM === 'truecolor' || COLORTERM === '24bit')) {
		                supportLevel = 3 /* trueColor */;
		            }
		            else if (TERM && (TERM.endsWith('-256color') || TERM.endsWith('256'))) {
		                supportLevel = 2 /* ansi256 */;
		            }
		            else {
		                supportLevel = 1 /* ansi */;
		            }
		        }
		    }
		}
		exports.options = {
		    enabled,
		    supportLevel,
		};
		function kolorist(start, end, level = 1 /* ansi */) {
		    const open = `\x1b[${start}m`;
		    const close = `\x1b[${end}m`;
		    const regex = new RegExp(`\\x1b\\[${end}m`, 'g');
		    return (str) => {
		        return exports.options.enabled && exports.options.supportLevel >= level
		            ? open + ('' + str).replace(regex, open) + close
		            : '' + str;
		    };
		}
		// Lower colors into 256 color space
		// Taken from https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
		// which is MIT licensed and copyright by Heather Arthur and Josh Junon
		function rgbToAnsi256(r, g, b) {
		    // We use the extended greyscale palette here, with the exception of
		    // black and white. normal palette only has 4 greyscale shades.
		    if (r >> 4 === g >> 4 && g >> 4 === b >> 4) {
		        if (r < 8) {
		            return 16;
		        }
		        if (r > 248) {
		            return 231;
		        }
		        return Math.round(((r - 8) / 247) * 24) + 232;
		    }
		    const ansi = 16 +
		        36 * Math.round((r / 255) * 5) +
		        6 * Math.round((g / 255) * 5) +
		        Math.round((b / 255) * 5);
		    return ansi;
		}
		function stripColors(str) {
		    return ('' + str)
		        .replace(/\x1b\[[0-9;]+m/g, '')
		        .replace(/\x1b\]8;;.*?\x07(.*?)\x1b\]8;;\x07/g, (_, group) => group);
		}
		exports.stripColors = stripColors;
		// modifiers
		exports.reset = kolorist(0, 0);
		exports.bold = kolorist(1, 22);
		exports.dim = kolorist(2, 22);
		exports.italic = kolorist(3, 23);
		exports.underline = kolorist(4, 24);
		exports.inverse = kolorist(7, 27);
		exports.hidden = kolorist(8, 28);
		exports.strikethrough = kolorist(9, 29);
		// colors
		exports.black = kolorist(30, 39);
		exports.red = kolorist(31, 39);
		exports.green = kolorist(32, 39);
		exports.yellow = kolorist(33, 39);
		exports.blue = kolorist(34, 39);
		exports.magenta = kolorist(35, 39);
		exports.cyan = kolorist(36, 39);
		exports.white = kolorist(97, 39);
		exports.gray = kolorist(90, 39);
		exports.lightGray = kolorist(37, 39);
		exports.lightRed = kolorist(91, 39);
		exports.lightGreen = kolorist(92, 39);
		exports.lightYellow = kolorist(93, 39);
		exports.lightBlue = kolorist(94, 39);
		exports.lightMagenta = kolorist(95, 39);
		exports.lightCyan = kolorist(96, 39);
		// background colors
		exports.bgBlack = kolorist(40, 49);
		exports.bgRed = kolorist(41, 49);
		exports.bgGreen = kolorist(42, 49);
		exports.bgYellow = kolorist(43, 49);
		exports.bgBlue = kolorist(44, 49);
		exports.bgMagenta = kolorist(45, 49);
		exports.bgCyan = kolorist(46, 49);
		exports.bgWhite = kolorist(107, 49);
		exports.bgGray = kolorist(100, 49);
		exports.bgLightRed = kolorist(101, 49);
		exports.bgLightGreen = kolorist(102, 49);
		exports.bgLightYellow = kolorist(103, 49);
		exports.bgLightBlue = kolorist(104, 49);
		exports.bgLightMagenta = kolorist(105, 49);
		exports.bgLightCyan = kolorist(106, 49);
		exports.bgLightGray = kolorist(47, 49);
		// 256 support
		const ansi256 = (n) => kolorist('38;5;' + n, 0, 2 /* ansi256 */);
		exports.ansi256 = ansi256;
		const ansi256Bg = (n) => kolorist('48;5;' + n, 0, 2 /* ansi256 */);
		exports.ansi256Bg = ansi256Bg;
		// TrueColor 24bit support
		const trueColor = (r, g, b) => {
		    return exports.options.supportLevel === 2 /* ansi256 */
		        ? exports.ansi256(rgbToAnsi256(r, g, b))
		        : kolorist(`38;2;${r};${g};${b}`, 0, 3 /* trueColor */);
		};
		exports.trueColor = trueColor;
		const trueColorBg = (r, g, b) => {
		    return exports.options.supportLevel === 2 /* ansi256 */
		        ? exports.ansi256Bg(rgbToAnsi256(r, g, b))
		        : kolorist(`48;2;${r};${g};${b}`, 0, 3 /* trueColor */);
		};
		exports.trueColorBg = trueColorBg;
		// Links
		const OSC = '\u001B]';
		const BEL = '\u0007';
		const SEP = ';';
		function link(text, url) {
		    return exports.options.enabled
		        ? OSC + '8' + SEP + SEP + url + BEL + text + OSC + '8' + SEP + SEP + BEL
		        : `${text} (\u200B${url}\u200B)`;
		}
		exports.link = link;
		
	} (cjs$1));
	return cjs$1;
}

var warn = {};

var hasRequiredWarn;

function requireWarn () {
	if (hasRequiredWarn) return warn;
	hasRequiredWarn = 1;

	const kolorist = requireCjs();

	const warned = /* @__PURE__ */ new Set();
	function warnOnce(msg) {
	  if (!warned.has(msg)) {
	    warned.add(msg);
	    console.warn(kolorist.yellow(`[@iconify-loader] ${msg}`));
	  }
	}

	warn.warnOnce = warnOnce;
	return warn;
}

var hasRequiredInstallPkg;

function requireInstallPkg () {
	if (hasRequiredInstallPkg) return installPkg;
	hasRequiredInstallPkg = 1;

	const installPkg$1 = requireDist$1();
	const utils = requireDist();
	const kolorist = requireCjs();
	const loader_warn = requireWarn();

	let pending;
	const tasks = {};
	async function tryInstallPkg(name, autoInstall) {
	  if (pending) {
	    await pending;
	  }
	  if (!tasks[name]) {
	    console.log(kolorist.cyan(`Installing ${name}...`));
	    if (typeof autoInstall === "function") {
	      tasks[name] = pending = autoInstall(name).then(() => utils.sleep(300)).finally(() => {
	        pending = void 0;
	      });
	    } else {
	      tasks[name] = pending = installPkg$1.installPackage(name, {
	        dev: true,
	        preferOffline: true
	      }).then(() => utils.sleep(300)).catch((e) => {
	        loader_warn.warnOnce(`Failed to install ${name}`);
	        console.error(e);
	      }).finally(() => {
	        pending = void 0;
	      });
	    }
	  }
	  return tasks[name];
	}

	installPkg.tryInstallPkg = tryInstallPkg;
	return installPkg;
}

var hasRequiredFs;

function requireFs () {
	if (hasRequiredFs) return fs;
	hasRequiredFs = 1;

	const fs$1 = require$$0$5;
	const localPkg = requireDist$2();
	const loader_installPkg = requireInstallPkg();
	const mlly = requireDist$3();
	requireDist$1();
	requireDist();
	requireCjs();
	requireWarn();

	const _collections = {};
	const isLegacyExists = localPkg.isPackageExists("@iconify/json");
	async function loadCollectionFromFS(name, autoInstall = false, scope = "@iconify-json", cwd = process.cwd()) {
	  if (!await _collections[name]) {
	    _collections[name] = task();
	  }
	  return _collections[name];
	  async function task() {
	    const packageName = scope.length === 0 ? name : `${scope}/${name}`;
	    let jsonPath = await mlly.resolvePath(`${packageName}/icons.json`, {
	      url: cwd
	    }).catch(() => void 0);
	    if (scope === "@iconify-json") {
	      if (!jsonPath && isLegacyExists) {
	        jsonPath = await mlly.resolvePath(
	          `@iconify/json/json/${name}.json`,
	          {
	            url: cwd
	          }
	        ).catch(() => void 0);
	      }
	      if (!jsonPath && !isLegacyExists && autoInstall) {
	        await loader_installPkg.tryInstallPkg(packageName, autoInstall);
	        jsonPath = await mlly.resolvePath(`${packageName}/icons.json`, {
	          url: cwd
	        }).catch(() => void 0);
	      }
	    } else if (!jsonPath && autoInstall) {
	      await loader_installPkg.tryInstallPkg(packageName, autoInstall);
	      jsonPath = await mlly.resolvePath(`${packageName}/icons.json`, {
	        url: cwd
	      }).catch(() => void 0);
	    }
	    if (!jsonPath) {
	      let packagePath = await mlly.resolvePath(packageName, {
	        url: cwd
	      }).catch(() => void 0);
	      if (packagePath?.match(/^[a-z]:/i)) {
	        packagePath = `file:///${packagePath}`.replace(/\\/g, "/");
	      }
	      if (packagePath) {
	        const { icons } = await localPkg.importModule(
	          packagePath
	        );
	        if (icons)
	          return icons;
	      }
	    }
	    let stat;
	    try {
	      stat = jsonPath ? await fs$1.promises.lstat(jsonPath) : void 0;
	    } catch (err) {
	      return void 0;
	    }
	    if (stat?.isFile()) {
	      return JSON.parse(
	        await fs$1.promises.readFile(jsonPath, "utf8")
	      );
	    } else {
	      return void 0;
	    }
	  }
	}

	fs.loadCollectionFromFS = loadCollectionFromFS;
	return fs;
}

var loader = {};

var custom = {};

var trim = {};

var hasRequiredTrim;

function requireTrim () {
	if (hasRequiredTrim) return trim;
	hasRequiredTrim = 1;

	function trimSVG(str) {
	  return str.replace(/(['"])\s*\n\s*([^>\\/\s])/g, "$1 $2").replace(/(["';{}><])\s*\n\s*/g, "$1").replace(/\s*\n\s*/g, " ").replace(/\s+"/g, '"').replace(/="\s+/g, '="').replace(/(\s)+\/>/g, "/>").trim();
	}

	trim.trimSVG = trimSVG;
	return trim;
}

var hasRequiredCustom;

function requireCustom () {
	if (hasRequiredCustom) return custom;
	hasRequiredCustom = 1;

	const createDebugger = requireSrc();
	const loader_utils = requireUtils();
	const svg_trim = requireTrim();
	requireBuild();
	requireDefaults$1();
	requireDefaults();
	requireSize();
	requireDefs();

	function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

	const createDebugger__default = /*#__PURE__*/_interopDefaultCompat(createDebugger);

	const debug = createDebugger__default("@iconify-loader:custom");
	async function getCustomIcon(custom, collection, icon, options) {
	  let result;
	  debug(`${collection}:${icon}`);
	  try {
	    if (typeof custom === "function") {
	      result = await custom(icon);
	    } else {
	      const inline = custom[icon];
	      result = typeof inline === "function" ? await inline() : inline;
	    }
	  } catch (err) {
	    console.warn(
	      `Failed to load custom icon "${icon}" in "${collection}":`,
	      err
	    );
	    return;
	  }
	  if (result) {
	    const cleanupIdx = result.indexOf("<svg");
	    if (cleanupIdx > 0)
	      result = result.slice(cleanupIdx);
	    const { transform } = options?.customizations ?? {};
	    result = typeof transform === "function" ? await transform(result, collection, icon) : result;
	    if (!result.startsWith("<svg")) {
	      console.warn(
	        `Custom icon "${icon}" in "${collection}" is not a valid SVG`
	      );
	      return result;
	    }
	    return await loader_utils.mergeIconProps(
	      options?.customizations?.trimCustomSvg === true ? svg_trim.trimSVG(result) : result,
	      collection,
	      icon,
	      options,
	      void 0
	    );
	  }
	}

	custom.getCustomIcon = getCustomIcon;
	return custom;
}

var hasRequiredLoader;

function requireLoader () {
	if (hasRequiredLoader) return loader;
	hasRequiredLoader = 1;

	const loader_custom = requireCustom();
	const loader_modern = requireModern();
	requireSrc();
	requireUtils();
	requireBuild();
	requireDefaults$1();
	requireDefaults();
	requireSize();
	requireDefs();
	requireTrim();
	requireGetIcon();
	requireMerge();
	requireTransformations();
	requireTree();

	const loadIcon = async (collection, icon, options) => {
	  const custom = options?.customCollections?.[collection];
	  if (custom) {
	    if (typeof custom === "function") {
	      let result;
	      try {
	        result = await custom(icon);
	      } catch (err) {
	        console.warn(
	          `Failed to load custom icon "${icon}" in "${collection}":`,
	          err
	        );
	        return;
	      }
	      if (result) {
	        if (typeof result === "string") {
	          return await loader_custom.getCustomIcon(
	            () => result,
	            collection,
	            icon,
	            options
	          );
	        }
	        if ("icons" in result) {
	          const ids = [
	            icon,
	            icon.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
	            icon.replace(/([a-z])(\d+)/g, "$1-$2")
	          ];
	          return await loader_modern.searchForIcon(
	            result,
	            collection,
	            ids,
	            options
	          );
	        }
	      }
	    } else {
	      return await loader_custom.getCustomIcon(custom, collection, icon, options);
	    }
	  }
	};

	loader.loadIcon = loadIcon;
	return loader;
}

var hasRequiredNodeLoader;

function requireNodeLoader () {
	if (hasRequiredNodeLoader) return nodeLoader;
	hasRequiredNodeLoader = 1;

	const loader_modern = requireModern();
	const loader_fs = requireFs();
	const loader_warn = requireWarn();
	const loader_loader = requireLoader();
	const loader_utils = requireUtils();
	requireBuild();
	requireDefaults$1();
	requireDefaults();
	requireSize();
	requireDefs();
	requireGetIcon();
	requireMerge();
	requireTransformations();
	requireTree();
	requireSrc();

	requireDist$2();
	requireInstallPkg();
	requireDist$1();
	requireDist();
	requireCjs();
	requireDist$3();
	requireCustom();
	requireTrim();

	const loadNodeIcon = async (collection, icon, options) => {
	  let result = await loader_loader.loadIcon(collection, icon, options);
	  if (result) {
	    return result;
	  }
	  const iconSet = await loader_fs.loadCollectionFromFS(
	    collection,
	    options?.autoInstall,
	    void 0,
	    options?.cwd
	  );
	  if (iconSet) {
	    result = await loader_modern.searchForIcon(
	      iconSet,
	      collection,
	      loader_utils.getPossibleIconNames(icon),
	      options
	    );
	  }
	  if (!result && options?.warn) {
	    loader_warn.warnOnce(`failed to load ${options.warn} icon`);
	  }
	  return result;
	};

	nodeLoader.loadNodeIcon = loadNodeIcon;
	return nodeLoader;
}

Object.defineProperty(dist$h, '__esModule', { value: true });

const cdn = presetIcons_DDHG4xNZ;
const core$6 = presetIcons_De8FRNb6;



async function createNodeLoader() {
  try {
    return await import('@iconify/utils/lib/loader/node-loader').then((i) => i?.loadNodeIcon);
  } catch {
  }
  try {
    return requireNodeLoader().loadNodeIcon;
  } catch {
  }
}
const presetIcons = /* @__PURE__ */ core$6.createPresetIcons(async (options) => {
  const {
    cdn: cdn$1
  } = options;
  const loaders = [];
  const {
    isNode,
    isVSCode,
    isESLint
  } = core$6.getEnvFlags();
  if (isNode && !isVSCode && !isESLint) {
    const nodeLoader = await createNodeLoader();
    if (nodeLoader !== void 0)
      loaders.push(nodeLoader);
  }
  if (cdn$1)
    loaders.push(cdn.createCDNLoader(cdn$1));
  loaders.push(core$6.loadIcon);
  return core$6.combineLoaders(loaders);
});

dist$h.combineLoaders = core$6.combineLoaders;
dist$h.createCDNFetchLoader = core$6.createCDNFetchLoader;
dist$h.createPresetIcons = core$6.createPresetIcons;
dist$h.getEnvFlags = core$6.getEnvFlags;
dist$h.icons = core$6.icons;
dist$h.default = presetIcons;
dist$h.presetIcons = presetIcons;

var dist$5 = {};

Object.defineProperty(dist$5, '__esModule', { value: true });

const core$5 = dist$p;

const LAYER_IMPORTS = "imports";

function createBunnyFontsProvider(name, host) {
  return {
    name,
    getImportUrl(fonts) {
      const fontFamilies = fonts.map((font) => {
        const { name: name2, weights, italic } = font;
        const formattedName = name2.toLowerCase().replace(/\s/g, "-");
        if (!weights?.length)
          return `${formattedName}${italic ? ":i" : ""}`;
        let weightsAsString = weights.map((weight) => weight.toString());
        const weightsHaveItalic = weightsAsString.some((weight) => weight.endsWith("i"));
        if (!weightsHaveItalic && italic)
          weightsAsString = weightsAsString.map((weight) => weight += "i");
        return `${formattedName}:${weightsAsString.join(",")}`;
      });
      return `${host}/css?family=${fontFamilies.join("|")}&display=swap`;
    }
  };
}
const BunnyFontsProvider = createBunnyFontsProvider(
  "bunny",
  "https://fonts.bunny.net"
);

function createGoogleCompatibleProvider(name, host) {
  return {
    name,
    getImportUrl(fonts) {
      const sort = (weights) => {
        const firstW = weights.map((w) => w[0]);
        const lastW = weights.map((w) => w[1]);
        return `${firstW.join(";")};${lastW.join(";")}`;
      };
      const strings = fonts.map((i) => {
        let name2 = i.name.replace(/\s+/g, "+");
        if (i.weights?.length) {
          name2 += i.italic ? `:ital,wght@${sort(i.weights.map((w) => [`0,${w}`, `1,${w}`]))}` : `:wght@${i.weights.join(";")}`;
        }
        return `family=${name2}`;
      }).join("&");
      return `${host}/css2?${strings}&display=swap`;
    }
  };
}
const GoogleFontsProvider = createGoogleCompatibleProvider("google", "https://fonts.googleapis.com");

const FontshareProvider = createFontshareProvider("fontshare", "https://api.fontshare.com");
function createFontshareProvider(name, host) {
  return {
    name,
    getImportUrl(fonts) {
      const strings = fonts.map((f) => {
        let name2 = f.name.replace(/\s+/g, "-").toLocaleLowerCase();
        if (f.weights?.length)
          name2 += `@${f.weights.flatMap((w) => f.italic ? Number(w) + 1 : w).sort().join()}`;
        else
          name2 += `@${f.italic ? 2 : 1}`;
        return `f[]=${name2}`;
      }).join("&");
      return `${host}/v2/css?${strings}&display=swap`;
    }
  };
}

const NoneProvider = {
  name: "none",
  getPreflight() {
    return "";
  },
  getFontName(font) {
    return font.name;
  }
};

const builtinProviders = {
  google: GoogleFontsProvider,
  bunny: BunnyFontsProvider,
  fontshare: FontshareProvider,
  none: NoneProvider
};
function resolveProvider(provider) {
  if (typeof provider === "string")
    return builtinProviders[provider];
  return provider;
}
function normalizedFontMeta(meta, defaultProvider) {
  if (typeof meta !== "string") {
    meta.provider = resolveProvider(meta.provider || defaultProvider);
    if (meta.weights)
      meta.weights = [...new Set(meta.weights.sort((a, b) => a.toString().localeCompare(b.toString(), "en", { numeric: true })))];
    return meta;
  }
  const [name, weights = ""] = meta.split(":");
  return {
    name,
    weights: [...new Set(weights.split(/[,;]\s*/).filter(Boolean).sort((a, b) => a.localeCompare(b, "en", { numeric: true })))],
    provider: resolveProvider(defaultProvider)
  };
}
function createWebFontPreset(fetcher) {
  return (options = {}) => {
    const {
      provider: defaultProvider = "google",
      extendTheme = true,
      inlineImports = true,
      themeKey = "fontFamily",
      customFetch = fetcher
    } = options;
    const fontObject = Object.fromEntries(
      Object.entries(options.fonts || {}).map(([name, meta]) => [name, core$5.toArray(meta).map((m) => normalizedFontMeta(m, defaultProvider))])
    );
    const fonts = Object.values(fontObject).flatMap((i) => i);
    const importCache = {};
    async function importUrl(url) {
      if (inlineImports) {
        if (!importCache[url]) {
          importCache[url] = customFetch(url).catch((e) => {
            console.error("Failed to fetch web fonts");
            console.error(e);
            if (typeof process !== "undefined" && process.env.CI)
              throw e;
          });
        }
        return await importCache[url];
      } else {
        return `@import url('${url}');`;
      }
    }
    const enabledProviders = new Set(fonts.map((i) => i.provider));
    const preset = {
      name: "@unocss/preset-web-fonts",
      preflights: [
        {
          async getCSS() {
            const preflights = [];
            for (const provider of enabledProviders) {
              const fontsForProvider = fonts.filter((i) => i.provider.name === provider.name);
              if (provider.getImportUrl) {
                const url = provider.getImportUrl(fontsForProvider);
                if (url)
                  preflights.push(await importUrl(url));
              }
              preflights.push(provider.getPreflight?.(fontsForProvider));
            }
            return preflights.filter(Boolean).join("\n");
          },
          layer: inlineImports ? void 0 : LAYER_IMPORTS
        }
      ]
    };
    if (extendTheme) {
      preset.extendTheme = (theme) => {
        if (!theme[themeKey])
          theme[themeKey] = {};
        const obj = Object.fromEntries(
          Object.entries(fontObject).map(([name, fonts2]) => [name, fonts2.map((f) => f.provider.getFontName?.(f) ?? `"${f.name}"`)])
        );
        for (const key of Object.keys(obj)) {
          if (typeof theme[themeKey][key] === "string")
            theme[themeKey][key] = obj[key].map((i) => `${i},`).join("") + theme[themeKey][key];
          else
            theme[themeKey][key] = obj[key].join(",");
        }
      };
    }
    return preset;
  };
}

const userAgentWoff2 = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36";
const defaultFetch = async (url) => (await import('./chunks/index.mjs')).$fetch(url, { headers: { "User-Agent": userAgentWoff2 }, retry: 3 });
const presetWebFonts = core$5.definePreset(createWebFontPreset(defaultFetch));

dist$5.createGoogleProvider = createGoogleCompatibleProvider;
dist$5.default = presetWebFonts;
dist$5.normalizedFontMeta = normalizedFontMeta;

var dist$4 = {};

Object.defineProperty(dist$4, '__esModule', { value: true });

const core$4 = dist$p;

function DEFAULT(theme) {
  return {
    "h1,h2,h3,h4,h5,h6": {
      "color": "var(--un-prose-headings)",
      "font-weight": "600",
      "line-height": 1.25
    },
    "a": {
      "color": "var(--un-prose-links)",
      "text-decoration": "underline",
      "font-weight": "500"
    },
    "a code": {
      color: "var(--un-prose-links)"
    },
    "p,ul,ol,pre": {
      "margin": "1em 0",
      "line-height": 1.75
    },
    "blockquote": {
      "margin": "1em 0",
      "padding-left": "1em",
      "font-style": "italic",
      "border-left": ".25em solid var(--un-prose-borders)"
    },
    // taking 16px as a base, we scale h1, h2, h3, and h4 like
    // 16 (base) > 18 (h4) > 22 (h3) > 28 (h2) > 36 (h1)
    "h1": {
      "margin": "1rem 0",
      // h1 is always at the top of the page, so only margin 1 * root font size
      "font-size": "2.25em"
    },
    "h2": {
      "margin": "1.75em 0 .5em",
      "font-size": "1.75em"
    },
    "h3": {
      "margin": "1.5em 0 .5em",
      "font-size": "1.375em"
    },
    "h4": {
      "margin": "1em 0",
      "font-size": "1.125em"
    },
    "img,video": {
      "max-width": "100%"
    },
    "figure,picture": {
      margin: "1em 0"
    },
    "figcaption": {
      "color": "var(--un-prose-captions)",
      "font-size": ".875em"
    },
    "code": {
      "color": "var(--un-prose-code)",
      "font-size": ".875em",
      "font-weight": 600,
      "font-family": theme.fontFamily?.mono
    },
    ":not(pre) > code::before,:not(pre) > code::after": {
      content: '"`"'
    },
    "pre": {
      "padding": "1.25rem 1.5rem",
      "overflow-x": "auto",
      "border-radius": ".375rem"
    },
    "pre,code": {
      "white-space": "pre",
      "word-spacing": "normal",
      "word-break": "normal",
      "word-wrap": "normal",
      "-moz-tab-size": 4,
      "-o-tab-size": 4,
      "tab-size": 4,
      "-webkit-hyphens": "none",
      "-moz-hyphens": "none",
      "hyphens": "none",
      "background": "transparent"
    },
    "pre code": {
      "font-weight": "inherit"
    },
    "ol,ul": {
      "padding-left": "1.25em"
    },
    "ol": {
      "list-style-type": "decimal"
    },
    'ol[type="A"]': {
      "list-style-type": "upper-alpha"
    },
    'ol[type="a"]': {
      "list-style-type": "lower-alpha"
    },
    'ol[type="A" s]': {
      "list-style-type": "upper-alpha"
    },
    'ol[type="a" s]': {
      "list-style-type": "lower-alpha"
    },
    'ol[type="I"]': {
      "list-style-type": "upper-roman"
    },
    'ol[type="i"]': {
      "list-style-type": "lower-roman"
    },
    'ol[type="I" s]': {
      "list-style-type": "upper-roman"
    },
    'ol[type="i" s]': {
      "list-style-type": "lower-roman"
    },
    'ol[type="1"]': {
      "list-style-type": "decimal"
    },
    "ul": {
      "list-style-type": "disc"
    },
    "ol > li::marker,ul > li::marker,summary::marker": {
      color: "var(--un-prose-lists)"
    },
    "hr": {
      margin: "2em 0",
      border: "1px solid var(--un-prose-hr)"
    },
    "table": {
      "display": "block",
      "margin": "1em 0",
      "border-collapse": "collapse",
      "overflow-x": "auto"
    },
    "tr:nth-child(2n)": {
      background: "var(--un-prose-bg-soft)"
    },
    "td,th": {
      border: "1px solid var(--un-prose-borders)",
      padding: ".625em 1em"
    },
    "abbr": {
      cursor: "help"
    },
    "kbd": {
      "color": "var(--un-prose-code)",
      "border": "1px solid",
      "padding": ".25rem .5rem",
      "font-size": ".875em",
      "border-radius": ".25rem"
    },
    "details": {
      margin: "1em 0",
      padding: "1.25rem 1.5rem",
      background: "var(--un-prose-bg-soft)"
    },
    "summary": {
      "cursor": "pointer",
      "font-weight": "600"
    }
  };
}

function getCSS(options) {
  let css = "";
  const { escapedSelector, selectorName, preflights, compatibility } = options;
  const disableNotUtility = compatibility?.noColonNot || compatibility?.noColonWhere;
  for (const selector in preflights) {
    const cssDeclarationBlock = preflights[selector];
    const notProseSelector = `:not(:where(.not-${selectorName},.not-${selectorName} *))`;
    const pseudoCSSMatchArray = selector.split(",").map((s) => {
      const match = s.match(/::?(?:[\(\)\:\-\d\w]+)$/g);
      if (match) {
        const matchStr = match[0];
        s = s.replace(matchStr, "");
        return escapedSelector.map((e) => disableNotUtility ? `${e} ${s}${matchStr}` : `${e} :where(${s})${notProseSelector}${matchStr}`).join(",");
      }
      return null;
    }).filter((v) => v);
    if (pseudoCSSMatchArray.length) {
      css += pseudoCSSMatchArray.join(",");
    } else {
      css += escapedSelector.map((e) => disableNotUtility ? selector.split(",").map((s) => `${e} ${s}`).join(",") : `${e} :where(${selector})${notProseSelector}`).join(",");
    }
    css += "{";
    for (const k in cssDeclarationBlock) {
      const v = cssDeclarationBlock[k];
      css += `${k}:${v};`;
    }
    css += "}";
  }
  return css;
}
function getPreflights(context, options) {
  const { escapedSelectors, selectorName, cssExtend, compatibility } = options;
  let escapedSelector = Array.from(escapedSelectors);
  if (!escapedSelector[escapedSelector.length - 1].startsWith(".") && !compatibility?.noColonIs)
    escapedSelector = [`:is(${escapedSelector[escapedSelector.length - 1]},.${selectorName})`];
  if (cssExtend)
    return getCSS({ escapedSelector, selectorName, preflights: core$4.mergeDeep(DEFAULT(context.theme), cssExtend), compatibility });
  return getCSS({ escapedSelector, selectorName, preflights: DEFAULT(context.theme), compatibility });
}

const presetTypography = core$4.definePreset((options) => {
  if (options?.className) {
    console.warn('[unocss:preset-typography] "className" is deprecated. Use "selectorName" instead.');
  }
  const escapedSelectors = /* @__PURE__ */ new Set();
  const selectorName = options?.selectorName || options?.className || "prose";
  const selectorNameRE = new RegExp(`^${selectorName}$`);
  const colorsRE = new RegExp(`^${selectorName}-([-\\w]+)$`);
  const invertRE = new RegExp(`^${selectorName}-invert$`);
  const compatibility = options?.compatibility;
  return {
    name: "@unocss/preset-typography",
    enforce: "post",
    layers: { typography: -20 },
    rules: [
      [
        selectorNameRE,
        (_, { rawSelector }) => {
          escapedSelectors.add(core$4.toEscapedSelector(rawSelector));
          return { "color": "var(--un-prose-body)", "max-width": "65ch" };
        },
        { layer: "typography" }
      ],
      [
        colorsRE,
        ([, color], { theme }) => {
          const baseColor = theme.colors?.[color];
          if (baseColor == null)
            return;
          const colorObject = typeof baseColor === "object" ? baseColor : {};
          return {
            "--un-prose-body": colorObject[700] ?? baseColor,
            "--un-prose-headings": colorObject[900] ?? baseColor,
            "--un-prose-links": colorObject[900] ?? baseColor,
            "--un-prose-lists": colorObject[400] ?? baseColor,
            "--un-prose-hr": colorObject[200] ?? baseColor,
            "--un-prose-captions": colorObject[500] ?? baseColor,
            "--un-prose-code": colorObject[900] ?? baseColor,
            "--un-prose-borders": colorObject[200] ?? baseColor,
            "--un-prose-bg-soft": colorObject[100] ?? baseColor,
            // invert colors (dark mode)
            "--un-prose-invert-body": colorObject[200] ?? baseColor,
            "--un-prose-invert-headings": colorObject[100] ?? baseColor,
            "--un-prose-invert-links": colorObject[100] ?? baseColor,
            "--un-prose-invert-lists": colorObject[500] ?? baseColor,
            "--un-prose-invert-hr": colorObject[700] ?? baseColor,
            "--un-prose-invert-captions": colorObject[400] ?? baseColor,
            "--un-prose-invert-code": colorObject[100] ?? baseColor,
            "--un-prose-invert-borders": colorObject[700] ?? baseColor,
            "--un-prose-invert-bg-soft": colorObject[800] ?? baseColor
          };
        },
        { layer: "typography" }
      ],
      [
        invertRE,
        () => {
          return {
            "--un-prose-body": "var(--un-prose-invert-body)",
            "--un-prose-headings": "var(--un-prose-invert-headings)",
            "--un-prose-links": "var(--un-prose-invert-links)",
            "--un-prose-lists": "var(--un-prose-invert-lists)",
            "--un-prose-hr": "var(--un-prose-invert-hr)",
            "--un-prose-captions": "var(--un-prose-invert-captions)",
            "--un-prose-code": "var(--un-prose-invert-code)",
            "--un-prose-borders": "var(--un-prose-invert-borders)",
            "--un-prose-bg-soft": "var(--un-prose-invert-bg-soft)"
          };
        },
        { layer: "typography" }
      ]
    ],
    preflights: [
      {
        layer: "typography",
        getCSS: (context) => {
          if (escapedSelectors.size > 0) {
            const cssExtend = typeof options?.cssExtend === "function" ? options.cssExtend(context.theme) : options?.cssExtend;
            return getPreflights(context, { escapedSelectors, selectorName, cssExtend, compatibility });
          }
        }
      }
    ]
  };
});

dist$4.default = presetTypography;
dist$4.presetTypography = presetTypography;

var dist$3 = {};

var cjs = {};

var tokenizer$2 = {};

var types$T = {};

// CSS Syntax Module Level 3
// https://www.w3.org/TR/css-syntax-3/
const EOF$1 = 0;                 // <EOF-token>
const Ident = 1;               // <ident-token>
const Function$3 = 2;            // <function-token>
const AtKeyword = 3;           // <at-keyword-token>
const Hash$3 = 4;                // <hash-token>
const String$2 = 5;              // <string-token>
const BadString = 6;           // <bad-string-token>
const Url$3 = 7;                 // <url-token>
const BadUrl = 8;              // <bad-url-token>
const Delim = 9;               // <delim-token>
const Number$2 = 10;             // <number-token>
const Percentage$3 = 11;         // <percentage-token>
const Dimension$3 = 12;          // <dimension-token>
const WhiteSpace$3 = 13;         // <whitespace-token>
const CDO$3 = 14;                // <CDO-token>
const CDC$3 = 15;                // <CDC-token>
const Colon = 16;              // <colon-token>     :
const Semicolon = 17;          // <semicolon-token> ;
const Comma = 18;              // <comma-token>     ,
const LeftSquareBracket = 19;  // <[-token>
const RightSquareBracket = 20; // <]-token>
const LeftParenthesis = 21;    // <(-token>
const RightParenthesis = 22;   // <)-token>
const LeftCurlyBracket = 23;   // <{-token>
const RightCurlyBracket = 24;  // <}-token>
const Comment$3 = 25;

types$T.AtKeyword = AtKeyword;
types$T.BadString = BadString;
types$T.BadUrl = BadUrl;
types$T.CDC = CDC$3;
types$T.CDO = CDO$3;
types$T.Colon = Colon;
types$T.Comma = Comma;
types$T.Comment = Comment$3;
types$T.Delim = Delim;
types$T.Dimension = Dimension$3;
types$T.EOF = EOF$1;
types$T.Function = Function$3;
types$T.Hash = Hash$3;
types$T.Ident = Ident;
types$T.LeftCurlyBracket = LeftCurlyBracket;
types$T.LeftParenthesis = LeftParenthesis;
types$T.LeftSquareBracket = LeftSquareBracket;
types$T.Number = Number$2;
types$T.Percentage = Percentage$3;
types$T.RightCurlyBracket = RightCurlyBracket;
types$T.RightParenthesis = RightParenthesis;
types$T.RightSquareBracket = RightSquareBracket;
types$T.Semicolon = Semicolon;
types$T.String = String$2;
types$T.Url = Url$3;
types$T.WhiteSpace = WhiteSpace$3;

var charCodeDefinitions$c = {};

const EOF = 0;

// https://drafts.csswg.org/css-syntax-3/
// § 4.2. Definitions

// digit
// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
function isDigit(code) {
    return code >= 0x0030 && code <= 0x0039;
}

// hex digit
// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
function isHexDigit(code) {
    return (
        isDigit(code) || // 0 .. 9
        (code >= 0x0041 && code <= 0x0046) || // A .. F
        (code >= 0x0061 && code <= 0x0066)    // a .. f
    );
}

// uppercase letter
// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
function isUppercaseLetter(code) {
    return code >= 0x0041 && code <= 0x005A;
}

// lowercase letter
// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
function isLowercaseLetter(code) {
    return code >= 0x0061 && code <= 0x007A;
}

// letter
// An uppercase letter or a lowercase letter.
function isLetter(code) {
    return isUppercaseLetter(code) || isLowercaseLetter(code);
}

// non-ASCII code point
// A code point with a value equal to or greater than U+0080 <control>.
function isNonAscii(code) {
    return code >= 0x0080;
}

// name-start code point
// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
function isNameStart(code) {
    return isLetter(code) || isNonAscii(code) || code === 0x005F;
}

// name code point
// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
function isName(code) {
    return isNameStart(code) || isDigit(code) || code === 0x002D;
}

// non-printable code point
// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
function isNonPrintable(code) {
    return (
        (code >= 0x0000 && code <= 0x0008) ||
        (code === 0x000B) ||
        (code >= 0x000E && code <= 0x001F) ||
        (code === 0x007F)
    );
}

// newline
// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
// as they are converted to U+000A LINE FEED during preprocessing.
// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
function isNewline(code) {
    return code === 0x000A || code === 0x000D || code === 0x000C;
}

// whitespace
// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
function isWhiteSpace(code) {
    return isNewline(code) || code === 0x0020 || code === 0x0009;
}

// § 4.3.8. Check if two code points are a valid escape
function isValidEscape(first, second) {
    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
    if (first !== 0x005C) {
        return false;
    }

    // Otherwise, if the second code point is a newline or EOF, return false.
    if (isNewline(second) || second === EOF) {
        return false;
    }

    // Otherwise, return true.
    return true;
}

// § 4.3.9. Check if three code points would start an identifier
function isIdentifierStart(first, second, third) {
    // Look at the first code point:

    // U+002D HYPHEN-MINUS
    if (first === 0x002D) {
        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
        // or the second and third code points are a valid escape, return true. Otherwise, return false.
        return (
            isNameStart(second) ||
            second === 0x002D ||
            isValidEscape(second, third)
        );
    }

    // name-start code point
    if (isNameStart(first)) {
        // Return true.
        return true;
    }

    // U+005C REVERSE SOLIDUS (\)
    if (first === 0x005C) {
        // If the first and second code points are a valid escape, return true. Otherwise, return false.
        return isValidEscape(first, second);
    }

    // anything else
    // Return false.
    return false;
}

// § 4.3.10. Check if three code points would start a number
function isNumberStart(first, second, third) {
    // Look at the first code point:

    // U+002B PLUS SIGN (+)
    // U+002D HYPHEN-MINUS (-)
    if (first === 0x002B || first === 0x002D) {
        // If the second code point is a digit, return true.
        if (isDigit(second)) {
            return 2;
        }

        // Otherwise, if the second code point is a U+002E FULL STOP (.)
        // and the third code point is a digit, return true.
        // Otherwise, return false.
        return second === 0x002E && isDigit(third) ? 3 : 0;
    }

    // U+002E FULL STOP (.)
    if (first === 0x002E) {
        // If the second code point is a digit, return true. Otherwise, return false.
        return isDigit(second) ? 2 : 0;
    }

    // digit
    if (isDigit(first)) {
        // Return true.
        return 1;
    }

    // anything else
    // Return false.
    return 0;
}

//
// Misc
//

// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
function isBOM(code) {
    // UTF-16BE
    if (code === 0xFEFF) {
        return 1;
    }

    // UTF-16LE
    if (code === 0xFFFE) {
        return 1;
    }

    return 0;
}

// Fast code category
// Only ASCII code points has a special meaning, that's why we define a maps for 0..127 codes only
const CATEGORY = new Array(0x80);
const EofCategory = 0x80;
const WhiteSpaceCategory = 0x82;
const DigitCategory = 0x83;
const NameStartCategory = 0x84;
const NonPrintableCategory = 0x85;

for (let i = 0; i < CATEGORY.length; i++) {
    CATEGORY[i] =
        isWhiteSpace(i) && WhiteSpaceCategory ||
        isDigit(i) && DigitCategory ||
        isNameStart(i) && NameStartCategory ||
        isNonPrintable(i) && NonPrintableCategory ||
        i || EofCategory;
}

function charCodeCategory(code) {
    return code < 0x80 ? CATEGORY[code] : NameStartCategory;
}

charCodeDefinitions$c.DigitCategory = DigitCategory;
charCodeDefinitions$c.EofCategory = EofCategory;
charCodeDefinitions$c.NameStartCategory = NameStartCategory;
charCodeDefinitions$c.NonPrintableCategory = NonPrintableCategory;
charCodeDefinitions$c.WhiteSpaceCategory = WhiteSpaceCategory;
charCodeDefinitions$c.charCodeCategory = charCodeCategory;
charCodeDefinitions$c.isBOM = isBOM;
charCodeDefinitions$c.isDigit = isDigit;
charCodeDefinitions$c.isHexDigit = isHexDigit;
charCodeDefinitions$c.isIdentifierStart = isIdentifierStart;
charCodeDefinitions$c.isLetter = isLetter;
charCodeDefinitions$c.isLowercaseLetter = isLowercaseLetter;
charCodeDefinitions$c.isName = isName;
charCodeDefinitions$c.isNameStart = isNameStart;
charCodeDefinitions$c.isNewline = isNewline;
charCodeDefinitions$c.isNonAscii = isNonAscii;
charCodeDefinitions$c.isNonPrintable = isNonPrintable;
charCodeDefinitions$c.isNumberStart = isNumberStart;
charCodeDefinitions$c.isUppercaseLetter = isUppercaseLetter;
charCodeDefinitions$c.isValidEscape = isValidEscape;
charCodeDefinitions$c.isWhiteSpace = isWhiteSpace;

var utils$9 = {};

const charCodeDefinitions$b = charCodeDefinitions$c;

function getCharCode(source, offset) {
    return offset < source.length ? source.charCodeAt(offset) : 0;
}

function getNewlineLength(source, offset, code) {
    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
        return 2;
    }

    return 1;
}

function cmpChar(testStr, offset, referenceCode) {
    let code = testStr.charCodeAt(offset);

    // code.toLowerCase() for A..Z
    if (charCodeDefinitions$b.isUppercaseLetter(code)) {
        code = code | 32;
    }

    return code === referenceCode;
}

function cmpStr(testStr, start, end, referenceStr) {
    if (end - start !== referenceStr.length) {
        return false;
    }

    if (start < 0 || end > testStr.length) {
        return false;
    }

    for (let i = start; i < end; i++) {
        const referenceCode = referenceStr.charCodeAt(i - start);
        let testCode = testStr.charCodeAt(i);

        // testCode.toLowerCase() for A..Z
        if (charCodeDefinitions$b.isUppercaseLetter(testCode)) {
            testCode = testCode | 32;
        }

        if (testCode !== referenceCode) {
            return false;
        }
    }

    return true;
}

function findWhiteSpaceStart(source, offset) {
    for (; offset >= 0; offset--) {
        if (!charCodeDefinitions$b.isWhiteSpace(source.charCodeAt(offset))) {
            break;
        }
    }

    return offset + 1;
}

function findWhiteSpaceEnd(source, offset) {
    for (; offset < source.length; offset++) {
        if (!charCodeDefinitions$b.isWhiteSpace(source.charCodeAt(offset))) {
            break;
        }
    }

    return offset;
}

function findDecimalNumberEnd(source, offset) {
    for (; offset < source.length; offset++) {
        if (!charCodeDefinitions$b.isDigit(source.charCodeAt(offset))) {
            break;
        }
    }

    return offset;
}

// § 4.3.7. Consume an escaped code point
function consumeEscaped(source, offset) {
    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
    // that the next input code point has already been verified to be part of a valid escape.
    offset += 2;

    // hex digit
    if (charCodeDefinitions$b.isHexDigit(getCharCode(source, offset - 1))) {
        // Consume as many hex digits as possible, but no more than 5.
        // Note that this means 1-6 hex digits have been consumed in total.
        for (const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
            if (!charCodeDefinitions$b.isHexDigit(getCharCode(source, offset))) {
                break;
            }
        }

        // If the next input code point is whitespace, consume it as well.
        const code = getCharCode(source, offset);
        if (charCodeDefinitions$b.isWhiteSpace(code)) {
            offset += getNewlineLength(source, offset, code);
        }
    }

    return offset;
}

// §4.3.11. Consume a name
// Note: This algorithm does not do the verification of the first few code points that are necessary
// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
// ensure that the stream starts with an identifier before calling this algorithm.
function consumeName(source, offset) {
    // Let result initially be an empty string.
    // Repeatedly consume the next input code point from the stream:
    for (; offset < source.length; offset++) {
        const code = source.charCodeAt(offset);

        // name code point
        if (charCodeDefinitions$b.isName(code)) {
            // Append the code point to result.
            continue;
        }

        // the stream starts with a valid escape
        if (charCodeDefinitions$b.isValidEscape(code, getCharCode(source, offset + 1))) {
            // Consume an escaped code point. Append the returned code point to result.
            offset = consumeEscaped(source, offset) - 1;
            continue;
        }

        // anything else
        // Reconsume the current input code point. Return result.
        break;
    }

    return offset;
}

// §4.3.12. Consume a number
function consumeNumber$1(source, offset) {
    let code = source.charCodeAt(offset);

    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
    // consume it and append it to repr.
    if (code === 0x002B || code === 0x002D) {
        code = source.charCodeAt(offset += 1);
    }

    // 3. While the next input code point is a digit, consume it and append it to repr.
    if (charCodeDefinitions$b.isDigit(code)) {
        offset = findDecimalNumberEnd(source, offset + 1);
        code = source.charCodeAt(offset);
    }

    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
    if (code === 0x002E && charCodeDefinitions$b.isDigit(source.charCodeAt(offset + 1))) {
        // 4.1 Consume them.
        // 4.2 Append them to repr.
        offset += 2;

        // 4.3 Set type to "number".
        // TODO

        // 4.4 While the next input code point is a digit, consume it and append it to repr.

        offset = findDecimalNumberEnd(source, offset);
    }

    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
    if (cmpChar(source, offset, 101 /* e */)) {
        let sign = 0;
        code = source.charCodeAt(offset + 1);

        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
        if (code === 0x002D || code === 0x002B) {
            sign = 1;
            code = source.charCodeAt(offset + 2);
        }

        // ... followed by a digit
        if (charCodeDefinitions$b.isDigit(code)) {
            // 5.1 Consume them.
            // 5.2 Append them to repr.

            // 5.3 Set type to "number".
            // TODO

            // 5.4 While the next input code point is a digit, consume it and append it to repr.
            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
        }
    }

    return offset;
}

// § 4.3.14. Consume the remnants of a bad url
// ... its sole use is to consume enough of the input stream to reach a recovery point
// where normal tokenizing can resume.
function consumeBadUrlRemnants(source, offset) {
    // Repeatedly consume the next input code point from the stream:
    for (; offset < source.length; offset++) {
        const code = source.charCodeAt(offset);

        // U+0029 RIGHT PARENTHESIS ())
        // EOF
        if (code === 0x0029) {
            // Return.
            offset++;
            break;
        }

        if (charCodeDefinitions$b.isValidEscape(code, getCharCode(source, offset + 1))) {
            // Consume an escaped code point.
            // Note: This allows an escaped right parenthesis ("\)") to be encountered
            // without ending the <bad-url-token>. This is otherwise identical to
            // the "anything else" clause.
            offset = consumeEscaped(source, offset);
        }
    }

    return offset;
}

// § 4.3.7. Consume an escaped code point
// Note: This algorithm assumes that escaped is valid without leading U+005C REVERSE SOLIDUS (\)
function decodeEscaped(escaped) {
    // Single char escaped that's not a hex digit
    if (escaped.length === 1 && !charCodeDefinitions$b.isHexDigit(escaped.charCodeAt(0))) {
        return escaped[0];
    }

    // Interpret the hex digits as a hexadecimal number.
    let code = parseInt(escaped, 16);

    if (
        (code === 0) ||                       // If this number is zero,
        (code >= 0xD800 && code <= 0xDFFF) || // or is for a surrogate,
        (code > 0x10FFFF)                     // or is greater than the maximum allowed code point
    ) {
        // ... return U+FFFD REPLACEMENT CHARACTER
        code = 0xFFFD;
    }

    // Otherwise, return the code point with that value.
    return String.fromCodePoint(code);
}

utils$9.cmpChar = cmpChar;
utils$9.cmpStr = cmpStr;
utils$9.consumeBadUrlRemnants = consumeBadUrlRemnants;
utils$9.consumeEscaped = consumeEscaped;
utils$9.consumeName = consumeName;
utils$9.consumeNumber = consumeNumber$1;
utils$9.decodeEscaped = decodeEscaped;
utils$9.findDecimalNumberEnd = findDecimalNumberEnd;
utils$9.findWhiteSpaceEnd = findWhiteSpaceEnd;
utils$9.findWhiteSpaceStart = findWhiteSpaceStart;
utils$9.getNewlineLength = getNewlineLength;

const tokenNames = [
    'EOF-token',
    'ident-token',
    'function-token',
    'at-keyword-token',
    'hash-token',
    'string-token',
    'bad-string-token',
    'url-token',
    'bad-url-token',
    'delim-token',
    'number-token',
    'percentage-token',
    'dimension-token',
    'whitespace-token',
    'CDO-token',
    'CDC-token',
    'colon-token',
    'semicolon-token',
    'comma-token',
    '[-token',
    ']-token',
    '(-token',
    ')-token',
    '{-token',
    '}-token'
];

var names$8 = tokenNames;

var OffsetToLocation$3 = {};

var adoptBuffer$3 = {};

const MIN_SIZE = 16 * 1024;

function adoptBuffer$2(buffer = null, size) {
    if (buffer === null || buffer.length < size) {
        return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
    }

    return buffer;
}

adoptBuffer$3.adoptBuffer = adoptBuffer$2;

const adoptBuffer$1 = adoptBuffer$3;
const charCodeDefinitions$a = charCodeDefinitions$c;

const N$4 = 10;
const F$2 = 12;
const R$2 = 13;

function computeLinesAndColumns(host) {
    const source = host.source;
    const sourceLength = source.length;
    const startOffset = source.length > 0 ? charCodeDefinitions$a.isBOM(source.charCodeAt(0)) : 0;
    const lines = adoptBuffer$1.adoptBuffer(host.lines, sourceLength);
    const columns = adoptBuffer$1.adoptBuffer(host.columns, sourceLength);
    let line = host.startLine;
    let column = host.startColumn;

    for (let i = startOffset; i < sourceLength; i++) {
        const code = source.charCodeAt(i);

        lines[i] = line;
        columns[i] = column++;

        if (code === N$4 || code === R$2 || code === F$2) {
            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$4) {
                i++;
                lines[i] = line;
                columns[i] = column;
            }

            line++;
            column = 1;
        }
    }

    lines[sourceLength] = line;
    columns[sourceLength] = column;

    host.lines = lines;
    host.columns = columns;
    host.computed = true;
}

let OffsetToLocation$2 = class OffsetToLocation {
    constructor() {
        this.lines = null;
        this.columns = null;
        this.computed = false;
    }
    setSource(source, startOffset = 0, startLine = 1, startColumn = 1) {
        this.source = source;
        this.startOffset = startOffset;
        this.startLine = startLine;
        this.startColumn = startColumn;
        this.computed = false;
    }
    getLocation(offset, filename) {
        if (!this.computed) {
            computeLinesAndColumns(this);
        }

        return {
            source: filename,
            offset: this.startOffset + offset,
            line: this.lines[offset],
            column: this.columns[offset]
        };
    }
    getLocationRange(start, end, filename) {
        if (!this.computed) {
            computeLinesAndColumns(this);
        }

        return {
            source: filename,
            start: {
                offset: this.startOffset + start,
                line: this.lines[start],
                column: this.columns[start]
            },
            end: {
                offset: this.startOffset + end,
                line: this.lines[end],
                column: this.columns[end]
            }
        };
    }
};

OffsetToLocation$3.OffsetToLocation = OffsetToLocation$2;

var TokenStream$4 = {};

const adoptBuffer = adoptBuffer$3;
const utils$8 = utils$9;
const names$7 = names$8;
const types$S = types$T;

const OFFSET_MASK = 0x00FFFFFF;
const TYPE_SHIFT = 24;
const balancePair$1 = new Map([
    [types$S.Function, types$S.RightParenthesis],
    [types$S.LeftParenthesis, types$S.RightParenthesis],
    [types$S.LeftSquareBracket, types$S.RightSquareBracket],
    [types$S.LeftCurlyBracket, types$S.RightCurlyBracket]
]);

let TokenStream$3 = class TokenStream {
    constructor(source, tokenize) {
        this.setSource(source, tokenize);
    }
    reset() {
        this.eof = false;
        this.tokenIndex = -1;
        this.tokenType = 0;
        this.tokenStart = this.firstCharOffset;
        this.tokenEnd = this.firstCharOffset;
    }
    setSource(source = '', tokenize = () => {}) {
        source = String(source || '');

        const sourceLength = source.length;
        const offsetAndType = adoptBuffer.adoptBuffer(this.offsetAndType, source.length + 1); // +1 because of eof-token
        const balance = adoptBuffer.adoptBuffer(this.balance, source.length + 1);
        let tokenCount = 0;
        let balanceCloseType = 0;
        let balanceStart = 0;
        let firstCharOffset = -1;

        // capture buffers
        this.offsetAndType = null;
        this.balance = null;

        tokenize(source, (type, start, end) => {
            switch (type) {
                default:
                    balance[tokenCount] = sourceLength;
                    break;

                case balanceCloseType: {
                    let balancePrev = balanceStart & OFFSET_MASK;
                    balanceStart = balance[balancePrev];
                    balanceCloseType = balanceStart >> TYPE_SHIFT;
                    balance[tokenCount] = balancePrev;
                    balance[balancePrev++] = tokenCount;
                    for (; balancePrev < tokenCount; balancePrev++) {
                        if (balance[balancePrev] === sourceLength) {
                            balance[balancePrev] = tokenCount;
                        }
                    }
                    break;
                }

                case types$S.LeftParenthesis:
                case types$S.Function:
                case types$S.LeftSquareBracket:
                case types$S.LeftCurlyBracket:
                    balance[tokenCount] = balanceStart;
                    balanceCloseType = balancePair$1.get(type);
                    balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
                    break;
            }

            offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | end;
            if (firstCharOffset === -1) {
                firstCharOffset = start;
            }
        });

        // finalize buffers
        offsetAndType[tokenCount] = (types$S.EOF << TYPE_SHIFT) | sourceLength; // <EOF-token>
        balance[tokenCount] = sourceLength;
        balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
        while (balanceStart !== 0) {
            const balancePrev = balanceStart & OFFSET_MASK;
            balanceStart = balance[balancePrev];
            balance[balancePrev] = sourceLength;
        }

        this.source = source;
        this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
        this.tokenCount = tokenCount;
        this.offsetAndType = offsetAndType;
        this.balance = balance;

        this.reset();
        this.next();
    }

    lookupType(offset) {
        offset += this.tokenIndex;

        if (offset < this.tokenCount) {
            return this.offsetAndType[offset] >> TYPE_SHIFT;
        }

        return types$S.EOF;
    }
    lookupOffset(offset) {
        offset += this.tokenIndex;

        if (offset < this.tokenCount) {
            return this.offsetAndType[offset - 1] & OFFSET_MASK;
        }

        return this.source.length;
    }
    lookupValue(offset, referenceStr) {
        offset += this.tokenIndex;

        if (offset < this.tokenCount) {
            return utils$8.cmpStr(
                this.source,
                this.offsetAndType[offset - 1] & OFFSET_MASK,
                this.offsetAndType[offset] & OFFSET_MASK,
                referenceStr
            );
        }

        return false;
    }
    getTokenStart(tokenIndex) {
        if (tokenIndex === this.tokenIndex) {
            return this.tokenStart;
        }

        if (tokenIndex > 0) {
            return tokenIndex < this.tokenCount
                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
        }

        return this.firstCharOffset;
    }
    substrToCursor(start) {
        return this.source.substring(start, this.tokenStart);
    }

    isBalanceEdge(pos) {
        return this.balance[this.tokenIndex] < pos;
    }
    isDelim(code, offset) {
        if (offset) {
            return (
                this.lookupType(offset) === types$S.Delim &&
                this.source.charCodeAt(this.lookupOffset(offset)) === code
            );
        }

        return (
            this.tokenType === types$S.Delim &&
            this.source.charCodeAt(this.tokenStart) === code
        );
    }

    skip(tokenCount) {
        let next = this.tokenIndex + tokenCount;

        if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
        } else {
            this.tokenIndex = this.tokenCount;
            this.next();
        }
    }
    next() {
        let next = this.tokenIndex + 1;

        if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.tokenEnd;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
        } else {
            this.eof = true;
            this.tokenIndex = this.tokenCount;
            this.tokenType = types$S.EOF;
            this.tokenStart = this.tokenEnd = this.source.length;
        }
    }
    skipSC() {
        while (this.tokenType === types$S.WhiteSpace || this.tokenType === types$S.Comment) {
            this.next();
        }
    }
    skipUntilBalanced(startToken, stopConsume) {
        let cursor = startToken;
        let balanceEnd;
        let offset;

        loop:
        for (; cursor < this.tokenCount; cursor++) {
            balanceEnd = this.balance[cursor];

            // stop scanning on balance edge that points to offset before start token
            if (balanceEnd < startToken) {
                break loop;
            }

            offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;

            // check stop condition
            switch (stopConsume(this.source.charCodeAt(offset))) {
                case 1: // just stop
                    break loop;

                case 2: // stop & included
                    cursor++;
                    break loop;

                default:
                    // fast forward to the end of balanced block
                    if (this.balance[balanceEnd] === cursor) {
                        cursor = balanceEnd;
                    }
            }
        }

        this.skip(cursor - this.tokenIndex);
    }

    forEachToken(fn) {
        for (let i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {
            const start = offset;
            const item = this.offsetAndType[i];
            const end = item & OFFSET_MASK;
            const type = item >> TYPE_SHIFT;

            offset = end;

            fn(type, start, end, i);
        }
    }
    dump() {
        const tokens = new Array(this.tokenCount);

        this.forEachToken((type, start, end, index) => {
            tokens[index] = {
                idx: index,
                type: names$7[type],
                chunk: this.source.substring(start, end),
                balance: this.balance[index]
            };
        });

        return tokens;
    }
};

TokenStream$4.TokenStream = TokenStream$3;

const types$R = types$T;
const charCodeDefinitions$9 = charCodeDefinitions$c;
const utils$7 = utils$9;
const names$6 = names$8;
const OffsetToLocation$1 = OffsetToLocation$3;
const TokenStream$2 = TokenStream$4;

function tokenize$1(source, onToken) {
    function getCharCode(offset) {
        return offset < sourceLength ? source.charCodeAt(offset) : 0;
    }

    // § 4.3.3. Consume a numeric token
    function consumeNumericToken() {
        // Consume a number and let number be the result.
        offset = utils$7.consumeNumber(source, offset);

        // If the next 3 input code points would start an identifier, then:
        if (charCodeDefinitions$9.isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
            // Consume a name. Set the <dimension-token>’s unit to the returned value.
            // Return the <dimension-token>.
            type = types$R.Dimension;
            offset = utils$7.consumeName(source, offset);
            return;
        }

        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
        if (getCharCode(offset) === 0x0025) {
            // Create a <percentage-token> with the same value as number, and return it.
            type = types$R.Percentage;
            offset++;
            return;
        }

        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
        type = types$R.Number;
    }

    // § 4.3.4. Consume an ident-like token
    function consumeIdentLikeToken() {
        const nameStartOffset = offset;

        // Consume a name, and let string be the result.
        offset = utils$7.consumeName(source, offset);

        // If string’s value is an ASCII case-insensitive match for "url",
        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
        if (utils$7.cmpStr(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
            // While the next two input code points are whitespace, consume the next input code point.
            offset = utils$7.findWhiteSpaceEnd(source, offset + 1);

            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
            // then create a <function-token> with its value set to string and return it.
            if (getCharCode(offset) === 0x0022 ||
                getCharCode(offset) === 0x0027) {
                type = types$R.Function;
                offset = nameStartOffset + 4;
                return;
            }

            // Otherwise, consume a url token, and return it.
            consumeUrlToken();
            return;
        }

        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
        // Create a <function-token> with its value set to string and return it.
        if (getCharCode(offset) === 0x0028) {
            type = types$R.Function;
            offset++;
            return;
        }

        // Otherwise, create an <ident-token> with its value set to string and return it.
        type = types$R.Ident;
    }

    // § 4.3.5. Consume a string token
    function consumeStringToken(endingCodePoint) {
        // This algorithm may be called with an ending code point, which denotes the code point
        // that ends the string. If an ending code point is not specified,
        // the current input code point is used.
        if (!endingCodePoint) {
            endingCodePoint = getCharCode(offset++);
        }

        // Initially create a <string-token> with its value set to the empty string.
        type = types$R.String;

        // Repeatedly consume the next input code point from the stream:
        for (; offset < source.length; offset++) {
            const code = source.charCodeAt(offset);

            switch (charCodeDefinitions$9.charCodeCategory(code)) {
                // ending code point
                case endingCodePoint:
                    // Return the <string-token>.
                    offset++;
                    return;

                    // EOF
                    // case EofCategory:
                    // This is a parse error. Return the <string-token>.
                    // return;

                // newline
                case charCodeDefinitions$9.WhiteSpaceCategory:
                    if (charCodeDefinitions$9.isNewline(code)) {
                        // This is a parse error. Reconsume the current input code point,
                        // create a <bad-string-token>, and return it.
                        offset += utils$7.getNewlineLength(source, offset, code);
                        type = types$R.BadString;
                        return;
                    }
                    break;

                // U+005C REVERSE SOLIDUS (\)
                case 0x005C:
                    // If the next input code point is EOF, do nothing.
                    if (offset === source.length - 1) {
                        break;
                    }

                    const nextCode = getCharCode(offset + 1);

                    // Otherwise, if the next input code point is a newline, consume it.
                    if (charCodeDefinitions$9.isNewline(nextCode)) {
                        offset += utils$7.getNewlineLength(source, offset + 1, nextCode);
                    } else if (charCodeDefinitions$9.isValidEscape(code, nextCode)) {
                        // Otherwise, (the stream starts with a valid escape) consume
                        // an escaped code point and append the returned code point to
                        // the <string-token>’s value.
                        offset = utils$7.consumeEscaped(source, offset) - 1;
                    }
                    break;

                // anything else
                // Append the current input code point to the <string-token>’s value.
            }
        }
    }

    // § 4.3.6. Consume a url token
    // Note: This algorithm assumes that the initial "url(" has already been consumed.
    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
    function consumeUrlToken() {
        // Initially create a <url-token> with its value set to the empty string.
        type = types$R.Url;

        // Consume as much whitespace as possible.
        offset = utils$7.findWhiteSpaceEnd(source, offset);

        // Repeatedly consume the next input code point from the stream:
        for (; offset < source.length; offset++) {
            const code = source.charCodeAt(offset);

            switch (charCodeDefinitions$9.charCodeCategory(code)) {
                // U+0029 RIGHT PARENTHESIS ())
                case 0x0029:
                    // Return the <url-token>.
                    offset++;
                    return;

                    // EOF
                    // case EofCategory:
                    // This is a parse error. Return the <url-token>.
                    // return;

                // whitespace
                case charCodeDefinitions$9.WhiteSpaceCategory:
                    // Consume as much whitespace as possible.
                    offset = utils$7.findWhiteSpaceEnd(source, offset);

                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
                    // consume it and return the <url-token>
                    // (if EOF was encountered, this is a parse error);
                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
                        if (offset < source.length) {
                            offset++;
                        }
                        return;
                    }

                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
                    // and return it.
                    offset = utils$7.consumeBadUrlRemnants(source, offset);
                    type = types$R.BadUrl;
                    return;

                // U+0022 QUOTATION MARK (")
                // U+0027 APOSTROPHE (')
                // U+0028 LEFT PARENTHESIS (()
                // non-printable code point
                case 0x0022:
                case 0x0027:
                case 0x0028:
                case charCodeDefinitions$9.NonPrintableCategory:
                    // This is a parse error. Consume the remnants of a bad url,
                    // create a <bad-url-token>, and return it.
                    offset = utils$7.consumeBadUrlRemnants(source, offset);
                    type = types$R.BadUrl;
                    return;

                // U+005C REVERSE SOLIDUS (\)
                case 0x005C:
                    // If the stream starts with a valid escape, consume an escaped code point and
                    // append the returned code point to the <url-token>’s value.
                    if (charCodeDefinitions$9.isValidEscape(code, getCharCode(offset + 1))) {
                        offset = utils$7.consumeEscaped(source, offset) - 1;
                        break;
                    }

                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
                    // create a <bad-url-token>, and return it.
                    offset = utils$7.consumeBadUrlRemnants(source, offset);
                    type = types$R.BadUrl;
                    return;

                // anything else
                // Append the current input code point to the <url-token>’s value.
            }
        }
    }

    // ensure source is a string
    source = String(source || '');

    const sourceLength = source.length;
    let start = charCodeDefinitions$9.isBOM(getCharCode(0));
    let offset = start;
    let type;

    // https://drafts.csswg.org/css-syntax-3/#consume-token
    // § 4.3.1. Consume a token
    while (offset < sourceLength) {
        const code = source.charCodeAt(offset);

        switch (charCodeDefinitions$9.charCodeCategory(code)) {
            // whitespace
            case charCodeDefinitions$9.WhiteSpaceCategory:
                // Consume as much whitespace as possible. Return a <whitespace-token>.
                type = types$R.WhiteSpace;
                offset = utils$7.findWhiteSpaceEnd(source, offset + 1);
                break;

            // U+0022 QUOTATION MARK (")
            case 0x0022:
                // Consume a string token and return it.
                consumeStringToken();
                break;

            // U+0023 NUMBER SIGN (#)
            case 0x0023:
                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
                if (charCodeDefinitions$9.isName(getCharCode(offset + 1)) || charCodeDefinitions$9.isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {
                    // Create a <hash-token>.
                    type = types$R.Hash;

                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
                    //     // TODO: set id flag
                    // }

                    // Consume a name, and set the <hash-token>’s value to the returned string.
                    offset = utils$7.consumeName(source, offset + 1);

                    // Return the <hash-token>.
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = types$R.Delim;
                    offset++;
                }

                break;

            // U+0027 APOSTROPHE (')
            case 0x0027:
                // Consume a string token and return it.
                consumeStringToken();
                break;

            // U+0028 LEFT PARENTHESIS (()
            case 0x0028:
                // Return a <(-token>.
                type = types$R.LeftParenthesis;
                offset++;
                break;

            // U+0029 RIGHT PARENTHESIS ())
            case 0x0029:
                // Return a <)-token>.
                type = types$R.RightParenthesis;
                offset++;
                break;

            // U+002B PLUS SIGN (+)
            case 0x002B:
                // If the input stream starts with a number, ...
                if (charCodeDefinitions$9.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    // ... reconsume the current input code point, consume a numeric token, and return it.
                    consumeNumericToken();
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = types$R.Delim;
                    offset++;
                }
                break;

            // U+002C COMMA (,)
            case 0x002C:
                // Return a <comma-token>.
                type = types$R.Comma;
                offset++;
                break;

            // U+002D HYPHEN-MINUS (-)
            case 0x002D:
                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
                if (charCodeDefinitions$9.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    consumeNumericToken();
                } else {
                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
                    if (getCharCode(offset + 1) === 0x002D &&
                        getCharCode(offset + 2) === 0x003E) {
                        type = types$R.CDC;
                        offset = offset + 3;
                    } else {
                        // Otherwise, if the input stream starts with an identifier, ...
                        if (charCodeDefinitions$9.isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                            // ... reconsume the current input code point, consume an ident-like token, and return it.
                            consumeIdentLikeToken();
                        } else {
                            // Otherwise, return a <delim-token> with its value set to the current input code point.
                            type = types$R.Delim;
                            offset++;
                        }
                    }
                }
                break;

            // U+002E FULL STOP (.)
            case 0x002E:
                // If the input stream starts with a number, ...
                if (charCodeDefinitions$9.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    // ... reconsume the current input code point, consume a numeric token, and return it.
                    consumeNumericToken();
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = types$R.Delim;
                    offset++;
                }

                break;

            // U+002F SOLIDUS (/)
            case 0x002F:
                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
                if (getCharCode(offset + 1) === 0x002A) {
                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
                    type = types$R.Comment;
                    offset = source.indexOf('*/', offset + 2);
                    offset = offset === -1 ? source.length : offset + 2;
                } else {
                    type = types$R.Delim;
                    offset++;
                }
                break;

            // U+003A COLON (:)
            case 0x003A:
                // Return a <colon-token>.
                type = types$R.Colon;
                offset++;
                break;

            // U+003B SEMICOLON (;)
            case 0x003B:
                // Return a <semicolon-token>.
                type = types$R.Semicolon;
                offset++;
                break;

            // U+003C LESS-THAN SIGN (<)
            case 0x003C:
                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
                if (getCharCode(offset + 1) === 0x0021 &&
                    getCharCode(offset + 2) === 0x002D &&
                    getCharCode(offset + 3) === 0x002D) {
                    // ... consume them and return a <CDO-token>.
                    type = types$R.CDO;
                    offset = offset + 4;
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = types$R.Delim;
                    offset++;
                }

                break;

            // U+0040 COMMERCIAL AT (@)
            case 0x0040:
                // If the next 3 input code points would start an identifier, ...
                if (charCodeDefinitions$9.isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
                    type = types$R.AtKeyword;
                    offset = utils$7.consumeName(source, offset + 1);
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = types$R.Delim;
                    offset++;
                }

                break;

            // U+005B LEFT SQUARE BRACKET ([)
            case 0x005B:
                // Return a <[-token>.
                type = types$R.LeftSquareBracket;
                offset++;
                break;

            // U+005C REVERSE SOLIDUS (\)
            case 0x005C:
                // If the input stream starts with a valid escape, ...
                if (charCodeDefinitions$9.isValidEscape(code, getCharCode(offset + 1))) {
                    // ... reconsume the current input code point, consume an ident-like token, and return it.
                    consumeIdentLikeToken();
                } else {
                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
                    type = types$R.Delim;
                    offset++;
                }
                break;

            // U+005D RIGHT SQUARE BRACKET (])
            case 0x005D:
                // Return a <]-token>.
                type = types$R.RightSquareBracket;
                offset++;
                break;

            // U+007B LEFT CURLY BRACKET ({)
            case 0x007B:
                // Return a <{-token>.
                type = types$R.LeftCurlyBracket;
                offset++;
                break;

            // U+007D RIGHT CURLY BRACKET (})
            case 0x007D:
                // Return a <}-token>.
                type = types$R.RightCurlyBracket;
                offset++;
                break;

            // digit
            case charCodeDefinitions$9.DigitCategory:
                // Reconsume the current input code point, consume a numeric token, and return it.
                consumeNumericToken();
                break;

            // name-start code point
            case charCodeDefinitions$9.NameStartCategory:
                // Reconsume the current input code point, consume an ident-like token, and return it.
                consumeIdentLikeToken();
                break;

                // EOF
                // case EofCategory:
                // Return an <EOF-token>.
                // break;

            // anything else
            default:
                // Return a <delim-token> with its value set to the current input code point.
                type = types$R.Delim;
                offset++;
        }

        // put token to stream
        onToken(type, start, start = offset);
    }
}

tokenizer$2.AtKeyword = types$R.AtKeyword;
tokenizer$2.BadString = types$R.BadString;
tokenizer$2.BadUrl = types$R.BadUrl;
tokenizer$2.CDC = types$R.CDC;
tokenizer$2.CDO = types$R.CDO;
tokenizer$2.Colon = types$R.Colon;
tokenizer$2.Comma = types$R.Comma;
tokenizer$2.Comment = types$R.Comment;
tokenizer$2.Delim = types$R.Delim;
tokenizer$2.Dimension = types$R.Dimension;
tokenizer$2.EOF = types$R.EOF;
tokenizer$2.Function = types$R.Function;
tokenizer$2.Hash = types$R.Hash;
tokenizer$2.Ident = types$R.Ident;
tokenizer$2.LeftCurlyBracket = types$R.LeftCurlyBracket;
tokenizer$2.LeftParenthesis = types$R.LeftParenthesis;
tokenizer$2.LeftSquareBracket = types$R.LeftSquareBracket;
tokenizer$2.Number = types$R.Number;
tokenizer$2.Percentage = types$R.Percentage;
tokenizer$2.RightCurlyBracket = types$R.RightCurlyBracket;
tokenizer$2.RightParenthesis = types$R.RightParenthesis;
tokenizer$2.RightSquareBracket = types$R.RightSquareBracket;
tokenizer$2.Semicolon = types$R.Semicolon;
tokenizer$2.String = types$R.String;
tokenizer$2.Url = types$R.Url;
tokenizer$2.WhiteSpace = types$R.WhiteSpace;
tokenizer$2.tokenTypes = types$R;
tokenizer$2.DigitCategory = charCodeDefinitions$9.DigitCategory;
tokenizer$2.EofCategory = charCodeDefinitions$9.EofCategory;
tokenizer$2.NameStartCategory = charCodeDefinitions$9.NameStartCategory;
tokenizer$2.NonPrintableCategory = charCodeDefinitions$9.NonPrintableCategory;
tokenizer$2.WhiteSpaceCategory = charCodeDefinitions$9.WhiteSpaceCategory;
tokenizer$2.charCodeCategory = charCodeDefinitions$9.charCodeCategory;
tokenizer$2.isBOM = charCodeDefinitions$9.isBOM;
tokenizer$2.isDigit = charCodeDefinitions$9.isDigit;
tokenizer$2.isHexDigit = charCodeDefinitions$9.isHexDigit;
tokenizer$2.isIdentifierStart = charCodeDefinitions$9.isIdentifierStart;
tokenizer$2.isLetter = charCodeDefinitions$9.isLetter;
tokenizer$2.isLowercaseLetter = charCodeDefinitions$9.isLowercaseLetter;
tokenizer$2.isName = charCodeDefinitions$9.isName;
tokenizer$2.isNameStart = charCodeDefinitions$9.isNameStart;
tokenizer$2.isNewline = charCodeDefinitions$9.isNewline;
tokenizer$2.isNonAscii = charCodeDefinitions$9.isNonAscii;
tokenizer$2.isNonPrintable = charCodeDefinitions$9.isNonPrintable;
tokenizer$2.isNumberStart = charCodeDefinitions$9.isNumberStart;
tokenizer$2.isUppercaseLetter = charCodeDefinitions$9.isUppercaseLetter;
tokenizer$2.isValidEscape = charCodeDefinitions$9.isValidEscape;
tokenizer$2.isWhiteSpace = charCodeDefinitions$9.isWhiteSpace;
tokenizer$2.cmpChar = utils$7.cmpChar;
tokenizer$2.cmpStr = utils$7.cmpStr;
tokenizer$2.consumeBadUrlRemnants = utils$7.consumeBadUrlRemnants;
tokenizer$2.consumeEscaped = utils$7.consumeEscaped;
tokenizer$2.consumeName = utils$7.consumeName;
tokenizer$2.consumeNumber = utils$7.consumeNumber;
tokenizer$2.decodeEscaped = utils$7.decodeEscaped;
tokenizer$2.findDecimalNumberEnd = utils$7.findDecimalNumberEnd;
tokenizer$2.findWhiteSpaceEnd = utils$7.findWhiteSpaceEnd;
tokenizer$2.findWhiteSpaceStart = utils$7.findWhiteSpaceStart;
tokenizer$2.getNewlineLength = utils$7.getNewlineLength;
tokenizer$2.tokenNames = names$6;
tokenizer$2.OffsetToLocation = OffsetToLocation$1.OffsetToLocation;
tokenizer$2.TokenStream = TokenStream$2.TokenStream;
tokenizer$2.tokenize = tokenize$1;

var create$7 = {};

var List$7 = {};

//
//                              list
//                            ┌──────┐
//             ┌──────────────┼─head │
//             │              │ tail─┼──────────────┐
//             │              └──────┘              │
//             ▼                                    ▼
//            item        item        item        item
//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
//          │ data │    │ data │    │ data │    │ data │
//          └──────┘    └──────┘    └──────┘    └──────┘
//

let releasedCursors = null;

let List$6 = class List {
    static createItem(data) {
        return {
            prev: null,
            next: null,
            data
        };
    }

    constructor() {
        this.head = null;
        this.tail = null;
        this.cursor = null;
    }
    createItem(data) {
        return List.createItem(data);
    }

    // cursor helpers
    allocateCursor(prev, next) {
        let cursor;

        if (releasedCursors !== null) {
            cursor = releasedCursors;
            releasedCursors = releasedCursors.cursor;
            cursor.prev = prev;
            cursor.next = next;
            cursor.cursor = this.cursor;
        } else {
            cursor = {
                prev,
                next,
                cursor: this.cursor
            };
        }

        this.cursor = cursor;

        return cursor;
    }
    releaseCursor() {
        const { cursor } = this;

        this.cursor = cursor.cursor;
        cursor.prev = null;
        cursor.next = null;
        cursor.cursor = releasedCursors;
        releasedCursors = cursor;
    }
    updateCursors(prevOld, prevNew, nextOld, nextNew) {
        let { cursor } = this;

        while (cursor !== null) {
            if (cursor.prev === prevOld) {
                cursor.prev = prevNew;
            }

            if (cursor.next === nextOld) {
                cursor.next = nextNew;
            }

            cursor = cursor.cursor;
        }
    }
    *[Symbol.iterator]() {
        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            yield cursor.data;
        }
    }

    // getters
    get size() {
        let size = 0;

        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            size++;
        }

        return size;
    }
    get isEmpty() {
        return this.head === null;
    }
    get first() {
        return this.head && this.head.data;
    }
    get last() {
        return this.tail && this.tail.data;
    }

    // convertors
    fromArray(array) {
        let cursor = null;
        this.head = null;

        for (let data of array) {
            const item = List.createItem(data);

            if (cursor !== null) {
                cursor.next = item;
            } else {
                this.head = item;
            }

            item.prev = cursor;
            cursor = item;
        }

        this.tail = cursor;
        return this;
    }
    toArray() {
        return [...this];
    }
    toJSON() {
        return [...this];
    }

    // array-like methods
    forEach(fn, thisArg = this) {
        // push cursor
        const cursor = this.allocateCursor(null, this.head);

        while (cursor.next !== null) {
            const item = cursor.next;
            cursor.next = item.next;
            fn.call(thisArg, item.data, item, this);
        }

        // pop cursor
        this.releaseCursor();
    }
    forEachRight(fn, thisArg = this) {
        // push cursor
        const cursor = this.allocateCursor(this.tail, null);

        while (cursor.prev !== null) {
            const item = cursor.prev;
            cursor.prev = item.prev;
            fn.call(thisArg, item.data, item, this);
        }

        // pop cursor
        this.releaseCursor();
    }
    reduce(fn, initialValue, thisArg = this) {
        // push cursor
        let cursor = this.allocateCursor(null, this.head);
        let acc = initialValue;
        let item;

        while (cursor.next !== null) {
            item = cursor.next;
            cursor.next = item.next;

            acc = fn.call(thisArg, acc, item.data, item, this);
        }

        // pop cursor
        this.releaseCursor();

        return acc;
    }
    reduceRight(fn, initialValue, thisArg = this) {
        // push cursor
        let cursor = this.allocateCursor(this.tail, null);
        let acc = initialValue;
        let item;

        while (cursor.prev !== null) {
            item = cursor.prev;
            cursor.prev = item.prev;

            acc = fn.call(thisArg, acc, item.data, item, this);
        }

        // pop cursor
        this.releaseCursor();

        return acc;
    }
    some(fn, thisArg = this) {
        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            if (fn.call(thisArg, cursor.data, cursor, this)) {
                return true;
            }
        }

        return false;
    }
    map(fn, thisArg = this) {
        const result = new List();

        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            result.appendData(fn.call(thisArg, cursor.data, cursor, this));
        }

        return result;
    }
    filter(fn, thisArg = this) {
        const result = new List();

        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            if (fn.call(thisArg, cursor.data, cursor, this)) {
                result.appendData(cursor.data);
            }
        }

        return result;
    }

    nextUntil(start, fn, thisArg = this) {
        if (start === null) {
            return;
        }

        // push cursor
        const cursor = this.allocateCursor(null, start);

        while (cursor.next !== null) {
            const item = cursor.next;
            cursor.next = item.next;
            if (fn.call(thisArg, item.data, item, this)) {
                break;
            }
        }

        // pop cursor
        this.releaseCursor();
    }
    prevUntil(start, fn, thisArg = this) {
        if (start === null) {
            return;
        }

        // push cursor
        const cursor = this.allocateCursor(start, null);

        while (cursor.prev !== null) {
            const item = cursor.prev;
            cursor.prev = item.prev;
            if (fn.call(thisArg, item.data, item, this)) {
                break;
            }
        }

        // pop cursor
        this.releaseCursor();
    }

    // mutation
    clear() {
        this.head = null;
        this.tail = null;
    }
    copy() {
        const result = new List();

        for (let data of this) {
            result.appendData(data);
        }

        return result;
    }
    prepend(item) {
        //      head
        //    ^
        // item
        this.updateCursors(null, item, this.head, item);

        // insert to the beginning of the list
        if (this.head !== null) {
            // new item <- first item
            this.head.prev = item;
            // new item -> first item
            item.next = this.head;
        } else {
            // if list has no head, then it also has no tail
            // in this case tail points to the new item
            this.tail = item;
        }

        // head always points to new item
        this.head = item;
        return this;
    }
    prependData(data) {
        return this.prepend(List.createItem(data));
    }
    append(item) {
        return this.insert(item);
    }
    appendData(data) {
        return this.insert(List.createItem(data));
    }
    insert(item, before = null) {
        if (before !== null) {
            // prev   before
            //      ^
            //     item
            this.updateCursors(before.prev, item, before, item);

            if (before.prev === null) {
                // insert to the beginning of list
                if (this.head !== before) {
                    throw new Error('before doesn\'t belong to list');
                }
                // since head points to before therefore list doesn't empty
                // no need to check tail
                this.head = item;
                before.prev = item;
                item.next = before;
                this.updateCursors(null, item);
            } else {
                // insert between two items
                before.prev.next = item;
                item.prev = before.prev;
                before.prev = item;
                item.next = before;
            }
        } else {
            // tail
            //      ^
            //      item
            this.updateCursors(this.tail, item, null, item);

            // insert to the ending of the list
            if (this.tail !== null) {
                // last item -> new item
                this.tail.next = item;
                // last item <- new item
                item.prev = this.tail;
            } else {
                // if list has no tail, then it also has no head
                // in this case head points to new item
                this.head = item;
            }

            // tail always points to new item
            this.tail = item;
        }

        return this;
    }
    insertData(data, before) {
        return this.insert(List.createItem(data), before);
    }
    remove(item) {
        //      item
        //       ^
        // prev     next
        this.updateCursors(item, item.prev, item, item.next);

        if (item.prev !== null) {
            item.prev.next = item.next;
        } else {
            if (this.head !== item) {
                throw new Error('item doesn\'t belong to list');
            }

            this.head = item.next;
        }

        if (item.next !== null) {
            item.next.prev = item.prev;
        } else {
            if (this.tail !== item) {
                throw new Error('item doesn\'t belong to list');
            }

            this.tail = item.prev;
        }

        item.prev = null;
        item.next = null;

        return item;
    }
    push(data) {
        this.insert(List.createItem(data));
    }
    pop() {
        return this.tail !== null ? this.remove(this.tail) : null;
    }
    unshift(data) {
        this.prepend(List.createItem(data));
    }
    shift() {
        return this.head !== null ? this.remove(this.head) : null;
    }
    prependList(list) {
        return this.insertList(list, this.head);
    }
    appendList(list) {
        return this.insertList(list);
    }
    insertList(list, before) {
        // ignore empty lists
        if (list.head === null) {
            return this;
        }

        if (before !== undefined && before !== null) {
            this.updateCursors(before.prev, list.tail, before, list.head);

            // insert in the middle of dist list
            if (before.prev !== null) {
                // before.prev <-> list.head
                before.prev.next = list.head;
                list.head.prev = before.prev;
            } else {
                this.head = list.head;
            }

            before.prev = list.tail;
            list.tail.next = before;
        } else {
            this.updateCursors(this.tail, list.tail, null, list.head);

            // insert to end of the list
            if (this.tail !== null) {
                // if destination list has a tail, then it also has a head,
                // but head doesn't change
                // dest tail -> source head
                this.tail.next = list.head;
                // dest tail <- source head
                list.head.prev = this.tail;
            } else {
                // if list has no a tail, then it also has no a head
                // in this case points head to new item
                this.head = list.head;
            }

            // tail always start point to new item
            this.tail = list.tail;
        }

        list.head = null;
        list.tail = null;
        return this;
    }
    replace(oldItem, newItemOrList) {
        if ('head' in newItemOrList) {
            this.insertList(newItemOrList, oldItem);
        } else {
            this.insert(newItemOrList, oldItem);
        }

        this.remove(oldItem);
    }
};

List$7.List = List$6;

var _SyntaxError$1 = {};

var createCustomError$4 = {};

function createCustomError$3(name, message) {
    // use Object.create(), because some VMs prevent setting line/column otherwise
    // (iOS Safari 10 even throws an exception)
    const error = Object.create(SyntaxError.prototype);
    const errorStack = new Error();

    return Object.assign(error, {
        name,
        message,
        get stack() {
            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, `${name}: ${message}\n`);
        }
    });
}

createCustomError$4.createCustomError = createCustomError$3;

const createCustomError$2 = createCustomError$4;

const MAX_LINE_LENGTH = 100;
const OFFSET_CORRECTION = 60;
const TAB_REPLACEMENT = '    ';

function sourceFragment({ source, line, column }, extraLines) {
    function processLines(start, end) {
        return lines
            .slice(start, end)
            .map((line, idx) =>
                String(start + idx + 1).padStart(maxNumLength) + ' |' + line
            ).join('\n');
    }

    const lines = source.split(/\r\n?|\n|\f/);
    const startLine = Math.max(1, line - extraLines) - 1;
    const endLine = Math.min(line + extraLines, lines.length + 1);
    const maxNumLength = Math.max(4, String(endLine).length) + 1;
    let cutLeft = 0;

    // column correction according to replaced tab before column
    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

    if (column > MAX_LINE_LENGTH) {
        cutLeft = column - OFFSET_CORRECTION + 3;
        column = OFFSET_CORRECTION - 2;
    }

    for (let i = startLine; i <= endLine; i++) {
        if (i >= 0 && i < lines.length) {
            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
            lines[i] =
                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
        }
    }

    return [
        processLines(startLine, line),
        new Array(column + maxNumLength + 2).join('-') + '^',
        processLines(line, endLine)
    ].filter(Boolean).join('\n');
}

function SyntaxError$5(message, source, offset, line, column) {
    const error = Object.assign(createCustomError$2.createCustomError('SyntaxError', message), {
        source,
        offset,
        line,
        column,
        sourceFragment(extraLines) {
            return sourceFragment({ source, line, column }, isNaN(extraLines) ? 0 : extraLines);
        },
        get formattedMessage() {
            return (
                `Parse error: ${message}\n` +
                sourceFragment({ source, line, column }, 2)
            );
        }
    });

    return error;
}

_SyntaxError$1.SyntaxError = SyntaxError$5;

var sequence$1 = {};

const types$Q = types$T;

function readSequence$1(recognizer) {
    const children = this.createList();
    let space = false;
    const context = {
        recognizer
    };

    while (!this.eof) {
        switch (this.tokenType) {
            case types$Q.Comment:
                this.next();
                continue;

            case types$Q.WhiteSpace:
                space = true;
                this.next();
                continue;
        }

        let child = recognizer.getNode.call(this, context);

        if (child === undefined) {
            break;
        }

        if (space) {
            if (recognizer.onWhiteSpace) {
                recognizer.onWhiteSpace.call(this, child, children, context);
            }
            space = false;
        }

        children.push(child);
    }

    if (space && recognizer.onWhiteSpace) {
        recognizer.onWhiteSpace.call(this, null, children, context);
    }

    return children;
}

sequence$1.readSequence = readSequence$1;

const List$5 = List$7;
const SyntaxError$4 = _SyntaxError$1;
const index$8 = tokenizer$2;
const sequence = sequence$1;
const OffsetToLocation = OffsetToLocation$3;
const TokenStream$1 = TokenStream$4;
const utils$6 = utils$9;
const types$P = types$T;
const names$5 = names$8;

const NOOP = () => {};
const EXCLAMATIONMARK$3 = 0x0021;  // U+0021 EXCLAMATION MARK (!)
const NUMBERSIGN$4 = 0x0023;       // U+0023 NUMBER SIGN (#)
const SEMICOLON = 0x003B;        // U+003B SEMICOLON (;)
const LEFTCURLYBRACKET$1 = 0x007B; // U+007B LEFT CURLY BRACKET ({)
const NULL = 0;

function createParseContext(name) {
    return function() {
        return this[name]();
    };
}

function fetchParseValues(dict) {
    const result = Object.create(null);

    for (const name in dict) {
        const item = dict[name];
        const fn = item.parse || item;

        if (fn) {
            result[name] = fn;
        }
    }

    return result;
}

function processConfig(config) {
    const parseConfig = {
        context: Object.create(null),
        scope: Object.assign(Object.create(null), config.scope),
        atrule: fetchParseValues(config.atrule),
        pseudo: fetchParseValues(config.pseudo),
        node: fetchParseValues(config.node)
    };

    for (const name in config.parseContext) {
        switch (typeof config.parseContext[name]) {
            case 'function':
                parseConfig.context[name] = config.parseContext[name];
                break;

            case 'string':
                parseConfig.context[name] = createParseContext(config.parseContext[name]);
                break;
        }
    }

    return {
        config: parseConfig,
        ...parseConfig,
        ...parseConfig.node
    };
}

function createParser(config) {
    let source = '';
    let filename = '<unknown>';
    let needPositions = false;
    let onParseError = NOOP;
    let onParseErrorThrow = false;

    const locationMap = new OffsetToLocation.OffsetToLocation();
    const parser = Object.assign(new TokenStream$1.TokenStream(), processConfig(config || {}), {
        parseAtrulePrelude: true,
        parseRulePrelude: true,
        parseValue: true,
        parseCustomProperty: false,

        readSequence: sequence.readSequence,

        consumeUntilBalanceEnd: () => 0,
        consumeUntilLeftCurlyBracket(code) {
            return code === LEFTCURLYBRACKET$1 ? 1 : 0;
        },
        consumeUntilLeftCurlyBracketOrSemicolon(code) {
            return code === LEFTCURLYBRACKET$1 || code === SEMICOLON ? 1 : 0;
        },
        consumeUntilExclamationMarkOrSemicolon(code) {
            return code === EXCLAMATIONMARK$3 || code === SEMICOLON ? 1 : 0;
        },
        consumeUntilSemicolonIncluded(code) {
            return code === SEMICOLON ? 2 : 0;
        },

        createList() {
            return new List$5.List();
        },
        createSingleNodeList(node) {
            return new List$5.List().appendData(node);
        },
        getFirstListNode(list) {
            return list && list.first;
        },
        getLastListNode(list) {
            return list && list.last;
        },

        parseWithFallback(consumer, fallback) {
            const startToken = this.tokenIndex;

            try {
                return consumer.call(this);
            } catch (e) {
                if (onParseErrorThrow) {
                    throw e;
                }

                const fallbackNode = fallback.call(this, startToken);

                onParseErrorThrow = true;
                onParseError(e, fallbackNode);
                onParseErrorThrow = false;

                return fallbackNode;
            }
        },

        lookupNonWSType(offset) {
            let type;

            do {
                type = this.lookupType(offset++);
                if (type !== types$P.WhiteSpace) {
                    return type;
                }
            } while (type !== NULL);

            return NULL;
        },

        charCodeAt(offset) {
            return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;
        },
        substring(offsetStart, offsetEnd) {
            return source.substring(offsetStart, offsetEnd);
        },
        substrToCursor(start) {
            return this.source.substring(start, this.tokenStart);
        },

        cmpChar(offset, charCode) {
            return utils$6.cmpChar(source, offset, charCode);
        },
        cmpStr(offsetStart, offsetEnd, str) {
            return utils$6.cmpStr(source, offsetStart, offsetEnd, str);
        },

        consume(tokenType) {
            const start = this.tokenStart;

            this.eat(tokenType);

            return this.substrToCursor(start);
        },
        consumeFunctionName() {
            const name = source.substring(this.tokenStart, this.tokenEnd - 1);

            this.eat(types$P.Function);

            return name;
        },
        consumeNumber(type) {
            const number = source.substring(this.tokenStart, utils$6.consumeNumber(source, this.tokenStart));

            this.eat(type);

            return number;
        },

        eat(tokenType) {
            if (this.tokenType !== tokenType) {
                const tokenName = names$5[tokenType].slice(0, -6).replace(/-/g, ' ').replace(/^./, m => m.toUpperCase());
                let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
                let offset = this.tokenStart;

                // tweak message and offset
                switch (tokenType) {
                    case types$P.Ident:
                        // when identifier is expected but there is a function or url
                        if (this.tokenType === types$P.Function || this.tokenType === types$P.Url) {
                            offset = this.tokenEnd - 1;
                            message = 'Identifier is expected but function found';
                        } else {
                            message = 'Identifier is expected';
                        }
                        break;

                    case types$P.Hash:
                        if (this.isDelim(NUMBERSIGN$4)) {
                            this.next();
                            offset++;
                            message = 'Name is expected';
                        }
                        break;

                    case types$P.Percentage:
                        if (this.tokenType === types$P.Number) {
                            offset = this.tokenEnd;
                            message = 'Percent sign is expected';
                        }
                        break;
                }

                this.error(message, offset);
            }

            this.next();
        },
        eatIdent(name) {
            if (this.tokenType !== types$P.Ident || this.lookupValue(0, name) === false) {
                this.error(`Identifier "${name}" is expected`);
            }

            this.next();
        },
        eatDelim(code) {
            if (!this.isDelim(code)) {
                this.error(`Delim "${String.fromCharCode(code)}" is expected`);
            }

            this.next();
        },

        getLocation(start, end) {
            if (needPositions) {
                return locationMap.getLocationRange(
                    start,
                    end,
                    filename
                );
            }

            return null;
        },
        getLocationFromList(list) {
            if (needPositions) {
                const head = this.getFirstListNode(list);
                const tail = this.getLastListNode(list);
                return locationMap.getLocationRange(
                    head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart,
                    tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart,
                    filename
                );
            }

            return null;
        },

        error(message, offset) {
            const location = typeof offset !== 'undefined' && offset < source.length
                ? locationMap.getLocation(offset)
                : this.eof
                    ? locationMap.getLocation(utils$6.findWhiteSpaceStart(source, source.length - 1))
                    : locationMap.getLocation(this.tokenStart);

            throw new SyntaxError$4.SyntaxError(
                message || 'Unexpected input',
                source,
                location.offset,
                location.line,
                location.column
            );
        }
    });

    const parse = function(source_, options) {
        source = source_;
        options = options || {};

        parser.setSource(source, index$8.tokenize);
        locationMap.setSource(
            source,
            options.offset,
            options.line,
            options.column
        );

        filename = options.filename || '<unknown>';
        needPositions = Boolean(options.positions);
        onParseError = typeof options.onParseError === 'function' ? options.onParseError : NOOP;
        onParseErrorThrow = false;

        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

        const { context = 'default', onComment } = options;

        if (context in parser.context === false) {
            throw new Error('Unknown context `' + context + '`');
        }

        if (typeof onComment === 'function') {
            parser.forEachToken((type, start, end) => {
                if (type === types$P.Comment) {
                    const loc = parser.getLocation(start, end);
                    const value = utils$6.cmpStr(source, end - 2, end, '*/')
                        ? source.slice(start + 2, end - 2)
                        : source.slice(start + 2, end);

                    onComment(value, loc);
                }
            });
        }

        const ast = parser.context[context].call(parser, options);

        if (!parser.eof) {
            parser.error();
        }

        return ast;
    };

    return Object.assign(parse, {
        SyntaxError: SyntaxError$4.SyntaxError,
        config: parser.config
    });
}

create$7.createParser = createParser;

var create$6 = {};

var sourceMap$1 = {};

var sourceMapGenerator = {};

var base64Vlq = {};

var base64$1 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
base64$1.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
base64$1.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = base64$1;

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
base64Vlq.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

var util$3 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

(function (exports) {
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	var MAX_CACHED_INPUTS = 32;

	/**
	 * Takes some function `f(input) -> result` and returns a memoized version of
	 * `f`.
	 *
	 * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The
	 * memoization is a dumb-simple, linear least-recently-used cache.
	 */
	function lruMemoize(f) {
	  var cache = [];

	  return function(input) {
	    for (var i = 0; i < cache.length; i++) {
	      if (cache[i].input === input) {
	        var temp = cache[0];
	        cache[0] = cache[i];
	        cache[i] = temp;
	        return cache[0].result;
	      }
	    }

	    var result = f(input);

	    cache.unshift({
	      input,
	      result,
	    });

	    if (cache.length > MAX_CACHED_INPUTS) {
	      cache.pop();
	    }

	    return result;
	  };
	}

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	var normalize = lruMemoize(function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);
	  // Split the path into parts between `/` characters. This is much faster than
	  // using `.split(/\/+/g)`.
	  var parts = [];
	  var start = 0;
	  var i = 0;
	  while (true) {
	    start = i;
	    i = path.indexOf("/", start);
	    if (i === -1) {
	      parts.push(path.slice(start));
	      break;
	    } else {
	      parts.push(path.slice(start, i));
	      while (i < path.length && path[i] === "/") {
	        i++;
	      }
	    }
	  }

	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	});
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp;

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL; 
} (util$3));

var arraySet = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util$2 = util$3;
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet$1() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet$1.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet$1();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet$1.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet$1.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util$2.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet$1.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util$2.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet$1.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util$2.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet$1.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet$1.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

arraySet.ArraySet = ArraySet$1;

var mappingList = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util$1 = util$3;

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util$1.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList$1() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList$1.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList$1.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList$1.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util$1.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

mappingList.MappingList = MappingList$1;

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = base64Vlq;
var util = util$3;
var ArraySet = arraySet.ArraySet;
var MappingList = mappingList.MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = '';

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;

const sourceMapGenerator_js = sourceMapGenerator;

const trackNodes = new Set(['Atrule', 'Selector', 'Declaration']);

function generateSourceMap(handlers) {
    const map = new sourceMapGenerator_js.SourceMapGenerator();
    const generated = {
        line: 1,
        column: 0
    };
    const original = {
        line: 0, // should be zero to add first mapping
        column: 0
    };
    const activatedGenerated = {
        line: 1,
        column: 0
    };
    const activatedMapping = {
        generated: activatedGenerated
    };
    let line = 1;
    let column = 0;
    let sourceMappingActive = false;

    const origHandlersNode = handlers.node;
    handlers.node = function(node) {
        if (node.loc && node.loc.start && trackNodes.has(node.type)) {
            const nodeLine = node.loc.start.line;
            const nodeColumn = node.loc.start.column - 1;

            if (original.line !== nodeLine ||
                original.column !== nodeColumn) {
                original.line = nodeLine;
                original.column = nodeColumn;

                generated.line = line;
                generated.column = column;

                if (sourceMappingActive) {
                    sourceMappingActive = false;
                    if (generated.line !== activatedGenerated.line ||
                        generated.column !== activatedGenerated.column) {
                        map.addMapping(activatedMapping);
                    }
                }

                sourceMappingActive = true;
                map.addMapping({
                    source: node.loc.source,
                    original,
                    generated
                });
            }
        }

        origHandlersNode.call(this, node);

        if (sourceMappingActive && trackNodes.has(node.type)) {
            activatedGenerated.line = line;
            activatedGenerated.column = column;
        }
    };

    const origHandlersEmit = handlers.emit;
    handlers.emit = function(value, type, auto) {
        for (let i = 0; i < value.length; i++) {
            if (value.charCodeAt(i) === 10) { // \n
                line++;
                column = 0;
            } else {
                column++;
            }
        }

        origHandlersEmit(value, type, auto);
    };

    const origHandlersResult = handlers.result;
    handlers.result = function() {
        if (sourceMappingActive) {
            map.addMapping(activatedMapping);
        }

        return {
            css: origHandlersResult(),
            map
        };
    };

    return handlers;
}

sourceMap$1.generateSourceMap = generateSourceMap;

var tokenBefore$1 = {};

const types$O = types$T;

const PLUSSIGN$9 = 0x002B;    // U+002B PLUS SIGN (+)
const HYPHENMINUS$6 = 0x002D; // U+002D HYPHEN-MINUS (-)

const code = (type, value) => {
    if (type === types$O.Delim) {
        type = value;
    }

    if (typeof type === 'string') {
        const charCode = type.charCodeAt(0);
        return charCode > 0x7F ? 0x8000 : charCode << 8;
    }

    return type;
};

// https://www.w3.org/TR/css-syntax-3/#serialization
// The only requirement for serialization is that it must "round-trip" with parsing,
// that is, parsing the stylesheet must produce the same data structures as parsing,
// serializing, and parsing again, except for consecutive <whitespace-token>s,
// which may be collapsed into a single token.

const specPairs = [
    [types$O.Ident, types$O.Ident],
    [types$O.Ident, types$O.Function],
    [types$O.Ident, types$O.Url],
    [types$O.Ident, types$O.BadUrl],
    [types$O.Ident, '-'],
    [types$O.Ident, types$O.Number],
    [types$O.Ident, types$O.Percentage],
    [types$O.Ident, types$O.Dimension],
    [types$O.Ident, types$O.CDC],
    [types$O.Ident, types$O.LeftParenthesis],

    [types$O.AtKeyword, types$O.Ident],
    [types$O.AtKeyword, types$O.Function],
    [types$O.AtKeyword, types$O.Url],
    [types$O.AtKeyword, types$O.BadUrl],
    [types$O.AtKeyword, '-'],
    [types$O.AtKeyword, types$O.Number],
    [types$O.AtKeyword, types$O.Percentage],
    [types$O.AtKeyword, types$O.Dimension],
    [types$O.AtKeyword, types$O.CDC],

    [types$O.Hash, types$O.Ident],
    [types$O.Hash, types$O.Function],
    [types$O.Hash, types$O.Url],
    [types$O.Hash, types$O.BadUrl],
    [types$O.Hash, '-'],
    [types$O.Hash, types$O.Number],
    [types$O.Hash, types$O.Percentage],
    [types$O.Hash, types$O.Dimension],
    [types$O.Hash, types$O.CDC],

    [types$O.Dimension, types$O.Ident],
    [types$O.Dimension, types$O.Function],
    [types$O.Dimension, types$O.Url],
    [types$O.Dimension, types$O.BadUrl],
    [types$O.Dimension, '-'],
    [types$O.Dimension, types$O.Number],
    [types$O.Dimension, types$O.Percentage],
    [types$O.Dimension, types$O.Dimension],
    [types$O.Dimension, types$O.CDC],

    ['#', types$O.Ident],
    ['#', types$O.Function],
    ['#', types$O.Url],
    ['#', types$O.BadUrl],
    ['#', '-'],
    ['#', types$O.Number],
    ['#', types$O.Percentage],
    ['#', types$O.Dimension],
    ['#', types$O.CDC], // https://github.com/w3c/csswg-drafts/pull/6874

    ['-', types$O.Ident],
    ['-', types$O.Function],
    ['-', types$O.Url],
    ['-', types$O.BadUrl],
    ['-', '-'],
    ['-', types$O.Number],
    ['-', types$O.Percentage],
    ['-', types$O.Dimension],
    ['-', types$O.CDC], // https://github.com/w3c/csswg-drafts/pull/6874

    [types$O.Number, types$O.Ident],
    [types$O.Number, types$O.Function],
    [types$O.Number, types$O.Url],
    [types$O.Number, types$O.BadUrl],
    [types$O.Number, types$O.Number],
    [types$O.Number, types$O.Percentage],
    [types$O.Number, types$O.Dimension],
    [types$O.Number, '%'],
    [types$O.Number, types$O.CDC], // https://github.com/w3c/csswg-drafts/pull/6874

    ['@', types$O.Ident],
    ['@', types$O.Function],
    ['@', types$O.Url],
    ['@', types$O.BadUrl],
    ['@', '-'],
    ['@', types$O.CDC], // https://github.com/w3c/csswg-drafts/pull/6874

    ['.', types$O.Number],
    ['.', types$O.Percentage],
    ['.', types$O.Dimension],

    ['+', types$O.Number],
    ['+', types$O.Percentage],
    ['+', types$O.Dimension],

    ['/', '*']
];
// validate with scripts/generate-safe
const safePairs = specPairs.concat([
    [types$O.Ident, types$O.Hash],

    [types$O.Dimension, types$O.Hash],

    [types$O.Hash, types$O.Hash],

    [types$O.AtKeyword, types$O.LeftParenthesis],
    [types$O.AtKeyword, types$O.String],
    [types$O.AtKeyword, types$O.Colon],

    [types$O.Percentage, types$O.Percentage],
    [types$O.Percentage, types$O.Dimension],
    [types$O.Percentage, types$O.Function],
    [types$O.Percentage, '-'],

    [types$O.RightParenthesis, types$O.Ident],
    [types$O.RightParenthesis, types$O.Function],
    [types$O.RightParenthesis, types$O.Percentage],
    [types$O.RightParenthesis, types$O.Dimension],
    [types$O.RightParenthesis, types$O.Hash],
    [types$O.RightParenthesis, '-']
]);

function createMap(pairs) {
    const isWhiteSpaceRequired = new Set(
        pairs.map(([prev, next]) => (code(prev) << 16 | code(next)))
    );

    return function(prevCode, type, value) {
        const nextCode = code(type, value);
        const nextCharCode = value.charCodeAt(0);
        const emitWs =
            (nextCharCode === HYPHENMINUS$6 &&
                type !== types$O.Ident &&
                type !== types$O.Function &&
                type !== types$O.CDC) ||
            (nextCharCode === PLUSSIGN$9)
                ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8)
                : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);

        if (emitWs) {
            this.emit(' ', types$O.WhiteSpace, true);
        }

        return nextCode;
    };
}

const spec = createMap(specPairs);
const safe = createMap(safePairs);

tokenBefore$1.safe = safe;
tokenBefore$1.spec = spec;

const index$7 = tokenizer$2;
const sourceMap = sourceMap$1;
const tokenBefore = tokenBefore$1;
const types$N = types$T;

const REVERSESOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\)

function processChildren(node, delimeter) {
    if (typeof delimeter === 'function') {
        let prev = null;

        node.children.forEach(node => {
            if (prev !== null) {
                delimeter.call(this, prev);
            }

            this.node(node);
            prev = node;
        });

        return;
    }

    node.children.forEach(this.node, this);
}

function processChunk(chunk) {
    index$7.tokenize(chunk, (type, start, end) => {
        this.token(type, chunk.slice(start, end));
    });
}

function createGenerator(config) {
    const types$1 = new Map();

    for (let name in config.node) {
        const item = config.node[name];
        const fn = item.generate || item;

        if (typeof fn === 'function') {
            types$1.set(name, item.generate || item);
        }
    }

    return function(node, options) {
        let buffer = '';
        let prevCode = 0;
        let handlers = {
            node(node) {
                if (types$1.has(node.type)) {
                    types$1.get(node.type).call(publicApi, node);
                } else {
                    throw new Error('Unknown node type: ' + node.type);
                }
            },
            tokenBefore: tokenBefore.safe,
            token(type, value) {
                prevCode = this.tokenBefore(prevCode, type, value);

                this.emit(value, type, false);

                if (type === types$N.Delim && value.charCodeAt(0) === REVERSESOLIDUS) {
                    this.emit('\n', types$N.WhiteSpace, true);
                }
            },
            emit(value) {
                buffer += value;
            },
            result() {
                return buffer;
            }
        };

        if (options) {
            if (typeof options.decorator === 'function') {
                handlers = options.decorator(handlers);
            }

            if (options.sourceMap) {
                handlers = sourceMap.generateSourceMap(handlers);
            }

            if (options.mode in tokenBefore) {
                handlers.tokenBefore = tokenBefore[options.mode];
            }
        }

        const publicApi = {
            node: (node) => handlers.node(node),
            children: processChildren,
            token: (type, value) => handlers.token(type, value),
            tokenize: processChunk
        };

        handlers.node(node);

        return handlers.result();
    };
}

create$6.createGenerator = createGenerator;

var create$5 = {};

const List$4 = List$7;

function createConvertor(walk) {
    return {
        fromPlainObject(ast) {
            walk(ast, {
                enter(node) {
                    if (node.children && node.children instanceof List$4.List === false) {
                        node.children = new List$4.List().fromArray(node.children);
                    }
                }
            });

            return ast;
        },
        toPlainObject(ast) {
            walk(ast, {
                leave(node) {
                    if (node.children && node.children instanceof List$4.List) {
                        node.children = node.children.toArray();
                    }
                }
            });

            return ast;
        }
    };
}

create$5.createConvertor = createConvertor;

var create$4 = {};

const { hasOwnProperty: hasOwnProperty$3 } = Object.prototype;
const noop$2 = function() {};

function ensureFunction$1(value) {
    return typeof value === 'function' ? value : noop$2;
}

function invokeForType(fn, type) {
    return function(node, item, list) {
        if (node.type === type) {
            fn.call(this, node, item, list);
        }
    };
}

function getWalkersFromStructure(name, nodeType) {
    const structure = nodeType.structure;
    const walkers = [];

    for (const key in structure) {
        if (hasOwnProperty$3.call(structure, key) === false) {
            continue;
        }

        let fieldTypes = structure[key];
        const walker = {
            name: key,
            type: false,
            nullable: false
        };

        if (!Array.isArray(fieldTypes)) {
            fieldTypes = [fieldTypes];
        }

        for (const fieldType of fieldTypes) {
            if (fieldType === null) {
                walker.nullable = true;
            } else if (typeof fieldType === 'string') {
                walker.type = 'node';
            } else if (Array.isArray(fieldType)) {
                walker.type = 'list';
            }
        }

        if (walker.type) {
            walkers.push(walker);
        }
    }

    if (walkers.length) {
        return {
            context: nodeType.walkContext,
            fields: walkers
        };
    }

    return null;
}

function getTypesFromConfig(config) {
    const types = {};

    for (const name in config.node) {
        if (hasOwnProperty$3.call(config.node, name)) {
            const nodeType = config.node[name];

            if (!nodeType.structure) {
                throw new Error('Missed `structure` field in `' + name + '` node type definition');
            }

            types[name] = getWalkersFromStructure(name, nodeType);
        }
    }

    return types;
}

function createTypeIterator(config, reverse) {
    const fields = config.fields.slice();
    const contextName = config.context;
    const useContext = typeof contextName === 'string';

    if (reverse) {
        fields.reverse();
    }

    return function(node, context, walk, walkReducer) {
        let prevContextValue;

        if (useContext) {
            prevContextValue = context[contextName];
            context[contextName] = node;
        }

        for (const field of fields) {
            const ref = node[field.name];

            if (!field.nullable || ref) {
                if (field.type === 'list') {
                    const breakWalk = reverse
                        ? ref.reduceRight(walkReducer, false)
                        : ref.reduce(walkReducer, false);

                    if (breakWalk) {
                        return true;
                    }
                } else if (walk(ref)) {
                    return true;
                }
            }
        }

        if (useContext) {
            context[contextName] = prevContextValue;
        }
    };
}

function createFastTraveralMap({
    StyleSheet,
    Atrule,
    Rule,
    Block,
    DeclarationList
}) {
    return {
        Atrule: {
            StyleSheet,
            Atrule,
            Rule,
            Block
        },
        Rule: {
            StyleSheet,
            Atrule,
            Rule,
            Block
        },
        Declaration: {
            StyleSheet,
            Atrule,
            Rule,
            Block,
            DeclarationList
        }
    };
}

function createWalker(config) {
    const types = getTypesFromConfig(config);
    const iteratorsNatural = {};
    const iteratorsReverse = {};
    const breakWalk = Symbol('break-walk');
    const skipNode = Symbol('skip-node');

    for (const name in types) {
        if (hasOwnProperty$3.call(types, name) && types[name] !== null) {
            iteratorsNatural[name] = createTypeIterator(types[name], false);
            iteratorsReverse[name] = createTypeIterator(types[name], true);
        }
    }

    const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
    const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

    const walk = function(root, options) {
        function walkNode(node, item, list) {
            const enterRet = enter.call(context, node, item, list);

            if (enterRet === breakWalk) {
                return true;
            }

            if (enterRet === skipNode) {
                return false;
            }

            if (iterators.hasOwnProperty(node.type)) {
                if (iterators[node.type](node, context, walkNode, walkReducer)) {
                    return true;
                }
            }

            if (leave.call(context, node, item, list) === breakWalk) {
                return true;
            }

            return false;
        }

        let enter = noop$2;
        let leave = noop$2;
        let iterators = iteratorsNatural;
        let walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
        const context = {
            break: breakWalk,
            skip: skipNode,

            root,
            stylesheet: null,
            atrule: null,
            atrulePrelude: null,
            rule: null,
            selector: null,
            block: null,
            declaration: null,
            function: null
        };

        if (typeof options === 'function') {
            enter = options;
        } else if (options) {
            enter = ensureFunction$1(options.enter);
            leave = ensureFunction$1(options.leave);

            if (options.reverse) {
                iterators = iteratorsReverse;
            }

            if (options.visit) {
                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
                    iterators = options.reverse
                        ? fastTraversalIteratorsReverse[options.visit]
                        : fastTraversalIteratorsNatural[options.visit];
                } else if (!types.hasOwnProperty(options.visit)) {
                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).sort().join(', ') + ')');
                }

                enter = invokeForType(enter, options.visit);
                leave = invokeForType(leave, options.visit);
            }
        }

        if (enter === noop$2 && leave === noop$2) {
            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
        }

        walkNode(root);
    };

    walk.break = breakWalk;
    walk.skip = skipNode;

    walk.find = function(ast, fn) {
        let found = null;

        walk(ast, function(node, item, list) {
            if (fn.call(this, node, item, list)) {
                found = node;
                return breakWalk;
            }
        });

        return found;
    };

    walk.findLast = function(ast, fn) {
        let found = null;

        walk(ast, {
            reverse: true,
            enter(node, item, list) {
                if (fn.call(this, node, item, list)) {
                    found = node;
                    return breakWalk;
                }
            }
        });

        return found;
    };

    walk.findAll = function(ast, fn) {
        const found = [];

        walk(ast, function(node, item, list) {
            if (fn.call(this, node, item, list)) {
                found.push(node);
            }
        });

        return found;
    };

    return walk;
}

create$4.createWalker = createWalker;

var Lexer$3 = {};

var error$1 = {};

var generate$K = {};

function noop$1(value) {
    return value;
}

function generateMultiplier(multiplier) {
    const { min, max, comma } = multiplier;

    if (min === 0 && max === 0) {
        return comma ? '#?' : '*';
    }

    if (min === 0 && max === 1) {
        return '?';
    }

    if (min === 1 && max === 0) {
        return comma ? '#' : '+';
    }

    if (min === 1 && max === 1) {
        return '';
    }

    return (
        (comma ? '#' : '') +
        (min === max
            ? '{' + min + '}'
            : '{' + min + ',' + (max !== 0 ? max : '') + '}'
        )
    );
}

function generateTypeOpts(node) {
    switch (node.type) {
        case 'Range':
            return (
                ' [' +
                (node.min === null ? '-∞' : node.min) +
                ',' +
                (node.max === null ? '∞' : node.max) +
                ']'
            );

        default:
            throw new Error('Unknown node type `' + node.type + '`');
    }
}

function generateSequence(node, decorate, forceBraces, compact) {
    const combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
    const result = node.terms
        .map(term => internalGenerate(term, decorate, forceBraces, compact))
        .join(combinator);

    if (node.explicit || forceBraces) {
        return (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
    }

    return result;
}

function internalGenerate(node, decorate, forceBraces, compact) {
    let result;

    switch (node.type) {
        case 'Group':
            result =
                generateSequence(node, decorate, forceBraces, compact) +
                (node.disallowEmpty ? '!' : '');
            break;

        case 'Multiplier':
            // return since node is a composition
            return (
                internalGenerate(node.term, decorate, forceBraces, compact) +
                decorate(generateMultiplier(node), node)
            );

        case 'Type':
            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
            break;

        case 'Property':
            result = '<\'' + node.name + '\'>';
            break;

        case 'Keyword':
            result = node.name;
            break;

        case 'AtKeyword':
            result = '@' + node.name;
            break;

        case 'Function':
            result = node.name + '(';
            break;

        case 'String':
        case 'Token':
            result = node.value;
            break;

        case 'Comma':
            result = ',';
            break;

        default:
            throw new Error('Unknown node type `' + node.type + '`');
    }

    return decorate(result, node);
}

function generate$J(node, options) {
    let decorate = noop$1;
    let forceBraces = false;
    let compact = false;

    if (typeof options === 'function') {
        decorate = options;
    } else if (options) {
        forceBraces = Boolean(options.forceBraces);
        compact = Boolean(options.compact);
        if (typeof options.decorate === 'function') {
            decorate = options.decorate;
        }
    }

    return internalGenerate(node, decorate, forceBraces, compact);
}

generate$K.generate = generate$J;

const createCustomError$1 = createCustomError$4;
const generate$I = generate$K;

const defaultLoc = { offset: 0, line: 1, column: 1 };

function locateMismatch(matchResult, node) {
    const tokens = matchResult.tokens;
    const longestMatch = matchResult.longestMatch;
    const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
    const badNode = mismatchNode !== node ? mismatchNode : null;
    let mismatchOffset = 0;
    let mismatchLength = 0;
    let entries = 0;
    let css = '';
    let start;
    let end;

    for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i].value;

        if (i === longestMatch) {
            mismatchLength = token.length;
            mismatchOffset = css.length;
        }

        if (badNode !== null && tokens[i].node === badNode) {
            if (i <= longestMatch) {
                entries++;
            } else {
                entries = 0;
            }
        }

        css += token;
    }

    if (longestMatch === tokens.length || entries > 1) { // last
        start = fromLoc(badNode || node, 'end') || buildLoc(defaultLoc, css);
        end = buildLoc(start);
    } else {
        start = fromLoc(badNode, 'start') ||
            buildLoc(fromLoc(node, 'start') || defaultLoc, css.slice(0, mismatchOffset));
        end = fromLoc(badNode, 'end') ||
            buildLoc(start, css.substr(mismatchOffset, mismatchLength));
    }

    return {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
    };
}

function fromLoc(node, point) {
    const value = node && node.loc && node.loc[point];

    if (value) {
        return 'line' in value ? buildLoc(value) : value;
    }

    return null;
}

function buildLoc({ offset, line, column }, extra) {
    const loc = {
        offset,
        line,
        column
    };

    if (extra) {
        const lines = extra.split(/\n|\r\n?|\f/);

        loc.offset += extra.length;
        loc.line += lines.length - 1;
        loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
    }

    return loc;
}

const SyntaxReferenceError = function(type, referenceName) {
    const error = createCustomError$1.createCustomError(
        'SyntaxReferenceError',
        type + (referenceName ? ' `' + referenceName + '`' : '')
    );

    error.reference = referenceName;

    return error;
};

const SyntaxMatchError = function(message, syntax, node, matchResult) {
    const error = createCustomError$1.createCustomError('SyntaxMatchError', message);
    const {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
    } = locateMismatch(matchResult, node);

    error.rawMessage = message;
    error.syntax = syntax ? generate$I.generate(syntax) : '<generic>';
    error.css = css;
    error.mismatchOffset = mismatchOffset;
    error.mismatchLength = mismatchLength;
    error.message = message + '\n' +
        '  syntax: ' + error.syntax + '\n' +
        '   value: ' + (css || '<empty string>') + '\n' +
        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

    Object.assign(error, start);
    error.loc = {
        source: (node && node.loc && node.loc.source) || '<unknown>',
        start,
        end
    };

    return error;
};

error$1.SyntaxMatchError = SyntaxMatchError;
error$1.SyntaxReferenceError = SyntaxReferenceError;

var names$4 = {};

const keywords$1 = new Map();
const properties$3 = new Map();
const HYPHENMINUS$5 = 45; // '-'.charCodeAt()

const keyword = getKeywordDescriptor;
const property = getPropertyDescriptor;
const vendorPrefix = getVendorPrefix;
function isCustomProperty(str, offset) {
    offset = offset || 0;

    return str.length - offset >= 2 &&
           str.charCodeAt(offset) === HYPHENMINUS$5 &&
           str.charCodeAt(offset + 1) === HYPHENMINUS$5;
}

function getVendorPrefix(str, offset) {
    offset = offset || 0;

    // verdor prefix should be at least 3 chars length
    if (str.length - offset >= 3) {
        // vendor prefix starts with hyper minus following non-hyper minus
        if (str.charCodeAt(offset) === HYPHENMINUS$5 &&
            str.charCodeAt(offset + 1) !== HYPHENMINUS$5) {
            // vendor prefix should contain a hyper minus at the ending
            const secondDashIndex = str.indexOf('-', offset + 2);

            if (secondDashIndex !== -1) {
                return str.substring(offset, secondDashIndex + 1);
            }
        }
    }

    return '';
}

function getKeywordDescriptor(keyword) {
    if (keywords$1.has(keyword)) {
        return keywords$1.get(keyword);
    }

    const name = keyword.toLowerCase();
    let descriptor = keywords$1.get(name);

    if (descriptor === undefined) {
        const custom = isCustomProperty(name, 0);
        const vendor = !custom ? getVendorPrefix(name, 0) : '';
        descriptor = Object.freeze({
            basename: name.substr(vendor.length),
            name,
            prefix: vendor,
            vendor,
            custom
        });
    }

    keywords$1.set(keyword, descriptor);

    return descriptor;
}

function getPropertyDescriptor(property) {
    if (properties$3.has(property)) {
        return properties$3.get(property);
    }

    let name = property;
    let hack = property[0];

    if (hack === '/') {
        hack = property[1] === '/' ? '//' : '/';
    } else if (hack !== '_' &&
               hack !== '*' &&
               hack !== '$' &&
               hack !== '#' &&
               hack !== '+' &&
               hack !== '&') {
        hack = '';
    }

    const custom = isCustomProperty(name, hack.length);

    // re-use result when possible (the same as for lower case)
    if (!custom) {
        name = name.toLowerCase();
        if (properties$3.has(name)) {
            const descriptor = properties$3.get(name);
            properties$3.set(property, descriptor);
            return descriptor;
        }
    }

    const vendor = !custom ? getVendorPrefix(name, hack.length) : '';
    const prefix = name.substr(0, hack.length + vendor.length);
    const descriptor = Object.freeze({
        basename: name.substr(prefix.length),
        name: name.substr(hack.length),
        hack,
        vendor,
        prefix,
        custom
    });

    properties$3.set(property, descriptor);

    return descriptor;
}

names$4.isCustomProperty = isCustomProperty;
names$4.keyword = keyword;
names$4.property = property;
names$4.vendorPrefix = vendorPrefix;

var genericConst$2 = {};

// https://drafts.csswg.org/css-cascade-5/
const cssWideKeywords = [
    'initial',
    'inherit',
    'unset',
    'revert',
    'revert-layer'
];

genericConst$2.cssWideKeywords = cssWideKeywords;

var generic$1 = {};

const charCodeDefinitions$8 = charCodeDefinitions$c;
const types$M = types$T;
const utils$5 = utils$9;

const PLUSSIGN$8 = 0x002B;    // U+002B PLUS SIGN (+)
const HYPHENMINUS$4 = 0x002D; // U+002D HYPHEN-MINUS (-)
const N$3 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
const DISALLOW_SIGN$1 = true;
const ALLOW_SIGN$1 = false;

function isDelim$1(token, code) {
    return token !== null && token.type === types$M.Delim && token.value.charCodeAt(0) === code;
}

function skipSC(token, offset, getNextToken) {
    while (token !== null && (token.type === types$M.WhiteSpace || token.type === types$M.Comment)) {
        token = getNextToken(++offset);
    }

    return offset;
}

function checkInteger$1(token, valueOffset, disallowSign, offset) {
    if (!token) {
        return 0;
    }

    const code = token.value.charCodeAt(valueOffset);

    if (code === PLUSSIGN$8 || code === HYPHENMINUS$4) {
        if (disallowSign) {
            // Number sign is not allowed
            return 0;
        }
        valueOffset++;
    }

    for (; valueOffset < token.value.length; valueOffset++) {
        if (!charCodeDefinitions$8.isDigit(token.value.charCodeAt(valueOffset))) {
            // Integer is expected
            return 0;
        }
    }

    return offset + 1;
}

// ... <signed-integer>
// ... ['+' | '-'] <signless-integer>
function consumeB$1(token, offset_, getNextToken) {
    let sign = false;
    let offset = skipSC(token, offset_, getNextToken);

    token = getNextToken(offset);

    if (token === null) {
        return offset_;
    }

    if (token.type !== types$M.Number) {
        if (isDelim$1(token, PLUSSIGN$8) || isDelim$1(token, HYPHENMINUS$4)) {
            sign = true;
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);

            if (token === null || token.type !== types$M.Number) {
                return 0;
            }
        } else {
            return offset_;
        }
    }

    if (!sign) {
        const code = token.value.charCodeAt(0);
        if (code !== PLUSSIGN$8 && code !== HYPHENMINUS$4) {
            // Number sign is expected
            return 0;
        }
    }

    return checkInteger$1(token, sign ? 0 : 1, sign, offset);
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
function anPlusB(token, getNextToken) {
    /* eslint-disable brace-style*/
    let offset = 0;

    if (!token) {
        return 0;
    }

    // <integer>
    if (token.type === types$M.Number) {
        return checkInteger$1(token, 0, ALLOW_SIGN$1, offset); // b
    }

    // -n
    // -n <signed-integer>
    // -n ['+' | '-'] <signless-integer>
    // -n- <signless-integer>
    // <dashndashdigit-ident>
    else if (token.type === types$M.Ident && token.value.charCodeAt(0) === HYPHENMINUS$4) {
        // expect 1st char is N
        if (!utils$5.cmpChar(token.value, 1, N$3)) {
            return 0;
        }

        switch (token.value.length) {
            // -n
            // -n <signed-integer>
            // -n ['+' | '-'] <signless-integer>
            case 2:
                return consumeB$1(getNextToken(++offset), offset, getNextToken);

            // -n- <signless-integer>
            case 3:
                if (token.value.charCodeAt(2) !== HYPHENMINUS$4) {
                    return 0;
                }

                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);

                return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);

            // <dashndashdigit-ident>
            default:
                if (token.value.charCodeAt(2) !== HYPHENMINUS$4) {
                    return 0;
                }

                return checkInteger$1(token, 3, DISALLOW_SIGN$1, offset);
        }
    }

    // '+'? n
    // '+'? n <signed-integer>
    // '+'? n ['+' | '-'] <signless-integer>
    // '+'? n- <signless-integer>
    // '+'? <ndashdigit-ident>
    else if (token.type === types$M.Ident || (isDelim$1(token, PLUSSIGN$8) && getNextToken(offset + 1).type === types$M.Ident)) {
        // just ignore a plus
        if (token.type !== types$M.Ident) {
            token = getNextToken(++offset);
        }

        if (token === null || !utils$5.cmpChar(token.value, 0, N$3)) {
            return 0;
        }

        switch (token.value.length) {
            // '+'? n
            // '+'? n <signed-integer>
            // '+'? n ['+' | '-'] <signless-integer>
            case 1:
                return consumeB$1(getNextToken(++offset), offset, getNextToken);

            // '+'? n- <signless-integer>
            case 2:
                if (token.value.charCodeAt(1) !== HYPHENMINUS$4) {
                    return 0;
                }

                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);

                return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);

            // '+'? <ndashdigit-ident>
            default:
                if (token.value.charCodeAt(1) !== HYPHENMINUS$4) {
                    return 0;
                }

                return checkInteger$1(token, 2, DISALLOW_SIGN$1, offset);
        }
    }

    // <ndashdigit-dimension>
    // <ndash-dimension> <signless-integer>
    // <n-dimension>
    // <n-dimension> <signed-integer>
    // <n-dimension> ['+' | '-'] <signless-integer>
    else if (token.type === types$M.Dimension) {
        let code = token.value.charCodeAt(0);
        let sign = code === PLUSSIGN$8 || code === HYPHENMINUS$4 ? 1 : 0;
        let i = sign;

        for (; i < token.value.length; i++) {
            if (!charCodeDefinitions$8.isDigit(token.value.charCodeAt(i))) {
                break;
            }
        }

        if (i === sign) {
            // Integer is expected
            return 0;
        }

        if (!utils$5.cmpChar(token.value, i, N$3)) {
            return 0;
        }

        // <n-dimension>
        // <n-dimension> <signed-integer>
        // <n-dimension> ['+' | '-'] <signless-integer>
        if (i + 1 === token.value.length) {
            return consumeB$1(getNextToken(++offset), offset, getNextToken);
        } else {
            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$4) {
                return 0;
            }

            // <ndash-dimension> <signless-integer>
            if (i + 2 === token.value.length) {
                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);

                return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);
            }
            // <ndashdigit-dimension>
            else {
                return checkInteger$1(token, i + 2, DISALLOW_SIGN$1, offset);
            }
        }
    }

    return 0;
}

var genericAnPlusB$1 = anPlusB;

const charCodeDefinitions$7 = charCodeDefinitions$c;
const types$L = types$T;
const utils$4 = utils$9;

const PLUSSIGN$7 = 0x002B;     // U+002B PLUS SIGN (+)
const HYPHENMINUS$3 = 0x002D;  // U+002D HYPHEN-MINUS (-)
const QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
const U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

function isDelim(token, code) {
    return token !== null && token.type === types$L.Delim && token.value.charCodeAt(0) === code;
}

function startsWith$1(token, code) {
    return token.value.charCodeAt(0) === code;
}

function hexSequence(token, offset, allowDash) {
    let hexlen = 0;

    for (let pos = offset; pos < token.value.length; pos++) {
        const code = token.value.charCodeAt(pos);

        if (code === HYPHENMINUS$3 && allowDash && hexlen !== 0) {
            hexSequence(token, offset + hexlen + 1, false);
            return 6; // dissallow following question marks
        }

        if (!charCodeDefinitions$7.isHexDigit(code)) {
            return 0; // not a hex digit
        }

        if (++hexlen > 6) {
            return 0; // too many hex digits
        }    }

    return hexlen;
}

function withQuestionMarkSequence(consumed, length, getNextToken) {
    if (!consumed) {
        return 0; // nothing consumed
    }

    while (isDelim(getNextToken(length), QUESTIONMARK$2)) {
        if (++consumed > 6) {
            return 0; // too many question marks
        }

        length++;
    }

    return length;
}

// https://drafts.csswg.org/css-syntax/#urange
// Informally, the <urange> production has three forms:
// U+0001
//      Defines a range consisting of a single code point, in this case the code point "1".
// U+0001-00ff
//      Defines a range of codepoints between the first and the second value, in this case
//      the range between "1" and "ff" (255 in decimal) inclusive.
// U+00??
//      Defines a range of codepoints where the "?" characters range over all hex digits,
//      in this case defining the same as the value U+0000-00ff.
// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
//
// <urange> =
//   u '+' <ident-token> '?'* |
//   u <dimension-token> '?'* |
//   u <number-token> '?'* |
//   u <number-token> <dimension-token> |
//   u <number-token> <number-token> |
//   u '+' '?'+
function urange(token, getNextToken) {
    let length = 0;

    // should start with `u` or `U`
    if (token === null || token.type !== types$L.Ident || !utils$4.cmpChar(token.value, 0, U$1)) {
        return 0;
    }

    token = getNextToken(++length);
    if (token === null) {
        return 0;
    }

    // u '+' <ident-token> '?'*
    // u '+' '?'+
    if (isDelim(token, PLUSSIGN$7)) {
        token = getNextToken(++length);
        if (token === null) {
            return 0;
        }

        if (token.type === types$L.Ident) {
            // u '+' <ident-token> '?'*
            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
        }

        if (isDelim(token, QUESTIONMARK$2)) {
            // u '+' '?'+
            return withQuestionMarkSequence(1, ++length, getNextToken);
        }

        // Hex digit or question mark is expected
        return 0;
    }

    // u <number-token> '?'*
    // u <number-token> <dimension-token>
    // u <number-token> <number-token>
    if (token.type === types$L.Number) {
        const consumedHexLength = hexSequence(token, 1, true);
        if (consumedHexLength === 0) {
            return 0;
        }

        token = getNextToken(++length);
        if (token === null) {
            // u <number-token> <eof>
            return length;
        }

        if (token.type === types$L.Dimension || token.type === types$L.Number) {
            // u <number-token> <dimension-token>
            // u <number-token> <number-token>
            if (!startsWith$1(token, HYPHENMINUS$3) || !hexSequence(token, 1, false)) {
                return 0;
            }

            return length + 1;
        }

        // u <number-token> '?'*
        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
    }

    // u <dimension-token> '?'*
    if (token.type === types$L.Dimension) {
        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
    }

    return 0;
}

var genericUrange$1 = urange;

const genericConst$1 = genericConst$2;
const genericAnPlusB = genericAnPlusB$1;
const genericUrange = genericUrange$1;
const types$K = types$T;
const charCodeDefinitions$6 = charCodeDefinitions$c;
const utils$3 = utils$9;

const calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];
const balancePair = new Map([
    [types$K.Function, types$K.RightParenthesis],
    [types$K.LeftParenthesis, types$K.RightParenthesis],
    [types$K.LeftSquareBracket, types$K.RightSquareBracket],
    [types$K.LeftCurlyBracket, types$K.RightCurlyBracket]
]);

// safe char code getter
function charCodeAt(str, index) {
    return index < str.length ? str.charCodeAt(index) : 0;
}

function eqStr(actual, expected) {
    return utils$3.cmpStr(actual, 0, actual.length, expected);
}

function eqStrAny(actual, expected) {
    for (let i = 0; i < expected.length; i++) {
        if (eqStr(actual, expected[i])) {
            return true;
        }
    }

    return false;
}

// IE postfix hack, i.e. 123\0 or 123px\9
function isPostfixIeHack(str, offset) {
    if (offset !== str.length - 2) {
        return false;
    }

    return (
        charCodeAt(str, offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
        charCodeDefinitions$6.isDigit(charCodeAt(str, offset + 1))
    );
}

function outOfRange(opts, value, numEnd) {
    if (opts && opts.type === 'Range') {
        const num = Number(
            numEnd !== undefined && numEnd !== value.length
                ? value.substr(0, numEnd)
                : value
        );

        if (isNaN(num)) {
            return true;
        }

        // FIXME: when opts.min is a string it's a dimension, skip a range validation
        // for now since it requires a type covertation which is not implmented yet
        if (opts.min !== null && num < opts.min && typeof opts.min !== 'string') {
            return true;
        }

        // FIXME: when opts.max is a string it's a dimension, skip a range validation
        // for now since it requires a type covertation which is not implmented yet
        if (opts.max !== null && num > opts.max && typeof opts.max !== 'string') {
            return true;
        }
    }

    return false;
}

function consumeFunction(token, getNextToken) {
    let balanceCloseType = 0;
    let balanceStash = [];
    let length = 0;

    // balanced token consuming
    scan:
    do {
        switch (token.type) {
            case types$K.RightCurlyBracket:
            case types$K.RightParenthesis:
            case types$K.RightSquareBracket:
                if (token.type !== balanceCloseType) {
                    break scan;
                }

                balanceCloseType = balanceStash.pop();

                if (balanceStash.length === 0) {
                    length++;
                    break scan;
                }

                break;

            case types$K.Function:
            case types$K.LeftParenthesis:
            case types$K.LeftSquareBracket:
            case types$K.LeftCurlyBracket:
                balanceStash.push(balanceCloseType);
                balanceCloseType = balancePair.get(token.type);
                break;
        }

        length++;
    } while (token = getNextToken(length));

    return length;
}

// TODO: implement
// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
// https://drafts.csswg.org/css-values/#calc-notation
function calc(next) {
    return function(token, getNextToken, opts) {
        if (token === null) {
            return 0;
        }

        if (token.type === types$K.Function && eqStrAny(token.value, calcFunctionNames)) {
            return consumeFunction(token, getNextToken);
        }

        return next(token, getNextToken, opts);
    };
}

function tokenType(expectedTokenType) {
    return function(token) {
        if (token === null || token.type !== expectedTokenType) {
            return 0;
        }

        return 1;
    };
}

// =========================
// Complex types
//

// https://drafts.csswg.org/css-values-4/#custom-idents
// 4.2. Author-defined Identifiers: the <custom-ident> type
// Some properties accept arbitrary author-defined identifiers as a component value.
// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
//
// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
function customIdent(token) {
    if (token === null || token.type !== types$K.Ident) {
        return 0;
    }

    const name = token.value.toLowerCase();

    // The CSS-wide keywords are not valid <custom-ident>s
    if (eqStrAny(name, genericConst$1.cssWideKeywords)) {
        return 0;
    }

    // The default keyword is reserved and is also not a valid <custom-ident>
    if (eqStr(name, 'default')) {
        return 0;
    }

    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
    // Specifications using <custom-ident> must specify clearly what other keywords
    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
    // in that property’s value definition are excluded. Excluded keywords are excluded
    // in all ASCII case permutations.

    return 1;
}

// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
function customPropertyName(token) {
    // ... defined as any valid identifier
    if (token === null || token.type !== types$K.Ident) {
        return 0;
    }

    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
    if (charCodeAt(token.value, 0) !== 0x002D || charCodeAt(token.value, 1) !== 0x002D) {
        return 0;
    }

    return 1;
}

// https://drafts.csswg.org/css-color-4/#hex-notation
// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
function hexColor(token) {
    if (token === null || token.type !== types$K.Hash) {
        return 0;
    }

    const length = token.value.length;

    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
        return 0;
    }

    for (let i = 1; i < length; i++) {
        if (!charCodeDefinitions$6.isHexDigit(charCodeAt(token.value, i))) {
            return 0;
        }
    }

    return 1;
}

function idSelector(token) {
    if (token === null || token.type !== types$K.Hash) {
        return 0;
    }

    if (!charCodeDefinitions$6.isIdentifierStart(charCodeAt(token.value, 1), charCodeAt(token.value, 2), charCodeAt(token.value, 3))) {
        return 0;
    }

    return 1;
}

// https://drafts.csswg.org/css-syntax/#any-value
// It represents the entirety of what a valid declaration can have as its value.
function declarationValue(token, getNextToken) {
    if (!token) {
        return 0;
    }

    let balanceCloseType = 0;
    let balanceStash = [];
    let length = 0;

    // The <declaration-value> production matches any sequence of one or more tokens,
    // so long as the sequence does not contain ...
    scan:
    do {
        switch (token.type) {
            // ... <bad-string-token>, <bad-url-token>,
            case types$K.BadString:
            case types$K.BadUrl:
                break scan;

            // ... unmatched <)-token>, <]-token>, or <}-token>,
            case types$K.RightCurlyBracket:
            case types$K.RightParenthesis:
            case types$K.RightSquareBracket:
                if (token.type !== balanceCloseType) {
                    break scan;
                }

                balanceCloseType = balanceStash.pop();
                break;

            // ... or top-level <semicolon-token> tokens
            case types$K.Semicolon:
                if (balanceCloseType === 0) {
                    break scan;
                }

                break;

            // ... or <delim-token> tokens with a value of "!"
            case types$K.Delim:
                if (balanceCloseType === 0 && token.value === '!') {
                    break scan;
                }

                break;

            case types$K.Function:
            case types$K.LeftParenthesis:
            case types$K.LeftSquareBracket:
            case types$K.LeftCurlyBracket:
                balanceStash.push(balanceCloseType);
                balanceCloseType = balancePair.get(token.type);
                break;
        }

        length++;
    } while (token = getNextToken(length));

    return length;
}

// https://drafts.csswg.org/css-syntax/#any-value
// The <any-value> production is identical to <declaration-value>, but also
// allows top-level <semicolon-token> tokens and <delim-token> tokens
// with a value of "!". It represents the entirety of what valid CSS can be in any context.
function anyValue(token, getNextToken) {
    if (!token) {
        return 0;
    }

    let balanceCloseType = 0;
    let balanceStash = [];
    let length = 0;

    // The <any-value> production matches any sequence of one or more tokens,
    // so long as the sequence ...
    scan:
    do {
        switch (token.type) {
            // ... does not contain <bad-string-token>, <bad-url-token>,
            case types$K.BadString:
            case types$K.BadUrl:
                break scan;

            // ... unmatched <)-token>, <]-token>, or <}-token>,
            case types$K.RightCurlyBracket:
            case types$K.RightParenthesis:
            case types$K.RightSquareBracket:
                if (token.type !== balanceCloseType) {
                    break scan;
                }

                balanceCloseType = balanceStash.pop();
                break;

            case types$K.Function:
            case types$K.LeftParenthesis:
            case types$K.LeftSquareBracket:
            case types$K.LeftCurlyBracket:
                balanceStash.push(balanceCloseType);
                balanceCloseType = balancePair.get(token.type);
                break;
        }

        length++;
    } while (token = getNextToken(length));

    return length;
}

// =========================
// Dimensions
//

function dimension(type) {
    if (type) {
        type = new Set(type);
    }

    return function(token, getNextToken, opts) {
        if (token === null || token.type !== types$K.Dimension) {
            return 0;
        }

        const numberEnd = utils$3.consumeNumber(token.value, 0);

        // check unit
        if (type !== null) {
            // check for IE postfix hack, i.e. 123px\0 or 123px\9
            const reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
            const unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
                ? token.value.substr(numberEnd)
                : token.value.substring(numberEnd, reverseSolidusOffset);

            if (type.has(unit.toLowerCase()) === false) {
                return 0;
            }
        }

        // check range if specified
        if (outOfRange(opts, token.value, numberEnd)) {
            return 0;
        }

        return 1;
    };
}

// =========================
// Percentage
//

// §5.5. Percentages: the <percentage> type
// https://drafts.csswg.org/css-values-4/#percentages
function percentage(token, getNextToken, opts) {
    // ... corresponds to the <percentage-token> production
    if (token === null || token.type !== types$K.Percentage) {
        return 0;
    }

    // check range if specified
    if (outOfRange(opts, token.value, token.value.length - 1)) {
        return 0;
    }

    return 1;
}

// =========================
// Numeric
//

// https://drafts.csswg.org/css-values-4/#numbers
// The value <zero> represents a literal number with the value 0. Expressions that merely
// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
// only literal <number-token>s do.
function zero(next) {
    if (typeof next !== 'function') {
        next = function() {
            return 0;
        };
    }

    return function(token, getNextToken, opts) {
        if (token !== null && token.type === types$K.Number) {
            if (Number(token.value) === 0) {
                return 1;
            }
        }

        return next(token, getNextToken, opts);
    };
}

// § 5.3. Real Numbers: the <number> type
// https://drafts.csswg.org/css-values-4/#numbers
// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
// ... It corresponds to the <number-token> production
function number(token, getNextToken, opts) {
    if (token === null) {
        return 0;
    }

    const numberEnd = utils$3.consumeNumber(token.value, 0);
    const isNumber = numberEnd === token.value.length;
    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
        return 0;
    }

    // check range if specified
    if (outOfRange(opts, token.value, numberEnd)) {
        return 0;
    }

    return 1;
}

// §5.2. Integers: the <integer> type
// https://drafts.csswg.org/css-values-4/#integers
function integer(token, getNextToken, opts) {
    // ... corresponds to a subset of the <number-token> production
    if (token === null || token.type !== types$K.Number) {
        return 0;
    }

    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
    let i = charCodeAt(token.value, 0) === 0x002B ||       // U+002B PLUS SIGN (+)
            charCodeAt(token.value, 0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

    // When written literally, an integer is one or more decimal digits 0 through 9 ...
    for (; i < token.value.length; i++) {
        if (!charCodeDefinitions$6.isDigit(charCodeAt(token.value, i))) {
            return 0;
        }
    }

    // check range if specified
    if (outOfRange(opts, token.value, i)) {
        return 0;
    }

    return 1;
}

// token types
const tokenTypes = {
    'ident-token': tokenType(types$K.Ident),
    'function-token': tokenType(types$K.Function),
    'at-keyword-token': tokenType(types$K.AtKeyword),
    'hash-token': tokenType(types$K.Hash),
    'string-token': tokenType(types$K.String),
    'bad-string-token': tokenType(types$K.BadString),
    'url-token': tokenType(types$K.Url),
    'bad-url-token': tokenType(types$K.BadUrl),
    'delim-token': tokenType(types$K.Delim),
    'number-token': tokenType(types$K.Number),
    'percentage-token': tokenType(types$K.Percentage),
    'dimension-token': tokenType(types$K.Dimension),
    'whitespace-token': tokenType(types$K.WhiteSpace),
    'CDO-token': tokenType(types$K.CDO),
    'CDC-token': tokenType(types$K.CDC),
    'colon-token': tokenType(types$K.Colon),
    'semicolon-token': tokenType(types$K.Semicolon),
    'comma-token': tokenType(types$K.Comma),
    '[-token': tokenType(types$K.LeftSquareBracket),
    ']-token': tokenType(types$K.RightSquareBracket),
    '(-token': tokenType(types$K.LeftParenthesis),
    ')-token': tokenType(types$K.RightParenthesis),
    '{-token': tokenType(types$K.LeftCurlyBracket),
    '}-token': tokenType(types$K.RightCurlyBracket)
};

// token production types
const productionTypes = {
    // token type aliases
    'string': tokenType(types$K.String),
    'ident': tokenType(types$K.Ident),

    // percentage
    'percentage': calc(percentage),

    // numeric
    'zero': zero(),
    'number': calc(number),
    'integer': calc(integer),

    // complex types
    'custom-ident': customIdent,
    'custom-property-name': customPropertyName,
    'hex-color': hexColor,
    'id-selector': idSelector, // element( <id-selector> )
    'an-plus-b': genericAnPlusB,
    'urange': genericUrange,
    'declaration-value': declarationValue,
    'any-value': anyValue
};

// dimensions types depend on units set
function createDemensionTypes(units) {
    const {
        angle,
        decibel,
        frequency,
        flex,
        length,
        resolution,
        semitones,
        time
    } = units || {};

    return {
        'dimension': calc(dimension(null)),
        'angle': calc(dimension(angle)),
        'decibel': calc(dimension(decibel)),
        'frequency': calc(dimension(frequency)),
        'flex': calc(dimension(flex)),
        'length': calc(zero(dimension(length))),
        'resolution': calc(dimension(resolution)),
        'semitones': calc(dimension(semitones)),
        'time': calc(dimension(time))
    };
}

function createGenericTypes(units) {
    return {
        ...tokenTypes,
        ...productionTypes,
        ...createDemensionTypes(units)
    };
}

generic$1.createDemensionTypes = createDemensionTypes;
generic$1.createGenericTypes = createGenericTypes;
generic$1.productionTypes = productionTypes;
generic$1.tokenTypes = tokenTypes;

var units$1 = {};

const length = [
    // absolute length units https://www.w3.org/TR/css-values-3/#lengths
    'cm', 'mm', 'q', 'in', 'pt', 'pc', 'px',
    // font-relative length units https://drafts.csswg.org/css-values-4/#font-relative-lengths
    'em', 'rem',
    'ex', 'rex',
    'cap', 'rcap',
    'ch', 'rch',
    'ic', 'ric',
    'lh', 'rlh',
    // viewport-percentage lengths https://drafts.csswg.org/css-values-4/#viewport-relative-lengths
    'vw', 'svw', 'lvw', 'dvw',
    'vh', 'svh', 'lvh', 'dvh',
    'vi', 'svi', 'lvi', 'dvi',
    'vb', 'svb', 'lvb', 'dvb',
    'vmin', 'svmin', 'lvmin', 'dvmin',
    'vmax', 'svmax', 'lvmax', 'dvmax',
    // container relative lengths https://drafts.csswg.org/css-contain-3/#container-lengths
    'cqw', 'cqh', 'cqi', 'cqb', 'cqmin', 'cqmax'
];
const angle = ['deg', 'grad', 'rad', 'turn'];    // https://www.w3.org/TR/css-values-3/#angles
const time = ['s', 'ms'];                        // https://www.w3.org/TR/css-values-3/#time
const frequency = ['hz', 'khz'];                 // https://www.w3.org/TR/css-values-3/#frequency
const resolution = ['dpi', 'dpcm', 'dppx', 'x']; // https://www.w3.org/TR/css-values-3/#resolution
const flex$1 = ['fr'];                             // https://drafts.csswg.org/css-grid/#fr-unit
const decibel = ['db'];                          // https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
const semitones = ['st'];                        // https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch

units$1.angle = angle;
units$1.decibel = decibel;
units$1.flex = flex$1;
units$1.frequency = frequency;
units$1.length = length;
units$1.resolution = resolution;
units$1.semitones = semitones;
units$1.time = time;

const index$6 = tokenizer$2;

const astToTokens = {
    decorator(handlers) {
        const tokens = [];
        let curNode = null;

        return {
            ...handlers,
            node(node) {
                const tmp = curNode;
                curNode = node;
                handlers.node.call(this, node);
                curNode = tmp;
            },
            emit(value, type, auto) {
                tokens.push({
                    type,
                    value,
                    node: auto ? null : curNode
                });
            },
            result() {
                return tokens;
            }
        };
    }
};

function stringToTokens(str) {
    const tokens = [];

    index$6.tokenize(str, (type, start, end) =>
        tokens.push({
            type,
            value: str.slice(start, end),
            node: null
        })
    );

    return tokens;
}

function prepareTokens$1(value, syntax) {
    if (typeof value === 'string') {
        return stringToTokens(value);
    }

    return syntax.generate(value, astToTokens);
}

var prepareTokens_1 = prepareTokens$1;

var matchGraph$2 = {};

var parse$K = {};

var tokenizer$1 = {};

var _SyntaxError = {};

const createCustomError = createCustomError$4;

function SyntaxError$3(message, input, offset) {
    return Object.assign(createCustomError.createCustomError('SyntaxError', message), {
        input,
        offset,
        rawMessage: message,
        message: message + '\n' +
            '  ' + input + '\n' +
            '--' + new Array((offset || input.length) + 1).join('-') + '^'
    });
}

_SyntaxError.SyntaxError = SyntaxError$3;

const SyntaxError$2 = _SyntaxError;

const TAB$1 = 9;
const N$2 = 10;
const F$1 = 12;
const R$1 = 13;
const SPACE$3 = 32;

class Tokenizer {
    constructor(str) {
        this.str = str;
        this.pos = 0;
    }
    charCodeAt(pos) {
        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
    }
    charCode() {
        return this.charCodeAt(this.pos);
    }
    nextCharCode() {
        return this.charCodeAt(this.pos + 1);
    }
    nextNonWsCode(pos) {
        return this.charCodeAt(this.findWsEnd(pos));
    }
    findWsEnd(pos) {
        for (; pos < this.str.length; pos++) {
            const code = this.str.charCodeAt(pos);
            if (code !== R$1 && code !== N$2 && code !== F$1 && code !== SPACE$3 && code !== TAB$1) {
                break;
            }
        }

        return pos;
    }
    substringToPos(end) {
        return this.str.substring(this.pos, this.pos = end);
    }
    eat(code) {
        if (this.charCode() !== code) {
            this.error('Expect `' + String.fromCharCode(code) + '`');
        }

        this.pos++;
    }
    peek() {
        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
    }
    error(message) {
        throw new SyntaxError$2.SyntaxError(message, this.str, this.pos);
    }
}

tokenizer$1.Tokenizer = Tokenizer;

const tokenizer = tokenizer$1;

const TAB = 9;
const N$1 = 10;
const F = 12;
const R = 13;
const SPACE$2 = 32;
const EXCLAMATIONMARK$2 = 33;    // !
const NUMBERSIGN$3 = 35;         // #
const AMPERSAND$5 = 38;          // &
const APOSTROPHE$2 = 39;         // '
const LEFTPARENTHESIS$2 = 40;    // (
const RIGHTPARENTHESIS$2 = 41;   // )
const ASTERISK$6 = 42;           // *
const PLUSSIGN$6 = 43;           // +
const COMMA = 44;              // ,
const HYPERMINUS = 45;         // -
const LESSTHANSIGN = 60;       // <
const GREATERTHANSIGN$2 = 62;    // >
const QUESTIONMARK$1 = 63;       // ?
const COMMERCIALAT = 64;       // @
const LEFTSQUAREBRACKET = 91;  // [
const RIGHTSQUAREBRACKET = 93; // ]
const LEFTCURLYBRACKET = 123;  // {
const VERTICALLINE$3 = 124;      // |
const RIGHTCURLYBRACKET = 125; // }
const INFINITY = 8734;         // ∞
const NAME_CHAR = new Uint8Array(128).map((_, idx) =>
    /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0
);
const COMBINATOR_PRECEDENCE = {
    ' ': 1,
    '&&': 2,
    '||': 3,
    '|': 4
};

function scanSpaces(tokenizer) {
    return tokenizer.substringToPos(
        tokenizer.findWsEnd(tokenizer.pos)
    );
}

function scanWord(tokenizer) {
    let end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
        const code = tokenizer.str.charCodeAt(end);
        if (code >= 128 || NAME_CHAR[code] === 0) {
            break;
        }
    }

    if (tokenizer.pos === end) {
        tokenizer.error('Expect a keyword');
    }

    return tokenizer.substringToPos(end);
}

function scanNumber(tokenizer) {
    let end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
        const code = tokenizer.str.charCodeAt(end);
        if (code < 48 || code > 57) {
            break;
        }
    }

    if (tokenizer.pos === end) {
        tokenizer.error('Expect a number');
    }

    return tokenizer.substringToPos(end);
}

function scanString(tokenizer) {
    const end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

    if (end === -1) {
        tokenizer.pos = tokenizer.str.length;
        tokenizer.error('Expect an apostrophe');
    }

    return tokenizer.substringToPos(end + 1);
}

function readMultiplierRange(tokenizer) {
    let min = null;
    let max = null;

    tokenizer.eat(LEFTCURLYBRACKET);

    min = scanNumber(tokenizer);

    if (tokenizer.charCode() === COMMA) {
        tokenizer.pos++;
        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
            max = scanNumber(tokenizer);
        }
    } else {
        max = min;
    }

    tokenizer.eat(RIGHTCURLYBRACKET);

    return {
        min: Number(min),
        max: max ? Number(max) : 0
    };
}

function readMultiplier(tokenizer) {
    let range = null;
    let comma = false;

    switch (tokenizer.charCode()) {
        case ASTERISK$6:
            tokenizer.pos++;

            range = {
                min: 0,
                max: 0
            };

            break;

        case PLUSSIGN$6:
            tokenizer.pos++;

            range = {
                min: 1,
                max: 0
            };

            break;

        case QUESTIONMARK$1:
            tokenizer.pos++;

            range = {
                min: 0,
                max: 1
            };

            break;

        case NUMBERSIGN$3:
            tokenizer.pos++;

            comma = true;

            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
                range = readMultiplierRange(tokenizer);
            } else if (tokenizer.charCode() === QUESTIONMARK$1) {
                // https://www.w3.org/TR/css-values-4/#component-multipliers
                // > the # and ? multipliers may be stacked as #?
                // In this case just treat "#?" as a single multiplier
                // { min: 0, max: 0, comma: true }
                tokenizer.pos++;
                range = {
                    min: 0,
                    max: 0
                };
            } else {
                range = {
                    min: 1,
                    max: 0
                };
            }

            break;

        case LEFTCURLYBRACKET:
            range = readMultiplierRange(tokenizer);
            break;

        default:
            return null;
    }

    return {
        type: 'Multiplier',
        comma,
        min: range.min,
        max: range.max,
        term: null
    };
}

function maybeMultiplied(tokenizer, node) {
    const multiplier = readMultiplier(tokenizer);

    if (multiplier !== null) {
        multiplier.term = node;

        // https://www.w3.org/TR/css-values-4/#component-multipliers
        // > The + and # multipliers may be stacked as +#;
        // Represent "+#" as nested multipliers:
        // { ...<multiplier #>,
        //   term: {
        //     ...<multipler +>,
        //     term: node
        //   }
        // }
        if (tokenizer.charCode() === NUMBERSIGN$3 &&
            tokenizer.charCodeAt(tokenizer.pos - 1) === PLUSSIGN$6) {
            return maybeMultiplied(tokenizer, multiplier);
        }

        return multiplier;
    }

    return node;
}

function maybeToken(tokenizer) {
    const ch = tokenizer.peek();

    if (ch === '') {
        return null;
    }

    return {
        type: 'Token',
        value: ch
    };
}

function readProperty$1(tokenizer) {
    let name;

    tokenizer.eat(LESSTHANSIGN);
    tokenizer.eat(APOSTROPHE$2);

    name = scanWord(tokenizer);

    tokenizer.eat(APOSTROPHE$2);
    tokenizer.eat(GREATERTHANSIGN$2);

    return maybeMultiplied(tokenizer, {
        type: 'Property',
        name
    });
}

// https://drafts.csswg.org/css-values-3/#numeric-ranges
// 4.1. Range Restrictions and Range Definition Notation
//
// Range restrictions can be annotated in the numeric type notation using CSS bracketed
// range notation—[min,max]—within the angle brackets, after the identifying keyword,
// indicating a closed range between (and including) min and max.
// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
function readTypeRange(tokenizer) {
    // use null for Infinity to make AST format JSON serializable/deserializable
    let min = null; // -Infinity
    let max = null; // Infinity
    let sign = 1;

    tokenizer.eat(LEFTSQUAREBRACKET);

    if (tokenizer.charCode() === HYPERMINUS) {
        tokenizer.peek();
        sign = -1;
    }

    if (sign == -1 && tokenizer.charCode() === INFINITY) {
        tokenizer.peek();
    } else {
        min = sign * Number(scanNumber(tokenizer));

        if (NAME_CHAR[tokenizer.charCode()] !== 0) {
            min += scanWord(tokenizer);
        }
    }

    scanSpaces(tokenizer);
    tokenizer.eat(COMMA);
    scanSpaces(tokenizer);

    if (tokenizer.charCode() === INFINITY) {
        tokenizer.peek();
    } else {
        sign = 1;

        if (tokenizer.charCode() === HYPERMINUS) {
            tokenizer.peek();
            sign = -1;
        }

        max = sign * Number(scanNumber(tokenizer));

        if (NAME_CHAR[tokenizer.charCode()] !== 0) {
            max += scanWord(tokenizer);
        }
    }

    tokenizer.eat(RIGHTSQUAREBRACKET);

    return {
        type: 'Range',
        min,
        max
    };
}

function readType(tokenizer) {
    let name;
    let opts = null;

    tokenizer.eat(LESSTHANSIGN);
    name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS$2 &&
        tokenizer.nextCharCode() === RIGHTPARENTHESIS$2) {
        tokenizer.pos += 2;
        name += '()';
    }

    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
        scanSpaces(tokenizer);
        opts = readTypeRange(tokenizer);
    }

    tokenizer.eat(GREATERTHANSIGN$2);

    return maybeMultiplied(tokenizer, {
        type: 'Type',
        name,
        opts
    });
}

function readKeywordOrFunction(tokenizer) {
    const name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS$2) {
        tokenizer.pos++;

        return {
            type: 'Function',
            name
        };
    }

    return maybeMultiplied(tokenizer, {
        type: 'Keyword',
        name
    });
}

function regroupTerms(terms, combinators) {
    function createGroup(terms, combinator) {
        return {
            type: 'Group',
            terms,
            combinator,
            disallowEmpty: false,
            explicit: false
        };
    }

    let combinator;

    combinators = Object.keys(combinators)
        .sort((a, b) => COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b]);

    while (combinators.length > 0) {
        combinator = combinators.shift();

        let i = 0;
        let subgroupStart = 0;

        for (; i < terms.length; i++) {
            const term = terms[i];

            if (term.type === 'Combinator') {
                if (term.value === combinator) {
                    if (subgroupStart === -1) {
                        subgroupStart = i - 1;
                    }
                    terms.splice(i, 1);
                    i--;
                } else {
                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
                        terms.splice(
                            subgroupStart,
                            i - subgroupStart,
                            createGroup(terms.slice(subgroupStart, i), combinator)
                        );
                        i = subgroupStart + 1;
                    }
                    subgroupStart = -1;
                }
            }
        }

        if (subgroupStart !== -1 && combinators.length) {
            terms.splice(
                subgroupStart,
                i - subgroupStart,
                createGroup(terms.slice(subgroupStart, i), combinator)
            );
        }
    }

    return combinator;
}

function readImplicitGroup(tokenizer) {
    const terms = [];
    const combinators = {};
    let token;
    let prevToken = null;
    let prevTokenPos = tokenizer.pos;

    while (token = peek(tokenizer)) {
        if (token.type !== 'Spaces') {
            if (token.type === 'Combinator') {
                // check for combinator in group beginning and double combinator sequence
                if (prevToken === null || prevToken.type === 'Combinator') {
                    tokenizer.pos = prevTokenPos;
                    tokenizer.error('Unexpected combinator');
                }

                combinators[token.value] = true;
            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
                combinators[' '] = true;  // a b
                terms.push({
                    type: 'Combinator',
                    value: ' '
                });
            }

            terms.push(token);
            prevToken = token;
            prevTokenPos = tokenizer.pos;
        }
    }

    // check for combinator in group ending
    if (prevToken !== null && prevToken.type === 'Combinator') {
        tokenizer.pos -= prevTokenPos;
        tokenizer.error('Unexpected combinator');
    }

    return {
        type: 'Group',
        terms,
        combinator: regroupTerms(terms, combinators) || ' ',
        disallowEmpty: false,
        explicit: false
    };
}

function readGroup(tokenizer) {
    let result;

    tokenizer.eat(LEFTSQUAREBRACKET);
    result = readImplicitGroup(tokenizer);
    tokenizer.eat(RIGHTSQUAREBRACKET);

    result.explicit = true;

    if (tokenizer.charCode() === EXCLAMATIONMARK$2) {
        tokenizer.pos++;
        result.disallowEmpty = true;
    }

    return result;
}

function peek(tokenizer) {
    let code = tokenizer.charCode();

    if (code < 128 && NAME_CHAR[code] === 1) {
        return readKeywordOrFunction(tokenizer);
    }

    switch (code) {
        case RIGHTSQUAREBRACKET:
            // don't eat, stop scan a group
            break;

        case LEFTSQUAREBRACKET:
            return maybeMultiplied(tokenizer, readGroup(tokenizer));

        case LESSTHANSIGN:
            return tokenizer.nextCharCode() === APOSTROPHE$2
                ? readProperty$1(tokenizer)
                : readType(tokenizer);

        case VERTICALLINE$3:
            return {
                type: 'Combinator',
                value: tokenizer.substringToPos(
                    tokenizer.pos + (tokenizer.nextCharCode() === VERTICALLINE$3 ? 2 : 1)
                )
            };

        case AMPERSAND$5:
            tokenizer.pos++;
            tokenizer.eat(AMPERSAND$5);

            return {
                type: 'Combinator',
                value: '&&'
            };

        case COMMA:
            tokenizer.pos++;
            return {
                type: 'Comma'
            };

        case APOSTROPHE$2:
            return maybeMultiplied(tokenizer, {
                type: 'String',
                value: scanString(tokenizer)
            });

        case SPACE$2:
        case TAB:
        case N$1:
        case R:
        case F:
            return {
                type: 'Spaces',
                value: scanSpaces(tokenizer)
            };

        case COMMERCIALAT:
            code = tokenizer.nextCharCode();

            if (code < 128 && NAME_CHAR[code] === 1) {
                tokenizer.pos++;
                return {
                    type: 'AtKeyword',
                    name: scanWord(tokenizer)
                };
            }

            return maybeToken(tokenizer);

        case ASTERISK$6:
        case PLUSSIGN$6:
        case QUESTIONMARK$1:
        case NUMBERSIGN$3:
        case EXCLAMATIONMARK$2:
            // prohibited tokens (used as a multiplier start)
            break;

        case LEFTCURLYBRACKET:
            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
            // check next char isn't a number, because it's likely a disjoined multiplier
            code = tokenizer.nextCharCode();

            if (code < 48 || code > 57) {
                return maybeToken(tokenizer);
            }

            break;

        default:
            return maybeToken(tokenizer);
    }
}

function parse$J(source) {
    const tokenizer$1 = new tokenizer.Tokenizer(source);
    const result = readImplicitGroup(tokenizer$1);

    if (tokenizer$1.pos !== source.length) {
        tokenizer$1.error('Unexpected input');
    }

    // reduce redundant groups with single group term
    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
        return result.terms[0];
    }

    return result;
}

parse$K.parse = parse$J;

const parse$I = parse$K;

const MATCH = { type: 'Match' };
const MISMATCH = { type: 'Mismatch' };
const DISALLOW_EMPTY = { type: 'DisallowEmpty' };

const LEFTPARENTHESIS$1 = 40;  // (
const RIGHTPARENTHESIS$1 = 41; // )

function createCondition(match, thenBranch, elseBranch) {
    // reduce node count
    if (thenBranch === MATCH && elseBranch === MISMATCH) {
        return match;
    }

    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
        return match;
    }

    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
        thenBranch = match.then;
        match = match.match;
    }

    return {
        type: 'If',
        match,
        then: thenBranch,
        else: elseBranch
    };
}

function isFunctionType(name) {
    return (
        name.length > 2 &&
        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
    );
}

function isEnumCapatible(term) {
    return (
        term.type === 'Keyword' ||
        term.type === 'AtKeyword' ||
        term.type === 'Function' ||
        term.type === 'Type' && isFunctionType(term.name)
    );
}

function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
    switch (combinator) {
        case ' ': {
            // Juxtaposing components means that all of them must occur, in the given order.
            //
            // a b c
            // =
            // match a
            //   then match b
            //     then match c
            //       then MATCH
            //       else MISMATCH
            //     else MISMATCH
            //   else MISMATCH
            let result = MATCH;

            for (let i = terms.length - 1; i >= 0; i--) {
                const term = terms[i];

                result = createCondition(
                    term,
                    result,
                    MISMATCH
                );
            }
            return result;
        }

        case '|': {
            // A bar (|) separates two or more alternatives: exactly one of them must occur.
            //
            // a | b | c
            // =
            // match a
            //   then MATCH
            //   else match b
            //     then MATCH
            //     else match c
            //       then MATCH
            //       else MISMATCH

            let result = MISMATCH;
            let map = null;

            for (let i = terms.length - 1; i >= 0; i--) {
                let term = terms[i];

                // reduce sequence of keywords into a Enum
                if (isEnumCapatible(term)) {
                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
                        map = Object.create(null);
                        result = createCondition(
                            {
                                type: 'Enum',
                                map
                            },
                            MATCH,
                            result
                        );
                    }

                    if (map !== null) {
                        const key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
                        if (key in map === false) {
                            map[key] = term;
                            continue;
                        }
                    }
                }

                map = null;

                // create a new conditonal node
                result = createCondition(
                    term,
                    MATCH,
                    result
                );
            }
            return result;
        }

        case '&&': {
            // A double ampersand (&&) separates two or more components,
            // all of which must occur, in any order.

            // Use MatchOnce for groups with a large number of terms,
            // since &&-groups produces at least N!-node trees
            if (terms.length > 5) {
                return {
                    type: 'MatchOnce',
                    terms,
                    all: true
                };
            }

            // Use a combination tree for groups with small number of terms
            //
            // a && b && c
            // =
            // match a
            //   then [b && c]
            //   else match b
            //     then [a && c]
            //     else match c
            //       then [a && b]
            //       else MISMATCH
            //
            // a && b
            // =
            // match a
            //   then match b
            //     then MATCH
            //     else MISMATCH
            //   else match b
            //     then match a
            //       then MATCH
            //       else MISMATCH
            //     else MISMATCH
            let result = MISMATCH;

            for (let i = terms.length - 1; i >= 0; i--) {
                const term = terms[i];
                let thenClause;

                if (terms.length > 1) {
                    thenClause = buildGroupMatchGraph(
                        combinator,
                        terms.filter(function(newGroupTerm) {
                            return newGroupTerm !== term;
                        }),
                        false
                    );
                } else {
                    thenClause = MATCH;
                }

                result = createCondition(
                    term,
                    thenClause,
                    result
                );
            }
            return result;
        }

        case '||': {
            // A double bar (||) separates two or more options:
            // one or more of them must occur, in any order.

            // Use MatchOnce for groups with a large number of terms,
            // since ||-groups produces at least N!-node trees
            if (terms.length > 5) {
                return {
                    type: 'MatchOnce',
                    terms,
                    all: false
                };
            }

            // Use a combination tree for groups with small number of terms
            //
            // a || b || c
            // =
            // match a
            //   then [b || c]
            //   else match b
            //     then [a || c]
            //     else match c
            //       then [a || b]
            //       else MISMATCH
            //
            // a || b
            // =
            // match a
            //   then match b
            //     then MATCH
            //     else MATCH
            //   else match b
            //     then match a
            //       then MATCH
            //       else MATCH
            //     else MISMATCH
            let result = atLeastOneTermMatched ? MATCH : MISMATCH;

            for (let i = terms.length - 1; i >= 0; i--) {
                const term = terms[i];
                let thenClause;

                if (terms.length > 1) {
                    thenClause = buildGroupMatchGraph(
                        combinator,
                        terms.filter(function(newGroupTerm) {
                            return newGroupTerm !== term;
                        }),
                        true
                    );
                } else {
                    thenClause = MATCH;
                }

                result = createCondition(
                    term,
                    thenClause,
                    result
                );
            }
            return result;
        }
    }
}

function buildMultiplierMatchGraph(node) {
    let result = MATCH;
    let matchTerm = buildMatchGraphInternal(node.term);

    if (node.max === 0) {
        // disable repeating of empty match to prevent infinite loop
        matchTerm = createCondition(
            matchTerm,
            DISALLOW_EMPTY,
            MISMATCH
        );

        // an occurrence count is not limited, make a cycle;
        // to collect more terms on each following matching mismatch
        result = createCondition(
            matchTerm,
            null, // will be a loop
            MISMATCH
        );

        result.then = createCondition(
            MATCH,
            MATCH,
            result // make a loop
        );

        if (node.comma) {
            result.then.else = createCondition(
                { type: 'Comma', syntax: node },
                result,
                MISMATCH
            );
        }
    } else {
        // create a match node chain for [min .. max] interval with optional matches
        for (let i = node.min || 1; i <= node.max; i++) {
            if (node.comma && result !== MATCH) {
                result = createCondition(
                    { type: 'Comma', syntax: node },
                    result,
                    MISMATCH
                );
            }

            result = createCondition(
                matchTerm,
                createCondition(
                    MATCH,
                    MATCH,
                    result
                ),
                MISMATCH
            );
        }
    }

    if (node.min === 0) {
        // allow zero match
        result = createCondition(
            MATCH,
            MATCH,
            result
        );
    } else {
        // create a match node chain to collect [0 ... min - 1] required matches
        for (let i = 0; i < node.min - 1; i++) {
            if (node.comma && result !== MATCH) {
                result = createCondition(
                    { type: 'Comma', syntax: node },
                    result,
                    MISMATCH
                );
            }

            result = createCondition(
                matchTerm,
                result,
                MISMATCH
            );
        }
    }

    return result;
}

function buildMatchGraphInternal(node) {
    if (typeof node === 'function') {
        return {
            type: 'Generic',
            fn: node
        };
    }

    switch (node.type) {
        case 'Group': {
            let result = buildGroupMatchGraph(
                node.combinator,
                node.terms.map(buildMatchGraphInternal),
                false
            );

            if (node.disallowEmpty) {
                result = createCondition(
                    result,
                    DISALLOW_EMPTY,
                    MISMATCH
                );
            }

            return result;
        }

        case 'Multiplier':
            return buildMultiplierMatchGraph(node);

        case 'Type':
        case 'Property':
            return {
                type: node.type,
                name: node.name,
                syntax: node
            };

        case 'Keyword':
            return {
                type: node.type,
                name: node.name.toLowerCase(),
                syntax: node
            };

        case 'AtKeyword':
            return {
                type: node.type,
                name: '@' + node.name.toLowerCase(),
                syntax: node
            };

        case 'Function':
            return {
                type: node.type,
                name: node.name.toLowerCase() + '(',
                syntax: node
            };

        case 'String':
            // convert a one char length String to a Token
            if (node.value.length === 3) {
                return {
                    type: 'Token',
                    value: node.value.charAt(1),
                    syntax: node
                };
            }

            // otherwise use it as is
            return {
                type: node.type,
                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
                syntax: node
            };

        case 'Token':
            return {
                type: node.type,
                value: node.value,
                syntax: node
            };

        case 'Comma':
            return {
                type: node.type,
                syntax: node
            };

        default:
            throw new Error('Unknown node type:', node.type);
    }
}

function buildMatchGraph(syntaxTree, ref) {
    if (typeof syntaxTree === 'string') {
        syntaxTree = parse$I.parse(syntaxTree);
    }

    return {
        type: 'MatchGraph',
        match: buildMatchGraphInternal(syntaxTree),
        syntax: ref || null,
        source: syntaxTree
    };
}

matchGraph$2.DISALLOW_EMPTY = DISALLOW_EMPTY;
matchGraph$2.MATCH = MATCH;
matchGraph$2.MISMATCH = MISMATCH;
matchGraph$2.buildMatchGraph = buildMatchGraph;

var match$1 = {};

const matchGraph$1 = matchGraph$2;
const types$J = types$T;

const { hasOwnProperty: hasOwnProperty$2 } = Object.prototype;
const STUB = 0;
const TOKEN = 1;
const OPEN_SYNTAX = 2;
const CLOSE_SYNTAX = 3;

const EXIT_REASON_MATCH = 'Match';
const EXIT_REASON_MISMATCH = 'Mismatch';
const EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

const ITERATION_LIMIT = 15000;

function reverseList(list) {
    let prev = null;
    let next = null;
    let item = list;

    while (item !== null) {
        next = item.prev;
        item.prev = prev;
        prev = item;
        item = next;
    }

    return prev;
}

function areStringsEqualCaseInsensitive(testStr, referenceStr) {
    if (testStr.length !== referenceStr.length) {
        return false;
    }

    for (let i = 0; i < testStr.length; i++) {
        const referenceCode = referenceStr.charCodeAt(i);
        let testCode = testStr.charCodeAt(i);

        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
        if (testCode >= 0x0041 && testCode <= 0x005A) {
            testCode = testCode | 32;
        }

        if (testCode !== referenceCode) {
            return false;
        }
    }

    return true;
}

function isContextEdgeDelim(token) {
    if (token.type !== types$J.Delim) {
        return false;
    }

    // Fix matching for unicode-range: U+30??, U+FF00-FF9F
    // Probably we need to check out previous match instead
    return token.value !== '?';
}

function isCommaContextStart(token) {
    if (token === null) {
        return true;
    }

    return (
        token.type === types$J.Comma ||
        token.type === types$J.Function ||
        token.type === types$J.LeftParenthesis ||
        token.type === types$J.LeftSquareBracket ||
        token.type === types$J.LeftCurlyBracket ||
        isContextEdgeDelim(token)
    );
}

function isCommaContextEnd(token) {
    if (token === null) {
        return true;
    }

    return (
        token.type === types$J.RightParenthesis ||
        token.type === types$J.RightSquareBracket ||
        token.type === types$J.RightCurlyBracket ||
        (token.type === types$J.Delim && token.value === '/')
    );
}

function internalMatch(tokens, state, syntaxes) {
    function moveToNextToken() {
        do {
            tokenIndex++;
            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
        } while (token !== null && (token.type === types$J.WhiteSpace || token.type === types$J.Comment));
    }

    function getNextToken(offset) {
        const nextIndex = tokenIndex + offset;

        return nextIndex < tokens.length ? tokens[nextIndex] : null;
    }

    function stateSnapshotFromSyntax(nextState, prev) {
        return {
            nextState,
            matchStack,
            syntaxStack,
            thenStack,
            tokenIndex,
            prev
        };
    }

    function pushThenStack(nextState) {
        thenStack = {
            nextState,
            matchStack,
            syntaxStack,
            prev: thenStack
        };
    }

    function pushElseStack(nextState) {
        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
    }

    function addTokenToMatch() {
        matchStack = {
            type: TOKEN,
            syntax: state.syntax,
            token,
            prev: matchStack
        };

        moveToNextToken();
        syntaxStash = null;

        if (tokenIndex > longestMatch) {
            longestMatch = tokenIndex;
        }
    }

    function openSyntax() {
        syntaxStack = {
            syntax: state.syntax,
            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
            prev: syntaxStack
        };

        matchStack = {
            type: OPEN_SYNTAX,
            syntax: state.syntax,
            token: matchStack.token,
            prev: matchStack
        };
    }

    function closeSyntax() {
        if (matchStack.type === OPEN_SYNTAX) {
            matchStack = matchStack.prev;
        } else {
            matchStack = {
                type: CLOSE_SYNTAX,
                syntax: syntaxStack.syntax,
                token: matchStack.token,
                prev: matchStack
            };
        }

        syntaxStack = syntaxStack.prev;
    }

    let syntaxStack = null;
    let thenStack = null;
    let elseStack = null;

    // null – stashing allowed, nothing stashed
    // false – stashing disabled, nothing stashed
    // anithing else – fail stashable syntaxes, some syntax stashed
    let syntaxStash = null;

    let iterationCount = 0; // count iterations and prevent infinite loop
    let exitReason = null;

    let token = null;
    let tokenIndex = -1;
    let longestMatch = 0;
    let matchStack = {
        type: STUB,
        syntax: null,
        token: null,
        prev: null
    };

    moveToNextToken();

    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
        // function mapList(list, fn) {
        //     const result = [];
        //     while (list) {
        //         result.unshift(fn(list));
        //         list = list.prev;
        //     }
        //     return result;
        // }
        // console.log('--\n',
        //     '#' + iterationCount,
        //     require('util').inspect({
        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
        //         token: token && token.value,
        //         tokenIndex,
        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
        //     }, { depth: null })
        // );
        switch (state.type) {
            case 'Match':
                if (thenStack === null) {
                    // turn to MISMATCH when some tokens left unmatched
                    if (token !== null) {
                        // doesn't mismatch if just one token left and it's an IE hack
                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
                            state = matchGraph$1.MISMATCH;
                            break;
                        }
                    }

                    // break the main loop, return a result - MATCH
                    exitReason = EXIT_REASON_MATCH;
                    break;
                }

                // go to next syntax (`then` branch)
                state = thenStack.nextState;

                // check match is not empty
                if (state === matchGraph$1.DISALLOW_EMPTY) {
                    if (thenStack.matchStack === matchStack) {
                        state = matchGraph$1.MISMATCH;
                        break;
                    } else {
                        state = matchGraph$1.MATCH;
                    }
                }

                // close syntax if needed
                while (thenStack.syntaxStack !== syntaxStack) {
                    closeSyntax();
                }

                // pop stack
                thenStack = thenStack.prev;
                break;

            case 'Mismatch':
                // when some syntax is stashed
                if (syntaxStash !== null && syntaxStash !== false) {
                    // there is no else branches or a branch reduce match stack
                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
                        // restore state from the stash
                        elseStack = syntaxStash;
                        syntaxStash = false; // disable stashing
                    }
                } else if (elseStack === null) {
                    // no else branches -> break the main loop
                    // return a result - MISMATCH
                    exitReason = EXIT_REASON_MISMATCH;
                    break;
                }

                // go to next syntax (`else` branch)
                state = elseStack.nextState;

                // restore all the rest stack states
                thenStack = elseStack.thenStack;
                syntaxStack = elseStack.syntaxStack;
                matchStack = elseStack.matchStack;
                tokenIndex = elseStack.tokenIndex;
                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

                // pop stack
                elseStack = elseStack.prev;
                break;

            case 'MatchGraph':
                state = state.match;
                break;

            case 'If':
                // IMPORTANT: else stack push must go first,
                // since it stores the state of thenStack before changes
                if (state.else !== matchGraph$1.MISMATCH) {
                    pushElseStack(state.else);
                }

                if (state.then !== matchGraph$1.MATCH) {
                    pushThenStack(state.then);
                }

                state = state.match;
                break;

            case 'MatchOnce':
                state = {
                    type: 'MatchOnceBuffer',
                    syntax: state,
                    index: 0,
                    mask: 0
                };
                break;

            case 'MatchOnceBuffer': {
                const terms = state.syntax.terms;

                if (state.index === terms.length) {
                    // no matches at all or it's required all terms to be matched
                    if (state.mask === 0 || state.syntax.all) {
                        state = matchGraph$1.MISMATCH;
                        break;
                    }

                    // a partial match is ok
                    state = matchGraph$1.MATCH;
                    break;
                }

                // all terms are matched
                if (state.mask === (1 << terms.length) - 1) {
                    state = matchGraph$1.MATCH;
                    break;
                }

                for (; state.index < terms.length; state.index++) {
                    const matchFlag = 1 << state.index;

                    if ((state.mask & matchFlag) === 0) {
                        // IMPORTANT: else stack push must go first,
                        // since it stores the state of thenStack before changes
                        pushElseStack(state);
                        pushThenStack({
                            type: 'AddMatchOnce',
                            syntax: state.syntax,
                            mask: state.mask | matchFlag
                        });

                        // match
                        state = terms[state.index++];
                        break;
                    }
                }
                break;
            }

            case 'AddMatchOnce':
                state = {
                    type: 'MatchOnceBuffer',
                    syntax: state.syntax,
                    index: 0,
                    mask: state.mask
                };
                break;

            case 'Enum':
                if (token !== null) {
                    let name = token.value.toLowerCase();

                    // drop \0 and \9 hack from keyword name
                    if (name.indexOf('\\') !== -1) {
                        name = name.replace(/\\[09].*$/, '');
                    }

                    if (hasOwnProperty$2.call(state.map, name)) {
                        state = state.map[name];
                        break;
                    }
                }

                state = matchGraph$1.MISMATCH;
                break;

            case 'Generic': {
                const opts = syntaxStack !== null ? syntaxStack.opts : null;
                const lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
                    while (tokenIndex < lastTokenIndex) {
                        addTokenToMatch();
                    }

                    state = matchGraph$1.MATCH;
                } else {
                    state = matchGraph$1.MISMATCH;
                }

                break;
            }

            case 'Type':
            case 'Property': {
                const syntaxDict = state.type === 'Type' ? 'types' : 'properties';
                const dictSyntax = hasOwnProperty$2.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

                if (!dictSyntax || !dictSyntax.match) {
                    throw new Error(
                        'Bad syntax reference: ' +
                        (state.type === 'Type'
                            ? '<' + state.name + '>'
                            : '<\'' + state.name + '\'>')
                    );
                }

                // stash a syntax for types with low priority
                if (syntaxStash !== false && token !== null && state.type === 'Type') {
                    const lowPriorityMatching =
                        // https://drafts.csswg.org/css-values-4/#custom-idents
                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
                        // can only claim the keyword if no other unfulfilled production can claim it.
                        (state.name === 'custom-ident' && token.type === types$J.Ident) ||

                        // https://drafts.csswg.org/css-values-4/#lengths
                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
                        // it must parse as a <number>
                        (state.name === 'length' && token.value === '0');

                    if (lowPriorityMatching) {
                        if (syntaxStash === null) {
                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
                        }

                        state = matchGraph$1.MISMATCH;
                        break;
                    }
                }

                openSyntax();
                state = dictSyntax.match;
                break;
            }

            case 'Keyword': {
                const name = state.name;

                if (token !== null) {
                    let keywordName = token.value;

                    // drop \0 and \9 hack from keyword name
                    if (keywordName.indexOf('\\') !== -1) {
                        keywordName = keywordName.replace(/\\[09].*$/, '');
                    }

                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
                        addTokenToMatch();
                        state = matchGraph$1.MATCH;
                        break;
                    }
                }

                state = matchGraph$1.MISMATCH;
                break;
            }

            case 'AtKeyword':
            case 'Function':
                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
                    addTokenToMatch();
                    state = matchGraph$1.MATCH;
                    break;
                }

                state = matchGraph$1.MISMATCH;
                break;

            case 'Token':
                if (token !== null && token.value === state.value) {
                    addTokenToMatch();
                    state = matchGraph$1.MATCH;
                    break;
                }

                state = matchGraph$1.MISMATCH;
                break;

            case 'Comma':
                if (token !== null && token.type === types$J.Comma) {
                    if (isCommaContextStart(matchStack.token)) {
                        state = matchGraph$1.MISMATCH;
                    } else {
                        addTokenToMatch();
                        state = isCommaContextEnd(token) ? matchGraph$1.MISMATCH : matchGraph$1.MATCH;
                    }
                } else {
                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? matchGraph$1.MATCH : matchGraph$1.MISMATCH;
                }

                break;

            case 'String':
                let string = '';
                let lastTokenIndex = tokenIndex;

                for (; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
                    string += tokens[lastTokenIndex].value;
                }

                if (areStringsEqualCaseInsensitive(string, state.value)) {
                    while (tokenIndex < lastTokenIndex) {
                        addTokenToMatch();
                    }

                    state = matchGraph$1.MATCH;
                } else {
                    state = matchGraph$1.MISMATCH;
                }

                break;

            default:
                throw new Error('Unknown node type: ' + state.type);
        }
    }

    switch (exitReason) {
        case null:
            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
            exitReason = EXIT_REASON_ITERATION_LIMIT;
            matchStack = null;
            break;

        case EXIT_REASON_MATCH:
            while (syntaxStack !== null) {
                closeSyntax();
            }
            break;

        default:
            matchStack = null;
    }

    return {
        tokens,
        reason: exitReason,
        iterations: iterationCount,
        match: matchStack,
        longestMatch
    };
}

function matchAsList(tokens, matchGraph, syntaxes) {
    const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

    if (matchResult.match !== null) {
        let item = reverseList(matchResult.match).prev;

        matchResult.match = [];

        while (item !== null) {
            switch (item.type) {
                case OPEN_SYNTAX:
                case CLOSE_SYNTAX:
                    matchResult.match.push({
                        type: item.type,
                        syntax: item.syntax
                    });
                    break;

                default:
                    matchResult.match.push({
                        token: item.token.value,
                        node: item.token.node
                    });
                    break;
            }

            item = item.prev;
        }
    }

    return matchResult;
}

function matchAsTree(tokens, matchGraph, syntaxes) {
    const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

    if (matchResult.match === null) {
        return matchResult;
    }

    let item = matchResult.match;
    let host = matchResult.match = {
        syntax: matchGraph.syntax || null,
        match: []
    };
    const hostStack = [host];

    // revert a list and start with 2nd item since 1st is a stub item
    item = reverseList(item).prev;

    // build a tree
    while (item !== null) {
        switch (item.type) {
            case OPEN_SYNTAX:
                host.match.push(host = {
                    syntax: item.syntax,
                    match: []
                });
                hostStack.push(host);
                break;

            case CLOSE_SYNTAX:
                hostStack.pop();
                host = hostStack[hostStack.length - 1];
                break;

            default:
                host.match.push({
                    syntax: item.syntax || null,
                    token: item.token.value,
                    node: item.token.node
                });
        }

        item = item.prev;
    }

    return matchResult;
}

match$1.matchAsList = matchAsList;
match$1.matchAsTree = matchAsTree;

var trace$1 = {};

function getTrace(node) {
    function shouldPutToTrace(syntax) {
        if (syntax === null) {
            return false;
        }

        return (
            syntax.type === 'Type' ||
            syntax.type === 'Property' ||
            syntax.type === 'Keyword'
        );
    }

    function hasMatch(matchNode) {
        if (Array.isArray(matchNode.match)) {
            // use for-loop for better perfomance
            for (let i = 0; i < matchNode.match.length; i++) {
                if (hasMatch(matchNode.match[i])) {
                    if (shouldPutToTrace(matchNode.syntax)) {
                        result.unshift(matchNode.syntax);
                    }

                    return true;
                }
            }
        } else if (matchNode.node === node) {
            result = shouldPutToTrace(matchNode.syntax)
                ? [matchNode.syntax]
                : [];

            return true;
        }

        return false;
    }

    let result = null;

    if (this.matched !== null) {
        hasMatch(this.matched);
    }

    return result;
}

function isType(node, type) {
    return testNode(this, node, match => match.type === 'Type' && match.name === type);
}

function isProperty(node, property) {
    return testNode(this, node, match => match.type === 'Property' && match.name === property);
}

function isKeyword(node) {
    return testNode(this, node, match => match.type === 'Keyword');
}

function testNode(match, node, fn) {
    const trace = getTrace.call(match, node);

    if (trace === null) {
        return false;
    }

    return trace.some(fn);
}

trace$1.getTrace = getTrace;
trace$1.isKeyword = isKeyword;
trace$1.isProperty = isProperty;
trace$1.isType = isType;

var search$1 = {};

const List$3 = List$7;

function getFirstMatchNode(matchNode) {
    if ('node' in matchNode) {
        return matchNode.node;
    }

    return getFirstMatchNode(matchNode.match[0]);
}

function getLastMatchNode(matchNode) {
    if ('node' in matchNode) {
        return matchNode.node;
    }

    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
}

function matchFragments(lexer, ast, match, type, name) {
    function findFragments(matchNode) {
        if (matchNode.syntax !== null &&
            matchNode.syntax.type === type &&
            matchNode.syntax.name === name) {
            const start = getFirstMatchNode(matchNode);
            const end = getLastMatchNode(matchNode);

            lexer.syntax.walk(ast, function(node, item, list) {
                if (node === start) {
                    const nodes = new List$3.List();

                    do {
                        nodes.appendData(item.data);

                        if (item.data === end) {
                            break;
                        }

                        item = item.next;
                    } while (item !== null);

                    fragments.push({
                        parent: list,
                        nodes
                    });
                }
            });
        }

        if (Array.isArray(matchNode.match)) {
            matchNode.match.forEach(findFragments);
        }
    }

    const fragments = [];

    if (match.matched !== null) {
        findFragments(match.matched);
    }

    return fragments;
}

search$1.matchFragments = matchFragments;

var structure$G = {};

const List$2 = List$7;

const { hasOwnProperty: hasOwnProperty$1 } = Object.prototype;

function isValidNumber(value) {
    // Number.isInteger(value) && value >= 0
    return (
        typeof value === 'number' &&
        isFinite(value) &&
        Math.floor(value) === value &&
        value >= 0
    );
}

function isValidLocation(loc) {
    return (
        Boolean(loc) &&
        isValidNumber(loc.offset) &&
        isValidNumber(loc.line) &&
        isValidNumber(loc.column)
    );
}

function createNodeStructureChecker(type, fields) {
    return function checkNode(node, warn) {
        if (!node || node.constructor !== Object) {
            return warn(node, 'Type of node should be an Object');
        }

        for (let key in node) {
            let valid = true;

            if (hasOwnProperty$1.call(node, key) === false) {
                continue;
            }

            if (key === 'type') {
                if (node.type !== type) {
                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
                }
            } else if (key === 'loc') {
                if (node.loc === null) {
                    continue;
                } else if (node.loc && node.loc.constructor === Object) {
                    if (typeof node.loc.source !== 'string') {
                        key += '.source';
                    } else if (!isValidLocation(node.loc.start)) {
                        key += '.start';
                    } else if (!isValidLocation(node.loc.end)) {
                        key += '.end';
                    } else {
                        continue;
                    }
                }

                valid = false;
            } else if (fields.hasOwnProperty(key)) {
                valid = false;

                for (let i = 0; !valid && i < fields[key].length; i++) {
                    const fieldType = fields[key][i];

                    switch (fieldType) {
                        case String:
                            valid = typeof node[key] === 'string';
                            break;

                        case Boolean:
                            valid = typeof node[key] === 'boolean';
                            break;

                        case null:
                            valid = node[key] === null;
                            break;

                        default:
                            if (typeof fieldType === 'string') {
                                valid = node[key] && node[key].type === fieldType;
                            } else if (Array.isArray(fieldType)) {
                                valid = node[key] instanceof List$2.List;
                            }
                    }
                }
            } else {
                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
            }

            if (!valid) {
                warn(node, 'Bad value for `' + type + '.' + key + '`');
            }
        }

        for (const key in fields) {
            if (hasOwnProperty$1.call(fields, key) &&
                hasOwnProperty$1.call(node, key) === false) {
                warn(node, 'Field `' + type + '.' + key + '` is missed');
            }
        }
    };
}

function processStructure(name, nodeType) {
    const structure = nodeType.structure;
    const fields = {
        type: String,
        loc: true
    };
    const docs = {
        type: '"' + name + '"'
    };

    for (const key in structure) {
        if (hasOwnProperty$1.call(structure, key) === false) {
            continue;
        }

        const docsTypes = [];
        const fieldTypes = fields[key] = Array.isArray(structure[key])
            ? structure[key].slice()
            : [structure[key]];

        for (let i = 0; i < fieldTypes.length; i++) {
            const fieldType = fieldTypes[i];
            if (fieldType === String || fieldType === Boolean) {
                docsTypes.push(fieldType.name);
            } else if (fieldType === null) {
                docsTypes.push('null');
            } else if (typeof fieldType === 'string') {
                docsTypes.push('<' + fieldType + '>');
            } else if (Array.isArray(fieldType)) {
                docsTypes.push('List'); // TODO: use type enum
            } else {
                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
            }
        }

        docs[key] = docsTypes.join(' | ');
    }

    return {
        docs,
        check: createNodeStructureChecker(name, fields)
    };
}

function getStructureFromConfig(config) {
    const structure = {};

    if (config.node) {
        for (const name in config.node) {
            if (hasOwnProperty$1.call(config.node, name)) {
                const nodeType = config.node[name];

                if (nodeType.structure) {
                    structure[name] = processStructure(name, nodeType);
                } else {
                    throw new Error('Missed `structure` field in `' + name + '` node type definition');
                }
            }
        }
    }

    return structure;
}

structure$G.getStructureFromConfig = getStructureFromConfig;

var walk$4 = {};

const noop = function() {};

function ensureFunction(value) {
    return typeof value === 'function' ? value : noop;
}

function walk$3(node, options, context) {
    function walk(node) {
        enter.call(context, node);

        switch (node.type) {
            case 'Group':
                node.terms.forEach(walk);
                break;

            case 'Multiplier':
                walk(node.term);
                break;

            case 'Type':
            case 'Property':
            case 'Keyword':
            case 'AtKeyword':
            case 'Function':
            case 'String':
            case 'Token':
            case 'Comma':
                break;

            default:
                throw new Error('Unknown type: ' + node.type);
        }

        leave.call(context, node);
    }

    let enter = noop;
    let leave = noop;

    if (typeof options === 'function') {
        enter = options;
    } else if (options) {
        enter = ensureFunction(options.enter);
        leave = ensureFunction(options.leave);
    }

    if (enter === noop && leave === noop) {
        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
    }

    walk(node);
}

walk$4.walk = walk$3;

const error = error$1;
const names$3 = names$4;
const genericConst = genericConst$2;
const generic = generic$1;
const units = units$1;
const prepareTokens = prepareTokens_1;
const matchGraph = matchGraph$2;
const match = match$1;
const trace = trace$1;
const search = search$1;
const structure$F = structure$G;
const parse$H = parse$K;
const generate$H = generate$K;
const walk$2 = walk$4;

const cssWideKeywordsSyntax = matchGraph.buildMatchGraph(genericConst.cssWideKeywords.join(' | '));

function dumpMapSyntax(map, compact, syntaxAsAst) {
    const result = {};

    for (const name in map) {
        if (map[name].syntax) {
            result[name] = syntaxAsAst
                ? map[name].syntax
                : generate$H.generate(map[name].syntax, { compact });
        }
    }

    return result;
}

function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
    const result = {};

    for (const [name, atrule] of Object.entries(map)) {
        result[name] = {
            prelude: atrule.prelude && (
                syntaxAsAst
                    ? atrule.prelude.syntax
                    : generate$H.generate(atrule.prelude.syntax, { compact })
            ),
            descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
        };
    }

    return result;
}

function valueHasVar(tokens) {
    for (let i = 0; i < tokens.length; i++) {
        if (tokens[i].value.toLowerCase() === 'var(') {
            return true;
        }
    }

    return false;
}

function buildMatchResult(matched, error, iterations) {
    return {
        matched,
        iterations,
        error,
        ...trace
    };
}

function matchSyntax(lexer, syntax, value, useCssWideKeywords) {
    const tokens = prepareTokens(value, lexer.syntax);
    let result;

    if (valueHasVar(tokens)) {
        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
    }

    if (useCssWideKeywords) {
        result = match.matchAsTree(tokens, lexer.cssWideKeywordsSyntax, lexer);
    }

    if (!useCssWideKeywords || !result.match) {
        result = match.matchAsTree(tokens, syntax.match, lexer);
        if (!result.match) {
            return buildMatchResult(
                null,
                new error.SyntaxMatchError(result.reason, syntax.syntax, value, result),
                result.iterations
            );
        }
    }

    return buildMatchResult(result.match, null, result.iterations);
}

let Lexer$2 = class Lexer {
    constructor(config, syntax, structure$1) {
        this.cssWideKeywordsSyntax = cssWideKeywordsSyntax;
        this.syntax = syntax;
        this.generic = false;
        this.units = { ...units };
        this.atrules = Object.create(null);
        this.properties = Object.create(null);
        this.types = Object.create(null);
        this.structure = structure$1 || structure$F.getStructureFromConfig(config);

        if (config) {
            if (config.units) {
                for (const group of Object.keys(units)) {
                    if (Array.isArray(config.units[group])) {
                        this.units[group] = config.units[group];
                    }
                }
            }

            if (config.types) {
                for (const name in config.types) {
                    this.addType_(name, config.types[name]);
                }
            }

            if (config.generic) {
                this.generic = true;
                for (const [name, value] of Object.entries(generic.createGenericTypes(this.units))) {
                    this.addType_(name, value);
                }
            }

            if (config.atrules) {
                for (const name in config.atrules) {
                    this.addAtrule_(name, config.atrules[name]);
                }
            }

            if (config.properties) {
                for (const name in config.properties) {
                    this.addProperty_(name, config.properties[name]);
                }
            }
        }
    }

    checkStructure(ast) {
        function collectWarning(node, message) {
            warns.push({ node, message });
        }

        const structure = this.structure;
        const warns = [];

        this.syntax.walk(ast, function(node) {
            if (structure.hasOwnProperty(node.type)) {
                structure[node.type].check(node, collectWarning);
            } else {
                collectWarning(node, 'Unknown node type `' + node.type + '`');
            }
        });

        return warns.length ? warns : false;
    }

    createDescriptor(syntax, type, name, parent = null) {
        const ref = {
            type,
            name
        };
        const descriptor = {
            type,
            name,
            parent,
            serializable: typeof syntax === 'string' || (syntax && typeof syntax.type === 'string'),
            syntax: null,
            match: null
        };

        if (typeof syntax === 'function') {
            descriptor.match = matchGraph.buildMatchGraph(syntax, ref);
        } else {
            if (typeof syntax === 'string') {
                // lazy parsing on first access
                Object.defineProperty(descriptor, 'syntax', {
                    get() {
                        Object.defineProperty(descriptor, 'syntax', {
                            value: parse$H.parse(syntax)
                        });

                        return descriptor.syntax;
                    }
                });
            } else {
                descriptor.syntax = syntax;
            }

            // lazy graph build on first access
            Object.defineProperty(descriptor, 'match', {
                get() {
                    Object.defineProperty(descriptor, 'match', {
                        value: matchGraph.buildMatchGraph(descriptor.syntax, ref)
                    });

                    return descriptor.match;
                }
            });
        }

        return descriptor;
    }
    addAtrule_(name, syntax) {
        if (!syntax) {
            return;
        }

        this.atrules[name] = {
            type: 'Atrule',
            name: name,
            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
            descriptors: syntax.descriptors
                ? Object.keys(syntax.descriptors).reduce(
                    (map, descName) => {
                        map[descName] = this.createDescriptor(syntax.descriptors[descName], 'AtruleDescriptor', descName, name);
                        return map;
                    },
                    Object.create(null)
                )
                : null
        };
    }
    addProperty_(name, syntax) {
        if (!syntax) {
            return;
        }

        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
    }
    addType_(name, syntax) {
        if (!syntax) {
            return;
        }

        this.types[name] = this.createDescriptor(syntax, 'Type', name);
    }

    checkAtruleName(atruleName) {
        if (!this.getAtrule(atruleName)) {
            return new error.SyntaxReferenceError('Unknown at-rule', '@' + atruleName);
        }
    }
    checkAtrulePrelude(atruleName, prelude) {
        const error = this.checkAtruleName(atruleName);

        if (error) {
            return error;
        }

        const atrule = this.getAtrule(atruleName);

        if (!atrule.prelude && prelude) {
            return new SyntaxError('At-rule `@' + atruleName + '` should not contain a prelude');
        }

        if (atrule.prelude && !prelude) {
            if (!matchSyntax(this, atrule.prelude, '', false).matched) {
                return new SyntaxError('At-rule `@' + atruleName + '` should contain a prelude');
            }
        }
    }
    checkAtruleDescriptorName(atruleName, descriptorName) {
        const error$1 = this.checkAtruleName(atruleName);

        if (error$1) {
            return error$1;
        }

        const atrule = this.getAtrule(atruleName);
        const descriptor = names$3.keyword(descriptorName);

        if (!atrule.descriptors) {
            return new SyntaxError('At-rule `@' + atruleName + '` has no known descriptors');
        }

        if (!atrule.descriptors[descriptor.name] &&
            !atrule.descriptors[descriptor.basename]) {
            return new error.SyntaxReferenceError('Unknown at-rule descriptor', descriptorName);
        }
    }
    checkPropertyName(propertyName) {
        if (!this.getProperty(propertyName)) {
            return new error.SyntaxReferenceError('Unknown property', propertyName);
        }
    }

    matchAtrulePrelude(atruleName, prelude) {
        const error = this.checkAtrulePrelude(atruleName, prelude);

        if (error) {
            return buildMatchResult(null, error);
        }

        const atrule = this.getAtrule(atruleName);

        if (!atrule.prelude) {
            return buildMatchResult(null, null);
        }

        return matchSyntax(this, atrule.prelude, prelude || '', false);
    }
    matchAtruleDescriptor(atruleName, descriptorName, value) {
        const error = this.checkAtruleDescriptorName(atruleName, descriptorName);

        if (error) {
            return buildMatchResult(null, error);
        }

        const atrule = this.getAtrule(atruleName);
        const descriptor = names$3.keyword(descriptorName);

        return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
    }
    matchDeclaration(node) {
        if (node.type !== 'Declaration') {
            return buildMatchResult(null, new Error('Not a Declaration node'));
        }

        return this.matchProperty(node.property, node.value);
    }
    matchProperty(propertyName, value) {
        // don't match syntax for a custom property at the moment
        if (names$3.property(propertyName).custom) {
            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
        }

        const error = this.checkPropertyName(propertyName);

        if (error) {
            return buildMatchResult(null, error);
        }

        return matchSyntax(this, this.getProperty(propertyName), value, true);
    }
    matchType(typeName, value) {
        const typeSyntax = this.getType(typeName);

        if (!typeSyntax) {
            return buildMatchResult(null, new error.SyntaxReferenceError('Unknown type', typeName));
        }

        return matchSyntax(this, typeSyntax, value, false);
    }
    match(syntax, value) {
        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
            return buildMatchResult(null, new error.SyntaxReferenceError('Bad syntax'));
        }

        if (typeof syntax === 'string' || !syntax.match) {
            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
        }

        return matchSyntax(this, syntax, value, false);
    }

    findValueFragments(propertyName, value, type, name) {
        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
    }
    findDeclarationValueFragments(declaration, type, name) {
        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
    }
    findAllFragments(ast, type, name) {
        const result = [];

        this.syntax.walk(ast, {
            visit: 'Declaration',
            enter: (declaration) => {
                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
            }
        });

        return result;
    }

    getAtrule(atruleName, fallbackBasename = true) {
        const atrule = names$3.keyword(atruleName);
        const atruleEntry = atrule.vendor && fallbackBasename
            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
            : this.atrules[atrule.name];

        return atruleEntry || null;
    }
    getAtrulePrelude(atruleName, fallbackBasename = true) {
        const atrule = this.getAtrule(atruleName, fallbackBasename);

        return atrule && atrule.prelude || null;
    }
    getAtruleDescriptor(atruleName, name) {
        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
            ? this.atrules[atruleName].declarators[name] || null
            : null;
    }
    getProperty(propertyName, fallbackBasename = true) {
        const property = names$3.property(propertyName);
        const propertyEntry = property.vendor && fallbackBasename
            ? this.properties[property.name] || this.properties[property.basename]
            : this.properties[property.name];

        return propertyEntry || null;
    }
    getType(name) {
        return hasOwnProperty.call(this.types, name) ? this.types[name] : null;
    }

    validate() {
        function validate(syntax, name, broken, descriptor) {
            if (broken.has(name)) {
                return broken.get(name);
            }

            broken.set(name, false);
            if (descriptor.syntax !== null) {
                walk$2.walk(descriptor.syntax, function(node) {
                    if (node.type !== 'Type' && node.type !== 'Property') {
                        return;
                    }

                    const map = node.type === 'Type' ? syntax.types : syntax.properties;
                    const brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

                    if (!hasOwnProperty.call(map, node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
                        broken.set(name, true);
                    }
                }, this);
            }
        }

        let brokenTypes = new Map();
        let brokenProperties = new Map();

        for (const key in this.types) {
            validate(this, key, brokenTypes, this.types[key]);
        }

        for (const key in this.properties) {
            validate(this, key, brokenProperties, this.properties[key]);
        }

        brokenTypes = [...brokenTypes.keys()].filter(name => brokenTypes.get(name));
        brokenProperties = [...brokenProperties.keys()].filter(name => brokenProperties.get(name));

        if (brokenTypes.length || brokenProperties.length) {
            return {
                types: brokenTypes,
                properties: brokenProperties
            };
        }

        return null;
    }
    dump(syntaxAsAst, pretty) {
        return {
            generic: this.generic,
            units: this.units,
            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
            atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
        };
    }
    toString() {
        return JSON.stringify(this.dump());
    }
};

Lexer$3.Lexer = Lexer$2;

function appendOrSet(a, b) {
    if (typeof b === 'string' && /^\s*\|/.test(b)) {
        return typeof a === 'string'
            ? a + b
            : b.replace(/^\s*\|\s*/, '');
    }

    return b || null;
}

function sliceProps(obj, props) {
    const result = Object.create(null);

    for (const [key, value] of Object.entries(obj)) {
        if (value) {
            result[key] = {};
            for (const prop of Object.keys(value)) {
                if (props.includes(prop)) {
                    result[key][prop] = value[prop];
                }
            }
        }
    }

    return result;
}

function mix$1(dest, src) {
    const result = { ...dest };

    for (const [prop, value] of Object.entries(src)) {
        switch (prop) {
            case 'generic':
                result[prop] = Boolean(value);
                break;

            case 'units':
                result[prop] = { ...dest[prop] };
                for (const [name, patch] of Object.entries(value)) {
                    result[prop][name] = Array.isArray(patch) ? patch : [];
                }
                break;

            case 'atrules':
                result[prop] = { ...dest[prop] };

                for (const [name, atrule] of Object.entries(value)) {
                    const exists = result[prop][name] || {};
                    const current = result[prop][name] = {
                        prelude: exists.prelude || null,
                        descriptors: {
                            ...exists.descriptors
                        }
                    };

                    if (!atrule) {
                        continue;
                    }

                    current.prelude = atrule.prelude
                        ? appendOrSet(current.prelude, atrule.prelude)
                        : current.prelude || null;

                    for (const [descriptorName, descriptorValue] of Object.entries(atrule.descriptors || {})) {
                        current.descriptors[descriptorName] = descriptorValue
                            ? appendOrSet(current.descriptors[descriptorName], descriptorValue)
                            : null;
                    }

                    if (!Object.keys(current.descriptors).length) {
                        current.descriptors = null;
                    }
                }
                break;

            case 'types':
            case 'properties':
                result[prop] = { ...dest[prop] };
                for (const [name, syntax] of Object.entries(value)) {
                    result[prop][name] = appendOrSet(result[prop][name], syntax);
                }
                break;

            case 'scope':
                result[prop] = { ...dest[prop] };
                for (const [name, props] of Object.entries(value)) {
                    result[prop][name] = { ...result[prop][name], ...props };
                }
                break;

            case 'parseContext':
                result[prop] = {
                    ...dest[prop],
                    ...value
                };
                break;

            case 'atrule':
            case 'pseudo':
                result[prop] = {
                    ...dest[prop],
                    ...sliceProps(value, ['parse']) };
                break;

            case 'node':
                result[prop] = {
                    ...dest[prop],
                    ...sliceProps(value, ['name', 'structure', 'parse', 'generate', 'walkContext'])
                };
                break;
        }
    }

    return result;
}

var mix_1 = mix$1;

const index$5 = tokenizer$2;
const create$2 = create$7;
const create$2$1 = create$6;
const create$3 = create$5;
const create$1$1 = create$4;
const Lexer$1 = Lexer$3;
const mix = mix_1;

function createSyntax(config) {
    const parse = create$2.createParser(config);
    const walk = create$1$1.createWalker(config);
    const generate = create$2$1.createGenerator(config);
    const { fromPlainObject, toPlainObject } = create$3.createConvertor(walk);

    const syntax = {
        lexer: null,
        createLexer: config => new Lexer$1.Lexer(config, syntax, syntax.lexer.structure),

        tokenize: index$5.tokenize,
        parse,
        generate,

        walk,
        find: walk.find,
        findLast: walk.findLast,
        findAll: walk.findAll,

        fromPlainObject,
        toPlainObject,

        fork(extension) {
            const base = mix({}, config); // copy of config

            return createSyntax(
                typeof extension === 'function'
                    ? extension(base, Object.assign)
                    : mix(base, extension)
            );
        }
    };

    syntax.lexer = new Lexer$1.Lexer({
        generic: true,
        units: config.units,
        types: config.types,
        atrules: config.atrules,
        properties: config.properties,
        node: config.node
    }, syntax);

    return syntax;
}
const createSyntax$1 = config => createSyntax(mix({}, config));

var create_1 = createSyntax$1;

const atrules = {
	charset: {
		prelude: "<string>"
	},
	"font-face": {
		descriptors: {
			"unicode-range": {
				comment: "replaces <unicode-range>, an old production name",
				syntax: "<urange>#"
			}
		}
	},
	nest: {
		prelude: "<complex-selector-list>"
	}
};
const properties$2 = {
	"-moz-background-clip": {
		comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
		syntax: "padding | border"
	},
	"-moz-border-radius-bottomleft": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
		syntax: "<'border-bottom-left-radius'>"
	},
	"-moz-border-radius-bottomright": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
		syntax: "<'border-bottom-right-radius'>"
	},
	"-moz-border-radius-topleft": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
		syntax: "<'border-top-left-radius'>"
	},
	"-moz-border-radius-topright": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
		syntax: "<'border-bottom-right-radius'>"
	},
	"-moz-control-character-visibility": {
		comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
		syntax: "visible | hidden"
	},
	"-moz-osx-font-smoothing": {
		comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
		syntax: "auto | grayscale"
	},
	"-moz-user-select": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
		syntax: "none | text | all | -moz-none"
	},
	"-ms-flex-align": {
		comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
		syntax: "start | end | center | baseline | stretch"
	},
	"-ms-flex-item-align": {
		comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
		syntax: "auto | start | end | center | baseline | stretch"
	},
	"-ms-flex-line-pack": {
		comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
		syntax: "start | end | center | justify | distribute | stretch"
	},
	"-ms-flex-negative": {
		comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
		syntax: "<'flex-shrink'>"
	},
	"-ms-flex-pack": {
		comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
		syntax: "start | end | center | justify | distribute"
	},
	"-ms-flex-order": {
		comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
		syntax: "<integer>"
	},
	"-ms-flex-positive": {
		comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
		syntax: "<'flex-grow'>"
	},
	"-ms-flex-preferred-size": {
		comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
		syntax: "<'flex-basis'>"
	},
	"-ms-interpolation-mode": {
		comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
		syntax: "nearest-neighbor | bicubic"
	},
	"-ms-grid-column-align": {
		comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
		syntax: "start | end | center | stretch"
	},
	"-ms-grid-row-align": {
		comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
		syntax: "start | end | center | stretch"
	},
	"-ms-hyphenate-limit-last": {
		comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
		syntax: "none | always | column | page | spread"
	},
	"-webkit-appearance": {
		comment: "webkit specific keywords",
		references: [
			"http://css-infos.net/property/-webkit-appearance"
		],
		syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button"
	},
	"-webkit-background-clip": {
		comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
		syntax: "[ <box> | border | padding | content | text ]#"
	},
	"-webkit-column-break-after": {
		comment: "added, http://help.dottoro.com/lcrthhhv.php",
		syntax: "always | auto | avoid"
	},
	"-webkit-column-break-before": {
		comment: "added, http://help.dottoro.com/lcxquvkf.php",
		syntax: "always | auto | avoid"
	},
	"-webkit-column-break-inside": {
		comment: "added, http://help.dottoro.com/lclhnthl.php",
		syntax: "always | auto | avoid"
	},
	"-webkit-font-smoothing": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
		syntax: "auto | none | antialiased | subpixel-antialiased"
	},
	"-webkit-mask-box-image": {
		comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
		syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
	},
	"-webkit-print-color-adjust": {
		comment: "missed",
		references: [
			"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
		],
		syntax: "economy | exact"
	},
	"-webkit-text-security": {
		comment: "missed; http://help.dottoro.com/lcbkewgt.php",
		syntax: "none | circle | disc | square"
	},
	"-webkit-user-drag": {
		comment: "missed; http://help.dottoro.com/lcbixvwm.php",
		syntax: "none | element | auto"
	},
	"-webkit-user-select": {
		comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
		syntax: "auto | none | text | all"
	},
	"alignment-baseline": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
		],
		syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
	},
	"background-clip": {
		comment: "used <bg-clip> from CSS Backgrounds and Borders 4 since it adds new values",
		references: [
			"https://github.com/csstree/csstree/issues/190"
		],
		syntax: "<bg-clip>#"
	},
	"baseline-shift": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
		],
		syntax: "baseline | sub | super | <svg-length>"
	},
	behavior: {
		comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
		syntax: "<url>+"
	},
	"clip-rule": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
		],
		syntax: "nonzero | evenodd"
	},
	cue: {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<'cue-before'> <'cue-after'>?"
	},
	"cue-after": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<url> <decibel>? | none"
	},
	"cue-before": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<url> <decibel>? | none"
	},
	cursor: {
		comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
		references: [
			"https://www.sitepoint.com/css3-cursor-styles/"
		],
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
	},
	display: {
		comment: "extended with -ms-flexbox",
		syntax: "| <-non-standard-display>"
	},
	position: {
		comment: "extended with -webkit-sticky",
		syntax: "| -webkit-sticky"
	},
	"dominant-baseline": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
		],
		syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
	},
	"image-rendering": {
		comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
		references: [
			"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
			"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
		],
		syntax: "| optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
	},
	fill: {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#FillProperty"
		],
		syntax: "<paint>"
	},
	"fill-opacity": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#FillProperty"
		],
		syntax: "<number-zero-one>"
	},
	"fill-rule": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#FillProperty"
		],
		syntax: "nonzero | evenodd"
	},
	filter: {
		comment: "extend with IE legacy syntaxes",
		syntax: "| <-ms-filter-function-list>"
	},
	"glyph-orientation-horizontal": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
		],
		syntax: "<angle>"
	},
	"glyph-orientation-vertical": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
		],
		syntax: "<angle>"
	},
	kerning: {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/text.html#KerningProperty"
		],
		syntax: "auto | <svg-length>"
	},
	"letter-spacing": {
		comment: "fix syntax <length> -> <length-percentage>",
		references: [
			"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
		],
		syntax: "normal | <length-percentage>"
	},
	marker: {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
		],
		syntax: "none | <url>"
	},
	"marker-end": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
		],
		syntax: "none | <url>"
	},
	"marker-mid": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
		],
		syntax: "none | <url>"
	},
	"marker-start": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
		],
		syntax: "none | <url>"
	},
	"max-width": {
		comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
		syntax: "| <-non-standard-width>"
	},
	width: {
		references: [
			"https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			"https://github.com/csstree/stylelint-validator/issues/29"
		],
		syntax: "| fill | stretch | intrinsic | -moz-max-content | -webkit-max-content | -moz-fit-content | -webkit-fit-content"
	},
	"min-width": {
		comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
		syntax: "| <-non-standard-width>"
	},
	overflow: {
		comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
		syntax: "| <-non-standard-overflow>"
	},
	pause: {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<'pause-before'> <'pause-after'>?"
	},
	"pause-after": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
	},
	"pause-before": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
	},
	rest: {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<'rest-before'> <'rest-after'>?"
	},
	"rest-after": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
	},
	"rest-before": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
	},
	"shape-rendering": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
		],
		syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
	},
	src: {
		comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
		syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
	},
	speak: {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "auto | none | normal"
	},
	"speak-as": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
	},
	stroke: {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "<paint>"
	},
	"stroke-dasharray": {
		comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "none | [ <svg-length>+ ]#"
	},
	"stroke-dashoffset": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "<svg-length>"
	},
	"stroke-linecap": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "butt | round | square"
	},
	"stroke-linejoin": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "miter | round | bevel"
	},
	"stroke-miterlimit": {
		comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "<number-one-or-greater>"
	},
	"stroke-opacity": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "<number-zero-one>"
	},
	"stroke-width": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "<svg-length>"
	},
	"text-anchor": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
		],
		syntax: "start | middle | end"
	},
	"unicode-bidi": {
		comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
		syntax: "| -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate | -webkit-isolate-override | -webkit-plaintext"
	},
	"unicode-range": {
		comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
		syntax: "<urange>#"
	},
	"voice-balance": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<number> | left | center | right | leftwards | rightwards"
	},
	"voice-duration": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "auto | <time>"
	},
	"voice-family": {
		comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
	},
	"voice-pitch": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
	},
	"voice-range": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
	},
	"voice-rate": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
	},
	"voice-stress": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "normal | strong | moderate | none | reduced"
	},
	"voice-volume": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
	},
	"writing-mode": {
		comment: "extend with SVG keywords",
		syntax: "| <svg-writing-mode>"
	}
};
const types$I = {
	"-legacy-gradient": {
		comment: "added collection of legacy gradient syntaxes",
		syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
	},
	"-legacy-linear-gradient": {
		comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
		syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
	},
	"-legacy-repeating-linear-gradient": {
		comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
		syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
	},
	"-legacy-linear-gradient-arguments": {
		comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
		syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
	},
	"-legacy-radial-gradient": {
		comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
		syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
	},
	"-legacy-repeating-radial-gradient": {
		comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
		syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
	},
	"-legacy-radial-gradient-arguments": {
		comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
		syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
	},
	"-legacy-radial-gradient-size": {
		comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
		syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
	},
	"-legacy-radial-gradient-shape": {
		comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
		syntax: "circle | ellipse"
	},
	"-non-standard-font": {
		comment: "non standard fonts",
		references: [
			"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
		],
		syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
	},
	"-non-standard-color": {
		comment: "non standard colors",
		references: [
			"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
			"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
		],
		syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
	},
	"-non-standard-image-rendering": {
		comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
		syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
	},
	"-non-standard-overflow": {
		comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
		syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
	},
	"-non-standard-width": {
		comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
		syntax: "fill-available | min-intrinsic | intrinsic | -moz-available | -moz-fit-content | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
	},
	"-webkit-gradient()": {
		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
		syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
	},
	"-webkit-gradient-color-stop": {
		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
		syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
	},
	"-webkit-gradient-point": {
		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
		syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
	},
	"-webkit-gradient-radius": {
		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
		syntax: "<length> | <percentage>"
	},
	"-webkit-gradient-type": {
		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
		syntax: "linear | radial"
	},
	"-webkit-mask-box-repeat": {
		comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
		syntax: "repeat | stretch | round"
	},
	"-webkit-mask-clip-style": {
		comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
		syntax: "border | border-box | padding | padding-box | content | content-box | text"
	},
	"-ms-filter-function-list": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
		syntax: "<-ms-filter-function>+"
	},
	"-ms-filter-function": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
		syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
	},
	"-ms-filter-function-progid": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
		syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
	},
	"-ms-filter-function-legacy": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
		syntax: "<ident-token> | <function-token> <any-value>? )"
	},
	"-ms-filter": {
		syntax: "<string>"
	},
	age: {
		comment: "https://www.w3.org/TR/css3-speech/#voice-family",
		syntax: "child | young | old"
	},
	"attr-name": {
		syntax: "<wq-name>"
	},
	"attr-fallback": {
		syntax: "<any-value>"
	},
	"bg-clip": {
		comment: "missed, https://drafts.csswg.org/css-backgrounds-4/#typedef-bg-clip",
		syntax: "<box> | border | text"
	},
	bottom: {
		comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
		syntax: "<length> | auto"
	},
	"content-list": {
		comment: "added attr(), see https://github.com/csstree/csstree/issues/201",
		syntax: "[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> | <attr()> ]+"
	},
	"element()": {
		comment: "https://drafts.csswg.org/css-gcpm/#element-syntax & https://drafts.csswg.org/css-images-4/#element-notation",
		syntax: "element( <custom-ident> , [ first | start | last | first-except ]? ) | element( <id-selector> )"
	},
	"generic-voice": {
		comment: "https://www.w3.org/TR/css3-speech/#voice-family",
		syntax: "[ <age>? <gender> <integer>? ]"
	},
	gender: {
		comment: "https://www.w3.org/TR/css3-speech/#voice-family",
		syntax: "male | female | neutral"
	},
	"generic-family": {
		comment: "added -apple-system",
		references: [
			"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
		],
		syntax: "| -apple-system"
	},
	gradient: {
		comment: "added legacy syntaxes support",
		syntax: "| <-legacy-gradient>"
	},
	left: {
		comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
		syntax: "<length> | auto"
	},
	"mask-image": {
		comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
		syntax: "<mask-reference>#"
	},
	"named-color": {
		comment: "added non standard color names",
		syntax: "| <-non-standard-color>"
	},
	paint: {
		comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
		syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
	},
	right: {
		comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
		syntax: "<length> | auto"
	},
	shape: {
		comment: "missed spaces in function body and add backwards compatible syntax",
		syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
	},
	"scroll-timeline-axis": {
		comment: "missed definition",
		syntax: "block | inline | vertical | horizontal"
	},
	"scroll-timeline-name": {
		comment: "missed definition",
		references: [
			"https://w3c.github.io/csswg-drafts/scroll-animations/#propdef-scroll-timeline-name"
		],
		syntax: "none | <custom-ident>"
	},
	"single-animation-composition": {
		comment: "missed definition",
		references: [
			"https://w3c.github.io/csswg-drafts/css-animations-2/#typedef-single-animation-composition"
		],
		syntax: "replace | add | accumulate"
	},
	"svg-length": {
		comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
		references: [
			"https://www.w3.org/TR/SVG11/coords.html#Units"
		],
		syntax: "<percentage> | <length> | <number>"
	},
	"svg-writing-mode": {
		comment: "SVG specific keywords (deprecated for CSS)",
		references: [
			"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
			"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
		],
		syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
	},
	top: {
		comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
		syntax: "<length> | auto"
	},
	x: {
		comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
		syntax: "<number>"
	},
	y: {
		comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
		syntax: "<number>"
	},
	declaration: {
		comment: "missed, restored by https://drafts.csswg.org/css-syntax",
		syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
	},
	"declaration-list": {
		comment: "missed, restored by https://drafts.csswg.org/css-syntax",
		syntax: "[ <declaration>? ';' ]* <declaration>?"
	},
	url: {
		comment: "https://drafts.csswg.org/css-values-4/#urls",
		syntax: "url( <string> <url-modifier>* ) | <url-token>"
	},
	"url-modifier": {
		comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
		syntax: "<ident> | <function-token> <any-value> )"
	},
	"number-zero-one": {
		syntax: "<number [0,1]>"
	},
	"number-one-or-greater": {
		syntax: "<number [1,∞]>"
	},
	"-non-standard-display": {
		syntax: "-ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
	}
};
const patch$2 = {
	atrules: atrules,
	properties: properties$2,
	types: types$I
};

const patch$3 = {
	__proto__: null,
	atrules: atrules,
	default: patch$2,
	properties: properties$2,
	types: types$I
};

const require$$0$1 = /*@__PURE__*/getAugmentedNamespace(patch$3);

const patch = require$$0$1;

const patch$1 = patch;

var dataPatch$1 = patch$1;

var atRules = {
	"@charset": {
	syntax: "@charset \"<charset>\";",
	groups: [
		"CSS Charsets"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
},
	"@counter-style": {
	syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
	interfaces: [
		"CSSCounterStyleRule"
	],
	groups: [
		"CSS Counter Styles"
	],
	descriptors: {
		"additive-symbols": {
			syntax: "[ <integer> && <symbol> ]#",
			media: "all",
			initial: "n/a (required)",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		fallback: {
			syntax: "<counter-style-name>",
			media: "all",
			initial: "decimal",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		negative: {
			syntax: "<symbol> <symbol>?",
			media: "all",
			initial: "\"-\" hyphen-minus",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		pad: {
			syntax: "<integer> && <symbol>",
			media: "all",
			initial: "0 \"\"",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		prefix: {
			syntax: "<symbol>",
			media: "all",
			initial: "\"\"",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		range: {
			syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
			media: "all",
			initial: "auto",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		"speak-as": {
			syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
			media: "all",
			initial: "auto",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		suffix: {
			syntax: "<symbol>",
			media: "all",
			initial: "\". \"",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		symbols: {
			syntax: "<symbol>+",
			media: "all",
			initial: "n/a (required)",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		system: {
			syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
			media: "all",
			initial: "symbolic",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		}
	},
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
},
	"@document": {
	syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
	interfaces: [
		"CSSGroupingRule",
		"CSSConditionRule"
	],
	groups: [
		"CSS Conditional Rules"
	],
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
},
	"@font-face": {
	syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ] ||\n  [ size-adjust: <size-adjust>; ] ||\n  [ ascent-override: <ascent-override>; ] ||\n  [ descent-override: <descent-override>; ] ||\n  [ line-gap-override: <line-gap-override>; ]\n}",
	interfaces: [
		"CSSFontFaceRule"
	],
	groups: [
		"CSS Fonts"
	],
	descriptors: {
		"ascent-override": {
			syntax: "normal | <percentage>",
			media: "all",
			initial: "normal",
			percentages: "asSpecified",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "experimental"
		},
		"descent-override": {
			syntax: "normal | <percentage>",
			media: "all",
			initial: "normal",
			percentages: "asSpecified",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "experimental"
		},
		"font-display": {
			syntax: "[ auto | block | swap | fallback | optional ]",
			media: "visual",
			percentages: "no",
			initial: "auto",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "experimental"
		},
		"font-family": {
			syntax: "<family-name>",
			media: "all",
			initial: "n/a (required)",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		"font-feature-settings": {
			syntax: "normal | <feature-tag-value>#",
			media: "all",
			initial: "normal",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		"font-variation-settings": {
			syntax: "normal | [ <string> <number> ]#",
			media: "all",
			initial: "normal",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		"font-stretch": {
			syntax: "<font-stretch-absolute>{1,2}",
			media: "all",
			initial: "normal",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		"font-style": {
			syntax: "normal | italic | oblique <angle>{0,2}",
			media: "all",
			initial: "normal",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		"font-weight": {
			syntax: "<font-weight-absolute>{1,2}",
			media: "all",
			initial: "normal",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		"font-variant": {
			syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
			media: "all",
			initial: "normal",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		"line-gap-override": {
			syntax: "normal | <percentage>",
			media: "all",
			initial: "normal",
			percentages: "asSpecified",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "experimental"
		},
		"size-adjust": {
			syntax: "<percentage>",
			media: "all",
			initial: "100%",
			percentages: "asSpecified",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "experimental"
		},
		src: {
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
			media: "all",
			initial: "n/a (required)",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		"unicode-range": {
			syntax: "<unicode-range>#",
			media: "all",
			initial: "U+0-10FFFF",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		}
	},
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
},
	"@font-feature-values": {
	syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
	interfaces: [
		"CSSFontFeatureValuesRule"
	],
	groups: [
		"CSS Fonts"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
},
	"@import": {
	syntax: "@import [ <string> | <url> ]\n        [ layer | layer(<layer-name>) ]?\n        [ supports( [ <supports-condition> | <declaration> ] ) ]?\n        <media-query-list>? ;",
	groups: [
		"CSS Conditional Rules",
		"Media Queries"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
},
	"@keyframes": {
	syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
	interfaces: [
		"CSSKeyframeRule",
		"CSSKeyframesRule"
	],
	groups: [
		"CSS Animations"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
},
	"@layer": {
	syntax: "@layer [ <layer-name># | <layer-name>?  {\n  <stylesheet>\n} ]",
	interfaces: [
		"CSSLayerBlockRule",
		"CSSLayerStatementRule"
	],
	groups: [
		"CSS Cascading and Inheritance"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@layer"
},
	"@media": {
	syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
	interfaces: [
		"CSSGroupingRule",
		"CSSConditionRule",
		"CSSMediaRule",
		"CSSCustomMediaRule"
	],
	groups: [
		"CSS Conditional Rules",
		"Media Queries"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
},
	"@namespace": {
	syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
	groups: [
		"CSS Namespaces"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
},
	"@page": {
	syntax: "@page <page-selector-list> {\n  <page-body>\n}",
	interfaces: [
		"CSSPageRule"
	],
	groups: [
		"CSS Pages"
	],
	descriptors: {
		bleed: {
			syntax: "auto | <length>",
			media: [
				"visual",
				"paged"
			],
			initial: "auto",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		marks: {
			syntax: "none | [ crop || cross ]",
			media: [
				"visual",
				"paged"
			],
			initial: "none",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		size: {
			syntax: "<length>{1,2} | auto | [ <page-size> || [ portrait | landscape ] ]",
			media: [
				"visual",
				"paged"
			],
			initial: "auto",
			percentages: "no",
			computed: "asSpecifiedRelativeToAbsoluteLengths",
			order: "orderOfAppearance",
			status: "standard"
		}
	},
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
},
	"@property": {
	syntax: "@property <custom-property-name> {\n  <declaration-list>\n}",
	interfaces: [
		"CSS",
		"CSSPropertyRule"
	],
	groups: [
		"CSS Houdini"
	],
	descriptors: {
		syntax: {
			syntax: "<string>",
			media: "all",
			percentages: "no",
			initial: "n/a (required)",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "experimental"
		},
		inherits: {
			syntax: "true | false",
			media: "all",
			percentages: "no",
			initial: "auto",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "experimental"
		},
		"initial-value": {
			syntax: "<string>",
			media: "all",
			initial: "n/a (required)",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "experimental"
		}
	},
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@property"
},
	"@scroll-timeline": {
	syntax: "@scroll-timeline <timeline-name> { <declaration-list> }",
	interfaces: [
		"ScrollTimeline"
	],
	groups: [
		"CSS Animations"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@scroll-timeline"
},
	"@supports": {
	syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
	interfaces: [
		"CSSGroupingRule",
		"CSSConditionRule",
		"CSSSupportsRule"
	],
	groups: [
		"CSS Conditional Rules"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
},
	"@viewport": {
	syntax: "@viewport {\n  <group-rule-body>\n}",
	interfaces: [
		"CSSViewportRule"
	],
	groups: [
		"CSS Device Adaptation"
	],
	descriptors: {
		height: {
			syntax: "<viewport-length>{1,2}",
			media: [
				"visual",
				"continuous"
			],
			initial: [
				"min-height",
				"max-height"
			],
			percentages: [
				"min-height",
				"max-height"
			],
			computed: [
				"min-height",
				"max-height"
			],
			order: "orderOfAppearance",
			status: "standard"
		},
		"max-height": {
			syntax: "<viewport-length>",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "referToHeightOfInitialViewport",
			computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
			order: "uniqueOrder",
			status: "standard"
		},
		"max-width": {
			syntax: "<viewport-length>",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "referToWidthOfInitialViewport",
			computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
			order: "uniqueOrder",
			status: "standard"
		},
		"max-zoom": {
			syntax: "auto | <number> | <percentage>",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "the zoom factor itself",
			computed: "autoNonNegativeOrPercentage",
			order: "uniqueOrder",
			status: "standard"
		},
		"min-height": {
			syntax: "<viewport-length>",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "referToHeightOfInitialViewport",
			computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
			order: "uniqueOrder",
			status: "standard"
		},
		"min-width": {
			syntax: "<viewport-length>",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "referToWidthOfInitialViewport",
			computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
			order: "uniqueOrder",
			status: "standard"
		},
		"min-zoom": {
			syntax: "auto | <number> | <percentage>",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "the zoom factor itself",
			computed: "autoNonNegativeOrPercentage",
			order: "uniqueOrder",
			status: "standard"
		},
		orientation: {
			syntax: "auto | portrait | landscape",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "referToSizeOfBoundingBox",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		"user-zoom": {
			syntax: "zoom | fixed",
			media: [
				"visual",
				"continuous"
			],
			initial: "zoom",
			percentages: "referToSizeOfBoundingBox",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		"viewport-fit": {
			syntax: "auto | contain | cover",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		width: {
			syntax: "<viewport-length>{1,2}",
			media: [
				"visual",
				"continuous"
			],
			initial: [
				"min-width",
				"max-width"
			],
			percentages: [
				"min-width",
				"max-width"
			],
			computed: [
				"min-width",
				"max-width"
			],
			order: "orderOfAppearance",
			status: "standard"
		},
		zoom: {
			syntax: "auto | <number> | <percentage>",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "the zoom factor itself",
			computed: "autoNonNegativeOrPercentage",
			order: "uniqueOrder",
			status: "standard"
		}
	},
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
}
};

const all = {
	syntax: "initial | inherit | unset | revert | revert-layer",
	media: "noPracticalMedia",
	inherited: false,
	animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
	percentages: "no",
	groups: [
		"CSS Miscellaneous"
	],
	initial: "noPracticalInitialValue",
	appliesto: "allElements",
	computed: "asSpecifiedAppliesToEachProperty",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
};
const animation = {
	syntax: "<single-animation>#",
	media: "visual",
	inherited: false,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: [
		"animation-name",
		"animation-duration",
		"animation-timing-function",
		"animation-delay",
		"animation-iteration-count",
		"animation-direction",
		"animation-fill-mode",
		"animation-play-state",
		"animation-timeline"
	],
	appliesto: "allElementsAndPseudos",
	computed: [
		"animation-name",
		"animation-duration",
		"animation-timing-function",
		"animation-delay",
		"animation-direction",
		"animation-iteration-count",
		"animation-fill-mode",
		"animation-play-state",
		"animation-timeline"
	],
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
};
const appearance = {
	syntax: "none | auto | textfield | menulist-button | <compat-auto>",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
};
const azimuth = {
	syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
	media: "aural",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Speech"
	],
	initial: "center",
	appliesto: "allElements",
	computed: "normalizedAngle",
	order: "orderOfAppearance",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
};
const background = {
	syntax: "[ <bg-layer> , ]* <final-bg-layer>",
	media: "visual",
	inherited: false,
	animationType: [
		"background-color",
		"background-image",
		"background-clip",
		"background-position",
		"background-size",
		"background-repeat",
		"background-attachment"
	],
	percentages: [
		"background-position",
		"background-size"
	],
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"background-image",
		"background-position",
		"background-size",
		"background-repeat",
		"background-origin",
		"background-clip",
		"background-attachment",
		"background-color"
	],
	appliesto: "allElements",
	computed: [
		"background-image",
		"background-position",
		"background-size",
		"background-repeat",
		"background-origin",
		"background-clip",
		"background-attachment",
		"background-color"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
};
const border = {
	syntax: "<line-width> || <line-style> || <color>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-color",
		"border-style",
		"border-width"
	],
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-width",
		"border-style",
		"border-color"
	],
	appliesto: "allElements",
	computed: [
		"border-width",
		"border-style",
		"border-color"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
};
const bottom = {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToContainingBlockHeight",
	groups: [
		"CSS Positioning"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
};
const caret = {
	syntax: "<'caret-color'> || <'caret-shape'>",
	media: "interactive",
	inherited: true,
	animationType: [
		"caret-color",
		"caret-shape"
	],
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: [
		"caret-color",
		"caret-shape"
	],
	appliesto: "elementsThatAcceptInput",
	computed: [
		"caret-color",
		"caret-shape"
	],
	order: "perGrammar",
	status: "standard"
};
const clear = {
	syntax: "none | left | right | both | inline-start | inline-end",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Positioning"
	],
	initial: "none",
	appliesto: "blockLevelElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
};
const clip = {
	syntax: "<shape> | auto",
	media: "visual",
	inherited: false,
	animationType: "rectangle",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "auto",
	appliesto: "absolutelyPositionedElements",
	computed: "autoOrRectangle",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
};
const color$1 = {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Color"
	],
	initial: "canvastext",
	appliesto: "allElementsAndText",
	computed: "computedColor",
	order: "perGrammar",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
};
const columns = {
	syntax: "<'column-width'> || <'column-count'>",
	media: "visual",
	inherited: false,
	animationType: [
		"column-width",
		"column-count"
	],
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: [
		"column-width",
		"column-count"
	],
	appliesto: "blockContainersExceptTableWrappers",
	computed: [
		"column-width",
		"column-count"
	],
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
};
const contain = {
	syntax: "none | strict | content | [ [ size || inline-size ] || layout || style || paint ]",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Containment"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
};
const content = {
	syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ [ <string> | <counter> ]+ ]?",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Generated Content"
	],
	initial: "normal",
	appliesto: "allElementsTreeAbidingPseudoElementsPageMarginBoxes",
	computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
};
const cursor = {
	syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
	media: [
		"visual",
		"interactive"
	],
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecifiedURLsAbsolute",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
};
const direction = {
	syntax: "ltr | rtl",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Writing Modes"
	],
	initial: "ltr",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
};
const display = {
	syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
	media: "all",
	inherited: false,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"CSS Display"
	],
	initial: "inline",
	appliesto: "allElements",
	computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
};
const filter = {
	syntax: "none | <filter-function-list>",
	media: "visual",
	inherited: false,
	animationType: "filterList",
	percentages: "no",
	groups: [
		"Filter Effects"
	],
	initial: "none",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
};
const flex = {
	syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
	media: "visual",
	inherited: false,
	animationType: [
		"flex-grow",
		"flex-shrink",
		"flex-basis"
	],
	percentages: "no",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: [
		"flex-grow",
		"flex-shrink",
		"flex-basis"
	],
	appliesto: "flexItemsAndInFlowPseudos",
	computed: [
		"flex-grow",
		"flex-shrink",
		"flex-basis"
	],
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
};
const float = {
	syntax: "left | right | none | inline-start | inline-end",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Positioning"
	],
	initial: "none",
	appliesto: "allElementsNoEffectIfDisplayNone",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
};
const font = {
	syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
	media: "visual",
	inherited: true,
	animationType: [
		"font-style",
		"font-variant",
		"font-weight",
		"font-stretch",
		"font-size",
		"line-height",
		"font-family"
	],
	percentages: [
		"font-size",
		"line-height"
	],
	groups: [
		"CSS Fonts"
	],
	initial: [
		"font-style",
		"font-variant",
		"font-weight",
		"font-stretch",
		"font-size",
		"line-height",
		"font-family"
	],
	appliesto: "allElements",
	computed: [
		"font-style",
		"font-variant",
		"font-weight",
		"font-stretch",
		"font-size",
		"line-height",
		"font-family"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
};
const gap = {
	syntax: "<'row-gap'> <'column-gap'>?",
	media: "visual",
	inherited: false,
	animationType: [
		"row-gap",
		"column-gap"
	],
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: [
		"row-gap",
		"column-gap"
	],
	appliesto: "multiColumnElementsFlexContainersGridContainers",
	computed: [
		"row-gap",
		"column-gap"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
};
const grid = {
	syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: [
		"grid-template-rows",
		"grid-template-columns",
		"grid-auto-rows",
		"grid-auto-columns"
	],
	groups: [
		"CSS Grid Layout"
	],
	initial: [
		"grid-template-rows",
		"grid-template-columns",
		"grid-template-areas",
		"grid-auto-rows",
		"grid-auto-columns",
		"grid-auto-flow",
		"grid-column-gap",
		"grid-row-gap",
		"column-gap",
		"row-gap"
	],
	appliesto: "gridContainers",
	computed: [
		"grid-template-rows",
		"grid-template-columns",
		"grid-template-areas",
		"grid-auto-rows",
		"grid-auto-columns",
		"grid-auto-flow",
		"grid-column-gap",
		"grid-row-gap",
		"column-gap",
		"row-gap"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
};
const height = {
	syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "allElementsButNonReplacedAndTableColumns",
	computed: "percentageAutoOrAbsoluteLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
};
const hyphens = {
	syntax: "none | manual | auto",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "manual",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
};
const inset = {
	syntax: "<'top'>{1,4}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "logicalHeightOrWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"top",
		"bottom",
		"left",
		"right"
	],
	appliesto: "positionedElements",
	computed: [
		"top",
		"bottom",
		"left",
		"right"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
};
const isolation = {
	syntax: "auto | isolate",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Compositing and Blending"
	],
	initial: "auto",
	appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
};
const left = {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Positioning"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
};
const margin = {
	syntax: "[ <length> | <percentage> | auto ]{1,4}",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: [
		"margin-bottom",
		"margin-left",
		"margin-right",
		"margin-top"
	],
	appliesto: "allElementsExceptTableDisplayTypes",
	computed: [
		"margin-bottom",
		"margin-left",
		"margin-right",
		"margin-top"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
};
const mask = {
	syntax: "<mask-layer>#",
	media: "visual",
	inherited: false,
	animationType: [
		"mask-image",
		"mask-mode",
		"mask-repeat",
		"mask-position",
		"mask-clip",
		"mask-origin",
		"mask-size",
		"mask-composite"
	],
	percentages: [
		"mask-position"
	],
	groups: [
		"CSS Masking"
	],
	initial: [
		"mask-image",
		"mask-mode",
		"mask-repeat",
		"mask-position",
		"mask-clip",
		"mask-origin",
		"mask-size",
		"mask-composite"
	],
	appliesto: "allElementsSVGContainerElements",
	computed: [
		"mask-image",
		"mask-mode",
		"mask-repeat",
		"mask-position",
		"mask-clip",
		"mask-origin",
		"mask-size",
		"mask-composite"
	],
	order: "perGrammar",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
};
const offset = {
	syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
	media: "visual",
	inherited: false,
	animationType: [
		"offset-position",
		"offset-path",
		"offset-distance",
		"offset-anchor",
		"offset-rotate"
	],
	percentages: [
		"offset-position",
		"offset-distance",
		"offset-anchor"
	],
	groups: [
		"CSS Motion Path"
	],
	initial: [
		"offset-position",
		"offset-path",
		"offset-distance",
		"offset-anchor",
		"offset-rotate"
	],
	appliesto: "transformableElements",
	computed: [
		"offset-position",
		"offset-path",
		"offset-distance",
		"offset-anchor",
		"offset-rotate"
	],
	order: "perGrammar",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
};
const opacity = {
	syntax: "<alpha-value>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "mapToRange0To1",
	groups: [
		"CSS Color"
	],
	initial: "1",
	appliesto: "allElements",
	computed: "specifiedValueNumberClipped0To1",
	order: "perGrammar",
	alsoAppliesTo: [
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
};
const order = {
	syntax: "<integer>",
	media: "visual",
	inherited: false,
	animationType: "integer",
	percentages: "no",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: "0",
	appliesto: "flexItemsGridItemsAbsolutelyPositionedContainerChildren",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
};
const orphans = {
	syntax: "<integer>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fragmentation"
	],
	initial: "2",
	appliesto: "blockContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
};
const outline = {
	syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
	media: [
		"visual",
		"interactive"
	],
	inherited: false,
	animationType: [
		"outline-color",
		"outline-width",
		"outline-style"
	],
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: [
		"outline-color",
		"outline-style",
		"outline-width"
	],
	appliesto: "allElements",
	computed: [
		"outline-color",
		"outline-width",
		"outline-style"
	],
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
};
const overflow = {
	syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "visible",
	appliesto: "blockContainersFlexContainersGridContainers",
	computed: [
		"overflow-x",
		"overflow-y"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
};
const padding = {
	syntax: "[ <length> | <percentage> ]{1,4}",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: [
		"padding-bottom",
		"padding-left",
		"padding-right",
		"padding-top"
	],
	appliesto: "allElementsExceptInternalTableDisplayTypes",
	computed: [
		"padding-bottom",
		"padding-left",
		"padding-right",
		"padding-top"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
};
const perspective = {
	syntax: "none | <length>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Transforms"
	],
	initial: "none",
	appliesto: "transformableElements",
	computed: "absoluteLengthOrNone",
	order: "uniqueOrder",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
};
const position$1 = {
	syntax: "static | relative | absolute | sticky | fixed",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Positioning"
	],
	initial: "static",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
};
const quotes = {
	syntax: "none | auto | [ <string> <string> ]+",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Generated Content"
	],
	initial: "dependsOnUserAgent",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
};
const resize = {
	syntax: "none | both | horizontal | vertical | block | inline",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "none",
	appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
};
const right = {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Positioning"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
};
const rotate = {
	syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
	media: "visual",
	inherited: false,
	animationType: "transform",
	percentages: "no",
	groups: [
		"CSS Transforms"
	],
	initial: "none",
	appliesto: "transformableElements",
	computed: "asSpecified",
	order: "perGrammar",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
};
const scale = {
	syntax: "none | <number>{1,3}",
	media: "visual",
	inherited: false,
	animationType: "transform",
	percentages: "no",
	groups: [
		"CSS Transforms"
	],
	initial: "none",
	appliesto: "transformableElements",
	computed: "asSpecified",
	order: "perGrammar",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
};
const top = {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToContainingBlockHeight",
	groups: [
		"CSS Positioning"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
};
const transform = {
	syntax: "none | <transform-list>",
	media: "visual",
	inherited: false,
	animationType: "transform",
	percentages: "referToSizeOfBoundingBox",
	groups: [
		"CSS Transforms"
	],
	initial: "none",
	appliesto: "transformableElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
};
const transition = {
	syntax: "<single-transition>#",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transitions"
	],
	initial: [
		"transition-delay",
		"transition-duration",
		"transition-property",
		"transition-timing-function"
	],
	appliesto: "allElementsAndPseudos",
	computed: [
		"transition-delay",
		"transition-duration",
		"transition-property",
		"transition-timing-function"
	],
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
};
const translate = {
	syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
	media: "visual",
	inherited: false,
	animationType: "transform",
	percentages: "referToSizeOfBoundingBox",
	groups: [
		"CSS Transforms"
	],
	initial: "none",
	appliesto: "transformableElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "perGrammar",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
};
const visibility = {
	syntax: "visible | hidden | collapse",
	media: "visual",
	inherited: true,
	animationType: "visibility",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "visible",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
};
const widows = {
	syntax: "<integer>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fragmentation"
	],
	initial: "2",
	appliesto: "blockContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
};
const width = {
	syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "allElementsButNonReplacedAndTableRows",
	computed: "percentageAutoOrAbsoluteLength",
	order: "lengthOrPercentageBeforeKeywordIfBothPresent",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
};
const zoom = {
	syntax: "normal | reset | <number> | <percentage>",
	media: "visual",
	inherited: false,
	animationType: "integer",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
};
const properties = {
	"--*": {
	syntax: "<declaration-value>",
	media: "all",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Variables"
	],
	initial: "seeProse",
	appliesto: "allElements",
	computed: "asSpecifiedWithVarsSubstituted",
	order: "perGrammar",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
},
	"-ms-accelerator": {
	syntax: "false | true",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "false",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
},
	"-ms-block-progression": {
	syntax: "tb | rl | bt | lr",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "tb",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
},
	"-ms-content-zoom-chaining": {
	syntax: "none | chained",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "none",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
},
	"-ms-content-zooming": {
	syntax: "none | zoom",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "zoomForTheTopLevelNoneForTheRest",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
},
	"-ms-content-zoom-limit": {
	syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: [
		"-ms-content-zoom-limit-max",
		"-ms-content-zoom-limit-min"
	],
	groups: [
		"Microsoft Extensions"
	],
	initial: [
		"-ms-content-zoom-limit-max",
		"-ms-content-zoom-limit-min"
	],
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: [
		"-ms-content-zoom-limit-max",
		"-ms-content-zoom-limit-min"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
},
	"-ms-content-zoom-limit-max": {
	syntax: "<percentage>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "maxZoomFactor",
	groups: [
		"Microsoft Extensions"
	],
	initial: "400%",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
},
	"-ms-content-zoom-limit-min": {
	syntax: "<percentage>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "minZoomFactor",
	groups: [
		"Microsoft Extensions"
	],
	initial: "100%",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
},
	"-ms-content-zoom-snap": {
	syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: [
		"-ms-content-zoom-snap-type",
		"-ms-content-zoom-snap-points"
	],
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: [
		"-ms-content-zoom-snap-type",
		"-ms-content-zoom-snap-points"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
},
	"-ms-content-zoom-snap-points": {
	syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "snapInterval(0%, 100%)",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
},
	"-ms-content-zoom-snap-type": {
	syntax: "none | proximity | mandatory",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "none",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
},
	"-ms-filter": {
	syntax: "<string>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "\"\"",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
},
	"-ms-flow-from": {
	syntax: "[ none | <custom-ident> ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "none",
	appliesto: "nonReplacedElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
},
	"-ms-flow-into": {
	syntax: "[ none | <custom-ident> ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "none",
	appliesto: "iframeElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
},
	"-ms-grid-columns": {
	syntax: "none | <track-list> | <auto-track-list>",
	media: "visual",
	inherited: false,
	animationType: "simpleListOfLpcDifferenceLpc",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "none",
	appliesto: "gridContainers",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-columns"
},
	"-ms-grid-rows": {
	syntax: "none | <track-list> | <auto-track-list>",
	media: "visual",
	inherited: false,
	animationType: "simpleListOfLpcDifferenceLpc",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "none",
	appliesto: "gridContainers",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-rows"
},
	"-ms-high-contrast-adjust": {
	syntax: "auto | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
},
	"-ms-hyphenate-limit-chars": {
	syntax: "auto | <integer>{1,3}",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
},
	"-ms-hyphenate-limit-lines": {
	syntax: "no-limit | <integer>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "no-limit",
	appliesto: "blockContainerElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
},
	"-ms-hyphenate-limit-zone": {
	syntax: "<percentage> | <length>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "referToLineBoxWidth",
	groups: [
		"Microsoft Extensions"
	],
	initial: "0",
	appliesto: "blockContainerElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
},
	"-ms-ime-align": {
	syntax: "auto | after",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
},
	"-ms-overflow-style": {
	syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
	media: "interactive",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
},
	"-ms-scrollbar-3dlight-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "dependsOnUserAgent",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
},
	"-ms-scrollbar-arrow-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "ButtonText",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
},
	"-ms-scrollbar-base-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "dependsOnUserAgent",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
},
	"-ms-scrollbar-darkshadow-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "ThreeDDarkShadow",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
},
	"-ms-scrollbar-face-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "ThreeDFace",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
},
	"-ms-scrollbar-highlight-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "ThreeDHighlight",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
},
	"-ms-scrollbar-shadow-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "ThreeDDarkShadow",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
},
	"-ms-scrollbar-track-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "Scrollbar",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
},
	"-ms-scroll-chaining": {
	syntax: "chained | none",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "chained",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
},
	"-ms-scroll-limit": {
	syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: [
		"-ms-scroll-limit-x-min",
		"-ms-scroll-limit-y-min",
		"-ms-scroll-limit-x-max",
		"-ms-scroll-limit-y-max"
	],
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: [
		"-ms-scroll-limit-x-min",
		"-ms-scroll-limit-y-min",
		"-ms-scroll-limit-x-max",
		"-ms-scroll-limit-y-max"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
},
	"-ms-scroll-limit-x-max": {
	syntax: "auto | <length>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
},
	"-ms-scroll-limit-x-min": {
	syntax: "<length>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "0",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
},
	"-ms-scroll-limit-y-max": {
	syntax: "auto | <length>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
},
	"-ms-scroll-limit-y-min": {
	syntax: "<length>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "0",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
},
	"-ms-scroll-rails": {
	syntax: "none | railed",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "railed",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
},
	"-ms-scroll-snap-points-x": {
	syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "snapInterval(0px, 100%)",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
},
	"-ms-scroll-snap-points-y": {
	syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "snapInterval(0px, 100%)",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
},
	"-ms-scroll-snap-type": {
	syntax: "none | proximity | mandatory",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "none",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
},
	"-ms-scroll-snap-x": {
	syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: [
		"-ms-scroll-snap-type",
		"-ms-scroll-snap-points-x"
	],
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: [
		"-ms-scroll-snap-type",
		"-ms-scroll-snap-points-x"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
},
	"-ms-scroll-snap-y": {
	syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: [
		"-ms-scroll-snap-type",
		"-ms-scroll-snap-points-y"
	],
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: [
		"-ms-scroll-snap-type",
		"-ms-scroll-snap-points-y"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
},
	"-ms-scroll-translation": {
	syntax: "none | vertical-to-horizontal",
	media: "interactive",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
},
	"-ms-text-autospace": {
	syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
},
	"-ms-touch-select": {
	syntax: "grippers | none",
	media: "interactive",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "grippers",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
},
	"-ms-user-select": {
	syntax: "none | element | text",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "text",
	appliesto: "nonReplacedElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
},
	"-ms-wrap-flow": {
	syntax: "auto | both | start | end | maximum | clear",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "auto",
	appliesto: "blockLevelElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
},
	"-ms-wrap-margin": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "0",
	appliesto: "exclusionElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
},
	"-ms-wrap-through": {
	syntax: "wrap | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "wrap",
	appliesto: "blockLevelElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
},
	"-moz-appearance": {
	syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "noneButOverriddenInUserAgentCSS",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
},
	"-moz-binding": {
	syntax: "<url> | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
},
	"-moz-border-bottom-colors": {
	syntax: "<color>+ | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
},
	"-moz-border-left-colors": {
	syntax: "<color>+ | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
},
	"-moz-border-right-colors": {
	syntax: "<color>+ | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
},
	"-moz-border-top-colors": {
	syntax: "<color>+ | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
},
	"-moz-context-properties": {
	syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElementsThatCanReferenceImages",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
},
	"-moz-float-edge": {
	syntax: "border-box | content-box | margin-box | padding-box",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "content-box",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
},
	"-moz-force-broken-image-icon": {
	syntax: "0 | 1",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "0",
	appliesto: "images",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
},
	"-moz-image-region": {
	syntax: "<shape> | auto",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "auto",
	appliesto: "xulImageElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
},
	"-moz-orient": {
	syntax: "inline | block | horizontal | vertical",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "inline",
	appliesto: "anyElementEffectOnProgressAndMeter",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
},
	"-moz-outline-radius": {
	syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
	media: "visual",
	inherited: false,
	animationType: [
		"-moz-outline-radius-topleft",
		"-moz-outline-radius-topright",
		"-moz-outline-radius-bottomright",
		"-moz-outline-radius-bottomleft"
	],
	percentages: [
		"-moz-outline-radius-topleft",
		"-moz-outline-radius-topright",
		"-moz-outline-radius-bottomright",
		"-moz-outline-radius-bottomleft"
	],
	groups: [
		"Mozilla Extensions"
	],
	initial: [
		"-moz-outline-radius-topleft",
		"-moz-outline-radius-topright",
		"-moz-outline-radius-bottomright",
		"-moz-outline-radius-bottomleft"
	],
	appliesto: "allElements",
	computed: [
		"-moz-outline-radius-topleft",
		"-moz-outline-radius-topright",
		"-moz-outline-radius-bottomright",
		"-moz-outline-radius-bottomleft"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
},
	"-moz-outline-radius-bottomleft": {
	syntax: "<outline-radius>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"Mozilla Extensions"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
},
	"-moz-outline-radius-bottomright": {
	syntax: "<outline-radius>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"Mozilla Extensions"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
},
	"-moz-outline-radius-topleft": {
	syntax: "<outline-radius>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"Mozilla Extensions"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
},
	"-moz-outline-radius-topright": {
	syntax: "<outline-radius>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"Mozilla Extensions"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
},
	"-moz-stack-sizing": {
	syntax: "ignore | stretch-to-fit",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "stretch-to-fit",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
},
	"-moz-text-blink": {
	syntax: "none | blink",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
},
	"-moz-user-focus": {
	syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
},
	"-moz-user-input": {
	syntax: "auto | none | enabled | disabled",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
},
	"-moz-user-modify": {
	syntax: "read-only | read-write | write-only",
	media: "interactive",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "read-only",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
},
	"-moz-window-dragging": {
	syntax: "drag | no-drag",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "drag",
	appliesto: "allElementsCreatingNativeWindows",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
},
	"-moz-window-shadow": {
	syntax: "default | menu | tooltip | sheet | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "default",
	appliesto: "allElementsCreatingNativeWindows",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
},
	"-webkit-appearance": {
	syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "noneButOverriddenInUserAgentCSS",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
},
	"-webkit-border-before": {
	syntax: "<'border-width'> || <'border-style'> || <color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: [
		"-webkit-border-before-width"
	],
	groups: [
		"WebKit Extensions"
	],
	initial: [
		"border-width",
		"border-style",
		"color"
	],
	appliesto: "allElements",
	computed: [
		"border-width",
		"border-style",
		"color"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
},
	"-webkit-border-before-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "nonstandard"
},
	"-webkit-border-before-style": {
	syntax: "<'border-style'>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard"
},
	"-webkit-border-before-width": {
	syntax: "<'border-width'>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"WebKit Extensions"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
	order: "uniqueOrder",
	status: "nonstandard"
},
	"-webkit-box-reflect": {
	syntax: "[ above | below | right | left ]? <length>? <image>?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
},
	"-webkit-line-clamp": {
	syntax: "none | <integer>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"WebKit Extensions",
		"CSS Overflow"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
},
	"-webkit-mask": {
	syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: [
		"-webkit-mask-image",
		"-webkit-mask-repeat",
		"-webkit-mask-attachment",
		"-webkit-mask-position",
		"-webkit-mask-origin",
		"-webkit-mask-clip"
	],
	appliesto: "allElements",
	computed: [
		"-webkit-mask-image",
		"-webkit-mask-repeat",
		"-webkit-mask-attachment",
		"-webkit-mask-position",
		"-webkit-mask-origin",
		"-webkit-mask-clip"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
},
	"-webkit-mask-attachment": {
	syntax: "<attachment>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "scroll",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
},
	"-webkit-mask-clip": {
	syntax: "[ <box> | border | padding | content | text ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "border",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
},
	"-webkit-mask-composite": {
	syntax: "<composite-style>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "source-over",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
},
	"-webkit-mask-image": {
	syntax: "<mask-reference>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "absoluteURIOrNone",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
},
	"-webkit-mask-origin": {
	syntax: "[ <box> | border | padding | content ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "padding",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
},
	"-webkit-mask-position": {
	syntax: "<position>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToSizeOfElement",
	groups: [
		"WebKit Extensions"
	],
	initial: "0% 0%",
	appliesto: "allElements",
	computed: "absoluteLengthOrPercentage",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
},
	"-webkit-mask-position-x": {
	syntax: "[ <length-percentage> | left | center | right ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToSizeOfElement",
	groups: [
		"WebKit Extensions"
	],
	initial: "0%",
	appliesto: "allElements",
	computed: "absoluteLengthOrPercentage",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
},
	"-webkit-mask-position-y": {
	syntax: "[ <length-percentage> | top | center | bottom ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToSizeOfElement",
	groups: [
		"WebKit Extensions"
	],
	initial: "0%",
	appliesto: "allElements",
	computed: "absoluteLengthOrPercentage",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
},
	"-webkit-mask-repeat": {
	syntax: "<repeat-style>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "repeat",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
},
	"-webkit-mask-repeat-x": {
	syntax: "repeat | no-repeat | space | round",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "repeat",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
},
	"-webkit-mask-repeat-y": {
	syntax: "repeat | no-repeat | space | round",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "repeat",
	appliesto: "allElements",
	computed: "absoluteLengthOrPercentage",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
},
	"-webkit-mask-size": {
	syntax: "<bg-size>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "relativeToBackgroundPositioningArea",
	groups: [
		"WebKit Extensions"
	],
	initial: "auto auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
},
	"-webkit-overflow-scrolling": {
	syntax: "auto | touch",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "auto",
	appliesto: "scrollingBoxes",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
},
	"-webkit-tap-highlight-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "black",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
},
	"-webkit-text-fill-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "color",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
},
	"-webkit-text-stroke": {
	syntax: "<length> || <color>",
	media: "visual",
	inherited: true,
	animationType: [
		"-webkit-text-stroke-width",
		"-webkit-text-stroke-color"
	],
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: [
		"-webkit-text-stroke-width",
		"-webkit-text-stroke-color"
	],
	appliesto: "allElements",
	computed: [
		"-webkit-text-stroke-width",
		"-webkit-text-stroke-color"
	],
	order: "canonicalOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
},
	"-webkit-text-stroke-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "color",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
},
	"-webkit-text-stroke-width": {
	syntax: "<length>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "absoluteLength",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
},
	"-webkit-touch-callout": {
	syntax: "default | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "default",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
},
	"-webkit-user-modify": {
	syntax: "read-only | read-write | read-write-plaintext-only",
	media: "interactive",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "read-only",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard"
},
	"accent-color": {
	syntax: "auto | <color>",
	media: "interactive",
	inherited: true,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asAutoOrColor",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/accent-color"
},
	"align-content": {
	syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: "normal",
	appliesto: "multilineFlexContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
},
	"align-items": {
	syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
},
	"align-self": {
	syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: "auto",
	appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
	computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
},
	"align-tracks": {
	syntax: "[ normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position> ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "normal",
	appliesto: "gridContainersWithMasonryLayoutInTheirBlockAxis",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-tracks"
},
	all: all,
	animation: animation,
	"animation-composition": {
	syntax: "<single-animation-composition>#",
	media: "visual",
	inherited: false,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "replace",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-composition"
},
	"animation-delay": {
	syntax: "<time>#",
	media: "visual",
	inherited: false,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "0s",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
},
	"animation-direction": {
	syntax: "<single-animation-direction>#",
	media: "visual",
	inherited: false,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "normal",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
},
	"animation-duration": {
	syntax: "<time>#",
	media: "visual",
	inherited: false,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "0s",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
},
	"animation-fill-mode": {
	syntax: "<single-animation-fill-mode>#",
	media: "visual",
	inherited: false,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "none",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
},
	"animation-iteration-count": {
	syntax: "<single-animation-iteration-count>#",
	media: "visual",
	inherited: false,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "1",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
},
	"animation-name": {
	syntax: "[ none | <keyframes-name> ]#",
	media: "visual",
	inherited: false,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "none",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
},
	"animation-play-state": {
	syntax: "<single-animation-play-state>#",
	media: "visual",
	inherited: false,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "running",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
},
	"animation-timing-function": {
	syntax: "<easing-function>#",
	media: "visual",
	inherited: false,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "ease",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
},
	"animation-timeline": {
	syntax: "<single-animation-timeline>#",
	media: "visual",
	inherited: false,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "listEachItemIdentifyerOrNoneAuto",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timeline"
},
	appearance: appearance,
	"aspect-ratio": {
	syntax: "auto | <ratio>",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "auto",
	appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
	computed: "asSpecified",
	order: "perGrammar",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
},
	azimuth: azimuth,
	"backdrop-filter": {
	syntax: "none | <filter-function-list>",
	media: "visual",
	inherited: false,
	animationType: "filterList",
	percentages: "no",
	groups: [
		"Filter Effects"
	],
	initial: "none",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
},
	"backface-visibility": {
	syntax: "visible | hidden",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transforms"
	],
	initial: "visible",
	appliesto: "transformableElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
},
	background: background,
	"background-attachment": {
	syntax: "<attachment>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "scroll",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
},
	"background-blend-mode": {
	syntax: "<blend-mode>#",
	media: "none",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Compositing and Blending"
	],
	initial: "normal",
	appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
},
	"background-clip": {
	syntax: "<box>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "border-box",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
},
	"background-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "transparent",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
},
	"background-image": {
	syntax: "<bg-image>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecifiedURLsAbsolute",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
},
	"background-origin": {
	syntax: "<box>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "padding-box",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
},
	"background-position": {
	syntax: "<bg-position>#",
	media: "visual",
	inherited: false,
	animationType: "repeatableListOfSimpleListOfLpc",
	percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "0% 0%",
	appliesto: "allElements",
	computed: [
		"background-position-x",
		"background-position-y"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
},
	"background-position-x": {
	syntax: "[ center | [ [ left | right | x-start | x-end ]? <length-percentage>? ]! ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "0%",
	appliesto: "allElements",
	computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
},
	"background-position-y": {
	syntax: "[ center | [ [ top | bottom | y-start | y-end ]? <length-percentage>? ]! ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "0%",
	appliesto: "allElements",
	computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
},
	"background-repeat": {
	syntax: "<repeat-style>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "repeat",
	appliesto: "allElements",
	computed: "listEachItemHasTwoKeywordsOnePerDimension",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
},
	"background-size": {
	syntax: "<bg-size>#",
	media: "visual",
	inherited: false,
	animationType: "repeatableListOfSimpleListOfLpc",
	percentages: "relativeToBackgroundPositioningArea",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "auto auto",
	appliesto: "allElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
},
	"block-overflow": {
	syntax: "clip | ellipsis | <string>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "clip",
	appliesto: "blockContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "experimental"
},
	"block-size": {
	syntax: "<'width'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "blockSizeOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "sameAsWidthAndHeight",
	computed: "sameAsWidthAndHeight",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
},
	border: border,
	"border-block": {
	syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	appliesto: "allElements",
	computed: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
},
	"border-block-color": {
	syntax: "<'border-top-color'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
},
	"border-block-style": {
	syntax: "<'border-top-style'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
},
	"border-block-width": {
	syntax: "<'border-top-width'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
},
	"border-block-end": {
	syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-block-end-color",
		"border-block-end-style",
		"border-block-end-width"
	],
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	appliesto: "allElements",
	computed: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
},
	"border-block-end-color": {
	syntax: "<'border-top-color'>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
},
	"border-block-end-style": {
	syntax: "<'border-top-style'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
},
	"border-block-end-width": {
	syntax: "<'border-top-width'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
},
	"border-block-start": {
	syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-block-start-color",
		"border-block-start-style",
		"border-block-start-width"
	],
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"border-width",
		"border-style",
		"color"
	],
	appliesto: "allElements",
	computed: [
		"border-width",
		"border-style",
		"border-block-start-color"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
},
	"border-block-start-color": {
	syntax: "<'border-top-color'>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
},
	"border-block-start-style": {
	syntax: "<'border-top-style'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
},
	"border-block-start-width": {
	syntax: "<'border-top-width'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
},
	"border-bottom": {
	syntax: "<line-width> || <line-style> || <color>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-bottom-color",
		"border-bottom-style",
		"border-bottom-width"
	],
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-bottom-width",
		"border-bottom-style",
		"border-bottom-color"
	],
	appliesto: "allElements",
	computed: [
		"border-bottom-width",
		"border-bottom-style",
		"border-bottom-color"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
},
	"border-bottom-color": {
	syntax: "<'border-top-color'>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
},
	"border-bottom-left-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
},
	"border-bottom-right-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
},
	"border-bottom-style": {
	syntax: "<line-style>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
},
	"border-bottom-width": {
	syntax: "<line-width>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
},
	"border-collapse": {
	syntax: "collapse | separate",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Table"
	],
	initial: "separate",
	appliesto: "tableElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
},
	"border-color": {
	syntax: "<color>{1,4}",
	media: "visual",
	inherited: false,
	animationType: [
		"border-bottom-color",
		"border-left-color",
		"border-right-color",
		"border-top-color"
	],
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-top-color",
		"border-right-color",
		"border-bottom-color",
		"border-left-color"
	],
	appliesto: "allElements",
	computed: [
		"border-bottom-color",
		"border-left-color",
		"border-right-color",
		"border-top-color"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
},
	"border-end-end-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
},
	"border-end-start-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
},
	"border-image": {
	syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: [
		"border-image-slice",
		"border-image-width"
	],
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-image-source",
		"border-image-slice",
		"border-image-width",
		"border-image-outset",
		"border-image-repeat"
	],
	appliesto: "allElementsExceptTableElementsWhenCollapse",
	computed: [
		"border-image-outset",
		"border-image-repeat",
		"border-image-slice",
		"border-image-source",
		"border-image-width"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
},
	"border-image-outset": {
	syntax: "[ <length> | <number> ]{1,4}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "0",
	appliesto: "allElementsExceptTableElementsWhenCollapse",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
},
	"border-image-repeat": {
	syntax: "[ stretch | repeat | round | space ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "stretch",
	appliesto: "allElementsExceptTableElementsWhenCollapse",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
},
	"border-image-slice": {
	syntax: "<number-percentage>{1,4} && fill?",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "referToSizeOfBorderImage",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "100%",
	appliesto: "allElementsExceptTableElementsWhenCollapse",
	computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
	order: "percentagesOrLengthsFollowedByFill",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
},
	"border-image-source": {
	syntax: "none | <image>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "none",
	appliesto: "allElementsExceptTableElementsWhenCollapse",
	computed: "noneOrImageWithAbsoluteURI",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
},
	"border-image-width": {
	syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "referToWidthOrHeightOfBorderImageArea",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "1",
	appliesto: "allElementsExceptTableElementsWhenCollapse",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
},
	"border-inline": {
	syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	appliesto: "allElements",
	computed: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
},
	"border-inline-end": {
	syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-inline-end-color",
		"border-inline-end-style",
		"border-inline-end-width"
	],
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"border-width",
		"border-style",
		"color"
	],
	appliesto: "allElements",
	computed: [
		"border-width",
		"border-style",
		"border-inline-end-color"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
},
	"border-inline-color": {
	syntax: "<'border-top-color'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
},
	"border-inline-style": {
	syntax: "<'border-top-style'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
},
	"border-inline-width": {
	syntax: "<'border-top-width'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
},
	"border-inline-end-color": {
	syntax: "<'border-top-color'>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
},
	"border-inline-end-style": {
	syntax: "<'border-top-style'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
},
	"border-inline-end-width": {
	syntax: "<'border-top-width'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
},
	"border-inline-start": {
	syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-inline-start-color",
		"border-inline-start-style",
		"border-inline-start-width"
	],
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"border-width",
		"border-style",
		"color"
	],
	appliesto: "allElements",
	computed: [
		"border-width",
		"border-style",
		"border-inline-start-color"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
},
	"border-inline-start-color": {
	syntax: "<'border-top-color'>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
},
	"border-inline-start-style": {
	syntax: "<'border-top-style'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
},
	"border-inline-start-width": {
	syntax: "<'border-top-width'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
},
	"border-left": {
	syntax: "<line-width> || <line-style> || <color>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-left-color",
		"border-left-style",
		"border-left-width"
	],
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-left-width",
		"border-left-style",
		"border-left-color"
	],
	appliesto: "allElements",
	computed: [
		"border-left-width",
		"border-left-style",
		"border-left-color"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
},
	"border-left-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
},
	"border-left-style": {
	syntax: "<line-style>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
},
	"border-left-width": {
	syntax: "<line-width>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
},
	"border-radius": {
	syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
	media: "visual",
	inherited: false,
	animationType: [
		"border-top-left-radius",
		"border-top-right-radius",
		"border-bottom-right-radius",
		"border-bottom-left-radius"
	],
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-top-left-radius",
		"border-top-right-radius",
		"border-bottom-right-radius",
		"border-bottom-left-radius"
	],
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: [
		"border-bottom-left-radius",
		"border-bottom-right-radius",
		"border-top-left-radius",
		"border-top-right-radius"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
},
	"border-right": {
	syntax: "<line-width> || <line-style> || <color>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-right-color",
		"border-right-style",
		"border-right-width"
	],
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-right-width",
		"border-right-style",
		"border-right-color"
	],
	appliesto: "allElements",
	computed: [
		"border-right-width",
		"border-right-style",
		"border-right-color"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
},
	"border-right-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
},
	"border-right-style": {
	syntax: "<line-style>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
},
	"border-right-width": {
	syntax: "<line-width>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
},
	"border-spacing": {
	syntax: "<length> <length>?",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Table"
	],
	initial: "0",
	appliesto: "tableElements",
	computed: "twoAbsoluteLengths",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
},
	"border-start-end-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
},
	"border-start-start-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
},
	"border-style": {
	syntax: "<line-style>{1,4}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-top-style",
		"border-right-style",
		"border-bottom-style",
		"border-left-style"
	],
	appliesto: "allElements",
	computed: [
		"border-bottom-style",
		"border-left-style",
		"border-right-style",
		"border-top-style"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
},
	"border-top": {
	syntax: "<line-width> || <line-style> || <color>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-top-color",
		"border-top-style",
		"border-top-width"
	],
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	appliesto: "allElements",
	computed: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
},
	"border-top-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
},
	"border-top-left-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
},
	"border-top-right-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
},
	"border-top-style": {
	syntax: "<line-style>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
},
	"border-top-width": {
	syntax: "<line-width>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
},
	"border-width": {
	syntax: "<line-width>{1,4}",
	media: "visual",
	inherited: false,
	animationType: [
		"border-bottom-width",
		"border-left-width",
		"border-right-width",
		"border-top-width"
	],
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-top-width",
		"border-right-width",
		"border-bottom-width",
		"border-left-width"
	],
	appliesto: "allElements",
	computed: [
		"border-bottom-width",
		"border-left-width",
		"border-right-width",
		"border-top-width"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
},
	bottom: bottom,
	"box-align": {
	syntax: "start | center | end | baseline | stretch",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "stretch",
	appliesto: "elementsWithDisplayBoxOrInlineBox",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
},
	"box-decoration-break": {
	syntax: "slice | clone",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fragmentation"
	],
	initial: "slice",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
},
	"box-direction": {
	syntax: "normal | reverse | inherit",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "normal",
	appliesto: "elementsWithDisplayBoxOrInlineBox",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
},
	"box-flex": {
	syntax: "<number>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "0",
	appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
},
	"box-flex-group": {
	syntax: "<integer>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "1",
	appliesto: "inFlowChildrenOfBoxElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
},
	"box-lines": {
	syntax: "single | multiple",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "single",
	appliesto: "boxElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
},
	"box-ordinal-group": {
	syntax: "<integer>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "1",
	appliesto: "childrenOfBoxElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
},
	"box-orient": {
	syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "inlineAxisHorizontalInXUL",
	appliesto: "elementsWithDisplayBoxOrInlineBox",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
},
	"box-pack": {
	syntax: "start | center | end | justify",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "start",
	appliesto: "elementsWithDisplayMozBoxMozInlineBox",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
},
	"box-shadow": {
	syntax: "none | <shadow>#",
	media: "visual",
	inherited: false,
	animationType: "shadowList",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "absoluteLengthsSpecifiedColorAsSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
},
	"box-sizing": {
	syntax: "content-box | border-box",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "content-box",
	appliesto: "allElementsAcceptingWidthOrHeight",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
},
	"break-after": {
	syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fragmentation"
	],
	initial: "auto",
	appliesto: "blockLevelElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
},
	"break-before": {
	syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fragmentation"
	],
	initial: "auto",
	appliesto: "blockLevelElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
},
	"break-inside": {
	syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fragmentation"
	],
	initial: "auto",
	appliesto: "blockLevelElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
},
	"caption-side": {
	syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Table"
	],
	initial: "top",
	appliesto: "tableCaptionElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
},
	caret: caret,
	"caret-color": {
	syntax: "auto | <color>",
	media: "interactive",
	inherited: true,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asAutoOrColor",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
},
	"caret-shape": {
	syntax: "auto | bar | block | underscore",
	media: "interactive",
	inherited: true,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "auto",
	appliesto: "elementsThatAcceptInput",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard"
},
	clear: clear,
	clip: clip,
	"clip-path": {
	syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
	media: "visual",
	inherited: false,
	animationType: "basicShapeOtherwiseNo",
	percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
	groups: [
		"CSS Masking"
	],
	initial: "none",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecifiedURLsAbsolute",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
},
	color: color$1,
	"print-color-adjust": {
	syntax: "economy | exact",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Color"
	],
	initial: "economy",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/print-color-adjust"
},
	"color-scheme": {
	syntax: "normal | [ light | dark | <custom-ident> ]+ && only?",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Color"
	],
	initial: "normal",
	appliesto: "allElementsAndText",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-scheme"
},
	"column-count": {
	syntax: "<integer> | auto",
	media: "visual",
	inherited: false,
	animationType: "integer",
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: "auto",
	appliesto: "blockContainersExceptTableWrappers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
},
	"column-fill": {
	syntax: "auto | balance | balance-all",
	media: "visualInContinuousMediaNoEffectInOverflowColumns",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: "balance",
	appliesto: "multicolElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
},
	"column-gap": {
	syntax: "normal | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Box Alignment"
	],
	initial: "normal",
	appliesto: "multiColumnElementsFlexContainersGridContainers",
	computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
},
	"column-rule": {
	syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
	media: "visual",
	inherited: false,
	animationType: [
		"column-rule-color",
		"column-rule-style",
		"column-rule-width"
	],
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: [
		"column-rule-width",
		"column-rule-style",
		"column-rule-color"
	],
	appliesto: "multicolElements",
	computed: [
		"column-rule-color",
		"column-rule-style",
		"column-rule-width"
	],
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
},
	"column-rule-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: "currentcolor",
	appliesto: "multicolElements",
	computed: "computedColor",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
},
	"column-rule-style": {
	syntax: "<'border-style'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: "none",
	appliesto: "multicolElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
},
	"column-rule-width": {
	syntax: "<'border-width'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: "medium",
	appliesto: "multicolElements",
	computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
},
	"column-span": {
	syntax: "none | all",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: "none",
	appliesto: "inFlowBlockLevelElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
},
	"column-width": {
	syntax: "<length> | auto",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: "auto",
	appliesto: "blockContainersExceptTableWrappers",
	computed: "absoluteLengthZeroOrLarger",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
},
	columns: columns,
	contain: contain,
	"contain-intrinsic-size": {
	syntax: "[ none | <length> | auto <length> ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: [
		"contain-intrinsic-width",
		"contain-intrinsic-height"
	],
	percentages: [
		"contain-intrinsic-width",
		"contain-intrinsic-height"
	],
	groups: [
		"CSS Containment"
	],
	initial: [
		"contain-intrinsic-width",
		"contain-intrinsic-height"
	],
	appliesto: "elementsForWhichSizeContainmentCanApply",
	computed: [
		"contain-intrinsic-width",
		"contain-intrinsic-height"
	],
	order: "perGrammar",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-size"
},
	"contain-intrinsic-block-size": {
	syntax: "none | <length> | auto <length>",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Containment"
	],
	initial: "none",
	appliesto: "elementsForWhichSizeContainmentCanApply",
	computed: "asSpecifiedWithLengthValuesComputed",
	order: "perGrammar",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-block-size"
},
	"contain-intrinsic-height": {
	syntax: "none | <length> | auto <length>",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Containment"
	],
	initial: "none",
	appliesto: "elementsForWhichSizeContainmentCanApply",
	computed: "asSpecifiedWithLengthValuesComputed",
	order: "perGrammar",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-height"
},
	"contain-intrinsic-inline-size": {
	syntax: "none | <length> | auto <length>",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Containment"
	],
	initial: "none",
	appliesto: "elementsForWhichSizeContainmentCanApply",
	computed: "asSpecifiedWithLengthValuesComputed",
	order: "perGrammar",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-inline-size"
},
	"contain-intrinsic-width": {
	syntax: "none | <length> | auto <length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Containment"
	],
	initial: "none",
	appliesto: "elementsForWhichSizeContainmentCanApply",
	computed: "asSpecifiedWithLengthValuesComputed",
	order: "perGrammar",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-width"
},
	content: content,
	"content-visibility": {
	syntax: "visible | auto | hidden",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Containment"
	],
	initial: "visible",
	appliesto: "elementsForWhichLayoutContainmentCanApply",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content-visibility"
},
	"counter-increment": {
	syntax: "[ <counter-name> <integer>? ]+ | none",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Counter Styles"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
},
	"counter-reset": {
	syntax: "[ <counter-name> <integer>? | <reversed-counter-name> <integer>? ]+ | none",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Counter Styles"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
},
	"counter-set": {
	syntax: "[ <counter-name> <integer>? ]+ | none",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Counter Styles"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
},
	cursor: cursor,
	direction: direction,
	display: display,
	"empty-cells": {
	syntax: "show | hide",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Table"
	],
	initial: "show",
	appliesto: "tableCellElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
},
	filter: filter,
	flex: flex,
	"flex-basis": {
	syntax: "content | <'width'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToFlexContainersInnerMainSize",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: "auto",
	appliesto: "flexItemsAndInFlowPseudos",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "lengthOrPercentageBeforeKeywordIfBothPresent",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
},
	"flex-direction": {
	syntax: "row | row-reverse | column | column-reverse",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: "row",
	appliesto: "flexContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
},
	"flex-flow": {
	syntax: "<'flex-direction'> || <'flex-wrap'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: [
		"flex-direction",
		"flex-wrap"
	],
	appliesto: "flexContainers",
	computed: [
		"flex-direction",
		"flex-wrap"
	],
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
},
	"flex-grow": {
	syntax: "<number>",
	media: "visual",
	inherited: false,
	animationType: "number",
	percentages: "no",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: "0",
	appliesto: "flexItemsAndInFlowPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
},
	"flex-shrink": {
	syntax: "<number>",
	media: "visual",
	inherited: false,
	animationType: "number",
	percentages: "no",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: "1",
	appliesto: "flexItemsAndInFlowPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
},
	"flex-wrap": {
	syntax: "nowrap | wrap | wrap-reverse",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: "nowrap",
	appliesto: "flexContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
},
	float: float,
	font: font,
	"font-family": {
	syntax: "[ <family-name> | <generic-family> ]#",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "dependsOnUserAgent",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
},
	"font-feature-settings": {
	syntax: "normal | <feature-tag-value>#",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
},
	"font-kerning": {
	syntax: "auto | normal | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
},
	"font-language-override": {
	syntax: "normal | <string>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
},
	"font-optical-sizing": {
	syntax: "auto | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
},
	"font-variation-settings": {
	syntax: "normal | [ <string> <number> ]#",
	media: "visual",
	inherited: true,
	animationType: "transform",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
},
	"font-size": {
	syntax: "<absolute-size> | <relative-size> | <length-percentage>",
	media: "visual",
	inherited: true,
	animationType: "length",
	percentages: "referToParentElementsFontSize",
	groups: [
		"CSS Fonts"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
},
	"font-size-adjust": {
	syntax: "none | [ ex-height | cap-height | ch-width | ic-width | ic-height ]? [ from-font | <number> ]",
	media: "visual",
	inherited: true,
	animationType: "number",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
},
	"font-smooth": {
	syntax: "auto | never | always | <absolute-size> | <length>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-smooth"
},
	"font-stretch": {
	syntax: "<font-stretch-absolute>",
	media: "visual",
	inherited: true,
	animationType: "fontStretch",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
},
	"font-style": {
	syntax: "normal | italic | oblique <angle>?",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
},
	"font-synthesis": {
	syntax: "none | [ weight || style || small-caps ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "weight style",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
},
	"font-variant": {
	syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
},
	"font-variant-alternates": {
	syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
},
	"font-variant-caps": {
	syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
},
	"font-variant-east-asian": {
	syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
},
	"font-variant-ligatures": {
	syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
},
	"font-variant-numeric": {
	syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
},
	"font-variant-position": {
	syntax: "normal | sub | super",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
},
	"font-weight": {
	syntax: "<font-weight-absolute> | bolder | lighter",
	media: "visual",
	inherited: true,
	animationType: "fontWeight",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
},
	"forced-color-adjust": {
	syntax: "auto | none",
	media: "visual",
	inherited: true,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"CSS Color"
	],
	initial: "auto",
	appliesto: "allElementsAndText",
	computed: "asSpecified",
	order: "perGrammar",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/forced-color-adjust"
},
	gap: gap,
	grid: grid,
	"grid-area": {
	syntax: "<grid-line> [ / <grid-line> ]{0,3}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: [
		"grid-row-start",
		"grid-column-start",
		"grid-row-end",
		"grid-column-end"
	],
	appliesto: "gridItemsAndBoxesWithinGridContainer",
	computed: [
		"grid-row-start",
		"grid-column-start",
		"grid-row-end",
		"grid-column-end"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
},
	"grid-auto-columns": {
	syntax: "<track-size>+",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "auto",
	appliesto: "gridContainers",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
},
	"grid-auto-flow": {
	syntax: "[ row | column ] || dense",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "row",
	appliesto: "gridContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
},
	"grid-auto-rows": {
	syntax: "<track-size>+",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "auto",
	appliesto: "gridContainers",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
},
	"grid-column": {
	syntax: "<grid-line> [ / <grid-line> ]?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: [
		"grid-column-start",
		"grid-column-end"
	],
	appliesto: "gridItemsAndBoxesWithinGridContainer",
	computed: [
		"grid-column-start",
		"grid-column-end"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
},
	"grid-column-end": {
	syntax: "<grid-line>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "auto",
	appliesto: "gridItemsAndBoxesWithinGridContainer",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
},
	"grid-column-gap": {
	syntax: "<length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "0",
	appliesto: "gridContainers",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
},
	"grid-column-start": {
	syntax: "<grid-line>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "auto",
	appliesto: "gridItemsAndBoxesWithinGridContainer",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
},
	"grid-gap": {
	syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
	media: "visual",
	inherited: false,
	animationType: [
		"grid-row-gap",
		"grid-column-gap"
	],
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: [
		"grid-row-gap",
		"grid-column-gap"
	],
	appliesto: "gridContainers",
	computed: [
		"grid-row-gap",
		"grid-column-gap"
	],
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
},
	"grid-row": {
	syntax: "<grid-line> [ / <grid-line> ]?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: [
		"grid-row-start",
		"grid-row-end"
	],
	appliesto: "gridItemsAndBoxesWithinGridContainer",
	computed: [
		"grid-row-start",
		"grid-row-end"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
},
	"grid-row-end": {
	syntax: "<grid-line>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "auto",
	appliesto: "gridItemsAndBoxesWithinGridContainer",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
},
	"grid-row-gap": {
	syntax: "<length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "0",
	appliesto: "gridContainers",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
},
	"grid-row-start": {
	syntax: "<grid-line>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "auto",
	appliesto: "gridItemsAndBoxesWithinGridContainer",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
},
	"grid-template": {
	syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: [
		"grid-template-columns",
		"grid-template-rows"
	],
	groups: [
		"CSS Grid Layout"
	],
	initial: [
		"grid-template-columns",
		"grid-template-rows",
		"grid-template-areas"
	],
	appliesto: "gridContainers",
	computed: [
		"grid-template-columns",
		"grid-template-rows",
		"grid-template-areas"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
},
	"grid-template-areas": {
	syntax: "none | <string>+",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "none",
	appliesto: "gridContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
},
	"grid-template-columns": {
	syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
	media: "visual",
	inherited: false,
	animationType: "simpleListOfLpcDifferenceLpc",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "none",
	appliesto: "gridContainers",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
},
	"grid-template-rows": {
	syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
	media: "visual",
	inherited: false,
	animationType: "simpleListOfLpcDifferenceLpc",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "none",
	appliesto: "gridContainers",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
},
	"hanging-punctuation": {
	syntax: "none | [ first || [ force-end | allow-end ] || last ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
},
	height: height,
	"hyphenate-character": {
	syntax: "auto | <string>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphenate-character"
},
	hyphens: hyphens,
	"image-orientation": {
	syntax: "from-image | <angle> | [ <angle>? flip ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Images"
	],
	initial: "from-image",
	appliesto: "allElements",
	computed: "angleRoundedToNextQuarter",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
},
	"image-rendering": {
	syntax: "auto | crisp-edges | pixelated",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Images"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
},
	"image-resolution": {
	syntax: "[ from-image || <resolution> ] && snap?",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Images"
	],
	initial: "1dppx",
	appliesto: "allElements",
	computed: "asSpecifiedWithExceptionOfResolution",
	order: "uniqueOrder",
	status: "experimental"
},
	"ime-mode": {
	syntax: "auto | normal | active | inactive | disabled",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "auto",
	appliesto: "textFields",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
},
	"initial-letter": {
	syntax: "normal | [ <number> <integer>? ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Inline"
	],
	initial: "normal",
	appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
},
	"initial-letter-align": {
	syntax: "[ auto | alphabetic | hanging | ideographic ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Inline"
	],
	initial: "auto",
	appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
},
	"inline-size": {
	syntax: "<'width'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "inlineSizeOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "sameAsWidthAndHeight",
	computed: "sameAsWidthAndHeight",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
},
	"input-security": {
	syntax: "auto | none",
	media: "interactive",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "auto",
	appliesto: "sensitiveTextInputs",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard"
},
	inset: inset,
	"inset-block": {
	syntax: "<'top'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "logicalHeightOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"inset-block-start",
		"inset-block-end"
	],
	appliesto: "positionedElements",
	computed: [
		"inset-block-start",
		"inset-block-end"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
},
	"inset-block-end": {
	syntax: "<'top'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "logicalHeightOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "sameAsBoxOffsets",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
},
	"inset-block-start": {
	syntax: "<'top'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "logicalHeightOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "sameAsBoxOffsets",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
},
	"inset-inline": {
	syntax: "<'top'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"inset-inline-start",
		"inset-inline-end"
	],
	appliesto: "positionedElements",
	computed: [
		"inset-inline-start",
		"inset-inline-end"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
},
	"inset-inline-end": {
	syntax: "<'top'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "sameAsBoxOffsets",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
},
	"inset-inline-start": {
	syntax: "<'top'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "sameAsBoxOffsets",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
},
	isolation: isolation,
	"justify-content": {
	syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: "normal",
	appliesto: "flexContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
},
	"justify-items": {
	syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: "legacy",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
},
	"justify-self": {
	syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: "auto",
	appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
},
	"justify-tracks": {
	syntax: "[ normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ] ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "normal",
	appliesto: "gridContainersWithMasonryLayoutInTheirInlineAxis",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-tracks"
},
	left: left,
	"letter-spacing": {
	syntax: "normal | <length>",
	media: "visual",
	inherited: true,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "optimumValueOfAbsoluteLengthOrNormal",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
},
	"line-break": {
	syntax: "auto | loose | normal | strict | anywhere",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
},
	"line-clamp": {
	syntax: "none | <integer>",
	media: "visual",
	inherited: false,
	animationType: "integer",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "none",
	appliesto: "blockContainersExceptMultiColumnContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "experimental"
},
	"line-height": {
	syntax: "normal | <number> | <length> | <percentage>",
	media: "visual",
	inherited: true,
	animationType: "numberOrLength",
	percentages: "referToElementFontSize",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "absoluteLengthOrAsSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
},
	"line-height-step": {
	syntax: "<length>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "0",
	appliesto: "blockContainers",
	computed: "absoluteLength",
	order: "perGrammar",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
},
	"list-style": {
	syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Lists and Counters"
	],
	initial: [
		"list-style-type",
		"list-style-position",
		"list-style-image"
	],
	appliesto: "listItems",
	computed: [
		"list-style-image",
		"list-style-position",
		"list-style-type"
	],
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
},
	"list-style-image": {
	syntax: "<image> | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Lists and Counters"
	],
	initial: "none",
	appliesto: "listItems",
	computed: "theKeywordListStyleImageNoneOrComputedValue",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
},
	"list-style-position": {
	syntax: "inside | outside",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Lists and Counters"
	],
	initial: "outside",
	appliesto: "listItems",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
},
	"list-style-type": {
	syntax: "<counter-style> | <string> | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Lists and Counters"
	],
	initial: "disc",
	appliesto: "listItems",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
},
	margin: margin,
	"margin-block": {
	syntax: "<'margin-left'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "dependsOnLayoutModel",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"margin-block-start",
		"margin-block-end"
	],
	appliesto: "sameAsMargin",
	computed: [
		"margin-block-start",
		"margin-block-end"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
},
	"margin-block-end": {
	syntax: "<'margin-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "dependsOnLayoutModel",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsMargin",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
},
	"margin-block-start": {
	syntax: "<'margin-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "dependsOnLayoutModel",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsMargin",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
},
	"margin-bottom": {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
},
	"margin-inline": {
	syntax: "<'margin-left'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "dependsOnLayoutModel",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"margin-inline-start",
		"margin-inline-end"
	],
	appliesto: "sameAsMargin",
	computed: [
		"margin-inline-start",
		"margin-inline-end"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
},
	"margin-inline-end": {
	syntax: "<'margin-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "dependsOnLayoutModel",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsMargin",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
},
	"margin-inline-start": {
	syntax: "<'margin-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "dependsOnLayoutModel",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsMargin",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
},
	"margin-left": {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
},
	"margin-right": {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
},
	"margin-top": {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
},
	"margin-trim": {
	syntax: "none | in-flow | all",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "none",
	appliesto: "blockContainersAndMultiColumnContainers",
	computed: "asSpecified",
	order: "perGrammar",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-trim"
},
	mask: mask,
	"mask-border": {
	syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
	media: "visual",
	inherited: false,
	animationType: [
		"mask-border-mode",
		"mask-border-outset",
		"mask-border-repeat",
		"mask-border-slice",
		"mask-border-source",
		"mask-border-width"
	],
	percentages: [
		"mask-border-slice",
		"mask-border-width"
	],
	groups: [
		"CSS Masking"
	],
	initial: [
		"mask-border-mode",
		"mask-border-outset",
		"mask-border-repeat",
		"mask-border-slice",
		"mask-border-source",
		"mask-border-width"
	],
	appliesto: "allElementsSVGContainerElements",
	computed: [
		"mask-border-mode",
		"mask-border-outset",
		"mask-border-repeat",
		"mask-border-slice",
		"mask-border-source",
		"mask-border-width"
	],
	order: "perGrammar",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
},
	"mask-border-mode": {
	syntax: "luminance | alpha",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "alpha",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
},
	"mask-border-outset": {
	syntax: "[ <length> | <number> ]{1,4}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "0",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
},
	"mask-border-repeat": {
	syntax: "[ stretch | repeat | round | space ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "stretch",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
},
	"mask-border-slice": {
	syntax: "<number-percentage>{1,4} fill?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToSizeOfMaskBorderImage",
	groups: [
		"CSS Masking"
	],
	initial: "0",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
},
	"mask-border-source": {
	syntax: "none | <image>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "none",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecifiedURLsAbsolute",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
},
	"mask-border-width": {
	syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "relativeToMaskBorderImageArea",
	groups: [
		"CSS Masking"
	],
	initial: "auto",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
},
	"mask-clip": {
	syntax: "[ <geometry-box> | no-clip ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "border-box",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
},
	"mask-composite": {
	syntax: "<compositing-operator>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "add",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
},
	"mask-image": {
	syntax: "<mask-reference>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "none",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecifiedURLsAbsolute",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
},
	"mask-mode": {
	syntax: "<masking-mode>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "match-source",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
},
	"mask-origin": {
	syntax: "<geometry-box>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "border-box",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
},
	"mask-position": {
	syntax: "<position>#",
	media: "visual",
	inherited: false,
	animationType: "repeatableListOfSimpleListOfLpc",
	percentages: "referToSizeOfMaskPaintingArea",
	groups: [
		"CSS Masking"
	],
	initial: "center",
	appliesto: "allElementsSVGContainerElements",
	computed: "consistsOfTwoKeywordsForOriginAndOffsets",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
},
	"mask-repeat": {
	syntax: "<repeat-style>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "repeat",
	appliesto: "allElementsSVGContainerElements",
	computed: "consistsOfTwoDimensionKeywords",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
},
	"mask-size": {
	syntax: "<bg-size>#",
	media: "visual",
	inherited: false,
	animationType: "repeatableListOfSimpleListOfLpc",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "auto",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
},
	"mask-type": {
	syntax: "luminance | alpha",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "luminance",
	appliesto: "maskElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
},
	"masonry-auto-flow": {
	syntax: "[ pack | next ] || [ definite-first | ordered ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "pack",
	appliesto: "gridContainersWithMasonryLayout",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/masonry-auto-flow"
},
	"math-depth": {
	syntax: "auto-add | add(<integer>) | <integer>",
	media: "visual",
	inherited: true,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"MathML"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-depth"
},
	"math-shift": {
	syntax: "normal | compact",
	media: "visual",
	inherited: true,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"MathML"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-shift"
},
	"math-style": {
	syntax: "normal | compact",
	media: "visual",
	inherited: true,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"MathML"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-style"
},
	"max-block-size": {
	syntax: "<'max-width'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "blockSizeOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "none",
	appliesto: "sameAsWidthAndHeight",
	computed: "sameAsMaxWidthAndMaxHeight",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
},
	"max-height": {
	syntax: "none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
	groups: [
		"CSS Box Model"
	],
	initial: "none",
	appliesto: "allElementsButNonReplacedAndTableColumns",
	computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
},
	"max-inline-size": {
	syntax: "<'max-width'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "inlineSizeOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "none",
	appliesto: "sameAsWidthAndHeight",
	computed: "sameAsMaxWidthAndMaxHeight",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
},
	"max-lines": {
	syntax: "none | <integer>",
	media: "visual",
	inherited: false,
	animationType: "integer",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "none",
	appliesto: "blockContainersExceptMultiColumnContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "experimental"
},
	"max-width": {
	syntax: "none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "none",
	appliesto: "allElementsButNonReplacedAndTableRows",
	computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
},
	"min-block-size": {
	syntax: "<'min-width'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "blockSizeOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsWidthAndHeight",
	computed: "sameAsMinWidthAndMinHeight",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
},
	"min-height": {
	syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "allElementsButNonReplacedAndTableColumns",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
},
	"min-inline-size": {
	syntax: "<'min-width'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "inlineSizeOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsWidthAndHeight",
	computed: "sameAsMinWidthAndMinHeight",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
},
	"min-width": {
	syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "allElementsButNonReplacedAndTableRows",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
},
	"mix-blend-mode": {
	syntax: "<blend-mode> | plus-lighter",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Compositing and Blending"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
},
	"object-fit": {
	syntax: "fill | contain | cover | none | scale-down",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Images"
	],
	initial: "fill",
	appliesto: "replacedElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
},
	"object-position": {
	syntax: "<position>",
	media: "visual",
	inherited: true,
	animationType: "repeatableListOfSimpleListOfLpc",
	percentages: "referToWidthAndHeightOfElement",
	groups: [
		"CSS Images"
	],
	initial: "50% 50%",
	appliesto: "replacedElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
},
	offset: offset,
	"offset-anchor": {
	syntax: "auto | <position>",
	media: "visual",
	inherited: false,
	animationType: "position",
	percentages: "relativeToWidthAndHeight",
	groups: [
		"CSS Motion Path"
	],
	initial: "auto",
	appliesto: "transformableElements",
	computed: "forLengthAbsoluteValueOtherwisePercentage",
	order: "perGrammar",
	status: "standard"
},
	"offset-distance": {
	syntax: "<length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToTotalPathLength",
	groups: [
		"CSS Motion Path"
	],
	initial: "0",
	appliesto: "transformableElements",
	computed: "forLengthAbsoluteValueOtherwisePercentage",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
},
	"offset-path": {
	syntax: "none | ray( [ <angle> && <size> && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
	media: "visual",
	inherited: false,
	animationType: "angleOrBasicShapeOrPath",
	percentages: "no",
	groups: [
		"CSS Motion Path"
	],
	initial: "none",
	appliesto: "transformableElements",
	computed: "asSpecified",
	order: "perGrammar",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
},
	"offset-position": {
	syntax: "auto | <position>",
	media: "visual",
	inherited: false,
	animationType: "position",
	percentages: "referToSizeOfContainingBlock",
	groups: [
		"CSS Motion Path"
	],
	initial: "auto",
	appliesto: "transformableElements",
	computed: "forLengthAbsoluteValueOtherwisePercentage",
	order: "perGrammar",
	status: "experimental"
},
	"offset-rotate": {
	syntax: "[ auto | reverse ] || <angle>",
	media: "visual",
	inherited: false,
	animationType: "angleOrBasicShapeOrPath",
	percentages: "no",
	groups: [
		"CSS Motion Path"
	],
	initial: "auto",
	appliesto: "transformableElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
},
	opacity: opacity,
	order: order,
	orphans: orphans,
	outline: outline,
	"outline-color": {
	syntax: "<color> | invert",
	media: [
		"visual",
		"interactive"
	],
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "invertOrCurrentColor",
	appliesto: "allElements",
	computed: "invertForTranslucentColorRGBAOtherwiseRGB",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
},
	"outline-offset": {
	syntax: "<length>",
	media: [
		"visual",
		"interactive"
	],
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
},
	"outline-style": {
	syntax: "auto | <'border-style'>",
	media: [
		"visual",
		"interactive"
	],
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
},
	"outline-width": {
	syntax: "<line-width>",
	media: [
		"visual",
		"interactive"
	],
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLength0ForNone",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
},
	overflow: overflow,
	"overflow-anchor": {
	syntax: "auto | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Scroll Anchoring"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard"
},
	"overflow-block": {
	syntax: "visible | hidden | clip | scroll | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "auto",
	appliesto: "blockContainersFlexContainersGridContainers",
	computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
	order: "perGrammar",
	status: "standard"
},
	"overflow-clip-box": {
	syntax: "padding-box | content-box",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "padding-box",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
},
	"overflow-clip-margin": {
	syntax: "<visual-box> || <length [0,∞]>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "0px",
	appliesto: "allElements",
	computed: "theComputedLength",
	order: "perGrammar",
	status: "standard"
},
	"overflow-inline": {
	syntax: "visible | hidden | clip | scroll | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "auto",
	appliesto: "blockContainersFlexContainersGridContainers",
	computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
	order: "perGrammar",
	status: "standard"
},
	"overflow-wrap": {
	syntax: "normal | break-word | anywhere",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "normal",
	appliesto: "nonReplacedInlineElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
},
	"overflow-x": {
	syntax: "visible | hidden | clip | scroll | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "visible",
	appliesto: "blockContainersFlexContainersGridContainers",
	computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
},
	"overflow-y": {
	syntax: "visible | hidden | clip | scroll | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "visible",
	appliesto: "blockContainersFlexContainersGridContainers",
	computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
},
	"overscroll-behavior": {
	syntax: "[ contain | none | auto ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: [
		"overscroll-behavior-x",
		"overscroll-behavior-y"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
},
	"overscroll-behavior-block": {
	syntax: "contain | none | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-block"
},
	"overscroll-behavior-inline": {
	syntax: "contain | none | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-inline"
},
	"overscroll-behavior-x": {
	syntax: "contain | none | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
},
	"overscroll-behavior-y": {
	syntax: "contain | none | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
},
	padding: padding,
	"padding-block": {
	syntax: "<'padding-left'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"padding-block-start",
		"padding-block-end"
	],
	appliesto: "allElementsExceptInternalTableDisplayTypes",
	computed: [
		"padding-block-start",
		"padding-block-end"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
},
	"padding-block-end": {
	syntax: "<'padding-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElementsExceptInternalTableDisplayTypes",
	computed: "asLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
},
	"padding-block-start": {
	syntax: "<'padding-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElementsExceptInternalTableDisplayTypes",
	computed: "asLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
},
	"padding-bottom": {
	syntax: "<length> | <percentage>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptInternalTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
},
	"padding-inline": {
	syntax: "<'padding-left'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"padding-inline-start",
		"padding-inline-end"
	],
	appliesto: "allElementsExceptInternalTableDisplayTypes",
	computed: [
		"padding-inline-start",
		"padding-inline-end"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
},
	"padding-inline-end": {
	syntax: "<'padding-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElementsExceptInternalTableDisplayTypes",
	computed: "asLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
},
	"padding-inline-start": {
	syntax: "<'padding-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElementsExceptInternalTableDisplayTypes",
	computed: "asLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
},
	"padding-left": {
	syntax: "<length> | <percentage>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptInternalTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
},
	"padding-right": {
	syntax: "<length> | <percentage>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptInternalTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
},
	"padding-top": {
	syntax: "<length> | <percentage>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptInternalTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
},
	"page-break-after": {
	syntax: "auto | always | avoid | left | right | recto | verso",
	media: [
		"visual",
		"paged"
	],
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Pages"
	],
	initial: "auto",
	appliesto: "blockElementsInNormalFlow",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
},
	"page-break-before": {
	syntax: "auto | always | avoid | left | right | recto | verso",
	media: [
		"visual",
		"paged"
	],
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Pages"
	],
	initial: "auto",
	appliesto: "blockElementsInNormalFlow",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
},
	"page-break-inside": {
	syntax: "auto | avoid",
	media: [
		"visual",
		"paged"
	],
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Pages"
	],
	initial: "auto",
	appliesto: "blockElementsInNormalFlow",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
},
	"paint-order": {
	syntax: "normal | [ fill || stroke || markers ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "normal",
	appliesto: "textElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
},
	perspective: perspective,
	"perspective-origin": {
	syntax: "<position>",
	media: "visual",
	inherited: false,
	animationType: "simpleListOfLpc",
	percentages: "referToSizeOfBoundingBox",
	groups: [
		"CSS Transforms"
	],
	initial: "50% 50%",
	appliesto: "transformableElements",
	computed: "forLengthAbsoluteValueOtherwisePercentage",
	order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
},
	"place-content": {
	syntax: "<'align-content'> <'justify-content'>?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: [
		"align-content",
		"justify-content"
	],
	appliesto: "multilineFlexContainers",
	computed: [
		"align-content",
		"justify-content"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
},
	"place-items": {
	syntax: "<'align-items'> <'justify-items'>?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: [
		"align-items",
		"justify-items"
	],
	appliesto: "allElements",
	computed: [
		"align-items",
		"justify-items"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
},
	"place-self": {
	syntax: "<'align-self'> <'justify-self'>?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: [
		"align-self",
		"justify-self"
	],
	appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
	computed: [
		"align-self",
		"justify-self"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
},
	"pointer-events": {
	syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
},
	position: position$1,
	quotes: quotes,
	resize: resize,
	right: right,
	rotate: rotate,
	"row-gap": {
	syntax: "normal | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Box Alignment"
	],
	initial: "normal",
	appliesto: "multiColumnElementsFlexContainersGridContainers",
	computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
},
	"ruby-align": {
	syntax: "start | center | space-between | space-around",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Ruby"
	],
	initial: "space-around",
	appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
},
	"ruby-merge": {
	syntax: "separate | collapse | auto",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Ruby"
	],
	initial: "separate",
	appliesto: "rubyAnnotationsContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental"
},
	"ruby-position": {
	syntax: "[ alternate || [ over | under ] ] | inter-character",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Ruby"
	],
	initial: "alternate",
	appliesto: "rubyAnnotationsContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
},
	scale: scale,
	"scrollbar-color": {
	syntax: "auto | <color>{2}",
	media: "visual",
	inherited: true,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Scrollbars"
	],
	initial: "auto",
	appliesto: "scrollingBoxes",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
},
	"scrollbar-gutter": {
	syntax: "auto | stable && both-edges?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "auto",
	appliesto: "scrollingBoxes",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-gutter"
},
	"scrollbar-width": {
	syntax: "auto | thin | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Scrollbars"
	],
	initial: "auto",
	appliesto: "scrollingBoxes",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
},
	"scroll-behavior": {
	syntax: "auto | smooth",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSSOM View"
	],
	initial: "auto",
	appliesto: "scrollingBoxes",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
},
	"scroll-margin": {
	syntax: "<length>{1,4}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: [
		"scroll-margin-bottom",
		"scroll-margin-left",
		"scroll-margin-right",
		"scroll-margin-top"
	],
	appliesto: "allElements",
	computed: [
		"scroll-margin-bottom",
		"scroll-margin-left",
		"scroll-margin-right",
		"scroll-margin-top"
	],
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
},
	"scroll-margin-block": {
	syntax: "<length>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: [
		"scroll-margin-block-start",
		"scroll-margin-block-end"
	],
	appliesto: "allElements",
	computed: [
		"scroll-margin-block-start",
		"scroll-margin-block-end"
	],
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
},
	"scroll-margin-block-start": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
},
	"scroll-margin-block-end": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
},
	"scroll-margin-bottom": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
},
	"scroll-margin-inline": {
	syntax: "<length>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: [
		"scroll-margin-inline-start",
		"scroll-margin-inline-end"
	],
	appliesto: "allElements",
	computed: [
		"scroll-margin-inline-start",
		"scroll-margin-inline-end"
	],
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
},
	"scroll-margin-inline-start": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
},
	"scroll-margin-inline-end": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
},
	"scroll-margin-left": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
},
	"scroll-margin-right": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
},
	"scroll-margin-top": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
},
	"scroll-padding": {
	syntax: "[ auto | <length-percentage> ]{1,4}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: [
		"scroll-padding-bottom",
		"scroll-padding-left",
		"scroll-padding-right",
		"scroll-padding-top"
	],
	appliesto: "scrollContainers",
	computed: [
		"scroll-padding-bottom",
		"scroll-padding-left",
		"scroll-padding-right",
		"scroll-padding-top"
	],
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
},
	"scroll-padding-block": {
	syntax: "[ auto | <length-percentage> ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: [
		"scroll-padding-block-start",
		"scroll-padding-block-end"
	],
	appliesto: "scrollContainers",
	computed: [
		"scroll-padding-block-start",
		"scroll-padding-block-end"
	],
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
},
	"scroll-padding-block-start": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
},
	"scroll-padding-block-end": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
},
	"scroll-padding-bottom": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
},
	"scroll-padding-inline": {
	syntax: "[ auto | <length-percentage> ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: [
		"scroll-padding-inline-start",
		"scroll-padding-inline-end"
	],
	appliesto: "scrollContainers",
	computed: [
		"scroll-padding-inline-start",
		"scroll-padding-inline-end"
	],
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
},
	"scroll-padding-inline-start": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
},
	"scroll-padding-inline-end": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
},
	"scroll-padding-left": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
},
	"scroll-padding-right": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
},
	"scroll-padding-top": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
},
	"scroll-snap-align": {
	syntax: "[ none | start | end | center ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
},
	"scroll-snap-coordinate": {
	syntax: "none | <position>#",
	media: "interactive",
	inherited: false,
	animationType: "position",
	percentages: "referToBorderBox",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
},
	"scroll-snap-destination": {
	syntax: "<position>",
	media: "interactive",
	inherited: false,
	animationType: "position",
	percentages: "relativeToScrollContainerPaddingBoxAxis",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0px 0px",
	appliesto: "scrollContainers",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
},
	"scroll-snap-points-x": {
	syntax: "none | repeat( <length-percentage> )",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "relativeToScrollContainerPaddingBoxAxis",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "none",
	appliesto: "scrollContainers",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
},
	"scroll-snap-points-y": {
	syntax: "none | repeat( <length-percentage> )",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "relativeToScrollContainerPaddingBoxAxis",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "none",
	appliesto: "scrollContainers",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
},
	"scroll-snap-stop": {
	syntax: "normal | always",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
},
	"scroll-snap-type": {
	syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
},
	"scroll-snap-type-x": {
	syntax: "none | mandatory | proximity",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "none",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
},
	"scroll-snap-type-y": {
	syntax: "none | mandatory | proximity",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "none",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
},
	"scroll-timeline": {
	syntax: "<scroll-timeline-name> || <scroll-timeline-axis>",
	media: "visual",
	inherited: false,
	animationType: [
		"scroll-timeline-name",
		"scroll-timeline-axis"
	],
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: [
		"scroll-timeline-name",
		"scroll-timeline-axis"
	],
	appliesto: "scrollContainers",
	computed: [
		"scroll-timeline-name",
		"scroll-timeline-axis"
	],
	order: "perGrammar",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-timeline"
},
	"scroll-timeline-axis": {
	syntax: "block | inline | vertical | horizontal",
	media: "interactive",
	inherited: false,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "block",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-timeline-axis"
},
	"scroll-timeline-name": {
	syntax: "none | <custom-ident>",
	media: "interactive",
	inherited: false,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "none",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-timeline-name"
},
	"shape-image-threshold": {
	syntax: "<alpha-value>",
	media: "visual",
	inherited: false,
	animationType: "number",
	percentages: "no",
	groups: [
		"CSS Shapes"
	],
	initial: "0.0",
	appliesto: "floats",
	computed: "specifiedValueNumberClipped0To1",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
},
	"shape-margin": {
	syntax: "<length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Shapes"
	],
	initial: "0",
	appliesto: "floats",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
},
	"shape-outside": {
	syntax: "none | [ <shape-box> || <basic-shape> ] | <image>",
	media: "visual",
	inherited: false,
	animationType: "basicShapeOtherwiseNo",
	percentages: "no",
	groups: [
		"CSS Shapes"
	],
	initial: "none",
	appliesto: "floats",
	computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
},
	"tab-size": {
	syntax: "<integer> | <length>",
	media: "visual",
	inherited: true,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "8",
	appliesto: "blockContainers",
	computed: "specifiedIntegerOrAbsoluteLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
},
	"table-layout": {
	syntax: "auto | fixed",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Table"
	],
	initial: "auto",
	appliesto: "tableElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
},
	"text-align": {
	syntax: "start | end | left | right | center | justify | match-parent",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "startOrNamelessValueIfLTRRightIfRTL",
	appliesto: "blockContainers",
	computed: "asSpecifiedExceptMatchParent",
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
},
	"text-align-last": {
	syntax: "auto | start | end | left | right | center | justify",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "auto",
	appliesto: "blockContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
},
	"text-combine-upright": {
	syntax: "none | all | [ digits <integer>? ]",
	media: "visual",
	inherited: true,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"CSS Writing Modes"
	],
	initial: "none",
	appliesto: "nonReplacedInlineElements",
	computed: "keywordPlusIntegerIfDigits",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
},
	"text-decoration": {
	syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
	media: "visual",
	inherited: false,
	animationType: [
		"text-decoration-color",
		"text-decoration-style",
		"text-decoration-line",
		"text-decoration-thickness"
	],
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: [
		"text-decoration-color",
		"text-decoration-style",
		"text-decoration-line"
	],
	appliesto: "allElements",
	computed: [
		"text-decoration-line",
		"text-decoration-style",
		"text-decoration-color",
		"text-decoration-thickness"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
},
	"text-decoration-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
},
	"text-decoration-line": {
	syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
},
	"text-decoration-skip": {
	syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "objects",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
},
	"text-decoration-skip-ink": {
	syntax: "auto | all | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
},
	"text-decoration-style": {
	syntax: "solid | double | dotted | dashed | wavy",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "solid",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
},
	"text-decoration-thickness": {
	syntax: "auto | from-font | <length> | <percentage> ",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "referToElementFontSize",
	groups: [
		"CSS Text Decoration"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
},
	"text-emphasis": {
	syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
	media: "visual",
	inherited: false,
	animationType: [
		"text-emphasis-color",
		"text-emphasis-style"
	],
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: [
		"text-emphasis-style",
		"text-emphasis-color"
	],
	appliesto: "allElements",
	computed: [
		"text-emphasis-style",
		"text-emphasis-color"
	],
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
},
	"text-emphasis-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
},
	"text-emphasis-position": {
	syntax: "[ over | under ] && [ right | left ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "over right",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
},
	"text-emphasis-style": {
	syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
},
	"text-indent": {
	syntax: "<length-percentage> && hanging? && each-line?",
	media: "visual",
	inherited: true,
	animationType: "lpc",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Text"
	],
	initial: "0",
	appliesto: "blockContainers",
	computed: "percentageOrAbsoluteLengthPlusKeywords",
	order: "lengthOrPercentageBeforeKeywords",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
},
	"text-justify": {
	syntax: "auto | inter-character | inter-word | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "auto",
	appliesto: "inlineLevelAndTableCellElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
},
	"text-orientation": {
	syntax: "mixed | upright | sideways",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Writing Modes"
	],
	initial: "mixed",
	appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
},
	"text-overflow": {
	syntax: "[ clip | ellipsis | <string> ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "clip",
	appliesto: "blockContainerElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
},
	"text-rendering": {
	syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Miscellaneous"
	],
	initial: "auto",
	appliesto: "textElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
},
	"text-shadow": {
	syntax: "none | <shadow-t>#",
	media: "visual",
	inherited: true,
	animationType: "shadowList",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "colorPlusThreeAbsoluteLengths",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
},
	"text-size-adjust": {
	syntax: "none | auto | <percentage>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "referToSizeOfFont",
	groups: [
		"CSS Text"
	],
	initial: "autoForSmartphoneBrowsersSupportingInflation",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
},
	"text-transform": {
	syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
},
	"text-underline-offset": {
	syntax: "auto | <length> | <percentage> ",
	media: "visual",
	inherited: true,
	animationType: "byComputedValueType",
	percentages: "referToElementFontSize",
	groups: [
		"CSS Text Decoration"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
},
	"text-underline-position": {
	syntax: "auto | from-font | [ under || [ left | right ] ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
},
	top: top,
	"touch-action": {
	syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Pointer Events"
	],
	initial: "auto",
	appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
},
	transform: transform,
	"transform-box": {
	syntax: "content-box | border-box | fill-box | stroke-box | view-box",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transforms"
	],
	initial: "view-box",
	appliesto: "transformableElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
},
	"transform-origin": {
	syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
	media: "visual",
	inherited: false,
	animationType: "simpleListOfLpc",
	percentages: "referToSizeOfBoundingBox",
	groups: [
		"CSS Transforms"
	],
	initial: "50% 50% 0",
	appliesto: "transformableElements",
	computed: "forLengthAbsoluteValueOtherwisePercentage",
	order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
},
	"transform-style": {
	syntax: "flat | preserve-3d",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transforms"
	],
	initial: "flat",
	appliesto: "transformableElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
},
	transition: transition,
	"transition-delay": {
	syntax: "<time>#",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transitions"
	],
	initial: "0s",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
},
	"transition-duration": {
	syntax: "<time>#",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transitions"
	],
	initial: "0s",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
},
	"transition-property": {
	syntax: "none | <single-transition-property>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transitions"
	],
	initial: "all",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
},
	"transition-timing-function": {
	syntax: "<easing-function>#",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transitions"
	],
	initial: "ease",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
},
	translate: translate,
	"unicode-bidi": {
	syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Writing Modes"
	],
	initial: "normal",
	appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
},
	"user-select": {
	syntax: "auto | text | none | contain | all",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
},
	"vertical-align": {
	syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToLineHeight",
	groups: [
		"CSS Table"
	],
	initial: "baseline",
	appliesto: "inlineLevelAndTableCellElements",
	computed: "absoluteLengthOrKeyword",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
},
	visibility: visibility,
	"white-space": {
	syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
},
	widows: widows,
	width: width,
	"will-change": {
	syntax: "auto | <animateable-feature>#",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Will Change"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
},
	"word-break": {
	syntax: "normal | break-all | keep-all | break-word",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
},
	"word-spacing": {
	syntax: "normal | <length>",
	media: "visual",
	inherited: true,
	animationType: "length",
	percentages: "referToWidthOfAffectedGlyph",
	groups: [
		"CSS Text"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "absoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
},
	"word-wrap": {
	syntax: "normal | break-word",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "normal",
	appliesto: "nonReplacedInlineElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
},
	"writing-mode": {
	syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Writing Modes"
	],
	initial: "horizontal-tb",
	appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
},
	"z-index": {
	syntax: "auto | <integer>",
	media: "visual",
	inherited: false,
	animationType: "integer",
	percentages: "no",
	groups: [
		"CSS Positioning"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
},
	zoom: zoom
};

const properties$1 = {
	__proto__: null,
	all: all,
	animation: animation,
	appearance: appearance,
	azimuth: azimuth,
	background: background,
	border: border,
	bottom: bottom,
	caret: caret,
	clear: clear,
	clip: clip,
	color: color$1,
	columns: columns,
	contain: contain,
	content: content,
	cursor: cursor,
	default: properties,
	direction: direction,
	display: display,
	filter: filter,
	flex: flex,
	float: float,
	font: font,
	gap: gap,
	grid: grid,
	height: height,
	hyphens: hyphens,
	inset: inset,
	isolation: isolation,
	left: left,
	margin: margin,
	mask: mask,
	offset: offset,
	opacity: opacity,
	order: order,
	orphans: orphans,
	outline: outline,
	overflow: overflow,
	padding: padding,
	perspective: perspective,
	position: position$1,
	quotes: quotes,
	resize: resize,
	right: right,
	rotate: rotate,
	scale: scale,
	top: top,
	transform: transform,
	transition: transition,
	translate: translate,
	visibility: visibility,
	widows: widows,
	width: width,
	zoom: zoom
};

const require$$2 = /*@__PURE__*/getAugmentedNamespace(properties$1);

const attachment = {
	syntax: "scroll | fixed | local"
};
const axis = {
	syntax: "block | inline | vertical | horizontal"
};
const box = {
	syntax: "border-box | padding-box | content-box"
};
const color = {
	syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hwb()> | <lab()> | <lch()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
};
const combinator = {
	syntax: "'>' | '+' | '~' | [ '||' ]"
};
const counter = {
	syntax: "<counter()> | <counters()>"
};
const gradient = {
	syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <repeating-conic-gradient()>"
};
const hue = {
	syntax: "<number> | <angle>"
};
const image = {
	syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
};
const nth$1 = {
	syntax: "<an-plus-b> | even | odd"
};
const position = {
	syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
};
const quote = {
	syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
};
const ratio = {
	syntax: "<number [0,∞]> [ / <number [0,∞]> ]?"
};
const scroller = {
	syntax: "root | nearest"
};
const shadow = {
	syntax: "inset? && <length>{2,4} && <color>?"
};
const shape = {
	syntax: "rect(<top>, <right>, <bottom>, <left>)"
};
const size = {
	syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
};
const symbol = {
	syntax: "<string> | <image> | <custom-ident>"
};
const target = {
	syntax: "<target-counter()> | <target-counters()> | <target-text()>"
};
const syntaxes = {
	"abs()": {
	syntax: "abs( <calc-sum> )"
},
	"absolute-size": {
	syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
},
	"acos()": {
	syntax: "acos( <calc-sum> )"
},
	"alpha-value": {
	syntax: "<number> | <percentage>"
},
	"angle-percentage": {
	syntax: "<angle> | <percentage>"
},
	"angular-color-hint": {
	syntax: "<angle-percentage>"
},
	"angular-color-stop": {
	syntax: "<color> && <color-stop-angle>?"
},
	"angular-color-stop-list": {
	syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
},
	"animateable-feature": {
	syntax: "scroll-position | contents | <custom-ident>"
},
	"asin()": {
	syntax: "asin( <calc-sum> )"
},
	"atan()": {
	syntax: "atan( <calc-sum> )"
},
	"atan2()": {
	syntax: "atan2( <calc-sum>, <calc-sum> )"
},
	attachment: attachment,
	"attr()": {
	syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
},
	"attr-matcher": {
	syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
},
	"attr-modifier": {
	syntax: "i | s"
},
	"attribute-selector": {
	syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
},
	"auto-repeat": {
	syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
},
	"auto-track-list": {
	syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
},
	axis: axis,
	"baseline-position": {
	syntax: "[ first | last ]? baseline"
},
	"basic-shape": {
	syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()> | <path()>"
},
	"bg-image": {
	syntax: "none | <image>"
},
	"bg-layer": {
	syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
},
	"bg-position": {
	syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
},
	"bg-size": {
	syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
},
	"blur()": {
	syntax: "blur( <length> )"
},
	"blend-mode": {
	syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
},
	box: box,
	"brightness()": {
	syntax: "brightness( <number-percentage> )"
},
	"calc()": {
	syntax: "calc( <calc-sum> )"
},
	"calc-sum": {
	syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
},
	"calc-product": {
	syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
},
	"calc-value": {
	syntax: "<number> | <dimension> | <percentage> | <calc-constant> | ( <calc-sum> )"
},
	"calc-constant": {
	syntax: "e | pi | infinity | -infinity | NaN"
},
	"cf-final-image": {
	syntax: "<image> | <color>"
},
	"cf-mixing-image": {
	syntax: "<percentage>? && <image>"
},
	"circle()": {
	syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
},
	"clamp()": {
	syntax: "clamp( <calc-sum>#{3} )"
},
	"class-selector": {
	syntax: "'.' <ident-token>"
},
	"clip-source": {
	syntax: "<url>"
},
	color: color,
	"color-stop": {
	syntax: "<color-stop-length> | <color-stop-angle>"
},
	"color-stop-angle": {
	syntax: "<angle-percentage>{1,2}"
},
	"color-stop-length": {
	syntax: "<length-percentage>{1,2}"
},
	"color-stop-list": {
	syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
},
	combinator: combinator,
	"common-lig-values": {
	syntax: "[ common-ligatures | no-common-ligatures ]"
},
	"compat-auto": {
	syntax: "searchfield | textarea | push-button | slider-horizontal | checkbox | radio | square-button | menulist | listbox | meter | progress-bar | button"
},
	"composite-style": {
	syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
},
	"compositing-operator": {
	syntax: "add | subtract | intersect | exclude"
},
	"compound-selector": {
	syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
},
	"compound-selector-list": {
	syntax: "<compound-selector>#"
},
	"complex-selector": {
	syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
},
	"complex-selector-list": {
	syntax: "<complex-selector>#"
},
	"conic-gradient()": {
	syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
},
	"contextual-alt-values": {
	syntax: "[ contextual | no-contextual ]"
},
	"content-distribution": {
	syntax: "space-between | space-around | space-evenly | stretch"
},
	"content-list": {
	syntax: "[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> ]+"
},
	"content-position": {
	syntax: "center | start | end | flex-start | flex-end"
},
	"content-replacement": {
	syntax: "<image>"
},
	"contrast()": {
	syntax: "contrast( [ <number-percentage> ] )"
},
	"cos()": {
	syntax: "cos( <calc-sum> )"
},
	counter: counter,
	"counter()": {
	syntax: "counter( <counter-name>, <counter-style>? )"
},
	"counter-name": {
	syntax: "<custom-ident>"
},
	"counter-style": {
	syntax: "<counter-style-name> | symbols()"
},
	"counter-style-name": {
	syntax: "<custom-ident>"
},
	"counters()": {
	syntax: "counters( <counter-name>, <string>, <counter-style>? )"
},
	"cross-fade()": {
	syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
},
	"cubic-bezier-timing-function": {
	syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)"
},
	"deprecated-system-color": {
	syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
},
	"discretionary-lig-values": {
	syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
},
	"display-box": {
	syntax: "contents | none"
},
	"display-inside": {
	syntax: "flow | flow-root | table | flex | grid | ruby"
},
	"display-internal": {
	syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
},
	"display-legacy": {
	syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
},
	"display-listitem": {
	syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
},
	"display-outside": {
	syntax: "block | inline | run-in"
},
	"drop-shadow()": {
	syntax: "drop-shadow( <length>{2,3} <color>? )"
},
	"east-asian-variant-values": {
	syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
},
	"east-asian-width-values": {
	syntax: "[ full-width | proportional-width ]"
},
	"element()": {
	syntax: "element( <id-selector> )"
},
	"ellipse()": {
	syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
},
	"ending-shape": {
	syntax: "circle | ellipse"
},
	"env()": {
	syntax: "env( <custom-ident> , <declaration-value>? )"
},
	"exp()": {
	syntax: "exp( <calc-sum> )"
},
	"explicit-track-list": {
	syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
},
	"family-name": {
	syntax: "<string> | <custom-ident>+"
},
	"feature-tag-value": {
	syntax: "<string> [ <integer> | on | off ]?"
},
	"feature-type": {
	syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
},
	"feature-value-block": {
	syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
},
	"feature-value-block-list": {
	syntax: "<feature-value-block>+"
},
	"feature-value-declaration": {
	syntax: "<custom-ident>: <integer>+;"
},
	"feature-value-declaration-list": {
	syntax: "<feature-value-declaration>"
},
	"feature-value-name": {
	syntax: "<custom-ident>"
},
	"fill-rule": {
	syntax: "nonzero | evenodd"
},
	"filter-function": {
	syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
},
	"filter-function-list": {
	syntax: "[ <filter-function> | <url> ]+"
},
	"final-bg-layer": {
	syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
},
	"fixed-breadth": {
	syntax: "<length-percentage>"
},
	"fixed-repeat": {
	syntax: "repeat( [ <integer [1,∞]> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
},
	"fixed-size": {
	syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
},
	"font-stretch-absolute": {
	syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
},
	"font-variant-css21": {
	syntax: "[ normal | small-caps ]"
},
	"font-weight-absolute": {
	syntax: "normal | bold | <number [1,1000]>"
},
	"frequency-percentage": {
	syntax: "<frequency> | <percentage>"
},
	"general-enclosed": {
	syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
},
	"generic-family": {
	syntax: "serif | sans-serif | cursive | fantasy | monospace"
},
	"generic-name": {
	syntax: "serif | sans-serif | cursive | fantasy | monospace"
},
	"geometry-box": {
	syntax: "<shape-box> | fill-box | stroke-box | view-box"
},
	gradient: gradient,
	"grayscale()": {
	syntax: "grayscale( <number-percentage> )"
},
	"grid-line": {
	syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
},
	"historical-lig-values": {
	syntax: "[ historical-ligatures | no-historical-ligatures ]"
},
	"hsl()": {
	syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
},
	"hsla()": {
	syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
},
	hue: hue,
	"hue-rotate()": {
	syntax: "hue-rotate( <angle> )"
},
	"hwb()": {
	syntax: "hwb( [<hue> | none] [<percentage> | none] [<percentage> | none] [ / [<alpha-value> | none] ]? )"
},
	"hypot()": {
	syntax: "hypot( <calc-sum># )"
},
	"id-selector": {
	syntax: "<hash-token>"
},
	image: image,
	"image()": {
	syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
},
	"image-set()": {
	syntax: "image-set( <image-set-option># )"
},
	"image-set-option": {
	syntax: "[ <image> | <string> ] [ <resolution> || type(<string>) ]"
},
	"image-src": {
	syntax: "<url> | <string>"
},
	"image-tags": {
	syntax: "ltr | rtl"
},
	"inflexible-breadth": {
	syntax: "<length-percentage> | min-content | max-content | auto"
},
	"inset()": {
	syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
},
	"invert()": {
	syntax: "invert( <number-percentage> )"
},
	"keyframes-name": {
	syntax: "<custom-ident> | <string>"
},
	"keyframe-block": {
	syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
},
	"keyframe-block-list": {
	syntax: "<keyframe-block>+"
},
	"keyframe-selector": {
	syntax: "from | to | <percentage>"
},
	"lab()": {
	syntax: "lab( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <percentage> | <number> | none] [ / [<alpha-value> | none] ]? )"
},
	"layer()": {
	syntax: "layer( <layer-name> )"
},
	"layer-name": {
	syntax: "<ident> [ '.' <ident> ]*"
},
	"lch()": {
	syntax: "lch( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <hue> | none] [ / [<alpha-value> | none] ]? )"
},
	"leader()": {
	syntax: "leader( <leader-type> )"
},
	"leader-type": {
	syntax: "dotted | solid | space | <string>"
},
	"length-percentage": {
	syntax: "<length> | <percentage>"
},
	"line-names": {
	syntax: "'[' <custom-ident>* ']'"
},
	"line-name-list": {
	syntax: "[ <line-names> | <name-repeat> ]+"
},
	"line-style": {
	syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
},
	"line-width": {
	syntax: "<length> | thin | medium | thick"
},
	"linear-color-hint": {
	syntax: "<length-percentage>"
},
	"linear-color-stop": {
	syntax: "<color> <color-stop-length>?"
},
	"linear-gradient()": {
	syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
},
	"log()": {
	syntax: "log( <calc-sum>, <calc-sum>? )"
},
	"mask-layer": {
	syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
},
	"mask-position": {
	syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
},
	"mask-reference": {
	syntax: "none | <image> | <mask-source>"
},
	"mask-source": {
	syntax: "<url>"
},
	"masking-mode": {
	syntax: "alpha | luminance | match-source"
},
	"matrix()": {
	syntax: "matrix( <number>#{6} )"
},
	"matrix3d()": {
	syntax: "matrix3d( <number>#{16} )"
},
	"max()": {
	syntax: "max( <calc-sum># )"
},
	"media-and": {
	syntax: "<media-in-parens> [ and <media-in-parens> ]+"
},
	"media-condition": {
	syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
},
	"media-condition-without-or": {
	syntax: "<media-not> | <media-and> | <media-in-parens>"
},
	"media-feature": {
	syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
},
	"media-in-parens": {
	syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
},
	"media-not": {
	syntax: "not <media-in-parens>"
},
	"media-or": {
	syntax: "<media-in-parens> [ or <media-in-parens> ]+"
},
	"media-query": {
	syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
},
	"media-query-list": {
	syntax: "<media-query>#"
},
	"media-type": {
	syntax: "<ident>"
},
	"mf-boolean": {
	syntax: "<mf-name>"
},
	"mf-name": {
	syntax: "<ident>"
},
	"mf-plain": {
	syntax: "<mf-name> : <mf-value>"
},
	"mf-range": {
	syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
},
	"mf-value": {
	syntax: "<number> | <dimension> | <ident> | <ratio>"
},
	"min()": {
	syntax: "min( <calc-sum># )"
},
	"minmax()": {
	syntax: "minmax( [ <length-percentage> | min-content | max-content | auto ] , [ <length-percentage> | <flex> | min-content | max-content | auto ] )"
},
	"mod()": {
	syntax: "mod( <calc-sum>, <calc-sum> )"
},
	"name-repeat": {
	syntax: "repeat( [ <integer [1,∞]> | auto-fill ], <line-names>+ )"
},
	"named-color": {
	syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
},
	"namespace-prefix": {
	syntax: "<ident>"
},
	"ns-prefix": {
	syntax: "[ <ident-token> | '*' ]? '|'"
},
	"number-percentage": {
	syntax: "<number> | <percentage>"
},
	"numeric-figure-values": {
	syntax: "[ lining-nums | oldstyle-nums ]"
},
	"numeric-fraction-values": {
	syntax: "[ diagonal-fractions | stacked-fractions ]"
},
	"numeric-spacing-values": {
	syntax: "[ proportional-nums | tabular-nums ]"
},
	nth: nth$1,
	"opacity()": {
	syntax: "opacity( [ <number-percentage> ] )"
},
	"overflow-position": {
	syntax: "unsafe | safe"
},
	"outline-radius": {
	syntax: "<length> | <percentage>"
},
	"page-body": {
	syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
},
	"page-margin-box": {
	syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
},
	"page-margin-box-type": {
	syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
},
	"page-selector-list": {
	syntax: "[ <page-selector># ]?"
},
	"page-selector": {
	syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
},
	"page-size": {
	syntax: "A5 | A4 | A3 | B5 | B4 | JIS-B5 | JIS-B4 | letter | legal | ledger"
},
	"path()": {
	syntax: "path( [ <fill-rule>, ]? <string> )"
},
	"paint()": {
	syntax: "paint( <ident>, <declaration-value>? )"
},
	"perspective()": {
	syntax: "perspective( [ <length [0,∞]> | none ] )"
},
	"polygon()": {
	syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
},
	position: position,
	"pow()": {
	syntax: "pow( <calc-sum>, <calc-sum> )"
},
	"pseudo-class-selector": {
	syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
},
	"pseudo-element-selector": {
	syntax: "':' <pseudo-class-selector>"
},
	"pseudo-page": {
	syntax: ": [ left | right | first | blank ]"
},
	quote: quote,
	"radial-gradient()": {
	syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
},
	ratio: ratio,
	"relative-selector": {
	syntax: "<combinator>? <complex-selector>"
},
	"relative-selector-list": {
	syntax: "<relative-selector>#"
},
	"relative-size": {
	syntax: "larger | smaller"
},
	"rem()": {
	syntax: "rem( <calc-sum>, <calc-sum> )"
},
	"repeat-style": {
	syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
},
	"repeating-conic-gradient()": {
	syntax: "repeating-conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
},
	"repeating-linear-gradient()": {
	syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
},
	"repeating-radial-gradient()": {
	syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
},
	"reversed-counter-name": {
	syntax: "reversed( <counter-name> )"
},
	"rgb()": {
	syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
},
	"rgba()": {
	syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
},
	"rotate()": {
	syntax: "rotate( [ <angle> | <zero> ] )"
},
	"rotate3d()": {
	syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
},
	"rotateX()": {
	syntax: "rotateX( [ <angle> | <zero> ] )"
},
	"rotateY()": {
	syntax: "rotateY( [ <angle> | <zero> ] )"
},
	"rotateZ()": {
	syntax: "rotateZ( [ <angle> | <zero> ] )"
},
	"round()": {
	syntax: "round( <rounding-strategy>?, <calc-sum>, <calc-sum> )"
},
	"rounding-strategy": {
	syntax: "nearest | up | down | to-zero"
},
	"saturate()": {
	syntax: "saturate( <number-percentage> )"
},
	"scale()": {
	syntax: "scale( [ <number> | <percentage> ]#{1,2} )"
},
	"scale3d()": {
	syntax: "scale3d( [ <number> | <percentage> ]#{3} )"
},
	"scaleX()": {
	syntax: "scaleX( [ <number> | <percentage> ] )"
},
	"scaleY()": {
	syntax: "scaleY( [ <number> | <percentage> ] )"
},
	"scaleZ()": {
	syntax: "scaleZ( [ <number> | <percentage> ] )"
},
	scroller: scroller,
	"self-position": {
	syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
},
	"shape-radius": {
	syntax: "<length-percentage> | closest-side | farthest-side"
},
	"sign()": {
	syntax: "sign( <calc-sum> )"
},
	"skew()": {
	syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
},
	"skewX()": {
	syntax: "skewX( [ <angle> | <zero> ] )"
},
	"skewY()": {
	syntax: "skewY( [ <angle> | <zero> ] )"
},
	"sepia()": {
	syntax: "sepia( <number-percentage> )"
},
	shadow: shadow,
	"shadow-t": {
	syntax: "[ <length>{2,3} && <color>? ]"
},
	shape: shape,
	"shape-box": {
	syntax: "<box> | margin-box"
},
	"side-or-corner": {
	syntax: "[ left | right ] || [ top | bottom ]"
},
	"sin()": {
	syntax: "sin( <calc-sum> )"
},
	"single-animation": {
	syntax: "<time> || <easing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
},
	"single-animation-direction": {
	syntax: "normal | reverse | alternate | alternate-reverse"
},
	"single-animation-fill-mode": {
	syntax: "none | forwards | backwards | both"
},
	"single-animation-iteration-count": {
	syntax: "infinite | <number>"
},
	"single-animation-play-state": {
	syntax: "running | paused"
},
	"single-animation-timeline": {
	syntax: "auto | none | <timeline-name> | scroll(<axis>? <scroller>?)"
},
	"single-transition": {
	syntax: "[ none | <single-transition-property> ] || <time> || <easing-function> || <time>"
},
	"single-transition-property": {
	syntax: "all | <custom-ident>"
},
	size: size,
	"sqrt()": {
	syntax: "sqrt( <calc-sum> )"
},
	"step-position": {
	syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
},
	"step-timing-function": {
	syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
},
	"subclass-selector": {
	syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
},
	"supports-condition": {
	syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
},
	"supports-in-parens": {
	syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
},
	"supports-feature": {
	syntax: "<supports-decl> | <supports-selector-fn>"
},
	"supports-decl": {
	syntax: "( <declaration> )"
},
	"supports-selector-fn": {
	syntax: "selector( <complex-selector> )"
},
	symbol: symbol,
	"tan()": {
	syntax: "tan( <calc-sum> )"
},
	target: target,
	"target-counter()": {
	syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
},
	"target-counters()": {
	syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
},
	"target-text()": {
	syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
},
	"time-percentage": {
	syntax: "<time> | <percentage>"
},
	"timeline-name": {
	syntax: "<custom-ident> | <string>"
},
	"easing-function": {
	syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
},
	"track-breadth": {
	syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
},
	"track-list": {
	syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
},
	"track-repeat": {
	syntax: "repeat( [ <integer [1,∞]> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
},
	"track-size": {
	syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( <length-percentage> )"
},
	"transform-function": {
	syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
},
	"transform-list": {
	syntax: "<transform-function>+"
},
	"translate()": {
	syntax: "translate( <length-percentage> , <length-percentage>? )"
},
	"translate3d()": {
	syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
},
	"translateX()": {
	syntax: "translateX( <length-percentage> )"
},
	"translateY()": {
	syntax: "translateY( <length-percentage> )"
},
	"translateZ()": {
	syntax: "translateZ( <length> )"
},
	"type-or-unit": {
	syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
},
	"type-selector": {
	syntax: "<wq-name> | <ns-prefix>? '*'"
},
	"var()": {
	syntax: "var( <custom-property-name> , <declaration-value>? )"
},
	"viewport-length": {
	syntax: "auto | <length-percentage>"
},
	"visual-box": {
	syntax: "content-box | padding-box | border-box"
},
	"wq-name": {
	syntax: "<ns-prefix>? <ident-token>"
}
};

const syntaxes$1 = {
	__proto__: null,
	attachment: attachment,
	axis: axis,
	box: box,
	color: color,
	combinator: combinator,
	counter: counter,
	default: syntaxes,
	gradient: gradient,
	hue: hue,
	image: image,
	nth: nth$1,
	position: position,
	quote: quote,
	ratio: ratio,
	scroller: scroller,
	shadow: shadow,
	shape: shape,
	size: size,
	symbol: symbol,
	target: target
};

const require$$3 = /*@__PURE__*/getAugmentedNamespace(syntaxes$1);

const dataPatch = dataPatch$1;

const mdnAtrules = atRules;
const mdnProperties = require$$2;
const mdnSyntaxes = require$$3;

const extendSyntax = /^\s*\|\s*/;

function preprocessAtrules(dict) {
    const result = Object.create(null);

    for (const atruleName in dict) {
        const atrule = dict[atruleName];
        let descriptors = null;

        if (atrule.descriptors) {
            descriptors = Object.create(null);

            for (const descriptor in atrule.descriptors) {
                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
            }
        }

        result[atruleName.substr(1)] = {
            prelude: atrule.syntax.trim().replace(/\{(.|\s)+\}/, '').match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
            descriptors
        };
    }

    return result;
}

function patchDictionary(dict, patchDict) {
    const result = {};

    // copy all syntaxes for an original dict
    for (const key in dict) {
        result[key] = dict[key].syntax || dict[key];
    }

    // apply a patch
    for (const key in patchDict) {
        if (key in dict) {
            if (patchDict[key].syntax) {
                result[key] = extendSyntax.test(patchDict[key].syntax)
                    ? result[key] + ' ' + patchDict[key].syntax.trim()
                    : patchDict[key].syntax;
            } else {
                delete result[key];
            }
        } else {
            if (patchDict[key].syntax) {
                result[key] = patchDict[key].syntax.replace(extendSyntax, '');
            }
        }
    }

    return result;
}

function patchAtrules(dict, patchDict) {
    const result = {};

    // copy all syntaxes for an original dict
    for (const key in dict) {
        const atrulePatch = patchDict[key] || {};

        result[key] = {
            prelude: key in patchDict && 'prelude' in atrulePatch
                ? atrulePatch.prelude
                : dict[key].prelude || null,
            descriptors: patchDictionary(dict[key].descriptors || {}, atrulePatch.descriptors || {})
        };
    }

    // apply a patch
    for (const key in patchDict) {
        if (!hasOwnProperty.call(dict, key)) {
            const atrulePatch = patchDict[key] || {};

            result[key] = {
                prelude: atrulePatch.prelude || null,
                descriptors: atrulePatch.descriptors && patchDictionary({}, atrulePatch.descriptors)
            };
        }
    }

    return result;
}

const definitions = {
    types: patchDictionary(mdnSyntaxes, dataPatch.types),
    atrules: patchAtrules(preprocessAtrules(mdnAtrules), dataPatch.atrules),
    properties: patchDictionary(mdnProperties, dataPatch.properties)
};

var data$1 = definitions;

var node = {};

var AnPlusB$2 = {};

const types$H = types$T;
const charCodeDefinitions$5 = charCodeDefinitions$c;

const PLUSSIGN$5 = 0x002B;    // U+002B PLUS SIGN (+)
const HYPHENMINUS$2 = 0x002D; // U+002D HYPHEN-MINUS (-)
const N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
const DISALLOW_SIGN = true;
const ALLOW_SIGN = false;

function checkInteger(offset, disallowSign) {
    let pos = this.tokenStart + offset;
    const code = this.charCodeAt(pos);

    if (code === PLUSSIGN$5 || code === HYPHENMINUS$2) {
        if (disallowSign) {
            this.error('Number sign is not allowed');
        }
        pos++;
    }

    for (; pos < this.tokenEnd; pos++) {
        if (!charCodeDefinitions$5.isDigit(this.charCodeAt(pos))) {
            this.error('Integer is expected', pos);
        }
    }
}

function checkTokenIsInteger(disallowSign) {
    return checkInteger.call(this, 0, disallowSign);
}

function expectCharCode(offset, code) {
    if (!this.cmpChar(this.tokenStart + offset, code)) {
        let msg = '';

        switch (code) {
            case N:
                msg = 'N is expected';
                break;
            case HYPHENMINUS$2:
                msg = 'HyphenMinus is expected';
                break;
        }

        this.error(msg, this.tokenStart + offset);
    }
}

// ... <signed-integer>
// ... ['+' | '-'] <signless-integer>
function consumeB() {
    let offset = 0;
    let sign = 0;
    let type = this.tokenType;

    while (type === types$H.WhiteSpace || type === types$H.Comment) {
        type = this.lookupType(++offset);
    }

    if (type !== types$H.Number) {
        if (this.isDelim(PLUSSIGN$5, offset) ||
            this.isDelim(HYPHENMINUS$2, offset)) {
            sign = this.isDelim(PLUSSIGN$5, offset) ? PLUSSIGN$5 : HYPHENMINUS$2;

            do {
                type = this.lookupType(++offset);
            } while (type === types$H.WhiteSpace || type === types$H.Comment);

            if (type !== types$H.Number) {
                this.skip(offset);
                checkTokenIsInteger.call(this, DISALLOW_SIGN);
            }
        } else {
            return null;
        }
    }

    if (offset > 0) {
        this.skip(offset);
    }

    if (sign === 0) {
        type = this.charCodeAt(this.tokenStart);
        if (type !== PLUSSIGN$5 && type !== HYPHENMINUS$2) {
            this.error('Number sign is expected');
        }
    }

    checkTokenIsInteger.call(this, sign !== 0);
    return sign === HYPHENMINUS$2 ? '-' + this.consume(types$H.Number) : this.consume(types$H.Number);
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
const name$F = 'AnPlusB';
const structure$E = {
    a: [String, null],
    b: [String, null]
};

function parse$G() {
    /* eslint-disable brace-style*/
    const start = this.tokenStart;
    let a = null;
    let b = null;

    // <integer>
    if (this.tokenType === types$H.Number) {
        checkTokenIsInteger.call(this, ALLOW_SIGN);
        b = this.consume(types$H.Number);
    }

    // -n
    // -n <signed-integer>
    // -n ['+' | '-'] <signless-integer>
    // -n- <signless-integer>
    // <dashndashdigit-ident>
    else if (this.tokenType === types$H.Ident && this.cmpChar(this.tokenStart, HYPHENMINUS$2)) {
        a = '-1';

        expectCharCode.call(this, 1, N);

        switch (this.tokenEnd - this.tokenStart) {
            // -n
            // -n <signed-integer>
            // -n ['+' | '-'] <signless-integer>
            case 2:
                this.next();
                b = consumeB.call(this);
                break;

            // -n- <signless-integer>
            case 3:
                expectCharCode.call(this, 2, HYPHENMINUS$2);

                this.next();
                this.skipSC();

                checkTokenIsInteger.call(this, DISALLOW_SIGN);

                b = '-' + this.consume(types$H.Number);
                break;

            // <dashndashdigit-ident>
            default:
                expectCharCode.call(this, 2, HYPHENMINUS$2);
                checkInteger.call(this, 3, DISALLOW_SIGN);
                this.next();

                b = this.substrToCursor(start + 2);
        }
    }

    // '+'? n
    // '+'? n <signed-integer>
    // '+'? n ['+' | '-'] <signless-integer>
    // '+'? n- <signless-integer>
    // '+'? <ndashdigit-ident>
    else if (this.tokenType === types$H.Ident || (this.isDelim(PLUSSIGN$5) && this.lookupType(1) === types$H.Ident)) {
        let sign = 0;
        a = '1';

        // just ignore a plus
        if (this.isDelim(PLUSSIGN$5)) {
            sign = 1;
            this.next();
        }

        expectCharCode.call(this, 0, N);

        switch (this.tokenEnd - this.tokenStart) {
            // '+'? n
            // '+'? n <signed-integer>
            // '+'? n ['+' | '-'] <signless-integer>
            case 1:
                this.next();
                b = consumeB.call(this);
                break;

            // '+'? n- <signless-integer>
            case 2:
                expectCharCode.call(this, 1, HYPHENMINUS$2);

                this.next();
                this.skipSC();

                checkTokenIsInteger.call(this, DISALLOW_SIGN);

                b = '-' + this.consume(types$H.Number);
                break;

            // '+'? <ndashdigit-ident>
            default:
                expectCharCode.call(this, 1, HYPHENMINUS$2);
                checkInteger.call(this, 2, DISALLOW_SIGN);
                this.next();

                b = this.substrToCursor(start + sign + 1);
        }
    }

    // <ndashdigit-dimension>
    // <ndash-dimension> <signless-integer>
    // <n-dimension>
    // <n-dimension> <signed-integer>
    // <n-dimension> ['+' | '-'] <signless-integer>
    else if (this.tokenType === types$H.Dimension) {
        const code = this.charCodeAt(this.tokenStart);
        const sign = code === PLUSSIGN$5 || code === HYPHENMINUS$2;
        let i = this.tokenStart + sign;

        for (; i < this.tokenEnd; i++) {
            if (!charCodeDefinitions$5.isDigit(this.charCodeAt(i))) {
                break;
            }
        }

        if (i === this.tokenStart + sign) {
            this.error('Integer is expected', this.tokenStart + sign);
        }

        expectCharCode.call(this, i - this.tokenStart, N);
        a = this.substring(start, i);

        // <n-dimension>
        // <n-dimension> <signed-integer>
        // <n-dimension> ['+' | '-'] <signless-integer>
        if (i + 1 === this.tokenEnd) {
            this.next();
            b = consumeB.call(this);
        } else {
            expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS$2);

            // <ndash-dimension> <signless-integer>
            if (i + 2 === this.tokenEnd) {
                this.next();
                this.skipSC();
                checkTokenIsInteger.call(this, DISALLOW_SIGN);
                b = '-' + this.consume(types$H.Number);
            }
            // <ndashdigit-dimension>
            else {
                checkInteger.call(this, i - this.tokenStart + 2, DISALLOW_SIGN);
                this.next();
                b = this.substrToCursor(i + 1);
            }
        }
    } else {
        this.error();
    }

    if (a !== null && a.charCodeAt(0) === PLUSSIGN$5) {
        a = a.substr(1);
    }

    if (b !== null && b.charCodeAt(0) === PLUSSIGN$5) {
        b = b.substr(1);
    }

    return {
        type: 'AnPlusB',
        loc: this.getLocation(start, this.tokenStart),
        a,
        b
    };
}

function generate$G(node) {
    if (node.a) {
        const a =
            node.a === '+1' && 'n' ||
            node.a ===  '1' && 'n' ||
            node.a === '-1' && '-n' ||
            node.a + 'n';

        if (node.b) {
            const b = node.b[0] === '-' || node.b[0] === '+'
                ? node.b
                : '+' + node.b;
            this.tokenize(a + b);
        } else {
            this.tokenize(a);
        }
    } else {
        this.tokenize(node.b);
    }
}

AnPlusB$2.generate = generate$G;
AnPlusB$2.name = name$F;
AnPlusB$2.parse = parse$G;
AnPlusB$2.structure = structure$E;

var Atrule$2 = {};

const types$G = types$T;

function consumeRaw$5(startToken) {
    return this.Raw(startToken, this.consumeUntilLeftCurlyBracketOrSemicolon, true);
}

function isDeclarationBlockAtrule() {
    for (let offset = 1, type; type = this.lookupType(offset); offset++) {
        if (type === types$G.RightCurlyBracket) {
            return true;
        }

        if (type === types$G.LeftCurlyBracket ||
            type === types$G.AtKeyword) {
            return false;
        }
    }

    return false;
}


const name$E = 'Atrule';
const walkContext$9 = 'atrule';
const structure$D = {
    name: String,
    prelude: ['AtrulePrelude', 'Raw', null],
    block: ['Block', null]
};

function parse$F(isDeclaration = false) {
    const start = this.tokenStart;
    let name;
    let nameLowerCase;
    let prelude = null;
    let block = null;

    this.eat(types$G.AtKeyword);

    name = this.substrToCursor(start + 1);
    nameLowerCase = name.toLowerCase();
    this.skipSC();

    // parse prelude
    if (this.eof === false &&
        this.tokenType !== types$G.LeftCurlyBracket &&
        this.tokenType !== types$G.Semicolon) {
        if (this.parseAtrulePrelude) {
            prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name, isDeclaration), consumeRaw$5);
        } else {
            prelude = consumeRaw$5.call(this, this.tokenIndex);
        }

        this.skipSC();
    }

    switch (this.tokenType) {
        case types$G.Semicolon:
            this.next();
            break;

        case types$G.LeftCurlyBracket:
            if (hasOwnProperty.call(this.atrule, nameLowerCase) &&
                typeof this.atrule[nameLowerCase].block === 'function') {
                block = this.atrule[nameLowerCase].block.call(this, isDeclaration);
            } else {
                // TODO: should consume block content as Raw?
                block = this.Block(isDeclarationBlockAtrule.call(this));
            }

            break;
    }

    return {
        type: 'Atrule',
        loc: this.getLocation(start, this.tokenStart),
        name,
        prelude,
        block
    };
}

function generate$F(node) {
    this.token(types$G.AtKeyword, '@' + node.name);

    if (node.prelude !== null) {
        this.node(node.prelude);
    }

    if (node.block) {
        this.node(node.block);
    } else {
        this.token(types$G.Semicolon, ';');
    }
}

Atrule$2.generate = generate$F;
Atrule$2.name = name$E;
Atrule$2.parse = parse$F;
Atrule$2.structure = structure$D;
Atrule$2.walkContext = walkContext$9;

var AtrulePrelude$2 = {};

const types$F = types$T;

const name$D = 'AtrulePrelude';
const walkContext$8 = 'atrulePrelude';
const structure$C = {
    children: [[]]
};

function parse$E(name) {
    let children = null;

    if (name !== null) {
        name = name.toLowerCase();
    }

    this.skipSC();

    if (hasOwnProperty.call(this.atrule, name) &&
        typeof this.atrule[name].prelude === 'function') {
        // custom consumer
        children = this.atrule[name].prelude.call(this);
    } else {
        // default consumer
        children = this.readSequence(this.scope.AtrulePrelude);
    }

    this.skipSC();

    if (this.eof !== true &&
        this.tokenType !== types$F.LeftCurlyBracket &&
        this.tokenType !== types$F.Semicolon) {
        this.error('Semicolon or block is expected');
    }

    return {
        type: 'AtrulePrelude',
        loc: this.getLocationFromList(children),
        children
    };
}

function generate$E(node) {
    this.children(node);
}

AtrulePrelude$2.generate = generate$E;
AtrulePrelude$2.name = name$D;
AtrulePrelude$2.parse = parse$E;
AtrulePrelude$2.structure = structure$C;
AtrulePrelude$2.walkContext = walkContext$8;

var AttributeSelector$2 = {};

const types$E = types$T;

const DOLLARSIGN$1 = 0x0024;       // U+0024 DOLLAR SIGN ($)
const ASTERISK$5 = 0x002A;         // U+002A ASTERISK (*)
const EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
const CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
const VERTICALLINE$2 = 0x007C;     // U+007C VERTICAL LINE (|)
const TILDE$2 = 0x007E;            // U+007E TILDE (~)

function getAttributeName() {
    if (this.eof) {
        this.error('Unexpected end of input');
    }

    const start = this.tokenStart;
    let expectIdent = false;

    if (this.isDelim(ASTERISK$5)) {
        expectIdent = true;
        this.next();
    } else if (!this.isDelim(VERTICALLINE$2)) {
        this.eat(types$E.Ident);
    }

    if (this.isDelim(VERTICALLINE$2)) {
        if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {
            this.next();
            this.eat(types$E.Ident);
        } else if (expectIdent) {
            this.error('Identifier is expected', this.tokenEnd);
        }
    } else if (expectIdent) {
        this.error('Vertical line is expected');
    }

    return {
        type: 'Identifier',
        loc: this.getLocation(start, this.tokenStart),
        name: this.substrToCursor(start)
    };
}

function getOperator() {
    const start = this.tokenStart;
    const code = this.charCodeAt(start);

    if (code !== EQUALSSIGN &&        // =
        code !== TILDE$2 &&             // ~=
        code !== CIRCUMFLEXACCENT &&  // ^=
        code !== DOLLARSIGN$1 &&        // $=
        code !== ASTERISK$5 &&          // *=
        code !== VERTICALLINE$2         // |=
    ) {
        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
    }

    this.next();

    if (code !== EQUALSSIGN) {
        if (!this.isDelim(EQUALSSIGN)) {
            this.error('Equal sign is expected');
        }

        this.next();
    }

    return this.substrToCursor(start);
}

// '[' <wq-name> ']'
// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
const name$C = 'AttributeSelector';
const structure$B = {
    name: 'Identifier',
    matcher: [String, null],
    value: ['String', 'Identifier', null],
    flags: [String, null]
};

function parse$D() {
    const start = this.tokenStart;
    let name;
    let matcher = null;
    let value = null;
    let flags = null;

    this.eat(types$E.LeftSquareBracket);
    this.skipSC();

    name = getAttributeName.call(this);
    this.skipSC();

    if (this.tokenType !== types$E.RightSquareBracket) {
        // avoid case `[name i]`
        if (this.tokenType !== types$E.Ident) {
            matcher = getOperator.call(this);

            this.skipSC();

            value = this.tokenType === types$E.String
                ? this.String()
                : this.Identifier();

            this.skipSC();
        }

        // attribute flags
        if (this.tokenType === types$E.Ident) {
            flags = this.consume(types$E.Ident);

            this.skipSC();
        }
    }

    this.eat(types$E.RightSquareBracket);

    return {
        type: 'AttributeSelector',
        loc: this.getLocation(start, this.tokenStart),
        name,
        matcher,
        value,
        flags
    };
}

function generate$D(node) {
    this.token(types$E.Delim, '[');
    this.node(node.name);

    if (node.matcher !== null) {
        this.tokenize(node.matcher);
        this.node(node.value);
    }

    if (node.flags !== null) {
        this.token(types$E.Ident, node.flags);
    }

    this.token(types$E.Delim, ']');
}

AttributeSelector$2.generate = generate$D;
AttributeSelector$2.name = name$C;
AttributeSelector$2.parse = parse$D;
AttributeSelector$2.structure = structure$B;

var Block$2 = {};

const types$D = types$T;

const AMPERSAND$4 = 0x0026;       // U+0026 AMPERSAND (&)

function consumeRaw$4(startToken) {
    return this.Raw(startToken, null, true);
}
function consumeRule() {
    return this.parseWithFallback(this.Rule, consumeRaw$4);
}
function consumeRawDeclaration(startToken) {
    return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
}
function consumeDeclaration() {
    if (this.tokenType === types$D.Semicolon) {
        return consumeRawDeclaration.call(this, this.tokenIndex);
    }

    const node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

    if (this.tokenType === types$D.Semicolon) {
        this.next();
    }

    return node;
}

const name$B = 'Block';
const walkContext$7 = 'block';
const structure$A = {
    children: [[
        'Atrule',
        'Rule',
        'Declaration'
    ]]
};

function parse$C(isStyleBlock) {
    const consumer = isStyleBlock ? consumeDeclaration : consumeRule;
    const start = this.tokenStart;
    let children = this.createList();

    this.eat(types$D.LeftCurlyBracket);

    scan:
    while (!this.eof) {
        switch (this.tokenType) {
            case types$D.RightCurlyBracket:
                break scan;

            case types$D.WhiteSpace:
            case types$D.Comment:
                this.next();
                break;

            case types$D.AtKeyword:
                children.push(this.parseWithFallback(this.Atrule.bind(this, isStyleBlock), consumeRaw$4));
                break;

            default:
                if (isStyleBlock && this.isDelim(AMPERSAND$4))  {
                    children.push(consumeRule.call(this));
                } else {
                    children.push(consumer.call(this));
                }
        }
    }

    if (!this.eof) {
        this.eat(types$D.RightCurlyBracket);
    }

    return {
        type: 'Block',
        loc: this.getLocation(start, this.tokenStart),
        children
    };
}

function generate$C(node) {
    this.token(types$D.LeftCurlyBracket, '{');
    this.children(node, prev => {
        if (prev.type === 'Declaration') {
            this.token(types$D.Semicolon, ';');
        }
    });
    this.token(types$D.RightCurlyBracket, '}');
}

Block$2.generate = generate$C;
Block$2.name = name$B;
Block$2.parse = parse$C;
Block$2.structure = structure$A;
Block$2.walkContext = walkContext$7;

var Brackets$2 = {};

const types$C = types$T;

const name$A = 'Brackets';
const structure$z = {
    children: [[]]
};

function parse$B(readSequence, recognizer) {
    const start = this.tokenStart;
    let children = null;

    this.eat(types$C.LeftSquareBracket);

    children = readSequence.call(this, recognizer);

    if (!this.eof) {
        this.eat(types$C.RightSquareBracket);
    }

    return {
        type: 'Brackets',
        loc: this.getLocation(start, this.tokenStart),
        children
    };
}

function generate$B(node) {
    this.token(types$C.Delim, '[');
    this.children(node);
    this.token(types$C.Delim, ']');
}

Brackets$2.generate = generate$B;
Brackets$2.name = name$A;
Brackets$2.parse = parse$B;
Brackets$2.structure = structure$z;

var CDC$2 = {};

const types$B = types$T;

const name$z = 'CDC';
const structure$y = [];

function parse$A() {
    const start = this.tokenStart;

    this.eat(types$B.CDC); // -->

    return {
        type: 'CDC',
        loc: this.getLocation(start, this.tokenStart)
    };
}

function generate$A() {
    this.token(types$B.CDC, '-->');
}

CDC$2.generate = generate$A;
CDC$2.name = name$z;
CDC$2.parse = parse$A;
CDC$2.structure = structure$y;

var CDO$2 = {};

const types$A = types$T;

const name$y = 'CDO';
const structure$x = [];

function parse$z() {
    const start = this.tokenStart;

    this.eat(types$A.CDO); // <!--

    return {
        type: 'CDO',
        loc: this.getLocation(start, this.tokenStart)
    };
}

function generate$z() {
    this.token(types$A.CDO, '<!--');
}

CDO$2.generate = generate$z;
CDO$2.name = name$y;
CDO$2.parse = parse$z;
CDO$2.structure = structure$x;

var ClassSelector$2 = {};

const types$z = types$T;

const FULLSTOP$2 = 0x002E; // U+002E FULL STOP (.)

// '.' ident
const name$x = 'ClassSelector';
const structure$w = {
    name: String
};

function parse$y() {
    this.eatDelim(FULLSTOP$2);

    return {
        type: 'ClassSelector',
        loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
        name: this.consume(types$z.Ident)
    };
}

function generate$y(node) {
    this.token(types$z.Delim, '.');
    this.token(types$z.Ident, node.name);
}

ClassSelector$2.generate = generate$y;
ClassSelector$2.name = name$x;
ClassSelector$2.parse = parse$y;
ClassSelector$2.structure = structure$w;

var Combinator$2 = {};

const types$y = types$T;

const PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
const SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
const GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
const TILDE$1 = 0x007E;           // U+007E TILDE (~)

const name$w = 'Combinator';
const structure$v = {
    name: String
};

// + | > | ~ | /deep/
function parse$x() {
    const start = this.tokenStart;
    let name;

    switch (this.tokenType) {
        case types$y.WhiteSpace:
            name = ' ';
            break;

        case types$y.Delim:
            switch (this.charCodeAt(this.tokenStart)) {
                case GREATERTHANSIGN$1:
                case PLUSSIGN$4:
                case TILDE$1:
                    this.next();
                    break;

                case SOLIDUS$5:
                    this.next();
                    this.eatIdent('deep');
                    this.eatDelim(SOLIDUS$5);
                    break;

                default:
                    this.error('Combinator is expected');
            }

            name = this.substrToCursor(start);
            break;
    }

    return {
        type: 'Combinator',
        loc: this.getLocation(start, this.tokenStart),
        name
    };
}

function generate$x(node) {
    this.tokenize(node.name);
}

Combinator$2.generate = generate$x;
Combinator$2.name = name$w;
Combinator$2.parse = parse$x;
Combinator$2.structure = structure$v;

var Comment$2 = {};

const types$x = types$T;

const ASTERISK$4 = 0x002A;        // U+002A ASTERISK (*)
const SOLIDUS$4 = 0x002F;         // U+002F SOLIDUS (/)


const name$v = 'Comment';
const structure$u = {
    value: String
};

function parse$w() {
    const start = this.tokenStart;
    let end = this.tokenEnd;

    this.eat(types$x.Comment);

    if ((end - start + 2) >= 2 &&
        this.charCodeAt(end - 2) === ASTERISK$4 &&
        this.charCodeAt(end - 1) === SOLIDUS$4) {
        end -= 2;
    }

    return {
        type: 'Comment',
        loc: this.getLocation(start, this.tokenStart),
        value: this.substring(start + 2, end)
    };
}

function generate$w(node) {
    this.token(types$x.Comment, '/*' + node.value + '*/');
}

Comment$2.generate = generate$w;
Comment$2.name = name$v;
Comment$2.parse = parse$w;
Comment$2.structure = structure$u;

var Declaration$2 = {};

const names$2 = names$4;
const types$w = types$T;

const EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)
const NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
const DOLLARSIGN = 0x0024;      // U+0024 DOLLAR SIGN ($)
const AMPERSAND$3 = 0x0026;       // U+0026 AMPERSAND (&)
const ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
const PLUSSIGN$3 = 0x002B;        // U+002B PLUS SIGN (+)
const SOLIDUS$3 = 0x002F;         // U+002F SOLIDUS (/)

function consumeValueRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, true);
}

function consumeCustomPropertyRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, false);
}

function consumeValue() {
    const startValueToken = this.tokenIndex;
    const value = this.Value();

    if (value.type !== 'Raw' &&
        this.eof === false &&
        this.tokenType !== types$w.Semicolon &&
        this.isDelim(EXCLAMATIONMARK$1) === false &&
        this.isBalanceEdge(startValueToken) === false) {
        this.error();
    }

    return value;
}

const name$u = 'Declaration';
const walkContext$6 = 'declaration';
const structure$t = {
    important: [Boolean, String],
    property: String,
    value: ['Value', 'Raw']
};

function parse$v() {
    const start = this.tokenStart;
    const startToken = this.tokenIndex;
    const property = readProperty.call(this);
    const customProperty = names$2.isCustomProperty(property);
    const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
    const consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
    let important = false;
    let value;

    this.skipSC();
    this.eat(types$w.Colon);

    const valueStart = this.tokenIndex;

    if (!customProperty) {
        this.skipSC();
    }

    if (parseValue) {
        value = this.parseWithFallback(consumeValue, consumeRaw);
    } else {
        value = consumeRaw.call(this, this.tokenIndex);
    }

    if (customProperty && value.type === 'Value' && value.children.isEmpty) {
        for (let offset = valueStart - this.tokenIndex; offset <= 0; offset++) {
            if (this.lookupType(offset) === types$w.WhiteSpace) {
                value.children.appendData({
                    type: 'WhiteSpace',
                    loc: null,
                    value: ' '
                });
                break;
            }
        }
    }

    if (this.isDelim(EXCLAMATIONMARK$1)) {
        important = getImportant.call(this);
        this.skipSC();
    }

    // Do not include semicolon to range per spec
    // https://drafts.csswg.org/css-syntax/#declaration-diagram

    if (this.eof === false &&
        this.tokenType !== types$w.Semicolon &&
        this.isBalanceEdge(startToken) === false) {
        this.error();
    }

    return {
        type: 'Declaration',
        loc: this.getLocation(start, this.tokenStart),
        important,
        property,
        value
    };
}

function generate$v(node) {
    this.token(types$w.Ident, node.property);
    this.token(types$w.Colon, ':');
    this.node(node.value);

    if (node.important) {
        this.token(types$w.Delim, '!');
        this.token(types$w.Ident, node.important === true ? 'important' : node.important);
    }
}

function readProperty() {
    const start = this.tokenStart;

    // hacks
    if (this.tokenType === types$w.Delim) {
        switch (this.charCodeAt(this.tokenStart)) {
            case ASTERISK$3:
            case DOLLARSIGN:
            case PLUSSIGN$3:
            case NUMBERSIGN$2:
            case AMPERSAND$3:
                this.next();
                break;

            // TODO: not sure we should support this hack
            case SOLIDUS$3:
                this.next();
                if (this.isDelim(SOLIDUS$3)) {
                    this.next();
                }
                break;
        }
    }

    if (this.tokenType === types$w.Hash) {
        this.eat(types$w.Hash);
    } else {
        this.eat(types$w.Ident);
    }

    return this.substrToCursor(start);
}

// ! ws* important
function getImportant() {
    this.eat(types$w.Delim);
    this.skipSC();

    const important = this.consume(types$w.Ident);

    // store original value in case it differ from `important`
    // for better original source restoring and hacks like `!ie` support
    return important === 'important' ? true : important;
}

Declaration$2.generate = generate$v;
Declaration$2.name = name$u;
Declaration$2.parse = parse$v;
Declaration$2.structure = structure$t;
Declaration$2.walkContext = walkContext$6;

var DeclarationList$2 = {};

const types$v = types$T;

const AMPERSAND$2 = 0x0026;       // U+0026 AMPERSAND (&)

function consumeRaw$3(startToken) {
    return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
}

const name$t = 'DeclarationList';
const structure$s = {
    children: [[
        'Declaration',
        'Atrule',
        'Rule'
    ]]
};

function parse$u() {
    const children = this.createList();

    while (!this.eof) {
        switch (this.tokenType) {
            case types$v.WhiteSpace:
            case types$v.Comment:
            case types$v.Semicolon:
                this.next();
                break;

            case types$v.AtKeyword:
                children.push(this.parseWithFallback(this.Atrule.bind(this, true), consumeRaw$3));
                break;

            default:
                if (this.isDelim(AMPERSAND$2))  {
                    children.push(this.parseWithFallback(this.Rule, consumeRaw$3));
                } else {
                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$3));
                }
        }
    }

    return {
        type: 'DeclarationList',
        loc: this.getLocationFromList(children),
        children
    };
}

function generate$u(node) {
    this.children(node, prev => {
        if (prev.type === 'Declaration') {
            this.token(types$v.Semicolon, ';');
        }
    });
}

DeclarationList$2.generate = generate$u;
DeclarationList$2.name = name$t;
DeclarationList$2.parse = parse$u;
DeclarationList$2.structure = structure$s;

var Dimension$2 = {};

const types$u = types$T;

const name$s = 'Dimension';
const structure$r = {
    value: String,
    unit: String
};

function parse$t() {
    const start = this.tokenStart;
    const value = this.consumeNumber(types$u.Dimension);

    return {
        type: 'Dimension',
        loc: this.getLocation(start, this.tokenStart),
        value,
        unit: this.substring(start + value.length, this.tokenStart)
    };
}

function generate$t(node) {
    this.token(types$u.Dimension, node.value + node.unit);
}

Dimension$2.generate = generate$t;
Dimension$2.name = name$s;
Dimension$2.parse = parse$t;
Dimension$2.structure = structure$r;

var _Function = {};

const types$t = types$T;

const name$r = 'Function';
const walkContext$5 = 'function';
const structure$q = {
    name: String,
    children: [[]]
};

// <function-token> <sequence> )
function parse$s(readSequence, recognizer) {
    const start = this.tokenStart;
    const name = this.consumeFunctionName();
    const nameLowerCase = name.toLowerCase();
    let children;

    children = recognizer.hasOwnProperty(nameLowerCase)
        ? recognizer[nameLowerCase].call(this, recognizer)
        : readSequence.call(this, recognizer);

    if (!this.eof) {
        this.eat(types$t.RightParenthesis);
    }

    return {
        type: 'Function',
        loc: this.getLocation(start, this.tokenStart),
        name,
        children
    };
}

function generate$s(node) {
    this.token(types$t.Function, node.name + '(');
    this.children(node);
    this.token(types$t.RightParenthesis, ')');
}

_Function.generate = generate$s;
_Function.name = name$r;
_Function.parse = parse$s;
_Function.structure = structure$q;
_Function.walkContext = walkContext$5;

var Hash$2 = {};

const types$s = types$T;

// '#' ident
const xxx = 'XXX';
const name$q = 'Hash';
const structure$p = {
    value: String
};
function parse$r() {
    const start = this.tokenStart;

    this.eat(types$s.Hash);

    return {
        type: 'Hash',
        loc: this.getLocation(start, this.tokenStart),
        value: this.substrToCursor(start + 1)
    };
}
function generate$r(node) {
    this.token(types$s.Hash, '#' + node.value);
}

Hash$2.generate = generate$r;
Hash$2.name = name$q;
Hash$2.parse = parse$r;
Hash$2.structure = structure$p;
Hash$2.xxx = xxx;

var Identifier$2 = {};

const types$r = types$T;

const name$p = 'Identifier';
const structure$o = {
    name: String
};

function parse$q() {
    return {
        type: 'Identifier',
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        name: this.consume(types$r.Ident)
    };
}

function generate$q(node) {
    this.token(types$r.Ident, node.name);
}

Identifier$2.generate = generate$q;
Identifier$2.name = name$p;
Identifier$2.parse = parse$q;
Identifier$2.structure = structure$o;

var IdSelector$2 = {};

const types$q = types$T;

const name$o = 'IdSelector';
const structure$n = {
    name: String
};

function parse$p() {
    const start = this.tokenStart;

    // TODO: check value is an ident
    this.eat(types$q.Hash);

    return {
        type: 'IdSelector',
        loc: this.getLocation(start, this.tokenStart),
        name: this.substrToCursor(start + 1)
    };
}

function generate$p(node) {
    // Using Delim instead of Hash is a hack to avoid for a whitespace between ident and id-selector
    // in safe mode (e.g. "a#id"), because IE11 doesn't allow a sequence <ident-token> <hash-token>
    // without a whitespace in values (e.g. "1px solid#000")
    this.token(types$q.Delim, '#' + node.name);
}

IdSelector$2.generate = generate$p;
IdSelector$2.name = name$o;
IdSelector$2.parse = parse$p;
IdSelector$2.structure = structure$n;

var MediaFeature$2 = {};

const types$p = types$T;

const name$n = 'MediaFeature';
const structure$m = {
    name: String,
    value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
};

function parse$o() {
    const start = this.tokenStart;
    let name;
    let value = null;

    this.eat(types$p.LeftParenthesis);
    this.skipSC();

    name = this.consume(types$p.Ident);
    this.skipSC();

    if (this.tokenType !== types$p.RightParenthesis) {
        this.eat(types$p.Colon);
        this.skipSC();

        switch (this.tokenType) {
            case types$p.Number:
                if (this.lookupNonWSType(1) === types$p.Delim) {
                    value = this.Ratio();
                } else {
                    value = this.Number();
                }

                break;

            case types$p.Dimension:
                value = this.Dimension();
                break;

            case types$p.Ident:
                value = this.Identifier();
                break;

            default:
                this.error('Number, dimension, ratio or identifier is expected');
        }

        this.skipSC();
    }

    this.eat(types$p.RightParenthesis);

    return {
        type: 'MediaFeature',
        loc: this.getLocation(start, this.tokenStart),
        name,
        value
    };
}

function generate$o(node) {
    this.token(types$p.LeftParenthesis, '(');
    this.token(types$p.Ident, node.name);

    if (node.value !== null) {
        this.token(types$p.Colon, ':');
        this.node(node.value);
    }

    this.token(types$p.RightParenthesis, ')');
}

MediaFeature$2.generate = generate$o;
MediaFeature$2.name = name$n;
MediaFeature$2.parse = parse$o;
MediaFeature$2.structure = structure$m;

var MediaQuery$2 = {};

const types$o = types$T;

const name$m = 'MediaQuery';
const structure$l = {
    children: [[
        'Identifier',
        'MediaFeature',
        'WhiteSpace'
    ]]
};

function parse$n() {
    const children = this.createList();
    let child = null;

    this.skipSC();

    scan:
    while (!this.eof) {
        switch (this.tokenType) {
            case types$o.Comment:
            case types$o.WhiteSpace:
                this.next();
                continue;

            case types$o.Ident:
                child = this.Identifier();
                break;

            case types$o.LeftParenthesis:
                child = this.MediaFeature();
                break;

            default:
                break scan;
        }

        children.push(child);
    }

    if (child === null) {
        this.error('Identifier or parenthesis is expected');
    }

    return {
        type: 'MediaQuery',
        loc: this.getLocationFromList(children),
        children
    };
}

function generate$n(node) {
    this.children(node);
}

MediaQuery$2.generate = generate$n;
MediaQuery$2.name = name$m;
MediaQuery$2.parse = parse$n;
MediaQuery$2.structure = structure$l;

var MediaQueryList$2 = {};

const types$n = types$T;

const name$l = 'MediaQueryList';
const structure$k = {
    children: [[
        'MediaQuery'
    ]]
};

function parse$m() {
    const children = this.createList();

    this.skipSC();

    while (!this.eof) {
        children.push(this.MediaQuery());

        if (this.tokenType !== types$n.Comma) {
            break;
        }

        this.next();
    }

    return {
        type: 'MediaQueryList',
        loc: this.getLocationFromList(children),
        children
    };
}

function generate$m(node) {
    this.children(node, () => this.token(types$n.Comma, ','));
}

MediaQueryList$2.generate = generate$m;
MediaQueryList$2.name = name$l;
MediaQueryList$2.parse = parse$m;
MediaQueryList$2.structure = structure$k;

var NestingSelector$2 = {};

const types$m = types$T;

const AMPERSAND$1 = 0x0026;       // U+0026 AMPERSAND (&)

const name$k = 'NestingSelector';
const structure$j = {
};

function parse$l() {
    const start = this.tokenStart;

    this.eatDelim(AMPERSAND$1);

    return {
        type: 'NestingSelector',
        loc: this.getLocation(start, this.tokenStart)
    };
}

function generate$l() {
    this.token(types$m.Delim, '&');
}

NestingSelector$2.generate = generate$l;
NestingSelector$2.name = name$k;
NestingSelector$2.parse = parse$l;
NestingSelector$2.structure = structure$j;

var Nth$2 = {};

const types$l = types$T;

const name$j = 'Nth';
const structure$i = {
    nth: ['AnPlusB', 'Identifier'],
    selector: ['SelectorList', null]
};

function parse$k() {
    this.skipSC();

    const start = this.tokenStart;
    let end = start;
    let selector = null;
    let nth;

    if (this.lookupValue(0, 'odd') || this.lookupValue(0, 'even')) {
        nth = this.Identifier();
    } else {
        nth = this.AnPlusB();
    }

    end = this.tokenStart;
    this.skipSC();

    if (this.lookupValue(0, 'of')) {
        this.next();

        selector = this.SelectorList();
        end = this.tokenStart;
    }

    return {
        type: 'Nth',
        loc: this.getLocation(start, end),
        nth,
        selector
    };
}

function generate$k(node) {
    this.node(node.nth);
    if (node.selector !== null) {
        this.token(types$l.Ident, 'of');
        this.node(node.selector);
    }
}

Nth$2.generate = generate$k;
Nth$2.name = name$j;
Nth$2.parse = parse$k;
Nth$2.structure = structure$i;

var _Number = {};

const types$k = types$T;

const name$i = 'Number';
const structure$h = {
    value: String
};

function parse$j() {
    return {
        type: 'Number',
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        value: this.consume(types$k.Number)
    };
}

function generate$j(node) {
    this.token(types$k.Number, node.value);
}

_Number.generate = generate$j;
_Number.name = name$i;
_Number.parse = parse$j;
_Number.structure = structure$h;

var Operator$2 = {};

// '/' | '*' | ',' | ':' | '+' | '-'
const name$h = 'Operator';
const structure$g = {
    value: String
};

function parse$i() {
    const start = this.tokenStart;

    this.next();

    return {
        type: 'Operator',
        loc: this.getLocation(start, this.tokenStart),
        value: this.substrToCursor(start)
    };
}

function generate$i(node) {
    this.tokenize(node.value);
}

Operator$2.generate = generate$i;
Operator$2.name = name$h;
Operator$2.parse = parse$i;
Operator$2.structure = structure$g;

var Parentheses$2 = {};

const types$j = types$T;

const name$g = 'Parentheses';
const structure$f = {
    children: [[]]
};

function parse$h(readSequence, recognizer) {
    const start = this.tokenStart;
    let children = null;

    this.eat(types$j.LeftParenthesis);

    children = readSequence.call(this, recognizer);

    if (!this.eof) {
        this.eat(types$j.RightParenthesis);
    }

    return {
        type: 'Parentheses',
        loc: this.getLocation(start, this.tokenStart),
        children
    };
}

function generate$h(node) {
    this.token(types$j.LeftParenthesis, '(');
    this.children(node);
    this.token(types$j.RightParenthesis, ')');
}

Parentheses$2.generate = generate$h;
Parentheses$2.name = name$g;
Parentheses$2.parse = parse$h;
Parentheses$2.structure = structure$f;

var Percentage$2 = {};

const types$i = types$T;

const name$f = 'Percentage';
const structure$e = {
    value: String
};

function parse$g() {
    return {
        type: 'Percentage',
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        value: this.consumeNumber(types$i.Percentage)
    };
}

function generate$g(node) {
    this.token(types$i.Percentage, node.value + '%');
}

Percentage$2.generate = generate$g;
Percentage$2.name = name$f;
Percentage$2.parse = parse$g;
Percentage$2.structure = structure$e;

var PseudoClassSelector$2 = {};

const types$h = types$T;

const name$e = 'PseudoClassSelector';
const walkContext$4 = 'function';
const structure$d = {
    name: String,
    children: [['Raw'], null]
};

// : [ <ident> | <function-token> <any-value>? ) ]
function parse$f() {
    const start = this.tokenStart;
    let children = null;
    let name;
    let nameLowerCase;

    this.eat(types$h.Colon);

    if (this.tokenType === types$h.Function) {
        name = this.consumeFunctionName();
        nameLowerCase = name.toLowerCase();

        if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
            this.skipSC();
            children = this.pseudo[nameLowerCase].call(this);
            this.skipSC();
        } else {
            children = this.createList();
            children.push(
                this.Raw(this.tokenIndex, null, false)
            );
        }

        this.eat(types$h.RightParenthesis);
    } else {
        name = this.consume(types$h.Ident);
    }

    return {
        type: 'PseudoClassSelector',
        loc: this.getLocation(start, this.tokenStart),
        name,
        children
    };
}

function generate$f(node) {
    this.token(types$h.Colon, ':');

    if (node.children === null) {
        this.token(types$h.Ident, node.name);
    } else {
        this.token(types$h.Function, node.name + '(');
        this.children(node);
        this.token(types$h.RightParenthesis, ')');
    }
}

PseudoClassSelector$2.generate = generate$f;
PseudoClassSelector$2.name = name$e;
PseudoClassSelector$2.parse = parse$f;
PseudoClassSelector$2.structure = structure$d;
PseudoClassSelector$2.walkContext = walkContext$4;

var PseudoElementSelector$2 = {};

const types$g = types$T;

const name$d = 'PseudoElementSelector';
const walkContext$3 = 'function';
const structure$c = {
    name: String,
    children: [['Raw'], null]
};

// :: [ <ident> | <function-token> <any-value>? ) ]
function parse$e() {
    const start = this.tokenStart;
    let children = null;
    let name;
    let nameLowerCase;

    this.eat(types$g.Colon);
    this.eat(types$g.Colon);

    if (this.tokenType === types$g.Function) {
        name = this.consumeFunctionName();
        nameLowerCase = name.toLowerCase();

        if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
            this.skipSC();
            children = this.pseudo[nameLowerCase].call(this);
            this.skipSC();
        } else {
            children = this.createList();
            children.push(
                this.Raw(this.tokenIndex, null, false)
            );
        }

        this.eat(types$g.RightParenthesis);
    } else {
        name = this.consume(types$g.Ident);
    }

    return {
        type: 'PseudoElementSelector',
        loc: this.getLocation(start, this.tokenStart),
        name,
        children
    };
}

function generate$e(node) {
    this.token(types$g.Colon, ':');
    this.token(types$g.Colon, ':');

    if (node.children === null) {
        this.token(types$g.Ident, node.name);
    } else {
        this.token(types$g.Function, node.name + '(');
        this.children(node);
        this.token(types$g.RightParenthesis, ')');
    }
}

PseudoElementSelector$2.generate = generate$e;
PseudoElementSelector$2.name = name$d;
PseudoElementSelector$2.parse = parse$e;
PseudoElementSelector$2.structure = structure$c;
PseudoElementSelector$2.walkContext = walkContext$3;

var Ratio$2 = {};

const types$f = types$T;
const charCodeDefinitions$4 = charCodeDefinitions$c;

const SOLIDUS$2 = 0x002F;  // U+002F SOLIDUS (/)
const FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

// Terms of <ratio> should be a positive numbers (not zero or negative)
// (see https://drafts.csswg.org/mediaqueries-3/#values)
// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
// and this is using by various sites. Therefore we relax checking on parse
// to test a term is unsigned number without an exponent part.
// Additional checking may be applied on lexer validation.
function consumeNumber() {
    this.skipSC();

    const value = this.consume(types$f.Number);

    for (let i = 0; i < value.length; i++) {
        const code = value.charCodeAt(i);
        if (!charCodeDefinitions$4.isDigit(code) && code !== FULLSTOP$1) {
            this.error('Unsigned number is expected', this.tokenStart - value.length + i);
        }
    }

    if (Number(value) === 0) {
        this.error('Zero number is not allowed', this.tokenStart - value.length);
    }

    return value;
}

const name$c = 'Ratio';
const structure$b = {
    left: String,
    right: String
};

// <positive-integer> S* '/' S* <positive-integer>
function parse$d() {
    const start = this.tokenStart;
    const left = consumeNumber.call(this);
    let right;

    this.skipSC();
    this.eatDelim(SOLIDUS$2);
    right = consumeNumber.call(this);

    return {
        type: 'Ratio',
        loc: this.getLocation(start, this.tokenStart),
        left,
        right
    };
}

function generate$d(node) {
    this.token(types$f.Number, node.left);
    this.token(types$f.Delim, '/');
    this.token(types$f.Number, node.right);
}

Ratio$2.generate = generate$d;
Ratio$2.name = name$c;
Ratio$2.parse = parse$d;
Ratio$2.structure = structure$b;

var Raw$2 = {};

const types$e = types$T;

function getOffsetExcludeWS() {
    if (this.tokenIndex > 0) {
        if (this.lookupType(-1) === types$e.WhiteSpace) {
            return this.tokenIndex > 1
                ? this.getTokenStart(this.tokenIndex - 1)
                : this.firstCharOffset;
        }
    }

    return this.tokenStart;
}

const name$b = 'Raw';
const structure$a = {
    value: String
};

function parse$c(startToken, consumeUntil, excludeWhiteSpace) {
    const startOffset = this.getTokenStart(startToken);
    let endOffset;

    this.skipUntilBalanced(startToken, consumeUntil || this.consumeUntilBalanceEnd);

    if (excludeWhiteSpace && this.tokenStart > startOffset) {
        endOffset = getOffsetExcludeWS.call(this);
    } else {
        endOffset = this.tokenStart;
    }

    return {
        type: 'Raw',
        loc: this.getLocation(startOffset, endOffset),
        value: this.substring(startOffset, endOffset)
    };
}

function generate$c(node) {
    this.tokenize(node.value);
}

Raw$2.generate = generate$c;
Raw$2.name = name$b;
Raw$2.parse = parse$c;
Raw$2.structure = structure$a;

var Rule$2 = {};

const types$d = types$T;

function consumeRaw$2(startToken) {
    return this.Raw(startToken, this.consumeUntilLeftCurlyBracket, true);
}

function consumePrelude() {
    const prelude = this.SelectorList();

    if (prelude.type !== 'Raw' &&
        this.eof === false &&
        this.tokenType !== types$d.LeftCurlyBracket) {
        this.error();
    }

    return prelude;
}

const name$a = 'Rule';
const walkContext$2 = 'rule';
const structure$9 = {
    prelude: ['SelectorList', 'Raw'],
    block: ['Block']
};

function parse$b() {
    const startToken = this.tokenIndex;
    const startOffset = this.tokenStart;
    let prelude;
    let block;

    if (this.parseRulePrelude) {
        prelude = this.parseWithFallback(consumePrelude, consumeRaw$2);
    } else {
        prelude = consumeRaw$2.call(this, startToken);
    }

    block = this.Block(true);

    return {
        type: 'Rule',
        loc: this.getLocation(startOffset, this.tokenStart),
        prelude,
        block
    };
}
function generate$b(node) {
    this.node(node.prelude);
    this.node(node.block);
}

Rule$2.generate = generate$b;
Rule$2.name = name$a;
Rule$2.parse = parse$b;
Rule$2.structure = structure$9;
Rule$2.walkContext = walkContext$2;

var Selector$3 = {};

const name$9 = 'Selector';
const structure$8 = {
    children: [[
        'TypeSelector',
        'IdSelector',
        'ClassSelector',
        'AttributeSelector',
        'PseudoClassSelector',
        'PseudoElementSelector',
        'Combinator',
        'WhiteSpace'
    ]]
};

function parse$a() {
    const children = this.readSequence(this.scope.Selector);

    // nothing were consumed
    if (this.getFirstListNode(children) === null) {
        this.error('Selector is expected');
    }

    return {
        type: 'Selector',
        loc: this.getLocationFromList(children),
        children
    };
}

function generate$a(node) {
    this.children(node);
}

Selector$3.generate = generate$a;
Selector$3.name = name$9;
Selector$3.parse = parse$a;
Selector$3.structure = structure$8;

var SelectorList$2 = {};

const types$c = types$T;

const name$8 = 'SelectorList';
const walkContext$1 = 'selector';
const structure$7 = {
    children: [[
        'Selector',
        'Raw'
    ]]
};

function parse$9() {
    const children = this.createList();

    while (!this.eof) {
        children.push(this.Selector());

        if (this.tokenType === types$c.Comma) {
            this.next();
            continue;
        }

        break;
    }

    return {
        type: 'SelectorList',
        loc: this.getLocationFromList(children),
        children
    };
}

function generate$9(node) {
    this.children(node, () => this.token(types$c.Comma, ','));
}

SelectorList$2.generate = generate$9;
SelectorList$2.name = name$8;
SelectorList$2.parse = parse$9;
SelectorList$2.structure = structure$7;
SelectorList$2.walkContext = walkContext$1;

var _String = {};

var string$3 = {};

const charCodeDefinitions$3 = charCodeDefinitions$c;
const utils$2 = utils$9;

const REVERSE_SOLIDUS$2 = 0x005c; // U+005C REVERSE SOLIDUS (\)
const QUOTATION_MARK$1 = 0x0022;  // "
const APOSTROPHE$1 = 0x0027;      // '

function decode$2(str) {
    const len = str.length;
    const firstChar = str.charCodeAt(0);
    const start = firstChar === QUOTATION_MARK$1 || firstChar === APOSTROPHE$1 ? 1 : 0;
    const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;
    let decoded = '';

    for (let i = start; i <= end; i++) {
        let code = str.charCodeAt(i);

        if (code === REVERSE_SOLIDUS$2) {
            // special case at the ending
            if (i === end) {
                // if the next input code point is EOF, do nothing
                // otherwise include last quote as escaped
                if (i !== len - 1) {
                    decoded = str.substr(i + 1);
                }
                break;
            }

            code = str.charCodeAt(++i);

            // consume escaped
            if (charCodeDefinitions$3.isValidEscape(REVERSE_SOLIDUS$2, code)) {
                const escapeStart = i - 1;
                const escapeEnd = utils$2.consumeEscaped(str, escapeStart);

                i = escapeEnd - 1;
                decoded += utils$2.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
            } else {
                // \r\n
                if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {
                    i++;
                }
            }
        } else {
            decoded += str[i];
        }
    }

    return decoded;
}

// https://drafts.csswg.org/cssom/#serialize-a-string
// § 2.1. Common Serializing Idioms
function encode$2(str, apostrophe) {
    const quote = apostrophe ? '\'' : '"';
    const quoteCode = apostrophe ? APOSTROPHE$1 : QUOTATION_MARK$1;
    let encoded = '';
    let wsBeforeHexIsNeeded = false;

    for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);

        // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).
        if (code === 0x0000) {
            encoded += '\uFFFD';
            continue;
        }

        // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F,
        // the character escaped as code point.
        // Note: Do not compare with 0x0001 since 0x0000 is precessed before
        if (code <= 0x001f || code === 0x007F) {
            encoded += '\\' + code.toString(16);
            wsBeforeHexIsNeeded = true;
            continue;
        }

        // If the character is '"' (U+0022) or "\" (U+005C), the escaped character.
        if (code === quoteCode || code === REVERSE_SOLIDUS$2) {
            encoded += '\\' + str.charAt(i);
            wsBeforeHexIsNeeded = false;
        } else {
            if (wsBeforeHexIsNeeded && (charCodeDefinitions$3.isHexDigit(code) || charCodeDefinitions$3.isWhiteSpace(code))) {
                encoded += ' ';
            }

            // Otherwise, the character itself.
            encoded += str.charAt(i);
            wsBeforeHexIsNeeded = false;
        }
    }

    return quote + encoded + quote;
}

string$3.decode = decode$2;
string$3.encode = encode$2;

const string$2 = string$3;
const types$b = types$T;

const name$7 = 'String';
const structure$6 = {
    value: String
};

function parse$8() {
    return {
        type: 'String',
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        value: string$2.decode(this.consume(types$b.String))
    };
}

function generate$8(node) {
    this.token(types$b.String, string$2.encode(node.value));
}

_String.generate = generate$8;
_String.name = name$7;
_String.parse = parse$8;
_String.structure = structure$6;

var StyleSheet$2 = {};

const types$a = types$T;

const EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)

function consumeRaw$1(startToken) {
    return this.Raw(startToken, null, false);
}

const name$6 = 'StyleSheet';
const walkContext = 'stylesheet';
const structure$5 = {
    children: [[
        'Comment',
        'CDO',
        'CDC',
        'Atrule',
        'Rule',
        'Raw'
    ]]
};

function parse$7() {
    const start = this.tokenStart;
    const children = this.createList();
    let child;

    while (!this.eof) {
        switch (this.tokenType) {
            case types$a.WhiteSpace:
                this.next();
                continue;

            case types$a.Comment:
                // ignore comments except exclamation comments (i.e. /*! .. */) on top level
                if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK) {
                    this.next();
                    continue;
                }

                child = this.Comment();
                break;

            case types$a.CDO: // <!--
                child = this.CDO();
                break;

            case types$a.CDC: // -->
                child = this.CDC();
                break;

            // CSS Syntax Module Level 3
            // §2.2 Error handling
            // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
            case types$a.AtKeyword:
                child = this.parseWithFallback(this.Atrule, consumeRaw$1);
                break;

            // Anything else starts a qualified rule ...
            default:
                child = this.parseWithFallback(this.Rule, consumeRaw$1);
        }

        children.push(child);
    }

    return {
        type: 'StyleSheet',
        loc: this.getLocation(start, this.tokenStart),
        children
    };
}

function generate$7(node) {
    this.children(node);
}

StyleSheet$2.generate = generate$7;
StyleSheet$2.name = name$6;
StyleSheet$2.parse = parse$7;
StyleSheet$2.structure = structure$5;
StyleSheet$2.walkContext = walkContext;

var TypeSelector$2 = {};

const types$9 = types$T;

const ASTERISK$2 = 0x002A;     // U+002A ASTERISK (*)
const VERTICALLINE$1 = 0x007C; // U+007C VERTICAL LINE (|)

function eatIdentifierOrAsterisk() {
    if (this.tokenType !== types$9.Ident &&
        this.isDelim(ASTERISK$2) === false) {
        this.error('Identifier or asterisk is expected');
    }

    this.next();
}

const name$5 = 'TypeSelector';
const structure$4 = {
    name: String
};

// ident
// ident|ident
// ident|*
// *
// *|ident
// *|*
// |ident
// |*
function parse$6() {
    const start = this.tokenStart;

    if (this.isDelim(VERTICALLINE$1)) {
        this.next();
        eatIdentifierOrAsterisk.call(this);
    } else {
        eatIdentifierOrAsterisk.call(this);

        if (this.isDelim(VERTICALLINE$1)) {
            this.next();
            eatIdentifierOrAsterisk.call(this);
        }
    }

    return {
        type: 'TypeSelector',
        loc: this.getLocation(start, this.tokenStart),
        name: this.substrToCursor(start)
    };
}

function generate$6(node) {
    this.tokenize(node.name);
}

TypeSelector$2.generate = generate$6;
TypeSelector$2.name = name$5;
TypeSelector$2.parse = parse$6;
TypeSelector$2.structure = structure$4;

var UnicodeRange$2 = {};

const types$8 = types$T;
const charCodeDefinitions$2 = charCodeDefinitions$c;

const PLUSSIGN$2 = 0x002B;     // U+002B PLUS SIGN (+)
const HYPHENMINUS$1 = 0x002D;  // U+002D HYPHEN-MINUS (-)
const QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)

function eatHexSequence(offset, allowDash) {
    let len = 0;

    for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {
        const code = this.charCodeAt(pos);

        if (code === HYPHENMINUS$1 && allowDash && len !== 0) {
            eatHexSequence.call(this, offset + len + 1, false);
            return -1;
        }

        if (!charCodeDefinitions$2.isHexDigit(code)) {
            this.error(
                allowDash && len !== 0
                    ? 'Hyphen minus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
                pos
            );
        }

        if (++len > 6) {
            this.error('Too many hex digits', pos);
        }    }

    this.next();
    return len;
}

function eatQuestionMarkSequence(max) {
    let count = 0;

    while (this.isDelim(QUESTIONMARK)) {
        if (++count > max) {
            this.error('Too many question marks');
        }

        this.next();
    }
}

function startsWith(code) {
    if (this.charCodeAt(this.tokenStart) !== code) {
        this.error((code === PLUSSIGN$2 ? 'Plus sign' : 'Hyphen minus') + ' is expected');
    }
}

// https://drafts.csswg.org/css-syntax/#urange
// Informally, the <urange> production has three forms:
// U+0001
//      Defines a range consisting of a single code point, in this case the code point "1".
// U+0001-00ff
//      Defines a range of codepoints between the first and the second value, in this case
//      the range between "1" and "ff" (255 in decimal) inclusive.
// U+00??
//      Defines a range of codepoints where the "?" characters range over all hex digits,
//      in this case defining the same as the value U+0000-00ff.
// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
//
// <urange> =
//   u '+' <ident-token> '?'* |
//   u <dimension-token> '?'* |
//   u <number-token> '?'* |
//   u <number-token> <dimension-token> |
//   u <number-token> <number-token> |
//   u '+' '?'+
function scanUnicodeRange() {
    let hexLength = 0;

    switch (this.tokenType) {
        case types$8.Number:
            // u <number-token> '?'*
            // u <number-token> <dimension-token>
            // u <number-token> <number-token>
            hexLength = eatHexSequence.call(this, 1, true);

            if (this.isDelim(QUESTIONMARK)) {
                eatQuestionMarkSequence.call(this, 6 - hexLength);
                break;
            }

            if (this.tokenType === types$8.Dimension ||
                this.tokenType === types$8.Number) {
                startsWith.call(this, HYPHENMINUS$1);
                eatHexSequence.call(this, 1, false);
                break;
            }

            break;

        case types$8.Dimension:
            // u <dimension-token> '?'*
            hexLength = eatHexSequence.call(this, 1, true);

            if (hexLength > 0) {
                eatQuestionMarkSequence.call(this, 6 - hexLength);
            }

            break;

        default:
            // u '+' <ident-token> '?'*
            // u '+' '?'+
            this.eatDelim(PLUSSIGN$2);

            if (this.tokenType === types$8.Ident) {
                hexLength = eatHexSequence.call(this, 0, true);
                if (hexLength > 0) {
                    eatQuestionMarkSequence.call(this, 6 - hexLength);
                }
                break;
            }

            if (this.isDelim(QUESTIONMARK)) {
                this.next();
                eatQuestionMarkSequence.call(this, 5);
                break;
            }

            this.error('Hex digit or question mark is expected');
    }
}

const name$4 = 'UnicodeRange';
const structure$3 = {
    value: String
};

function parse$5() {
    const start = this.tokenStart;

    // U or u
    this.eatIdent('u');
    scanUnicodeRange.call(this);

    return {
        type: 'UnicodeRange',
        loc: this.getLocation(start, this.tokenStart),
        value: this.substrToCursor(start)
    };
}

function generate$5(node) {
    this.tokenize(node.value);
}

UnicodeRange$2.generate = generate$5;
UnicodeRange$2.name = name$4;
UnicodeRange$2.parse = parse$5;
UnicodeRange$2.structure = structure$3;

var Url$2 = {};

var url$2 = {};

const charCodeDefinitions$1 = charCodeDefinitions$c;
const utils$1 = utils$9;

const SPACE$1 = 0x0020;            // U+0020 SPACE
const REVERSE_SOLIDUS$1 = 0x005c;  // U+005C REVERSE SOLIDUS (\)
const QUOTATION_MARK = 0x0022;   // "
const APOSTROPHE = 0x0027;       // '
const LEFTPARENTHESIS = 0x0028;  // U+0028 LEFT PARENTHESIS (()
const RIGHTPARENTHESIS = 0x0029; // U+0029 RIGHT PARENTHESIS ())

function decode$1(str) {
    const len = str.length;
    let start = 4; // length of "url("
    let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;
    let decoded = '';

    while (start < end && charCodeDefinitions$1.isWhiteSpace(str.charCodeAt(start))) {
        start++;
    }

    while (start < end && charCodeDefinitions$1.isWhiteSpace(str.charCodeAt(end))) {
        end--;
    }

    for (let i = start; i <= end; i++) {
        let code = str.charCodeAt(i);

        if (code === REVERSE_SOLIDUS$1) {
            // special case at the ending
            if (i === end) {
                // if the next input code point is EOF, do nothing
                // otherwise include last left parenthesis as escaped
                if (i !== len - 1) {
                    decoded = str.substr(i + 1);
                }
                break;
            }

            code = str.charCodeAt(++i);

            // consume escaped
            if (charCodeDefinitions$1.isValidEscape(REVERSE_SOLIDUS$1, code)) {
                const escapeStart = i - 1;
                const escapeEnd = utils$1.consumeEscaped(str, escapeStart);

                i = escapeEnd - 1;
                decoded += utils$1.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
            } else {
                // \r\n
                if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {
                    i++;
                }
            }
        } else {
            decoded += str[i];
        }
    }

    return decoded;
}

function encode$1(str) {
    let encoded = '';
    let wsBeforeHexIsNeeded = false;

    for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);

        // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).
        if (code === 0x0000) {
            encoded += '\uFFFD';
            continue;
        }

        // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F,
        // the character escaped as code point.
        // Note: Do not compare with 0x0001 since 0x0000 is precessed before
        if (code <= 0x001f || code === 0x007F) {
            encoded += '\\' + code.toString(16);
            wsBeforeHexIsNeeded = true;
            continue;
        }

        if (code === SPACE$1 ||
            code === REVERSE_SOLIDUS$1 ||
            code === QUOTATION_MARK ||
            code === APOSTROPHE ||
            code === LEFTPARENTHESIS ||
            code === RIGHTPARENTHESIS) {
            encoded += '\\' + str.charAt(i);
            wsBeforeHexIsNeeded = false;
        } else {
            if (wsBeforeHexIsNeeded && charCodeDefinitions$1.isHexDigit(code)) {
                encoded += ' ';
            }

            encoded += str.charAt(i);
            wsBeforeHexIsNeeded = false;
        }
    }

    return 'url(' + encoded + ')';
}

url$2.decode = decode$1;
url$2.encode = encode$1;

const url$1 = url$2;
const string$1 = string$3;
const types$7 = types$T;

const name$3 = 'Url';
const structure$2 = {
    value: String
};

// <url-token> | <function-token> <string> )
function parse$4() {
    const start = this.tokenStart;
    let value;

    switch (this.tokenType) {
        case types$7.Url:
            value = url$1.decode(this.consume(types$7.Url));
            break;

        case types$7.Function:
            if (!this.cmpStr(this.tokenStart, this.tokenEnd, 'url(')) {
                this.error('Function name must be `url`');
            }

            this.eat(types$7.Function);
            this.skipSC();
            value = string$1.decode(this.consume(types$7.String));
            this.skipSC();
            if (!this.eof) {
                this.eat(types$7.RightParenthesis);
            }
            break;

        default:
            this.error('Url or Function is expected');
    }

    return {
        type: 'Url',
        loc: this.getLocation(start, this.tokenStart),
        value
    };
}

function generate$4(node) {
    this.token(types$7.Url, url$1.encode(node.value));
}

Url$2.generate = generate$4;
Url$2.name = name$3;
Url$2.parse = parse$4;
Url$2.structure = structure$2;

var Value$2 = {};

const name$2 = 'Value';
const structure$1 = {
    children: [[]]
};

function parse$3() {
    const start = this.tokenStart;
    const children = this.readSequence(this.scope.Value);

    return {
        type: 'Value',
        loc: this.getLocation(start, this.tokenStart),
        children
    };
}

function generate$3(node) {
    this.children(node);
}

Value$2.generate = generate$3;
Value$2.name = name$2;
Value$2.parse = parse$3;
Value$2.structure = structure$1;

var WhiteSpace$2 = {};

const types$6 = types$T;

const SPACE = Object.freeze({
    type: 'WhiteSpace',
    loc: null,
    value: ' '
});

const name$1 = 'WhiteSpace';
const structure = {
    value: String
};

function parse$2() {
    this.eat(types$6.WhiteSpace);
    return SPACE;

    // return {
    //     type: 'WhiteSpace',
    //     loc: this.getLocation(this.tokenStart, this.tokenEnd),
    //     value: this.consume(WHITESPACE)
    // };
}

function generate$2(node) {
    this.token(types$6.WhiteSpace, node.value);
}

WhiteSpace$2.generate = generate$2;
WhiteSpace$2.name = name$1;
WhiteSpace$2.parse = parse$2;
WhiteSpace$2.structure = structure;

const AnPlusB$1 = AnPlusB$2;
const Atrule$1 = Atrule$2;
const AtrulePrelude$1 = AtrulePrelude$2;
const AttributeSelector$1 = AttributeSelector$2;
const Block$1 = Block$2;
const Brackets$1 = Brackets$2;
const CDC$1 = CDC$2;
const CDO$1 = CDO$2;
const ClassSelector$1 = ClassSelector$2;
const Combinator$1 = Combinator$2;
const Comment$1 = Comment$2;
const Declaration$1 = Declaration$2;
const DeclarationList$1 = DeclarationList$2;
const Dimension$1 = Dimension$2;
const Function$2 = _Function;
const Hash$1 = Hash$2;
const Identifier$1 = Identifier$2;
const IdSelector$1 = IdSelector$2;
const MediaFeature$1 = MediaFeature$2;
const MediaQuery$1 = MediaQuery$2;
const MediaQueryList$1 = MediaQueryList$2;
const NestingSelector$1 = NestingSelector$2;
const Nth$1 = Nth$2;
const Number$1$1 = _Number;
const Operator$1 = Operator$2;
const Parentheses$1 = Parentheses$2;
const Percentage$1 = Percentage$2;
const PseudoClassSelector$1 = PseudoClassSelector$2;
const PseudoElementSelector$1 = PseudoElementSelector$2;
const Ratio$1 = Ratio$2;
const Raw$1 = Raw$2;
const Rule$1 = Rule$2;
const Selector$2 = Selector$3;
const SelectorList$1 = SelectorList$2;
const String$1$1 = _String;
const StyleSheet$1 = StyleSheet$2;
const TypeSelector$1 = TypeSelector$2;
const UnicodeRange$1 = UnicodeRange$2;
const Url$1 = Url$2;
const Value$1 = Value$2;
const WhiteSpace$1 = WhiteSpace$2;



node.AnPlusB = AnPlusB$1;
node.Atrule = Atrule$1;
node.AtrulePrelude = AtrulePrelude$1;
node.AttributeSelector = AttributeSelector$1;
node.Block = Block$1;
node.Brackets = Brackets$1;
node.CDC = CDC$1;
node.CDO = CDO$1;
node.ClassSelector = ClassSelector$1;
node.Combinator = Combinator$1;
node.Comment = Comment$1;
node.Declaration = Declaration$1;
node.DeclarationList = DeclarationList$1;
node.Dimension = Dimension$1;
node.Function = Function$2;
node.Hash = Hash$1;
node.Identifier = Identifier$1;
node.IdSelector = IdSelector$1;
node.MediaFeature = MediaFeature$1;
node.MediaQuery = MediaQuery$1;
node.MediaQueryList = MediaQueryList$1;
node.NestingSelector = NestingSelector$1;
node.Nth = Nth$1;
node.Number = Number$1$1;
node.Operator = Operator$1;
node.Parentheses = Parentheses$1;
node.Percentage = Percentage$1;
node.PseudoClassSelector = PseudoClassSelector$1;
node.PseudoElementSelector = PseudoElementSelector$1;
node.Ratio = Ratio$1;
node.Raw = Raw$1;
node.Rule = Rule$1;
node.Selector = Selector$2;
node.SelectorList = SelectorList$1;
node.String = String$1$1;
node.StyleSheet = StyleSheet$1;
node.TypeSelector = TypeSelector$1;
node.UnicodeRange = UnicodeRange$1;
node.Url = Url$1;
node.Value = Value$1;
node.WhiteSpace = WhiteSpace$1;

const data = data$1;
const index$4 = node;

const lexerConfig = {
    generic: true,
    ...data,
    node: index$4
};

var lexer$2 = lexerConfig;

var scope = {};

const types$5 = types$T;

const NUMBERSIGN$1 = 0x0023;  // U+0023 NUMBER SIGN (#)
const ASTERISK$1 = 0x002A;    // U+002A ASTERISK (*)
const PLUSSIGN$1 = 0x002B;    // U+002B PLUS SIGN (+)
const HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)
const SOLIDUS$1 = 0x002F;     // U+002F SOLIDUS (/)
const U = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

function defaultRecognizer(context) {
    switch (this.tokenType) {
        case types$5.Hash:
            return this.Hash();

        case types$5.Comma:
            return this.Operator();

        case types$5.LeftParenthesis:
            return this.Parentheses(this.readSequence, context.recognizer);

        case types$5.LeftSquareBracket:
            return this.Brackets(this.readSequence, context.recognizer);

        case types$5.String:
            return this.String();

        case types$5.Dimension:
            return this.Dimension();

        case types$5.Percentage:
            return this.Percentage();

        case types$5.Number:
            return this.Number();

        case types$5.Function:
            return this.cmpStr(this.tokenStart, this.tokenEnd, 'url(')
                ? this.Url()
                : this.Function(this.readSequence, context.recognizer);

        case types$5.Url:
            return this.Url();

        case types$5.Ident:
            // check for unicode range, it should start with u+ or U+
            if (this.cmpChar(this.tokenStart, U) &&
                this.cmpChar(this.tokenStart + 1, PLUSSIGN$1)) {
                return this.UnicodeRange();
            } else {
                return this.Identifier();
            }

        case types$5.Delim: {
            const code = this.charCodeAt(this.tokenStart);

            if (code === SOLIDUS$1 ||
                code === ASTERISK$1 ||
                code === PLUSSIGN$1 ||
                code === HYPHENMINUS) {
                return this.Operator(); // TODO: replace with Delim
            }

            // TODO: produce a node with Delim node type

            if (code === NUMBERSIGN$1) {
                this.error('Hex or identifier is expected', this.tokenStart + 1);
            }

            break;
        }
    }
}

var _default$2 = defaultRecognizer;

const _default$1 = _default$2;

const atrulePrelude$1 = {
    getNode: _default$1
};

var atrulePrelude_1 = atrulePrelude$1;

const types$4 = types$T;

const NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)
const AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)
const ASTERISK = 0x002A;        // U+002A ASTERISK (*)
const PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)
const SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
const FULLSTOP = 0x002E;        // U+002E FULL STOP (.)
const GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)
const VERTICALLINE = 0x007C;    // U+007C VERTICAL LINE (|)
const TILDE = 0x007E;           // U+007E TILDE (~)

function onWhiteSpace(next, children) {
    if (children.last !== null && children.last.type !== 'Combinator' &&
        next !== null && next.type !== 'Combinator') {
        children.push({  // FIXME: this.Combinator() should be used instead
            type: 'Combinator',
            loc: null,
            name: ' '
        });
    }
}

function getNode() {
    switch (this.tokenType) {
        case types$4.LeftSquareBracket:
            return this.AttributeSelector();

        case types$4.Hash:
            return this.IdSelector();

        case types$4.Colon:
            if (this.lookupType(1) === types$4.Colon) {
                return this.PseudoElementSelector();
            } else {
                return this.PseudoClassSelector();
            }

        case types$4.Ident:
            return this.TypeSelector();

        case types$4.Number:
        case types$4.Percentage:
            return this.Percentage();

        case types$4.Dimension:
            // throws when .123ident
            if (this.charCodeAt(this.tokenStart) === FULLSTOP) {
                this.error('Identifier is expected', this.tokenStart + 1);
            }
            break;

        case types$4.Delim: {
            const code = this.charCodeAt(this.tokenStart);

            switch (code) {
                case PLUSSIGN:
                case GREATERTHANSIGN:
                case TILDE:
                case SOLIDUS:  // /deep/
                    return this.Combinator();

                case FULLSTOP:
                    return this.ClassSelector();

                case ASTERISK:
                case VERTICALLINE:
                    return this.TypeSelector();

                case NUMBERSIGN:
                    return this.IdSelector();

                case AMPERSAND:
                    return this.NestingSelector();
            }

            break;
        }
    }
}
const Selector$1 = {
    onWhiteSpace,
    getNode
};

var selector$2 = Selector$1;

// legacy IE function
// expression( <any-value> )
function expressionFn() {
    return this.createSingleNodeList(
        this.Raw(this.tokenIndex, null, false)
    );
}

var expression$1 = expressionFn;

const types$3 = types$T;

// var( <ident> , <value>? )
function varFn() {
    const children = this.createList();

    this.skipSC();

    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
    children.push(this.Identifier());

    this.skipSC();

    if (this.tokenType === types$3.Comma) {
        children.push(this.Operator());

        const startIndex = this.tokenIndex;
        const value = this.parseCustomProperty
            ? this.Value(null)
            : this.Raw(this.tokenIndex, this.consumeUntilExclamationMarkOrSemicolon, false);

        if (value.type === 'Value' && value.children.isEmpty) {
            for (let offset = startIndex - this.tokenIndex; offset <= 0; offset++) {
                if (this.lookupType(offset) === types$3.WhiteSpace) {
                    value.children.appendData({
                        type: 'WhiteSpace',
                        loc: null,
                        value: ' '
                    });
                    break;
                }
            }
        }

        children.push(value);
    }

    return children;
}

var _var$1 = varFn;

const _default = _default$2;
const expression = expression$1;
const _var = _var$1;

function isPlusMinusOperator(node) {
    return (
        node !== null &&
        node.type === 'Operator' &&
        (node.value[node.value.length - 1] === '-' || node.value[node.value.length - 1] === '+')
    );
}

const value$1 = {
    getNode: _default,
    onWhiteSpace(next, children) {
        if (isPlusMinusOperator(next)) {
            next.value = ' ' + next.value;
        }
        if (isPlusMinusOperator(children.last)) {
            children.last.value += ' ';
        }
    },
    'expression': expression,
    'var': _var
};

var value_1 = value$1;

const atrulePrelude = atrulePrelude_1;
const selector$1 = selector$2;
const value = value_1;



scope.AtrulePrelude = atrulePrelude;
scope.Selector = selector$1;
scope.Value = value;

const fontFace$1 = {
    parse: {
        prelude: null,
        block() {
            return this.Block(true);
        }
    }
};

var fontFace_1 = fontFace$1;

const types$2 = types$T;

const importAtrule = {
    parse: {
        prelude() {
            const children = this.createList();

            this.skipSC();

            switch (this.tokenType) {
                case types$2.String:
                    children.push(this.String());
                    break;

                case types$2.Url:
                case types$2.Function:
                    children.push(this.Url());
                    break;

                default:
                    this.error('String or url() is expected');
            }

            if (this.lookupNonWSType(0) === types$2.Ident ||
                this.lookupNonWSType(0) === types$2.LeftParenthesis) {
                children.push(this.MediaQueryList());
            }

            return children;
        },
        block: null
    }
};

var _import$1 = importAtrule;

const media$1 = {
    parse: {
        prelude() {
            return this.createSingleNodeList(
                this.MediaQueryList()
            );
        },
        block(isStyleBlock = false) {
            return this.Block(isStyleBlock);
        }
    }
};

var media_1 = media$1;

const nest$1 = {
    parse: {
        prelude() {
            return this.createSingleNodeList(
                this.SelectorList()
            );
        },
        block() {
            return this.Block(true);
        }
    }
};

var nest_1 = nest$1;

const page$1 = {
    parse: {
        prelude() {
            return this.createSingleNodeList(
                this.SelectorList()
            );
        },
        block() {
            return this.Block(true);
        }
    }
};

var page_1 = page$1;

const types$1 = types$T;

function consumeRaw() {
    return this.createSingleNodeList(
        this.Raw(this.tokenIndex, null, false)
    );
}

function parentheses() {
    this.skipSC();

    if (this.tokenType === types$1.Ident &&
        this.lookupNonWSType(1) === types$1.Colon) {
        return this.createSingleNodeList(
            this.Declaration()
        );
    }

    return readSequence.call(this);
}

function readSequence() {
    const children = this.createList();
    let child;

    this.skipSC();

    scan:
    while (!this.eof) {
        switch (this.tokenType) {
            case types$1.Comment:
            case types$1.WhiteSpace:
                this.next();
                continue;

            case types$1.Function:
                child = this.Function(consumeRaw, this.scope.AtrulePrelude);
                break;

            case types$1.Ident:
                child = this.Identifier();
                break;

            case types$1.LeftParenthesis:
                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
                break;

            default:
                break scan;
        }

        children.push(child);
    }

    return children;
}

const supports$1 = {
    parse: {
        prelude() {
            const children = readSequence.call(this);

            if (this.getFirstListNode(children) === null) {
                this.error('Condition is expected');
            }

            return children;
        },
        block(isStyleBlock = false) {
            return this.Block(isStyleBlock);
        }
    }
};

var supports_1 = supports$1;

const fontFace = fontFace_1;
const _import = _import$1;
const media = media_1;
const nest = nest_1;
const page = page_1;
const supports = supports_1;

const atrule = {
    'font-face': fontFace,
    'import': _import,
    media,
    nest,
    page,
    supports
};

var atrule_1 = atrule;

const selectorList = {
    parse() {
        return this.createSingleNodeList(
            this.SelectorList()
        );
    }
};

const selector = {
    parse() {
        return this.createSingleNodeList(
            this.Selector()
        );
    }
};

const identList = {
    parse() {
        return this.createSingleNodeList(
            this.Identifier()
        );
    }
};

const nth = {
    parse() {
        return this.createSingleNodeList(
            this.Nth()
        );
    }
};

const pseudo = {
    'dir': identList,
    'has': selectorList,
    'lang': identList,
    'matches': selectorList,
    'is': selectorList,
    '-moz-any': selectorList,
    '-webkit-any': selectorList,
    'where': selectorList,
    'not': selectorList,
    'nth-child': nth,
    'nth-last-child': nth,
    'nth-last-of-type': nth,
    'nth-of-type': nth,
    'slotted': selector,
    'host': selector,
    'host-context': selector
};

var pseudo_1 = pseudo;

var indexParse$1 = {};

const AnPlusB = AnPlusB$2;
const Atrule = Atrule$2;
const AtrulePrelude = AtrulePrelude$2;
const AttributeSelector = AttributeSelector$2;
const Block = Block$2;
const Brackets = Brackets$2;
const CDC = CDC$2;
const CDO = CDO$2;
const ClassSelector = ClassSelector$2;
const Combinator = Combinator$2;
const Comment = Comment$2;
const Declaration = Declaration$2;
const DeclarationList = DeclarationList$2;
const Dimension = Dimension$2;
const Function$1 = _Function;
const Hash = Hash$2;
const Identifier = Identifier$2;
const IdSelector = IdSelector$2;
const MediaFeature = MediaFeature$2;
const MediaQuery = MediaQuery$2;
const MediaQueryList = MediaQueryList$2;
const NestingSelector = NestingSelector$2;
const Nth = Nth$2;
const Number$1 = _Number;
const Operator = Operator$2;
const Parentheses = Parentheses$2;
const Percentage = Percentage$2;
const PseudoClassSelector = PseudoClassSelector$2;
const PseudoElementSelector = PseudoElementSelector$2;
const Ratio = Ratio$2;
const Raw = Raw$2;
const Rule = Rule$2;
const Selector = Selector$3;
const SelectorList = SelectorList$2;
const String$1 = _String;
const StyleSheet = StyleSheet$2;
const TypeSelector = TypeSelector$2;
const UnicodeRange = UnicodeRange$2;
const Url = Url$2;
const Value = Value$2;
const WhiteSpace = WhiteSpace$2;



indexParse$1.AnPlusB = AnPlusB.parse;
indexParse$1.Atrule = Atrule.parse;
indexParse$1.AtrulePrelude = AtrulePrelude.parse;
indexParse$1.AttributeSelector = AttributeSelector.parse;
indexParse$1.Block = Block.parse;
indexParse$1.Brackets = Brackets.parse;
indexParse$1.CDC = CDC.parse;
indexParse$1.CDO = CDO.parse;
indexParse$1.ClassSelector = ClassSelector.parse;
indexParse$1.Combinator = Combinator.parse;
indexParse$1.Comment = Comment.parse;
indexParse$1.Declaration = Declaration.parse;
indexParse$1.DeclarationList = DeclarationList.parse;
indexParse$1.Dimension = Dimension.parse;
indexParse$1.Function = Function$1.parse;
indexParse$1.Hash = Hash.parse;
indexParse$1.Identifier = Identifier.parse;
indexParse$1.IdSelector = IdSelector.parse;
indexParse$1.MediaFeature = MediaFeature.parse;
indexParse$1.MediaQuery = MediaQuery.parse;
indexParse$1.MediaQueryList = MediaQueryList.parse;
indexParse$1.NestingSelector = NestingSelector.parse;
indexParse$1.Nth = Nth.parse;
indexParse$1.Number = Number$1.parse;
indexParse$1.Operator = Operator.parse;
indexParse$1.Parentheses = Parentheses.parse;
indexParse$1.Percentage = Percentage.parse;
indexParse$1.PseudoClassSelector = PseudoClassSelector.parse;
indexParse$1.PseudoElementSelector = PseudoElementSelector.parse;
indexParse$1.Ratio = Ratio.parse;
indexParse$1.Raw = Raw.parse;
indexParse$1.Rule = Rule.parse;
indexParse$1.Selector = Selector.parse;
indexParse$1.SelectorList = SelectorList.parse;
indexParse$1.String = String$1.parse;
indexParse$1.StyleSheet = StyleSheet.parse;
indexParse$1.TypeSelector = TypeSelector.parse;
indexParse$1.UnicodeRange = UnicodeRange.parse;
indexParse$1.Url = Url.parse;
indexParse$1.Value = Value.parse;
indexParse$1.WhiteSpace = WhiteSpace.parse;

const index$3 = scope;
const index$1$1 = atrule_1;
const index$2$1 = pseudo_1;
const indexParse = indexParse$1;

const config$2 = {
    parseContext: {
        default: 'StyleSheet',
        stylesheet: 'StyleSheet',
        atrule: 'Atrule',
        atrulePrelude(options) {
            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
        },
        mediaQueryList: 'MediaQueryList',
        mediaQuery: 'MediaQuery',
        rule: 'Rule',
        selectorList: 'SelectorList',
        selector: 'Selector',
        block() {
            return this.Block(true);
        },
        declarationList: 'DeclarationList',
        declaration: 'Declaration',
        value: 'Value'
    },
    scope: index$3,
    atrule: index$1$1,
    pseudo: index$2$1,
    node: indexParse
};

var parser$1 = config$2;

const index$2 = node;

const config$1 = {
    node: index$2
};

var walker$1 = config$1;

const create$1 = create_1;
const lexer$1 = lexer$2;
const parser = parser$1;
const walker = walker$1;

const syntax = create$1({
    ...lexer$1,
    ...parser,
    ...walker
});

var syntax_1 = syntax;

var version$3 = {};

const name = "css-tree";
const version$2 = "2.3.1";
const description = "A tool set for CSS: fast detailed parser (CSS → AST), walker (AST traversal), generator (AST → CSS) and lexer (validation and matching) based on specs and browser implementations";
const author = "Roman Dvornov <rdvornov@gmail.com> (https://github.com/lahmatiy)";
const license = "MIT";
const repository = "csstree/csstree";
const keywords = [
	"css",
	"ast",
	"tokenizer",
	"parser",
	"walker",
	"lexer",
	"generator",
	"utils",
	"syntax",
	"validation"
];
const type = "module";
const module$1 = "./lib/index.js";
const main$2 = "./cjs/index.cjs";
const exports$1 = {
	".": {
		"import": "./lib/index.js",
		require: "./cjs/index.cjs"
	},
	"./dist/*": "./dist/*.js",
	"./package.json": "./package.json",
	"./tokenizer": {
		"import": "./lib/tokenizer/index.js",
		require: "./cjs/tokenizer/index.cjs"
	},
	"./parser": {
		"import": "./lib/parser/index.js",
		require: "./cjs/parser/index.cjs"
	},
	"./selector-parser": {
		"import": "./lib/parser/parse-selector.js",
		require: "./cjs/parser/parse-selector.cjs"
	},
	"./generator": {
		"import": "./lib/generator/index.js",
		require: "./cjs/generator/index.cjs"
	},
	"./walker": {
		"import": "./lib/walker/index.js",
		require: "./cjs/walker/index.cjs"
	},
	"./convertor": {
		"import": "./lib/convertor/index.js",
		require: "./cjs/convertor/index.cjs"
	},
	"./lexer": {
		"import": "./lib/lexer/index.js",
		require: "./cjs/lexer/index.cjs"
	},
	"./definition-syntax": {
		"import": "./lib/definition-syntax/index.js",
		require: "./cjs/definition-syntax/index.cjs"
	},
	"./definition-syntax-data": {
		"import": "./lib/data.js",
		require: "./cjs/data.cjs"
	},
	"./definition-syntax-data-patch": {
		"import": "./lib/data-patch.js",
		require: "./cjs/data-patch.cjs"
	},
	"./utils": {
		"import": "./lib/utils/index.js",
		require: "./cjs/utils/index.cjs"
	}
};
const browser = {
	"./cjs/data.cjs": "./dist/data.cjs",
	"./cjs/version.cjs": "./dist/version.cjs",
	"./lib/data.js": "./dist/data.js",
	"./lib/version.js": "./dist/version.js"
};
const unpkg = "dist/csstree.esm.js";
const jsdelivr = "dist/csstree.esm.js";
const scripts = {
	watch: "npm run build -- --watch",
	build: "npm run bundle && npm run esm-to-cjs --",
	"build-and-test": "npm run build && npm run test:dist && npm run test:cjs",
	bundle: "node scripts/bundle",
	"bundle-and-test": "npm run bundle && npm run test:dist",
	"esm-to-cjs": "node scripts/esm-to-cjs.cjs",
	"esm-to-cjs-and-test": "npm run esm-to-cjs && npm run test:cjs",
	lint: "eslint lib scripts && node scripts/review-syntax-patch --lint && node scripts/update-docs --lint",
	"lint-and-test": "npm run lint && npm test",
	"update:docs": "node scripts/update-docs",
	"review:syntax-patch": "node scripts/review-syntax-patch",
	test: "mocha lib/__tests --reporter ${REPORTER:-progress}",
	"test:cjs": "mocha cjs/__tests --reporter ${REPORTER:-progress}",
	"test:dist": "mocha dist/__tests --reporter ${REPORTER:-progress}",
	coverage: "c8 --exclude lib/__tests --reporter=lcovonly npm test",
	prepublishOnly: "npm run lint-and-test && npm run build-and-test",
	hydrogen: "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/parse --stat -o /dev/null"
};
const dependencies = {
	"mdn-data": "2.0.30",
	"source-map-js": "^1.0.1"
};
const devDependencies = {
	c8: "^7.12.0",
	clap: "^2.0.1",
	esbuild: "^0.14.53",
	eslint: "^8.4.1",
	"json-to-ast": "^2.1.0",
	mocha: "^9.2.2",
	rollup: "^2.68.0"
};
const engines = {
	node: "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0"
};
const files = [
	"data",
	"dist",
	"cjs",
	"!cjs/__tests",
	"lib",
	"!lib/__tests"
];
const _package = {
	name: name,
	version: version$2,
	description: description,
	author: author,
	license: license,
	repository: repository,
	keywords: keywords,
	type: type,
	module: module$1,
	main: main$2,
	exports: exports$1,
	browser: browser,
	unpkg: unpkg,
	jsdelivr: jsdelivr,
	scripts: scripts,
	dependencies: dependencies,
	devDependencies: devDependencies,
	engines: engines,
	files: files
};

const _package$1 = {
	__proto__: null,
	author: author,
	browser: browser,
	default: _package,
	dependencies: dependencies,
	description: description,
	devDependencies: devDependencies,
	engines: engines,
	exports: exports$1,
	files: files,
	jsdelivr: jsdelivr,
	keywords: keywords,
	license: license,
	main: main$2,
	module: module$1,
	name: name,
	repository: repository,
	scripts: scripts,
	type: type,
	unpkg: unpkg,
	version: version$2
};

const require$$0 = /*@__PURE__*/getAugmentedNamespace(_package$1);

const { version: version$1 } = require$$0;

version$3.version = version$1;

var definitionSyntax = {};

const SyntaxError$1 = _SyntaxError;
const generate$1 = generate$K;
const parse$1 = parse$K;
const walk$1 = walk$4;



definitionSyntax.SyntaxError = SyntaxError$1.SyntaxError;
definitionSyntax.generate = generate$1.generate;
definitionSyntax.parse = parse$1.parse;
definitionSyntax.walk = walk$1.walk;

var clone$2 = {};

const List$1 = List$7;

function clone$1(node) {
    const result = {};

    for (const key in node) {
        let value = node[key];

        if (value) {
            if (Array.isArray(value) || value instanceof List$1.List) {
                value = value.map(clone$1);
            } else if (value.constructor === Object) {
                value = clone$1(value);
            }
        }

        result[key] = value;
    }

    return result;
}

clone$2.clone = clone$1;

var ident$1 = {};

const charCodeDefinitions = charCodeDefinitions$c;
const utils = utils$9;

const REVERSE_SOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\)

function decode(str) {
    const end = str.length - 1;
    let decoded = '';

    for (let i = 0; i < str.length; i++) {
        let code = str.charCodeAt(i);

        if (code === REVERSE_SOLIDUS) {
            // special case at the ending
            if (i === end) {
                // if the next input code point is EOF, do nothing
                break;
            }

            code = str.charCodeAt(++i);

            // consume escaped
            if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
                const escapeStart = i - 1;
                const escapeEnd = utils.consumeEscaped(str, escapeStart);

                i = escapeEnd - 1;
                decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
            } else {
                // \r\n
                if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {
                    i++;
                }
            }
        } else {
            decoded += str[i];
        }
    }

    return decoded;
}

// https://drafts.csswg.org/cssom/#serialize-an-identifier
// § 2.1. Common Serializing Idioms
function encode(str) {
    let encoded = '';

    // If the character is the first character and is a "-" (U+002D),
    // and there is no second character, then the escaped character.
    // Note: That's means a single dash string "-" return as escaped dash,
    // so move the condition out of the main loop
    if (str.length === 1 && str.charCodeAt(0) === 0x002D) {
        return '\\-';
    }

    // To serialize an identifier means to create a string represented
    // by the concatenation of, for each character of the identifier:
    for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);

        // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).
        if (code === 0x0000) {
            encoded += '\uFFFD';
            continue;
        }

        if (
            // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F ...
            // Note: Do not compare with 0x0001 since 0x0000 is precessed before
            code <= 0x001F || code === 0x007F ||
            // [or] ... is in the range [0-9] (U+0030 to U+0039),
            (code >= 0x0030 && code <= 0x0039 && (
                // If the character is the first character ...
                i === 0 ||
                // If the character is the second character ... and the first character is a "-" (U+002D)
                i === 1 && str.charCodeAt(0) === 0x002D
            ))
        ) {
            // ... then the character escaped as code point.
            encoded += '\\' + code.toString(16) + ' ';
            continue;
        }

        // If the character is not handled by one of the above rules and is greater
        // than or equal to U+0080, is "-" (U+002D) or "_" (U+005F), or is in one
        // of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to U+005A),
        // or \[a-z] (U+0061 to U+007A), then the character itself.
        if (charCodeDefinitions.isName(code)) {
            encoded += str.charAt(i);
        } else {
            // Otherwise, the escaped character.
            encoded += '\\' + str.charAt(i);
        }
    }

    return encoded;
}

ident$1.decode = decode;
ident$1.encode = encode;

const index$1 = syntax_1;
const version = version$3;
const create = create_1;
const List = List$7;
const Lexer = Lexer$3;
const index = definitionSyntax;
const clone = clone$2;
const names$1 = names$4;
const ident = ident$1;
const string = string$3;
const url = url$2;
const types = types$T;
const names = names$8;
const TokenStream = TokenStream$4;

const {
    tokenize,
    parse,
    generate,
    lexer,
    createLexer,

    walk,
    find,
    findLast,
    findAll,

    toPlainObject,
    fromPlainObject,

    fork
} = index$1;

cjs.version = version.version;
cjs.createSyntax = create;
cjs.List = List.List;
cjs.Lexer = Lexer.Lexer;
cjs.definitionSyntax = index;
cjs.clone = clone.clone;
cjs.isCustomProperty = names$1.isCustomProperty;
cjs.keyword = names$1.keyword;
cjs.property = names$1.property;
cjs.vendorPrefix = names$1.vendorPrefix;
cjs.ident = ident;
cjs.string = string;
cjs.url = url;
cjs.tokenTypes = types;
cjs.tokenNames = names;
cjs.TokenStream = TokenStream.TokenStream;
cjs.createLexer = createLexer;
cjs.find = find;
cjs.findAll = findAll;
cjs.findLast = findLast;
cjs.fork = fork;
cjs.fromPlainObject = fromPlainObject;
cjs.generate = generate;
cjs.lexer = lexer;
cjs.parse = parse;
cjs.toPlainObject = toPlainObject;
cjs.tokenize = tokenize;
cjs.walk = walk;

Object.defineProperty(dist$3, '__esModule', { value: true });

const core$3 = dist$p;
const cssTree = cjs;
const ruleUtils = dist$k;

function handleThemeFn({ code, uno, options }, node) {
  const { throwOnMissing = true } = options;
  const offset = node.value.loc.start.offset;
  const str = code.original.slice(offset, node.value.loc.end.offset);
  code.overwrite(offset, node.value.loc.end.offset, ruleUtils.transformThemeFn(str, uno.config.theme, throwOnMissing));
}

const screenRuleRE = /(@screen) (.+) /g;
function handleScreen({ code, uno }, node) {
  let breakpointName = "";
  let prefix = "";
  if (node.name === "screen" && node.prelude?.type === "Raw")
    breakpointName = node.prelude.value.trim();
  if (!breakpointName)
    return;
  const match = breakpointName.match(/^(?:(lt|at)-)?(\w+)$/);
  if (match) {
    prefix = match[1];
    breakpointName = match[2];
  }
  const resolveBreakpoints = () => {
    let breakpoints;
    if (uno.userConfig && uno.userConfig.theme)
      breakpoints = uno.userConfig.theme.breakpoints;
    if (!breakpoints)
      breakpoints = uno.config.theme.breakpoints;
    return breakpoints ? Object.entries(breakpoints).sort((a, b) => Number.parseInt(a[1].replace(/[a-z]+/gi, "")) - Number.parseInt(b[1].replace(/[a-z]+/gi, ""))).map(([point, size]) => ({ point, size })) : void 0;
  };
  const variantEntries = (resolveBreakpoints() ?? []).map(({ point, size }, idx) => [point, size, idx]);
  const generateMediaQuery = (breakpointName2, prefix2) => {
    const [, size, idx] = variantEntries.find((i) => i[0] === breakpointName2);
    if (prefix2) {
      if (prefix2 === "lt")
        return `@media (max-width: ${calcMaxWidthBySize(size)})`;
      else if (prefix2 === "at")
        return `@media (min-width: ${size})${variantEntries[idx + 1] ? ` and (max-width: ${calcMaxWidthBySize(variantEntries[idx + 1][1])})` : ""}`;
      else
        throw new Error(`breakpoint variant not supported: ${prefix2}`);
    }
    return `@media (min-width: ${size})`;
  };
  if (!variantEntries.find((i) => i[0] === breakpointName))
    throw new Error(`breakpoint ${breakpointName} not found`);
  const offset = node.loc.start.offset;
  const str = code.original.slice(offset, node.loc.end.offset);
  const matches = Array.from(str.matchAll(screenRuleRE));
  if (!matches.length)
    return;
  for (const match2 of matches) {
    code.overwrite(
      offset + match2.index,
      offset + match2.index + match2[0].length,
      `${generateMediaQuery(breakpointName, prefix)} `
    );
  }
}
function calcMaxWidthBySize(size) {
  const value = size.match(/^-?[0-9]+\.?[0-9]*/)?.[0] || "";
  const unit = size.slice(value.length);
  const maxWidth = Number.parseFloat(value) - 0.1;
  return Number.isNaN(maxWidth) ? size : `${maxWidth}${unit}`;
}

async function handleApply(ctx, node) {
  const { code, uno, options, filename, offset } = ctx;
  const calcOffset = (pos) => offset ? pos + offset : pos;
  await Promise.all(
    node.block.children.map(async (childNode) => {
      if (childNode.type === "Raw")
        return transformDirectives(code, uno, options, filename, childNode.value, calcOffset(childNode.loc.start.offset));
      await parseApply(ctx, node, childNode);
    }).toArray()
  );
}
async function parseApply({ code, uno, offset, applyVariable }, node, childNode) {
  const calcOffset = (pos) => offset ? pos + offset : pos;
  let body;
  if (childNode.type === "Atrule" && childNode.name === "apply" && childNode.prelude && childNode.prelude.type === "Raw")
    body = childNode.prelude.value.trim();
  else if (childNode.type === "Declaration" && applyVariable.includes(childNode.property) && childNode.value.type === "Raw")
    body = childNode.value.value.trim();
  if (!body)
    return;
  if (/^(['"]).*\1$/.test(body))
    body = body.slice(1, -1);
  const classNames = core$3.expandVariantGroup(body).split(/\s+/g).map((className) => className.trim().replace(/\\/, ""));
  const utils = (await Promise.all(
    classNames.map((i) => uno.parseToken(i, "-"))
  )).filter(core$3.notNull).flat().sort((a, b) => a[0] - b[0]).sort((a, b) => (a[3] ? uno.parentOrders.get(a[3]) ?? 0 : 0) - (b[3] ? uno.parentOrders.get(b[3]) ?? 0 : 0)).reduce((acc, item) => {
    const target = acc.find((i) => i[1] === item[1] && i[3] === item[3]);
    if (target)
      target[2] += item[2];
    else
      acc.push([...item]);
    return acc;
  }, []);
  if (!utils.length)
    return;
  const simicolonOffset = code.toString()[childNode.loc.end.offset] === ";" ? 1 : 0;
  for (const i of utils) {
    const [, _selector, body2, parent] = i;
    const selectorOrGroup = _selector?.replace(core$3.regexScopePlaceholder, " ") || _selector;
    if (parent || selectorOrGroup && selectorOrGroup !== ".\\-") {
      let newSelector = cssTree.generate(node.prelude);
      if (selectorOrGroup && selectorOrGroup !== ".\\-") {
        const ruleAST = cssTree.parse(`${selectorOrGroup}{}`, {
          context: "rule"
        });
        const prelude = cssTree.clone(node.prelude);
        prelude.children.forEach((child) => {
          const selectorListAst = cssTree.clone(ruleAST.prelude);
          const classSelectors = new cssTree.List();
          selectorListAst.children.forEach((selectorAst) => {
            classSelectors.appendList(selectorAst.children.filter((i2) => i2.type === "ClassSelector" && i2.name === "\\-"));
          });
          classSelectors.forEach((i2) => Object.assign(i2, cssTree.clone(child)));
          Object.assign(child, selectorListAst);
        });
        newSelector = cssTree.generate(prelude);
      }
      let css = `${newSelector}{${body2}}`;
      if (parent)
        css = `${parent}{${css}}`;
      code.appendLeft(calcOffset(node.loc.end.offset), css);
    } else {
      if (body2.includes("@"))
        code.appendRight(code.original.length + simicolonOffset, body2);
      else
        code.appendRight(calcOffset(childNode.loc.end.offset + simicolonOffset), body2);
    }
  }
  code.remove(
    calcOffset(childNode.loc.start.offset),
    calcOffset(childNode.loc.end.offset + simicolonOffset)
  );
}

function transformerDirectives(options = {}) {
  return {
    name: "@unocss/transformer-directives",
    enforce: options?.enforce,
    idFilter: (id) => core$3.cssIdRE.test(id),
    transform: (code, id, ctx) => {
      return transformDirectives(code, ctx.uno, options, id);
    }
  };
}
async function transformDirectives(code, uno, options, filename, originalCode, offset) {
  let { applyVariable } = options;
  const varStyle = options.varStyle;
  if (applyVariable === void 0) {
    if (varStyle !== void 0)
      applyVariable = varStyle ? [`${varStyle}apply`] : [];
    applyVariable = ["--at-apply", "--uno-apply", "--uno"];
  }
  applyVariable = core$3.toArray(applyVariable || []);
  const hasApply = code.original.includes("@apply") || applyVariable.some((s) => code.original.includes(s));
  const hasScreen = code.original.includes("@screen");
  const hasThemeFn = ruleUtils.hasThemeFn(code.original);
  if (!hasApply && !hasThemeFn && !hasScreen)
    return;
  const ast = cssTree.parse(originalCode || code.original, {
    parseAtrulePrelude: false,
    positions: true,
    filename
  });
  if (ast.type !== "StyleSheet")
    return;
  const stack = [];
  const ctx = {
    options,
    applyVariable,
    uno,
    code,
    filename,
    offset
  };
  const processNode = async (node, _item, _list) => {
    if (hasScreen && node.type === "Atrule")
      handleScreen(ctx, node);
    if (hasThemeFn && node.type === "Declaration")
      handleThemeFn(ctx, node);
    if (hasApply && node.type === "Rule")
      await handleApply(ctx, node);
  };
  cssTree.walk(ast, (...args) => stack.push(processNode(...args)));
  await Promise.all(stack);
}

dist$3.default = transformerDirectives;
dist$3.transformDirectives = transformDirectives;

const core$2 = dist$p;

function transformerVariantGroup(options = {}) {
  return {
    name: "@unocss/transformer-variant-group",
    enforce: "pre",
    transform(s) {
      const result = core$2.parseVariantGroup(s, options.separators);
      return {
        get highlightAnnotations() {
          return [...result.groupsByOffset.values()].flatMap((group) => group.items);
        }
      };
    }
  };
}

var dist$2 = transformerVariantGroup;

const core$1 = dist$p;

function transformerCompileClass(options = {}) {
  const {
    trigger = /(["'`]):uno(?:-)?(?<name>[^\s\1]+)?:\s([^\1]*?)\1/g,
    classPrefix = "uno-",
    hashFn = hash,
    keepUnknown = true,
    alwaysHash = false
  } = options;
  const compiledClass = /* @__PURE__ */ new Set();
  const regexp = typeof trigger === "string" ? RegExp(`(["'\`])${core$1.escapeRegExp(trigger)}\\s([^\\1]*?)\\1`, "g") : trigger;
  return {
    name: "@unocss/transformer-compile-class",
    enforce: "pre",
    async transform(s, _, { uno, tokens, invalidate }) {
      const matches = [...s.original.matchAll(regexp)];
      if (!matches.length)
        return;
      const size = compiledClass.size;
      for (const match of matches) {
        let body = match.length === 4 && match.groups ? core$1.expandVariantGroup(match[3].trim()) : core$1.expandVariantGroup(match[2].trim());
        const start = match.index;
        const replacements = [];
        if (keepUnknown) {
          const result = await Promise.all(body.split(/\s+/).filter(Boolean).map(async (i) => [i, !!await uno.parseToken(i)]));
          const known = result.filter(([, matched]) => matched).map(([i]) => i);
          const unknown = result.filter(([, matched]) => !matched).map(([i]) => i);
          replacements.push(...unknown);
          body = known.join(" ");
        }
        if (body) {
          body = body.split(/\s+/).sort().join(" ");
          let hash2;
          let explicitName = false;
          if (match.groups && match.groups.name) {
            hash2 = match.groups.name;
            if (alwaysHash)
              hash2 += `-${hashFn(body)}`;
            explicitName = true;
          } else {
            hash2 = hashFn(body);
          }
          const className = `${classPrefix}${hash2}`;
          if (tokens && tokens.has(className) && explicitName) {
            const existing = uno.config.shortcuts.find((i) => i[0] === className);
            if (existing && existing[1] !== body)
              throw new Error(`Duplicated compile class name "${className}". One is "${body}" and the other is "${existing[1]}". Please choose different class name or set 'alwaysHash' to 'true'.`);
          }
          compiledClass.add(className);
          replacements.unshift(className);
          if (options.layer)
            uno.config.shortcuts.push([className, body, { layer: options.layer }]);
          else
            uno.config.shortcuts.push([className, body]);
          if (tokens)
            tokens.add(className);
        }
        s.overwrite(start + 1, start + match[0].length - 1, replacements.join(" "));
      }
      if (compiledClass.size > size)
        invalidate();
    }
  };
}
function hash(str) {
  let i;
  let l;
  let hval = 2166136261;
  for (i = 0, l = str.length; i < l; i++) {
    hval ^= str.charCodeAt(i);
    hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
  }
  return `00000${(hval >>> 0).toString(36)}`.slice(-6);
}

var dist$1 = transformerCompileClass;

const core = dist$p;

function createFilter(include, exclude) {
  const includePattern = core.toArray(include || []);
  const excludePattern = core.toArray(exclude || []);
  return (id) => {
    if (excludePattern.some((p) => id.match(p)))
      return false;
    return includePattern.some((p) => id.match(p));
  };
}
const elementRE = /(<\w[\w:\.$-]*\s)([\s\S]*?)(?=>[\s\S]?<\/[\s\w:\.$-]*>|\/>)/g;
const attributeRE = /(?<![~`!$%^&*()_+\-=[{;':"|,.<>/?]\s*)([a-zA-Z()#][\[?a-zA-Z0-9-_:()#%\]?]*)(?:\s*=\s*((?:'[^']*')|(?:"[^"]*")|\S+))?/g;
const valuedAttributeRE = /((?!\d|-{2}|-\d)[a-zA-Z0-9\u00A0-\uFFFF-_:!%-.~<]+)=(?:["]([^"]*)["]|[']([^']*)[']|[{]((?:[`(](?:[^`)]*)[`)]|[^}])+)[}])/gms;
function transformerAttributifyJsx(options = {}) {
  const {
    blocklist = []
  } = options;
  const isBlocked = (matchedRule) => {
    for (const blockedRule of blocklist) {
      if (blockedRule instanceof RegExp) {
        if (blockedRule.test(matchedRule))
          return true;
      } else if (matchedRule === blockedRule) {
        return true;
      }
    }
    return false;
  };
  const idFilter = createFilter(
    options.include || [/\.[jt]sx$/, /\.mdx$/],
    options.exclude || []
  );
  return {
    name: "@unocss/transformer-attributify-jsx",
    enforce: "pre",
    idFilter,
    async transform(code, _, { uno }) {
      const tasks = [];
      for (const item of Array.from(code.original.matchAll(elementRE))) {
        let attributifyPart = item[2];
        if (valuedAttributeRE.test(attributifyPart))
          attributifyPart = attributifyPart.replace(valuedAttributeRE, (match) => " ".repeat(match.length));
        for (const attr of attributifyPart.matchAll(attributeRE)) {
          const matchedRule = attr[0].replace(/\:/i, "-");
          if (matchedRule.includes("=") || isBlocked(matchedRule))
            continue;
          tasks.push(uno.parseToken(matchedRule).then((matched) => {
            if (matched) {
              const tag = item[1];
              const startIdx = (item.index || 0) + (attr.index || 0) + tag.length;
              const endIdx = startIdx + matchedRule.length;
              code.overwrite(startIdx, endIdx, `${matchedRule}=""`);
            }
          }));
        }
      }
      await Promise.all(tasks);
    }
  };
}

var dist = transformerAttributifyJsx;

(function (exports) {

	const core = dist$p;
	const presetUno = dist$o;
	const presetAttributify = dist$j;
	const presetTagify = dist$i;
	const presetIcons = dist$h;
	const presetWebFonts = dist$5;
	const presetTypography = dist$4;
	const presetMini = dist$m;
	const presetWind = dist$n;
	const transformerDirectives = dist$3;
	const transformerVariantGroup = dist$2;
	const transformerCompileClass = dist$1;
	const transformerAttributifyJsx = dist;

	function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

	const presetUno__default = /*#__PURE__*/_interopDefaultCompat(presetUno);
	const presetAttributify__default = /*#__PURE__*/_interopDefaultCompat(presetAttributify);
	const presetTagify__default = /*#__PURE__*/_interopDefaultCompat(presetTagify);
	const presetIcons__default = /*#__PURE__*/_interopDefaultCompat(presetIcons);
	const presetWebFonts__default = /*#__PURE__*/_interopDefaultCompat(presetWebFonts);
	const presetTypography__default = /*#__PURE__*/_interopDefaultCompat(presetTypography);
	const presetMini__default = /*#__PURE__*/_interopDefaultCompat(presetMini);
	const presetWind__default = /*#__PURE__*/_interopDefaultCompat(presetWind);
	const transformerDirectives__default = /*#__PURE__*/_interopDefaultCompat(transformerDirectives);
	const transformerVariantGroup__default = /*#__PURE__*/_interopDefaultCompat(transformerVariantGroup);
	const transformerCompileClass__default = /*#__PURE__*/_interopDefaultCompat(transformerCompileClass);
	const transformerAttributifyJsx__default = /*#__PURE__*/_interopDefaultCompat(transformerAttributifyJsx);

	function defineConfig(config) {
	  return config;
	}

	exports.presetUno = presetUno__default;
	exports.presetAttributify = presetAttributify__default;
	exports.presetTagify = presetTagify__default;
	exports.presetIcons = presetIcons__default;
	exports.presetWebFonts = presetWebFonts__default;
	exports.presetTypography = presetTypography__default;
	exports.presetMini = presetMini__default;
	exports.presetWind = presetWind__default;
	exports.transformerDirectives = transformerDirectives__default;
	exports.transformerVariantGroup = transformerVariantGroup__default;
	exports.transformerCompileClass = transformerCompileClass__default;
	exports.transformerAttributifyJsx = transformerAttributifyJsx__default;
	exports.defineConfig = defineConfig;
	Object.prototype.hasOwnProperty.call(core, '__proto__') &&
	  !Object.prototype.hasOwnProperty.call(exports, '__proto__') &&
	  Object.defineProperty(exports, '__proto__', {
	    enumerable: true,
	    value: core['__proto__']
	  });

	Object.keys(core).forEach(function (k) {
	  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) exports[k] = core[k];
	}); 
} (dist$q));

var __create = Object.create;
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$2 = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __export$2 = (target, all) => {
  for (var name in all)
    __defProp$2(target, name, { get: all[name], enumerable: true });
};
var __copyProps$2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames$2(from))
      if (!__hasOwnProp$2.call(to, key) && key !== except)
        __defProp$2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc$2(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps$2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp$2(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS$2 = (mod) => __copyProps$2(__defProp$2({}, "__esModule", { value: true }), mod);
var config_exports = {};
__export$2(config_exports, {
  evaluateUserConfig: () => evaluateUserConfig
});
var config = __toCommonJS$2(config_exports);
var unoCssModule = __toESM(dist$q);
var import_ofetch = node$2;
const AsyncFunction = Object.getPrototypeOf(async () => {
}).constructor;
const CDN_BASE = "https://esm.sh/";
const modulesCache = /* @__PURE__ */ new Map();
modulesCache.set("unocss", unoCssModule);
const nativeImport = new Function("a", "return import(a);");
async function fetchAndImportAnyModuleWithCDNCapabilities(name) {
  if (name.endsWith(".json")) {
    const response = await (0, import_ofetch.$fetch)(CDN_BASE + name, { responseType: "json" });
    return { default: response };
  }
  return nativeImport(CDN_BASE + name);
}
async function dynamicImportAnyModule(name) {
  if (modulesCache.has(name))
    return modulesCache.get(name);
  try {
    const module2 = await fetchAndImportAnyModuleWithCDNCapabilities(name);
    modulesCache.set(name, module2);
  } catch (error) {
    console.error(`Failed to import module ${name} from CDN`, error);
  }
}
const importUnocssRegex = /import\s(.*?)\sfrom\s*(['"])unocss\2/g;
const importObjectRegex = /import\s*(\{[\s\S]*?\})\s*from\s*(['"])([\w@/-]+)\2/g;
const importDefaultRegex = /import\s(.*?)\sfrom\s*(['"])([\w@/-]+)\2/g;
const exportDefaultRegex = /export default /;
const importRegex = /\bimport\s*\(/g;
async function evaluateUserConfig(configCode) {
  const transformedCode = configCode.replace(importUnocssRegex, 'const $1 = await __import("unocss");').replace(importObjectRegex, 'const $1 = await __import("$3");').replace(importDefaultRegex, 'const $1 = (await __import("$3")).default;').replace(exportDefaultRegex, "return ").replace(importRegex, "__import(");
  const wrappedDynamicImport = new AsyncFunction("__import", transformedCode);
  return await wrappedDynamicImport(dynamicImportAnyModule);
}

var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$1 = Object.getOwnPropertyNames;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __export$1 = (target, all) => {
  for (var name in all)
    __defProp$1(target, name, { get: all[name], enumerable: true });
};
var __copyProps$1 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames$1(from))
      if (!__hasOwnProp$1.call(to, key) && key !== except)
        __defProp$1(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc$1(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS$1 = (mod) => __copyProps$1(__defProp$1({}, "__esModule", { value: true }), mod);
var constants_exports = {};
__export$1(constants_exports, {
  defaultConfigRaw: () => defaultConfigRaw
});
var constants = __toCommonJS$1(constants_exports);
const defaultConfigRaw = `import {
  defineConfig,
  presetAttributify,
  presetIcons,
  presetUno,
  transformerDirectives,
  transformerVariantGroup,
} from 'unocss'

export default defineConfig({
  presets: [
    presetUno(),
    presetAttributify(),
    presetIcons({
      cdn: 'https://esm.sh/',
      'vertical-align': 'middle',
      extraProperties: {
        'display': 'inline-block',
      },
    }),
  ],
  transformers: [
    transformerDirectives(),
    transformerVariantGroup(),
  ],
})
`;

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var main_exports = {};
__export(main_exports, {
  default: () => UnoCSSPlugin
});
var main = __toCommonJS(main_exports);
var import_obsidian = require$$0$a;
var import_view = require$$1$4;
var import_unocss = dist$q;
var import_config = config;
var import_constants = constants;
function debounce(fn, wait) {
  let timer = null;
  return function(...args) {
    if (timer)
      return;
    timer = setTimeout(() => {
      timer = null;
      fn(...Array.from(args));
    }, wait);
  };
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
class UnoCSSCodeMirrorViewPlugin {
  constructor(view, unocssCodeGenerator) {
    __publicField(this, "view");
    __publicField(this, "styleElement");
    __publicField(this, "unocssCodeGenerator");
    this.view = view;
    this.unocssCodeGenerator = unocssCodeGenerator;
    this.init();
  }
  update(update) {
    if (!update.docChanged || !update.viewportChanged)
      return;
    const generate = debounce(this.generateOnUpdates.bind(this), 500);
    generate(update);
  }
  destroy() {
    try {
      if (this.styleElement?.parentElement)
        this.styleElement?.parentElement.removeChild(this.styleElement);
      this.styleElement?.remove();
    } catch (e) {
      console.error(e);
    }
  }
  async init() {
    await this.waitForViewDOM();
    await this.generate();
  }
  async waitForViewDOM(seconds = 5) {
    let i = 0;
    while (!this.view || !this.view.dom) {
      await sleep(1e3);
      i++;
      if (i > seconds)
        return;
    }
  }
  async generate() {
    await this.waitForViewDOM();
    await this.generateCSSFromHTMLContent(this.unocssCodeGenerator, this.view.dom, this.view.state.doc.toString());
  }
  async generateOnUpdates(update) {
    await this.waitForViewDOM();
    await this.generateCSSFromHTMLContent(this.unocssCodeGenerator, this.view.dom, update.state.doc.toString());
  }
  async generateCSSFromHTMLContent(unocssCodeGenerator, dom, htmlContent) {
    const generatedOutput = await unocssCodeGenerator.generate(htmlContent);
    const existingStyleElement = dom.querySelector("#obsidian-plugin-unocss-styles");
    if (existingStyleElement)
      this.styleElement = existingStyleElement;
    this.styleElement || (this.styleElement = dom.createEl("style"));
    this.styleElement.id = "obsidian-plugin-unocss-styles";
    this.styleElement.innerHTML = generatedOutput.css;
  }
}
class UnoCSSPlugin extends import_obsidian.Plugin {
  async onload() {
    const unocssConfig = await (0, import_config.evaluateUserConfig)(import_constants.defaultConfigRaw);
    if (!unocssConfig)
      return;
    const uno = (0, import_unocss.createGenerator)({}, unocssConfig);
    const editorPlugins = import_view.ViewPlugin.define((view) => new UnoCSSCodeMirrorViewPlugin(view, uno));
    this.registerEditorExtension(editorPlugins);
  }
}

const main$1 = /*@__PURE__*/getDefaultExportFromCjs$1(main);

module.exports = main$1;
//# sourceMappingURL=main.js.map
